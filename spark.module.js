import * as THREE from "three";
import { Mesh, OrthographicCamera, BufferGeometry, Float32BufferAttribute, Loader, FileLoader, Quaternion, Vector3, Color, Matrix4 } from "three";
const _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
class FullscreenTriangleGeometry extends BufferGeometry {
  constructor() {
    super();
    this.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
    this.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
  }
}
const _geometry = new FullscreenTriangleGeometry();
class FullScreenQuad {
  /**
   * Constructs a new full screen quad.
   *
   * @param {?Material} material - The material to render te full screen quad with.
   */
  constructor(material) {
    this._mesh = new Mesh(_geometry, material);
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the instance is no longer used in your app.
   */
  dispose() {
    this._mesh.geometry.dispose();
  }
  /**
   * Renders the full screen quad.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   */
  render(renderer) {
    renderer.render(this._mesh, _camera);
  }
  /**
   * The quad's material.
   *
   * @type {?Material}
   */
  get material() {
    return this._mesh.material;
  }
  set material(value) {
    this._mesh.material = value;
  }
}
var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b = new u16(31);
  for (var i = 0; i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  }
  var r = new i32(b[30]);
  for (var i = 1; i < 30; ++i) {
    for (var j = b[i]; j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return { b, r };
};
var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), fd = _b.b;
var rev = new u16(32768);
for (var i = 0; i < 32768; ++i) {
  var x = (i & 43690) >> 1 | (i & 21845) << 1;
  x = (x & 52428) >> 2 | (x & 13107) << 2;
  x = (x & 61680) >> 4 | (x & 3855) << 4;
  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
}
var hMap = function(cd, mb, r) {
  var s = cd.length;
  var i = 0;
  var l = new u16(mb);
  for (; i < s; ++i) {
    if (cd[i])
      ++l[cd[i] - 1];
  }
  var le = new u16(mb);
  for (i = 1; i < mb; ++i) {
    le[i] = le[i - 1] + l[i - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        var sv = i << 4 | cd[i];
        var r_1 = mb - cd[i];
        var v = le[cd[i] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (var i = 0; i < 144; ++i)
  flt[i] = 8;
for (var i = 144; i < 256; ++i)
  flt[i] = 9;
for (var i = 256; i < 280; ++i)
  flt[i] = 7;
for (var i = 280; i < 288; ++i)
  flt[i] = 8;
var fdt = new u8(32);
for (var i = 0; i < 32; ++i)
  fdt[i] = 5;
var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max$1 = function(a) {
  var m = a[0];
  for (var i = 1; i < a.length; ++i) {
    if (a[i] > m)
      m = a[i];
  }
  return m;
};
var bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
};
var bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
};
var shft = function(p) {
  return (p + 7) / 8 | 0;
};
var slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  return new u8(v.subarray(s, e));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
};
var inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
        if (t > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t), bt);
        st.b = bt += l, st.p = pos = t * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i = 0; i < hcLen; ++i) {
          clt[clim[i]] = bits(dat, pos + i * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max$1(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i = 0; i < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >> 4;
          if (s < 16) {
            ldt[i++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max$1(lt);
        dbt = max$1(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add2 = sym - 254;
        if (sym > 264) {
          var i = sym - 257, b = fleb[i];
          add2 = bits(dat, pos, (1 << b) - 1) + fl[i];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
        if (!d)
          err(3);
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add2;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (; bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (; bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
var et = /* @__PURE__ */ new u8(0);
var b2 = function(d, b) {
  return d[b] | d[b + 1] << 8;
};
var b4 = function(d, b) {
  return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
};
var b8 = function(d, b) {
  return b4(d, b) + b4(d, b + 4) * 4294967296;
};
var gzs = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    err(6, "invalid gzip data");
  var flg = d[3];
  var st = 10;
  if (flg & 4)
    st += (d[10] | d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
    ;
  return st + (flg & 2);
};
var Inflate = /* @__PURE__ */ function() {
  function Inflate2(opts, cb) {
    if (typeof opts == "function")
      cb = opts, opts = {};
    this.ondata = cb;
    var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);
    this.s = { i: 0, b: dict ? dict.length : 0 };
    this.o = new u8(32768);
    this.p = new u8(0);
    if (dict)
      this.o.set(dict);
  }
  Inflate2.prototype.e = function(c) {
    if (!this.ondata)
      err(5);
    if (this.d)
      err(4);
    if (!this.p.length)
      this.p = c;
    else if (c.length) {
      var n = new u8(this.p.length + c.length);
      n.set(this.p), n.set(c, this.p.length), this.p = n;
    }
  };
  Inflate2.prototype.c = function(final) {
    this.s.i = +(this.d = final || false);
    var bts = this.s.b;
    var dt = inflt(this.p, this.s, this.o);
    this.ondata(slc(dt, bts, this.s.b), this.d);
    this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
    this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  };
  Inflate2.prototype.push = function(chunk, final) {
    this.e(chunk), this.c(final);
  };
  return Inflate2;
}();
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
var Gunzip = /* @__PURE__ */ function() {
  function Gunzip2(opts, cb) {
    this.v = 1;
    this.r = 0;
    Inflate.call(this, opts, cb);
  }
  Gunzip2.prototype.push = function(chunk, final) {
    Inflate.prototype.e.call(this, chunk);
    this.r += chunk.length;
    if (this.v) {
      var p = this.p.subarray(this.v - 1);
      var s = p.length > 3 ? gzs(p) : 4;
      if (s > p.length) {
        if (!final)
          return;
      } else if (this.v > 1 && this.onmember) {
        this.onmember(this.r - p.length);
      }
      this.p = p.subarray(s), this.v = 0;
    }
    Inflate.prototype.c.call(this, final);
    if (this.s.f && !this.s.l && !final) {
      this.v = shft(this.s.p) + 9;
      this.s = { i: 0 };
      this.o = new u8(0);
      this.push(new u8(0), final);
    }
  };
  return Gunzip2;
}();
var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e) {
}
var dutf8 = function(d) {
  for (var r = "", i = 0; ; ) {
    var c = d[i++];
    var eb = (c > 127) + (c > 223) + (c > 239);
    if (i + eb > d.length)
      return { s: r, r: slc(d, i - 1) };
    if (!eb)
      r += String.fromCharCode(c);
    else if (eb == 3) {
      c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
    } else if (eb & 1)
      r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);
    else
      r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);
  }
};
function strFromU8(dat, latin1) {
  if (latin1) {
    var r = "";
    for (var i = 0; i < dat.length; i += 16384)
      r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
    return r;
  } else if (td) {
    return td.decode(dat);
  } else {
    var _a2 = dutf8(dat), s = _a2.s, r = _a2.r;
    if (r.length)
      err(8);
    return s;
  }
}
var slzh = function(d, b) {
  return b + 30 + b2(d, b + 26) + b2(d, b + 28);
};
var zh = function(d, b, z) {
  var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);
  var _a2 = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a2[0], su = _a2[1], off = _a2[2];
  return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];
};
var z64e = function(d, b) {
  for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
    ;
  return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
};
function unzipSync(data, opts) {
  var files = {};
  var e = data.length - 22;
  for (; b4(data, e) != 101010256; --e) {
    if (!e || data.length - e > 65558)
      err(13);
  }
  var c = b2(data, e + 8);
  if (!c)
    return {};
  var o = b4(data, e + 16);
  var z = o == 4294967295 || c == 65535;
  if (z) {
    var ze = b4(data, e - 12);
    z = b4(data, ze) == 101075792;
    if (z) {
      c = b4(data, ze + 32);
      o = b4(data, ze + 48);
    }
  }
  var fltr = opts && opts.filter;
  for (var i = 0; i < c; ++i) {
    var _a2 = zh(data, o, z), c_2 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);
    o = no;
    if (!fltr || fltr({
      name: fn,
      size: sc,
      originalSize: su,
      compression: c_2
    })) {
      if (!c_2)
        files[fn] = slc(data, b, b + sc);
      else if (c_2 == 8)
        files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });
      else
        err(14, "unknown compression type " + c_2);
    }
  }
  return files;
}
const jsContent$1 = '(function() {\n  "use strict";\n  let wasm;\n  function addToExternrefTable0(obj) {\n    const idx = wasm.__externref_table_alloc();\n    wasm.__wbindgen_export_2.set(idx, obj);\n    return idx;\n  }\n  function handleError(f, args) {\n    try {\n      return f.apply(this, args);\n    } catch (e) {\n      const idx = addToExternrefTable0(e);\n      wasm.__wbindgen_exn_store(idx);\n    }\n  }\n  function debugString(val) {\n    const type = typeof val;\n    if (type == "number" || type == "boolean" || val == null) {\n      return `${val}`;\n    }\n    if (type == "string") {\n      return `"${val}"`;\n    }\n    if (type == "symbol") {\n      const description = val.description;\n      if (description == null) {\n        return "Symbol";\n      } else {\n        return `Symbol(${description})`;\n      }\n    }\n    if (type == "function") {\n      const name = val.name;\n      if (typeof name == "string" && name.length > 0) {\n        return `Function(${name})`;\n      } else {\n        return "Function";\n      }\n    }\n    if (Array.isArray(val)) {\n      const length = val.length;\n      let debug = "[";\n      if (length > 0) {\n        debug += debugString(val[0]);\n      }\n      for (let i = 1; i < length; i++) {\n        debug += ", " + debugString(val[i]);\n      }\n      debug += "]";\n      return debug;\n    }\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches && builtInMatches.length > 1) {\n      className = builtInMatches[1];\n    } else {\n      return toString.call(val);\n    }\n    if (className == "Object") {\n      try {\n        return "Object(" + JSON.stringify(val) + ")";\n      } catch (_) {\n        return "Object";\n      }\n    }\n    if (val instanceof Error) {\n      return `${val.name}: ${val.message}\n${val.stack}`;\n    }\n    return className;\n  }\n  let WASM_VECTOR_LEN = 0;\n  let cachedUint8ArrayMemory0 = null;\n  function getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n      cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n  }\n  const cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: () => {\n    throw Error("TextEncoder not available");\n  } };\n  const encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n  } : function(arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n      read: arg.length,\n      written: buf.length\n    };\n  };\n  function passStringToWasm0(arg, malloc, realloc) {\n    if (realloc === void 0) {\n      const buf = cachedTextEncoder.encode(arg);\n      const ptr2 = malloc(buf.length, 1) >>> 0;\n      getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);\n      WASM_VECTOR_LEN = buf.length;\n      return ptr2;\n    }\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n    const mem = getUint8ArrayMemory0();\n    let offset = 0;\n    for (; offset < len; offset++) {\n      const code = arg.charCodeAt(offset);\n      if (code > 127) break;\n      mem[ptr + offset] = code;\n    }\n    if (offset !== len) {\n      if (offset !== 0) {\n        arg = arg.slice(offset);\n      }\n      ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n      const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n      const ret = encodeString(arg, view);\n      offset += ret.written;\n      ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n  }\n  let cachedDataViewMemory0 = null;\n  function getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {\n      cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n  }\n  const cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {\n    throw Error("TextDecoder not available");\n  } };\n  if (typeof TextDecoder !== "undefined") {\n    cachedTextDecoder.decode();\n  }\n  function getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n  }\n  function takeFromExternrefTable0(idx) {\n    const value = wasm.__wbindgen_export_2.get(idx);\n    wasm.__externref_table_dealloc(idx);\n    return value;\n  }\n  function init_lod_tree(num_splats, lod_tree) {\n    const ret = wasm.init_lod_tree(num_splats, lod_tree);\n    if (ret[2]) {\n      throw takeFromExternrefTable0(ret[1]);\n    }\n    return takeFromExternrefTable0(ret[0]);\n  }\n  function dispose_lod_tree(lod_id) {\n    wasm.dispose_lod_tree(lod_id);\n  }\n  let cachedUint32ArrayMemory0 = null;\n  function getUint32ArrayMemory0() {\n    if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {\n      cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32ArrayMemory0;\n  }\n  function passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getUint32ArrayMemory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n  }\n  function insert_lod_trees(lod_ids, page_bases, chunk_bases, counts, lod_trees) {\n    const ptr0 = passArray32ToWasm0(lod_ids, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArray32ToWasm0(page_bases, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ptr2 = passArray32ToWasm0(chunk_bases, wasm.__wbindgen_malloc);\n    const len2 = WASM_VECTOR_LEN;\n    const ptr3 = passArray32ToWasm0(counts, wasm.__wbindgen_malloc);\n    const len3 = WASM_VECTOR_LEN;\n    const ret = wasm.insert_lod_trees(ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, lod_trees);\n    if (ret[2]) {\n      throw takeFromExternrefTable0(ret[1]);\n    }\n    return takeFromExternrefTable0(ret[0]);\n  }\n  function clear_lod_trees(lod_ids, page_bases, chunk_bases, counts) {\n    const ptr0 = passArray32ToWasm0(lod_ids, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArray32ToWasm0(page_bases, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ptr2 = passArray32ToWasm0(chunk_bases, wasm.__wbindgen_malloc);\n    const len2 = WASM_VECTOR_LEN;\n    const ptr3 = passArray32ToWasm0(counts, wasm.__wbindgen_malloc);\n    const len3 = WASM_VECTOR_LEN;\n    const ret = wasm.clear_lod_trees(ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);\n    if (ret[2]) {\n      throw takeFromExternrefTable0(ret[1]);\n    }\n    return takeFromExternrefTable0(ret[0]);\n  }\n  let cachedFloat32ArrayMemory0 = null;\n  function getFloat32ArrayMemory0() {\n    if (cachedFloat32ArrayMemory0 === null || cachedFloat32ArrayMemory0.byteLength === 0) {\n      cachedFloat32ArrayMemory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32ArrayMemory0;\n  }\n  function passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getFloat32ArrayMemory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n  }\n  function traverse_lod_trees(max_splats, pixel_scale_limit, fov_x_degrees, fov_y_degrees, lod_ids, view_to_objects, lod_scales, outside_foveates, behind_foveates) {\n    const ptr0 = passArray32ToWasm0(lod_ids, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArrayF32ToWasm0(view_to_objects, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ptr2 = passArrayF32ToWasm0(lod_scales, wasm.__wbindgen_malloc);\n    const len2 = WASM_VECTOR_LEN;\n    const ptr3 = passArrayF32ToWasm0(outside_foveates, wasm.__wbindgen_malloc);\n    const len3 = WASM_VECTOR_LEN;\n    const ptr4 = passArrayF32ToWasm0(behind_foveates, wasm.__wbindgen_malloc);\n    const len4 = WASM_VECTOR_LEN;\n    const ret = wasm.traverse_lod_trees(max_splats, pixel_scale_limit, fov_x_degrees, fov_y_degrees, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, ptr4, len4);\n    if (ret[2]) {\n      throw takeFromExternrefTable0(ret[1]);\n    }\n    return takeFromExternrefTable0(ret[0]);\n  }\n  function sort_splats(num_splats, readback, ordering) {\n    const ret = wasm.sort_splats(num_splats, readback, ordering);\n    return ret >>> 0;\n  }\n  function sort32_splats(num_splats, readback, ordering) {\n    const ret = wasm.sort32_splats(num_splats, readback, ordering);\n    return ret >>> 0;\n  }\n  function isLikeNone(x) {\n    return x === void 0 || x === null;\n  }\n  function decode_to_packedsplats(file_type, path_name) {\n    var ptr0 = isLikeNone(file_type) ? 0 : passStringToWasm0(file_type, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ptr1 = isLikeNone(path_name) ? 0 : passStringToWasm0(path_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len1 = WASM_VECTOR_LEN;\n    const ret = wasm.decode_to_packedsplats(ptr0, len0, ptr1, len1);\n    if (ret[2]) {\n      throw takeFromExternrefTable0(ret[1]);\n    }\n    return ChunkDecoder.__wrap(ret[0]);\n  }\n  function decode_to_gsplatarray(file_type, path_name) {\n    var ptr0 = isLikeNone(file_type) ? 0 : passStringToWasm0(file_type, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ptr1 = isLikeNone(path_name) ? 0 : passStringToWasm0(path_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len1 = WASM_VECTOR_LEN;\n    const ret = wasm.decode_to_gsplatarray(ptr0, len0, ptr1, len1);\n    if (ret[2]) {\n      throw takeFromExternrefTable0(ret[1]);\n    }\n    return ChunkDecoder.__wrap(ret[0]);\n  }\n  function quick_lod_packedsplats(num_splats, packed, extra, lod_base) {\n    const ret = wasm.quick_lod_packedsplats(num_splats, packed, isLikeNone(extra) ? 0 : addToExternrefTable0(extra), lod_base);\n    if (ret[2]) {\n      throw takeFromExternrefTable0(ret[1]);\n    }\n    return takeFromExternrefTable0(ret[0]);\n  }\n  const ChunkDecoderFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {\n  }, unregister: () => {\n  } } : new FinalizationRegistry((ptr) => wasm.__wbg_chunkdecoder_free(ptr >>> 0, 1));\n  class ChunkDecoder {\n    static __wrap(ptr) {\n      ptr = ptr >>> 0;\n      const obj = Object.create(ChunkDecoder.prototype);\n      obj.__wbg_ptr = ptr;\n      ChunkDecoderFinalization.register(obj, obj.__wbg_ptr, obj);\n      return obj;\n    }\n    __destroy_into_raw() {\n      const ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      ChunkDecoderFinalization.unregister(this);\n      return ptr;\n    }\n    free() {\n      const ptr = this.__destroy_into_raw();\n      wasm.__wbg_chunkdecoder_free(ptr, 0);\n    }\n    /**\n     * @param {Uint8Array} bytes\n     */\n    push(bytes) {\n      const ret = wasm.chunkdecoder_push(this.__wbg_ptr, bytes);\n      if (ret[1]) {\n        throw takeFromExternrefTable0(ret[0]);\n      }\n    }\n    /**\n     * @returns {any}\n     */\n    finish() {\n      const ptr = this.__destroy_into_raw();\n      const ret = wasm.chunkdecoder_finish(ptr);\n      if (ret[2]) {\n        throw takeFromExternrefTable0(ret[1]);\n      }\n      return takeFromExternrefTable0(ret[0]);\n    }\n  }\n  const GsplatArrayFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {\n  }, unregister: () => {\n  } } : new FinalizationRegistry((ptr) => wasm.__wbg_gsplatarray_free(ptr >>> 0, 1));\n  class GsplatArray {\n    static __wrap(ptr) {\n      ptr = ptr >>> 0;\n      const obj = Object.create(GsplatArray.prototype);\n      obj.__wbg_ptr = ptr;\n      GsplatArrayFinalization.register(obj, obj.__wbg_ptr, obj);\n      return obj;\n    }\n    __destroy_into_raw() {\n      const ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      GsplatArrayFinalization.unregister(this);\n      return ptr;\n    }\n    free() {\n      const ptr = this.__destroy_into_raw();\n      wasm.__wbg_gsplatarray_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    get numSplats() {\n      const ret = wasm.__wbg_get_gsplatarray_numSplats(this.__wbg_ptr);\n      return ret >>> 0;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set numSplats(arg0) {\n      wasm.__wbg_set_gsplatarray_numSplats(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {number}\n     */\n    get maxShDegree() {\n      const ret = wasm.__wbg_get_gsplatarray_maxShDegree(this.__wbg_ptr);\n      return ret >>> 0;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set maxShDegree(arg0) {\n      wasm.__wbg_set_gsplatarray_maxShDegree(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {number}\n     */\n    len() {\n      const ret = wasm.gsplatarray_len(this.__wbg_ptr);\n      return ret >>> 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    has_lod() {\n      const ret = wasm.gsplatarray_has_lod(this.__wbg_ptr);\n      return ret !== 0;\n    }\n    /**\n     * @param {number} lod_base\n     */\n    quick_lod(lod_base) {\n      wasm.gsplatarray_quick_lod(this.__wbg_ptr, lod_base);\n    }\n    /**\n     * @returns {object}\n     */\n    to_packedsplats() {\n      const ret = wasm.gsplatarray_to_packedsplats(this.__wbg_ptr);\n      if (ret[2]) {\n        throw takeFromExternrefTable0(ret[1]);\n      }\n      return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @returns {object}\n     */\n    to_packedsplats_lod() {\n      const ret = wasm.gsplatarray_to_packedsplats_lod(this.__wbg_ptr);\n      if (ret[2]) {\n        throw takeFromExternrefTable0(ret[1]);\n      }\n      return takeFromExternrefTable0(ret[0]);\n    }\n  }\n  async function __wbg_load(module, imports) {\n    if (typeof Response === "function" && module instanceof Response) {\n      if (typeof WebAssembly.instantiateStreaming === "function") {\n        try {\n          return await WebAssembly.instantiateStreaming(module, imports);\n        } catch (e) {\n          if (module.headers.get("Content-Type") != "application/wasm") {\n            console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n", e);\n          } else {\n            throw e;\n          }\n        }\n      }\n      const bytes = await module.arrayBuffer();\n      return await WebAssembly.instantiate(bytes, imports);\n    } else {\n      const instance = await WebAssembly.instantiate(module, imports);\n      if (instance instanceof WebAssembly.Instance) {\n        return { instance, module };\n      } else {\n        return instance;\n      }\n    }\n  }\n  function __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\n      const ret = arg0.buffer;\n      return ret;\n    };\n    imports.wbg.__wbg_get_67b2ba62fc30de12 = function() {\n      return handleError(function(arg0, arg1) {\n        const ret = Reflect.get(arg0, arg1);\n        return ret;\n      }, arguments);\n    };\n    imports.wbg.__wbg_get_b9b93047fe3cf45b = function(arg0, arg1) {\n      const ret = arg0[arg1 >>> 0];\n      return ret;\n    };\n    imports.wbg.__wbg_gsplatarray_new = function(arg0) {\n      const ret = GsplatArray.__wrap(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_a446193dc22c12f8 = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_e2d2a49132c1b256 = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_new_405e22f390576ce2 = function() {\n      const ret = new Object();\n      return ret;\n    };\n    imports.wbg.__wbg_new_78feb108b6472713 = function() {\n      const ret = new Array();\n      return ret;\n    };\n    imports.wbg.__wbg_new_9fee97a409b32b68 = function(arg0) {\n      const ret = new Uint16Array(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_new_a12002a7f91c75be = function(arg0) {\n      const ret = new Uint8Array(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {\n      const ret = new Uint32Array(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(arg0, arg1, arg2) {\n      const ret = new Float32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(arg0, arg1, arg2) {\n      const ret = new Uint32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {\n      const ret = new Float32Array(arg0 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithlength_bd3de93688d68fbc = function(arg0) {\n      const ret = new Uint32Array(arg0 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_push_737cfc8c1432c2c6 = function(arg0, arg1) {\n      const ret = arg0.push(arg1);\n      return ret;\n    };\n    imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_3f1d0b984ed272ed = function(arg0, arg1, arg2) {\n      arg0[arg1] = arg2;\n    };\n    imports.wbg.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_bb8cecf6a62b9f46 = function() {\n      return handleError(function(arg0, arg1, arg2) {\n        const ret = Reflect.set(arg0, arg1, arg2);\n        return ret;\n      }, arguments);\n    };\n    imports.wbg.__wbg_set_d23661d19148b229 = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_subarray_769e1e0f81bb259b = function(arg0, arg1, arg2) {\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(arg0, arg1, arg2) {\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n      const ret = debugString(arg1);\n      const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n      const len1 = WASM_VECTOR_LEN;\n      getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n      getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbindgen_init_externref_table = function() {\n      const table = wasm.__wbindgen_export_2;\n      const offset = table.grow(4);\n      table.set(0, void 0);\n      table.set(offset + 0, void 0);\n      table.set(offset + 1, null);\n      table.set(offset + 2, true);\n      table.set(offset + 3, false);\n    };\n    imports.wbg.__wbindgen_is_falsy = function(arg0) {\n      const ret = !arg0;\n      return ret;\n    };\n    imports.wbg.__wbindgen_memory = function() {\n      const ret = wasm.memory;\n      return ret;\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n      const ret = arg0;\n      return ret;\n    };\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n      const ret = getStringFromWasm0(arg0, arg1);\n      return ret;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n      throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    return imports;\n  }\n  function __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedDataViewMemory0 = null;\n    cachedFloat32ArrayMemory0 = null;\n    cachedUint32ArrayMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n    wasm.__wbindgen_start();\n    return wasm;\n  }\n  async function __wbg_init(module_or_path) {\n    if (wasm !== void 0) return wasm;\n    if (typeof module_or_path !== "undefined") {\n      if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n        ({ module_or_path } = module_or_path);\n      } else {\n        console.warn("using deprecated parameters for the initialization function; pass a single object instead");\n      }\n    }\n    if (typeof module_or_path === "undefined") {\n      module_or_path = new URL("data:application/wasm;base64,AGFzbQEAAAAB+ANEYAN/f38Bf2ACf38Bf2ACf38AYAF/AGABfwF/YAN/f38AYAADf39/YAR/f39/AGAFf39/f38AYAF9AX1gAABgAW8Bf2AGf39/f39/AGAAAX9gA29/fwFvYAV/f39/fwF/YAFvAW9gA29vfwBgBH9/f38Bf2ADf35+AGADf35+AX9gAX8Bb2AAAW9gB39/f39/f38AYAF/A39/f2ACf30AYAR/fX9/AX9gB39/f39/f38Bf2AGf39/f39/AX9gBH9/f38Df39/YAN/b28Bf2ACfX0BfWAAAn9/YAJ/fwFvYANvb28Bf2ABfAFvYANvb28AYAJvfwFvYAJvbwF/YAJvbwFvYAJ/bwBgCX9/f39/f39/fwBgBn9/fX9/fwBgBH9/fX0BfWACf34AYAN/fX8Bf2AEfn5/fwF+YAF/AX1gCX9/f39/f35+fgBgA39+fwBgAn9+AX9gA319fQF9YAF+AX9gDn99fX1/f39/f39/f39/A39/f2AJf39/f39/f39vA39/f2AIf39/f39/f38Df39/YA19fX19fX19fX9vf319AW9gBH9vf30Df39/YAN/b38Df39/YAJ/bwN/f39gAn9vAn9/YAV/f31/fwBgBH99f38AYAV/f3x/fwBgBH98f38AYAV/f35/fwBgBH9+f38AYAF8AX8CwQkjA3diZxVfX3diZ19nc3BsYXRhcnJheV9uZXcAFQN3YmcVX193YmluZGdlbl9zdHJpbmdfbmV3ACEDd2JnGl9fd2JnX3NldF9iYjhjZWNmNmE2MmI5ZjQ2ACIDd2JnH19fd2JnX3N1YmFycmF5XzNhYWVlYzg5YmIyNTQ0ZjAADgN3YmcaX193YmdfbmV3XzQwNWUyMmYzOTA1NzZjZTIAFgN3YmcVX193YmluZGdlbl9udW1iZXJfbmV3ACMDd2JnGl9fd2JnX3NldF8zZjFkMGI5ODRlZDI3MmVkACQDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfYmQzZGU5MzY4OGQ2OGZiYwAVA3diZx1fX3diZ19sZW5ndGhfYTQ0NjE5M2RjMjJjMTJmOAALA3diZx9fX3diZ19zdWJhcnJheV9hYTkwNjVmYTlkYzVkZjk2AA4Dd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABYDd2JnHV9fd2JnX2J1ZmZlcl82MDljYzNlZWU1MWVkMTU4ABADd2JnGl9fd2JnX25ld19hMTIwMDJhN2Y5MWM3NWJlABADd2JnGl9fd2JnX3NldF82NTU5NWJkZDg2OGIzMDA5ABEDd2JnHV9fd2JnX2xlbmd0aF9lMmQyYTQ5MTMyYzFiMjU2AAsDd2JnGl9fd2JnX2dldF9iOWI5MzA0N2ZlM2NmNDViACUDd2JnGl9fd2JnX25ld183OGZlYjEwOGI2NDcyNzEzABYDd2JnG19fd2JnX3B1c2hfNzM3Y2ZjOGMxNDMyYzJjNgAmA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAALA3diZx9fX3diZ19zdWJhcnJheV83NjllMWUwZjgxYmIyNTliAA4Dd2JnGl9fd2JnX25ld185ZmVlOTdhNDA5YjMyYjY4ABADd2JnGl9fd2JnX3NldF9mNGYxZjBkYWEzMDY5NmZjABEDd2JnHV9fd2JnX2xlbmd0aF82Y2E1Mjc2NjVkODk2OTRkAAsDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfNWE1ZWZlMzEzY2ZkNTlmMQAVA3diZx1fX3diZ19sZW5ndGhfM2I0ZjAyMjE4OGFlOGRiNgALA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9lNmI3ZTY5YWNkNGM3MzU0AA4Dd2JnGl9fd2JnX3NldF8xMGJhZDliZWUwZTljNThiABEDd2JnGl9fd2JnX2dldF82N2IyYmE2MmZjMzBkZTEyACcDd2JnE19fd2JpbmRnZW5faXNfZmFsc3kACwN3YmcaX193YmdfbmV3X2UzYjMyMWRjZmVmODlmYzcAEAN3YmcaX193Ymdfc2V0X2QyMzY2MWQxOTE0OGIyMjkAEQN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZjFkZWFkNDRkMWZjNzIxMgAOA3diZxBfX3diaW5kZ2VuX3Rocm93AAIDd2JnF19fd2JpbmRnZW5fZGVidWdfc3RyaW5nACgDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFibGUACgOxA68DBRkIAAQXAwMaBQIEAAoHASkBFwcEBAoHBAcFBwUIAQUBDAIIAgQEBQMCAwgBBwECBCoCKwkICQcDBAEH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g0IIhoSEICFCCIhCgICA+A+DICFCGIhCgID8B4OEICFCKIhCgP4DgyAhQjiIhISEICBC2KLR78Kp5b8tfoUiIEI4hiAgQoD+A4NCKIaEICBCgID8B4NCGIYgIEKAgID4D4NCCIaEhCAgQgiIQoCAgPgPgyAgQhiIQoCA/AeDhCAgQiiIQoD+A4MgIEI4iISEhEKOip+43Pep+HF+IiFCOIYgIUKA/gODQiiGhCAhQoCA/AeDQhiGICFCgICA+A+DQgiGhIQgIUIIiEKAgID4D4MgIUIYiEKAgPwHg4QgIUIoiEKA/gODICFCOIiEhIQgIEKOnuCShIe+nXF+hSAgiTcDcAJAIAMoAlgiBCADKAJUTwRAQv///////////wAhLUKAgICAgICAgIB/IS5CgICAgICAgICAfyEvQoCAgICAgICAgH8hMEL///////////8AITFC////////////ACEyDAELQoCAgICAgICAgH8hMEL///////////8AITJC////////////ACExQv///////////wAhLUKAgICAgICAgIB/IS9CgICAgICAgICAfyEuAkADQCAAKAIUIgIgBEsEQCAAKAIQIARB0ABsai4BTCADLgFSSg0DIAQgACgCCCICTw0CIAMpA3ghIyADKQNwISUgAyAAKAIEIARBMGxq/QAEACAD/QkCXP3nAf1oIjf9HwH8BCIqNwOIAiADKQOAASEgIAMgN/0fAvwEIis3A5ACIAMpA4gBISEgAyA3/R8A/AQiJzcDgAIgJSAlICNCA4UiIkI4hiAiQoD+A4NCKIaEICJCgID8B4NCGIYgIkKAgID4D4NCCIaEhCAjQgiIQoCAgPgPgyAjQhiIQoCA/AeDhCAjQiiIQoD+A4MgI0I4iISEhELSgaqbq/qC16d/fiIjQjiGICNCgP4Dg0IohoQgI0KAgPwHg0IYhiAjQoCAgPgPg0IIhoSEICNCCIhCgICA+A+DICNCGIhCgID8B4OEICNCKIhCgP4DgyAjQjiIhISEICJC2KLR78Kp5b8tfoVCrf7V5NSF/ajYAH58QrjYj/Dyh7nXxwB8ICAgKoUiKEI4hiAoQoD+A4NCKIaEIChCgID8B4NCGIYgKEKAgID4D4NCCIaEhCAoQgiIQoCAgPgPgyAoQhiIQoCA/AeDhCAoQiiIQoD+A4MgKEI4iISE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ASIGQQlPBEAgAygCZCEFIAMoAmghByAIDAELIAYhBSAIIQdBCCEGIAsLIQIgBCgCACEKIAUgBkYEQCADQeAAahCNAiADKAJkIQUgAygCaCEHIAghAgsgByAFQQJ0aiAKNgIAIAIgAigCAEEBajYCACATIARBBGoiBEcNAAsMAQsgDyACNgIACyADQcgCaiADQYABaikCADcDACADQbgCaiADQfAAav0AAgD9CwMAIAMgA/0AAmD9CwOoAgJAAkACQAJ/An8CQCADKALMAiIGQQlJIgxFBEAgAygCrAIiAg0BQQEMAwsgDiAGIgINARpBAQwCCyADKAKwAgsiBCgCACIFIAAoAhQiD08NASAAKAIQIgogBUHQAGxqLwFMIQUgAkEBRwRAIARBBGohBCACQQFrQf////8DcSECA0AgBCgCACIHIA9PDQQgCiAHQdAAbGouAUwiByAFwSIFIAUgB0gbIQUgBEEEaiEEIAJBAWsiAg0ACwsgBcEgAy8BUkECa8FKBEAgAyADKAK8ASIFIAMoArABIgJGBH8gA0GwAWpBuJ/CABD7ASADKAK8ASEFIAMoArABBSACCyADKAK4AUEBayIEaiICIAQgAiAESRsiAjYCuAEgAygCtAEgAkEsbGoiAiAWNgIAIAIgAykDqAI3AgQgAkEMaiADQbACav0AAwD9CwIAIAJBHGogA0HAAmr9AAMA/QsCACADIAVBAWo2ArwBQQAMAQsgAygCrAEiAiADKAKgASIERgRAIANBoAFqQcifwgAQ+wEgAygCoAEhBCADKAKsASECCyADKAKkASADKAKoASACaiIFIARBACAEIAVNG2tBLGxqIgUgFjYCACAFIAMpA6gCNwIEIAVBDGogA0GwAmr9AAMA/QsCACAFQRxqIANBwAJq/QADAP0LAgAgAyACQQFqNgKsAUEACyADKAKcASIKIAMoApQBRgRAQQAhByMAQSBrIhIkAAJAAkAgA0GUAWoiEygCACIPQf////8BSw0AQQQgD0EBdCICIAJBBE0bIgVBAnQiAkH8////B0sNACASIA8EfyASIA9BAnQ2AhwgEiATKAIENgIUQQQFQQALNgIYIBJBCGpBBCACIBJBFGoQiAIgEigCCEEBRw0BIBIoAhAaIBIoAgwhBwsgB0HYn8IAEIMDAAsgEigCDCECIBMgBTYCACATIAI2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yMIAIAQ2AgBBpMjCAEGkyMIAKAIAIAVqIgA2AgAgBCAAQQFyNgIEDAULQajIwgAgBDYCAEGgyMIAQaDIwgAoAgAgBWoiADYCACAEIABBAXI2AgQgACAEaiAANgIADAQLQQAhA0GkyMIAKAIAIgAgBU0NAEGkyMIAIAAgBWsiATYCAEGsyMIAQazIwgAoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQgAEEIag8LIAMPC0GcyMIAQZzIwgAoAgBBfiACKAIcd3E2AgALAkAgA0EQTwRAIAIgBUEDcjYCBCACIAVqIgEgA0EBcjYCBCABIANqIAM2AgAgA0GAAk8EQCABIAMQywEMAgsgA0H4AXFBkMbCAGohAAJ/QZjIwgAoAgAiBEEBIANBA3Z0IgNxRQRAQZjIwgAgAyAEcjYCACAADAELIAAoAggLIQMgACABNgIIIAMgATYCDCABIAA2AgwgASADNgIIDAELIAIgAyAFaiIAQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIECyACQQhqDwsgAUEIagvuFwIbfwJ8IwBBsARrIgMkACADQgA3A5gBIANCADcDkAEgA0IANwOIASADQgA3A4ABIANCADcDeCADQgA3A3AgA0IANwNoIANCADcDYCADQgA3A1ggA0IANwNQIANCADcDSCADQgA3A0AgA0IANwM4IANCADcDMCADQgA3AyggA0IANwMgIANCADcDGCADQgA3AxAgA0IANwMIIANCADcDACADQgA3A7gCIANCADcDsAIgA0IANwOoAiADQgA3A6ACIANCADcDmAIgA0IANwOQAiADQgA3A4gCIANCADcDgAIgA0IANwP4ASADQgA3A/ABIANCADcD6AEgA0IANwPgASADQgA3A9gBIANCADcD0AEgA0IANwPIASADQgA3A8ABIANCADcDuAEgA0IANwOwASADQgA3A6gBIANCADcDoAEgA0IANwPYAyADQgA3A9ADIANCADcDyAMgA0IANwPAAyADQgA3A7gDIANCADcDsAMgA0IANwOoAyADQgA3A6ADIANCADcDmAMgA0IANwOQAyADQgA3A4gDIANCADcDgAMgA0IANwP4AiADQgA3A/ACIANCADcD6AIgA0IANwPgAiADQgA3A9gCIANCADcD0AIgA0IANwPIAiADQgA3A8ACIANB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IgMgASABoqIgAUSnRjuMh83GPqJEdOfK4vkAKr+goiACIAMgAUSy+26JEBGBP6JEd6zLVFVVxb+goqCgtgwECyABRBgtRFT7Ifk/oCICIAIgAqIiAaIiAyABIAGioiABRKdGO4yHzcY+okR058ri+QAqv6CiIAIgAyABRLL7bokQEYE/okR3rMtUVVXFv6CioKC2DAMLIARBgICAzANPBEAgASABoiIBRIFeDP3//9+/okQAAAAAAADwP6AgASABoiICREI6BeFTVaU/oqAgASACoiABRGlQ7uBCk/k+okQnHg/oh8BWv6CioLYMAwsgBSAAQwAAgHuSOAIIIAUqAggaQwAAgD8MAgtEGC1EVPshGcBEGC1EVPshGUAgBkEAThsgAaAiASABoiIBRIFeDP3//9+/okQAAAAAAADwP6AgASABoiICREI6BeFTVaU/oqAgASACoiABRGlQ7uBCk/k+okQnHg/oh8BWv6CioLYMAQtEGC1EVPshCcBEGC1EVPshCUAgBkEAThsgAaAiASABoiIBRIFeDP3//9+/okQAAAAAAADwP6AgASABoiICREI6BeFTVaU/oqAgASACoiABRGlQ7uBCk/k+okQnHg/oh8BWv6CioLaMCyAFQRBqJAALvQcBCn8jAEEgayIIJAACQAJAIAEoAhBFBEAgAUF/NgIQIAMgAyACQQNqQXxxIAJrIgprQQdxQQAgAyAKTxsiBGshCSADIARJDQECQAJAAkACfwJAIARFDQACfyAEQQFrIAIgA2oiBUEBayIGLQAAQQpGDQAaIAYgAiAJaiIGRg0BIARBAmsgBUECayIHLQAAQQpGDQAaIAYgB0YNASAEQQNrIAVBA2siBy0AAEEKRg0AGiAGIAdGDQEgBEEEayAFQQRrIgctAABBCkYNABogBiAHRg0BIARBBWsgBUEFayIHLQAAQQpGDQAaIAYgB0YNASAEQQZrIAVBBmsiBy0AAEEKRg0AGiAGIAdGDQEgBEEHayAFQQdrIgUtAABBCkYNABogBSAGRg0BIARBeHILIAlqQQFqDAELIAogAyADIApLGyEMQQAgBGshCiACQQRrIQ0gBEF/cyACaiEHA0ACQCAHIQUgCiEEIAkiBiAMTQ0AIARBCGshCiAFQQhrIQdBgIKECCACIAZBCGsiCWooAgAiC0GKlKjQAHNrIAtyQYCC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BSAGaiwAAEG/f0wNAQsgAiAGaiEEIAcNASAAQgE3AgggACADNgIEIAAgBDYCAA8LIAYgBCACIAVBxIjCABCVAwALIAIgBmpBAWshBiADIQECfwNAIAEiAkUEQEEAIQEgBCEFQQEMAgsgAkEBayEBIAIgBmotAABB3wBHDQALAkACQCABRQ0AAkAgASADTwRAIAEgA0cNASACDQJBACEGDAMLIAEgBGosAABBv39KDQELIAQgA0EAIAFB1IjCABCVAwALAkAgAiADTwRAIAMhBiACIANHDQEMAgsgAiAEaiwAAEG/f0wNACACIQYMAQsgBCADIAIgA0HkiMIAEJUDAAsgBCAGaiEFIAMgBmshAyAECyECIANFBEAMAQsgACADNgIMIAAgBTYCCCAAIAE2AgQgACACNgIADwsgAEEANgIAIABBADoABAuWBgEDfyMAQSBrIgMkACAAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEOKAIBAQEBAQEBAQMFAQEEAQEBAQEBAQEBAQEBAQEBAQEBAQEIAQEBAQcACyABQdwARg0FCyACQQFxRSABQf8FTXINByABELcBRQ0HIANBDmpBADoAACADQQA7AQwgAyABQRR2QfCAwgBqLQAAOgAPIAMgAUEEdkEPcUHwgMIAai0AADoAEyADIAFBCHZBD3FB8IDCAGotAAA6ABIgAyABQQx2QQ9xQfCAwgBqLQAAOgARIAMgAUEQdkEPcUHwgMIAai0AADoAECABQQFyZ0ECdiICIANBDGoiBWoiBEH7ADoAACAEQQFrQfUAOgAAIAUgAkECayICakHcADoAACADQRRqIgQgAUEPcUHwgMIAai0AADoAACAAIAMpAQw3AAAgA0H9ADoAFQwICyAAQgA3AQIgAEHc4AA7AQAMCgsgAEIANwECIABB3OgBOwEADAkLIABCADcBAiAAQdzkATsBAAwICyAAQgA3AQIgAEHc3AE7AQAMBwsgAEIANwECIABB3LgBOwEADAYLIAJBgAJxRQ0BIABCADcBAiAAQdzOADsBAAwFCyACQf///wdxQYCABE8NAwsgARD6AQ0BIANBGGpBADoAACADQQA7ARYgAyABQRR2QfCAwgBqLQAAOgAZIAMgAUEEdkEPcUHwgMIAai0AADoAHSADIAFBCHZBD3FB8IDCAGotAAA6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QYCAgNgDciADQRd0a3ILIQUgAS8BJCEBAn8gAkH//wFxBEAgAkH/B3EhAyACQYCAAnEhBCACQYD4AXEiAkGA+AFHBEAgBEEQdCIEIAJBDXRBgICA/ABxIANBDXRyQYCAgMADanIgAg0CGiADIANnQRBrIgJB//8DcUEIanRB////A3EgBEGAgIDYA3IgAkEXdGtyDAILIARBEHQiAiADQQ10ckGAgID+B3IgAw0BGiACQYCAgPwHcgwBCyACQRB0CyEDIAACfyABQf//AXEEQCABQf8HcSEAIAFBgIACcSECIAFBgPgBcSIBQYD4AUcEQCACQRB0IgIgAUENdEGAgID8AHEgAEENdHJBgICAwANqciABDQIaIAAgAGdBEGsiAEH//wNxQQhqdEH///8DcSACQYCAgNgDciAAQRd0a3IMAgsgAkEQdCIBIABBDXRyQYCAgP4HciAADQEaIAFBgICA/AdyDAELIAFBEHQLvhCcAf0TIAW+EJwB/SAAIAO+EJwB/SAB/QsEAAu2BAEEfyABLwEcIQQCfyABLwEaIgJB//8BcUUEQCACQRB0DAELIAJB/wdxIQUgAkGAgAJxIQMgAkGA+AFxIgJBgPgBRgRAIANBEHQhAiACQYCAgPwHciAFRQ0BGiACIAVBDXRyQYCAgP4HcgwBCyADQRB0IQMgAkENdEGAgID8AHEgBUENdHJBgICAwANqIANyIAINABogBSAFZ0EQayIFQf//A3FBCGp0Qf///wNxIANBgICA2ANyIAVBF3RrcgshBSABLwEeIQECfyAEQf//AXEEQCAEQf8HcSECIARBgIACcSEDIARBgPgBcSIEQYD4AUcEQCADQRB0IQMgBEENdEGAgID8AHEgAkENdHJBgICAwANqIANyIAQNAhogAiACZ0EQayIEQf//A3FBCGp0Qf///wNxIANBgICA2ANyIARBF3RrcgwCCyADQRB0IQQgBCACQQ10ckGAgID+B3IgAg0BGiAEQYCAgPwHcgwBCyAEQRB0CyEEIAACfyABQf//AXEEQCABQf8HcSECIAFBgIACcSEDIAFBgPgBcSIBQYD4AUcEQCADQRB0IQMgAUENdEGAgID8AHEgAkENdHJBgICAwANqIANyIAENAhogAiACZ0EQayIBQf//A3FBCGp0Qf///wNxIANBgICA2ANyIAFBF3RrcgwC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IAEoAhwhAQwBCyABKAIgIgIgASgCHCIBRg0BCyABIAdqIQggAiABayEDCyAAIAM2AgQgACAINgIAIAZBEGokAAuWAwEDfyMAQYABayIEJAACfwJAIAEoAggiAkGAgIAQcUUEQCACQYCAgCBxDQFBAyECIAAtAAAiACEDIABBCk8EQCAEIAAgAEHkAG4iA0HkAGxrQf8BcUEBdCICQbX6wABqLQAAOgACIAQgAkG0+sAAai0AADoAAUEBIQILQQAgACADG0UEQCAEIAJBAWsiAmogA0EBdEH+AXFBtfrAAGotAAA6AAALIAFBAUEBQQAgAiAEakEDIAJrEI4BDAILIAAtAAAhAkGBASEAA0AgACAEakECayACQQ9xIgNBMHIgA0HXAGogA0EKSRs6AAAgAkH/AXEiA0EEdiECIABBAWshACADQQ9LDQALIAFBAUGbisIAQQIgACAEakEBa0GBASAAaxCOAQwBCyAALQAAIQJBgQEhAANAIAAgBGpBAmsgAkEPcSIDQTByIANBN2ogA0EKSRs6AAAgAkH/AXEiA0EEdiECIABBAWshACADQQ9LDQALIAFBAUGbisIAQQIgACAEakEBa0GBASAAaxCOAQsgBEGAAWokAAu8AwIGfwF+IwBB0ABrIgIkACACQSBqIAAgACgCACgCBBECACACIAJByABqrUKAgICAwAGENwMoQQEhAyACQQE2AjQgAkHcq8IANgIwIAJCATcCPCACIAIpAyA3AkggAiACQShqNgI4AkAgASgCACIGIAEoAgQiByACQTBqEIwBDQAgAS0ACkGAAXFFBEBBACEDDAELIAJBGGogACAAKAIAKAIEEQIAIAJBEGogAigCGCACKAIcKAIYEQIAIAIoAhAiBEUEQEEAIQMMAQsgAkEIaiAEIAIoAhQiBSgCGBECACACKAIMIQAgAigCCCEBIAIgBTYCLCACIAQ2AiggAkEBNgI0IAJBoM/AADYCMCACQgE3AjwgAiACQShqrUKAgICAwAGEIgg3A0ggAiACQcgAajYCOCAGIAcgAkEwahCKAw0AA0AgAUUEQEEAIQMMAgsgAiABIAAoAhgRAgAgAigCBCACKAIAIAIgADYCLCACIAE2AiggAkEBNgI0IAJBoM/AADYCMCACQgE3AjwgAiAINwNIIAIgAkHIAGo2AjghASEAIAYgByACQTBq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A0F4cSIEQQRBCCADQQNxIgMbIAJqSQ0BIANBACAEIAJBJ2pLGw0CIAEQWwsgACgCFCEBIAAoAhgiAigCACIDBEAgASADEQMACyACKAIEIgIEQCABQQRrKAIAIgNBeHEiBEEEQQggA0EDcSIDGyACakkNASADQQAgBCACQSdqSxsNAiABEFsLAkAgAEF/Rg0AIAAgACgCBEEBayIBNgIEIAENACAAQQRrKAIAIgFBeHEiAkEgQSQgAUEDcSIBG0kNASABQQAgAkHEAE8bDQIgABBbCw8LQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIAC9cCAQV/QRFBACAAQa+wBE8bIgIgAkEIciIBIABBC3QiAiABQQJ0QYSUwQBqKAIAQQt0SRsiASABQQRyIgEgAUECdEGElMEAaigCAEELdCACSxsiASABQQJyIgEgAUECdEGElMEAaigCAEELdCACSxsiASABQQFqIgEgAUECdEGElMEAaigCAEELdCACSxsiASABQQFqIgEgAUECdEGElMEAaigCAEELdCACSxsiAUECdEGElMEAaigCAEELdCIEIAJGIAIgBEtqIAFqIgRBAnRBhJTBAGoiBSgCAEEVdiECQe8FIQECQCAEQSBNBEAgBSgCBEEVdiEBIARFDQELIAVBBGsoAgBB////AHEhAwsCQCABIAJBf3NqRQ0AIAAgA2shAyABQQFrIQFBACEAA0AgACACQe/ZwABqLQAAaiIAIANLDQEgASACQQFqIgJHDQALCyACQQFxC9cCAQV/QRJBACAAQbC4BE8bIgIgAkEJciIBIABBC3QiAiABQQJ0QZiSwQBqKAIAQQt0SRsiASABQQVqIgEgAUECdEGYksEAaigCAEELdCACSxsiASABQQJqIgEgAUECdEGYksEAaigCAEELdCACSxsiASABQQFqIgEgAUECdEGYksEAaigCAEELdCACSxsiASABQQFqIgEgAUECdEGYksEAaigCAEELdCACSxsiAUECdEGYksEAaigCAEELdCIEIAJGIAIgBEtqIAFqIgRBAnRBmJLBAGoiBSgCAEEVdiECQYkHIQECQCAEQSNNBEAgBSgCBEEVdiEBIARFDQELIAVBBGsoAgBB////AHEhAwsCQCABIAJBf3NqRQ0AIAAgA2shAyABQQFrIQFBACEAA0AgACAC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AiAGaiADIAQQ9gEhAgsgBCgCAEEEaigCACAAKAIAIAEoAgAQigEiAyAEKAIAQQRqKAIAIAAoAgAgAigCABCKAUYEfyACIAEgBCgCAEEEaigCACABKAIAIAIoAgAQigEgA3MbBSAACwu9AQEEfyMAQRBrIgIkACACQQhqIgMgAUEkaigCADYCACACIAEpAhw3AwACQAJAQQwQLiIEBEAgBCACKQMANwIAIARBCGogAygCADYCACABQQRqEHEgAUEEaygCACIDQXhxQSxBMCADQQNxIgUbSQ0BIAVBACADQdAATxsNAiABEFsgAEHMjsIANgIEIAAgBDYCACACQRBqJAAPCwALQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIAC6gBAQN/IwBBEGsiAyQAQQMhAiAALQAAIgAhBCAAQQpPBEAgAyAAIABB5ABuIgRB5ABsa0H/AXFBAXQiAkG1+sAAai0AADoADyADIAJBtPrAAGotAAA6AA5BASECC0EAIAAgBBtFBEAgAkEBayICIANBDWpqIARBAXRB/gFxQbX6wABqLQAAOgAACyABQQFBAUEAIANBDWogAmpBAyACaxCOASADQRBqJAALqgMBCH8jAEEQayIDJAAgACgCBCEFIAAoAgAhAEEBIQcgASgCAEG3icIAQQEgASgCBCgCDBEAACECIANBADoACSADIAI6AAggAyABNgIEAkACQCAFBEADQCADIAA2AgwgA0EMaiEIIwBBIGsiASQAQQEhBgJAIANBBGoiBC0ABA0AIAQtAAUhCQJAIAQoAgAiAi0ACkGAAXFFBEAgCUEBcUUNASACKAIAQbWJwgBBAiACKAIEKAIMEQAARQ0BDAILIAlBAXFFBEAgAigCAEHstMIAQQEgAigCBCgCDBEAAA0CCyABQQE6AA8gAUHk+MAANgIUIAEgAikCADcCACABIAIpAgg3AhggASABQQ9qNgIIIAEgATYCECAIIAFBEGoQxgINASABKAIQQYP5wABBAiABKAIUKAIMEQAAIQYMAQsgCCACEMYCIQYLIARBAToABSAEIAY6AAQgAUEgaiQAIABBAWohACAFQQFrIgUNAAsgAy0ACEEBcUUNAQwCCyACDQELIAMoAgQiACgCAEG4icIAQQEgACgCBCgCDBEAACEHCyADQRBqJAAgBwvhAQAgAEEg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DygCEBEAACIJRQ0ACyACQQA2AhAgAkKAgICAEDcCCCACQdydwAA2AhwgAkKggICADjcCICACIAJBCGo2AhggCSACQRhqEKwBDQggAigCCCEAIAIoAgwiBCACKAIQEIADIQMgAARAIARBBGsoAgAiBUF4cSIIQQRBCCAFQQNxIgUbIABqSQ0KIAVBACAIIABBJ2pLGw0LIAQQWwsgCSAJKAIAKAIAEQMAQQEhAEGUwsIAQZTCwgAoAgBBAWo2AgAgBkGDAUsNAQwCC0EAIQBBlMLCAEGUwsIAKAIAQQFqNgIAIAZBhAFJDQELIAcgEUkhACAGELUCCyALQQA2AgAgDCAMKAIAQQFrIgY2AgAgBkUEQCAMELYBCyAKIAA2AgQgCiADQQAgABs2AgAgAkEwaiQADAgLELMDCwALELUDAAtBzJ3AABC4AgALIAJBADYCGCACQRRqIAJBCGogAkEYakHc78EAEM8CAAtBvM3AAEE3IAJBFGpB9J3AAEH0zcAAEJMCAAtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgALIAooAgAgCigCBCAKQRBqJAALKgAgACABLQAAQQJ0IgFBpMvAAGooAgA2AgQgACABQbjLwABqKAIANgIACyEAAkAgAARAIAAoAgBFDQEQtQMACxCzAwALIAAgATYCRAshAAJAIAAEQCAAKAIARQ0BELUDAAsQswMACyAAIAE2AkgLJQAgAEUEQEGo78EAQTIQtAMACyAAIAIgAyAEIAUgASgCEBEPAAslACABIAAtAABBAnQiAEGAucIAaigCACAAQey4wgBqKAIAEIQBCyMAIABFBEBBqO/BAEEyELQDAAsgACACIAMgBCABKAIQERIACyMAIABFBEBBqO/BAEEyELQDAAsgACACIAMgBCABKAIQEQcACyMAIABFBEBBqO/BAEEyELQDAAsgACACIAMgBCABKAIQET4ACyMAIABFBEBBqO/BAEEyELQDAAsgACACIAMgBCABKAIQEUAACyMAIABFBEBBqO/BAEEyELQDAAsgACACIAMgBCABKAIQEUIACycAIAAoAgAtAABFBEAgAUGMisIAQQUQhAEPCyABQZGKwgBBBBCEAQsnACAAQRxqQQAgAkKtoMydv86x+lJRG0EAIAFCucS3xZeH/65OURsLKAAgAEEcakEAIAJC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ZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2NvcmUvc3JjL3NsaWNlL2luZGV4LnJzAGxpYnJhcnkvY29yZS9zcmMvbnVtL2ZsdDJkZWMvc3RyYXRlZ3kvZ3Jpc3UucnMAc3BhcmstaW50ZXJuYWwtcnMvc3JjL3JheWNhc3QucnMAbGlicmFyeS9jb3JlL3NyYy9zbGljZS9zb3J0L3NoYXJlZC9zbWFsbHNvcnQucnMAL1VzZXJzL2FzdW5kcXVpLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9zb3J0L3N0YWJsZS9xdWlja3NvcnQucnMAc3BhcmstaW50ZXJuYWwtcnMvc3JjL3NvcnQucnMAbGlicmFyeS9hbGxvYy9zcmMvZm10LnJzAC9Vc2Vycy9hc3VuZHF1aS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2FueWhvdy0xLjAuOTgvc3JjL2ZtdC5ycwBsaWJyYXJ5L2NvcmUvc3JjL251bS9kaXlfZmxvYXQucnMAc3BhcmstbGliL3NyYy9nc3BsYXQucnMAc3BhcmstaW50ZXJuYWwtcnMvc3JjL3BhY2tlZF9zcGxhdHMucnMAbGlicmFyeS9jb3JlL3NyYy9mbXQvYnVpbGRlcnMucnMAbGlicmFyeS9zdGQvc3JjL3N5cy9zeW5jL211dGV4L25vX3RocmVhZHMucnMAL1VzZXJzL2FzdW5kcXVpLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9zdGQvc3JjL3N5cy9zeW5jL29uY2Uvbm9fdGhyZWFkcy5ycwBsaWJyYXJ5L2FsbG9jL3NyYy9zdHIucnMAL1VzZXJzL2FzdW5kcXVpLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9jb3JlL3NyYy9pdGVyL3RyYWl0cy9pdGVyYXRvci5ycwAvVXNlcnMvYXN1bmRxdWkvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9hbnlob3ctMS4wLjk4L3NyYy9lcnJvci5ycwBsaWJyYXJ5L2NvcmUvc3JjL3NsaWNlL21lbWNoci5ycwAvVXNlcnMvYXN1bmRxdWkvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9taW5pel9veGlkZS0wLjguOS9zcmMvaW5mbGF0ZS9vdXRwdXRfYnVmZmVyLnJzAC9Vc2Vycy9hc3VuZHF1aS9zcGFyazMvcnVzdC9zcGFyay1saWIvc3JjL2RlY29kZXIucnMAbGlicmFyeS9zdGQvc3JjL2lvL3N0ZGlvLnJzAC9Vc2Vycy9hc3VuZHF1aS8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvY29yZS9zcmMvc3RyL3BhdHRlcm4ucnMAL3J1c3RjLzI5NDgzODgzZWVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9jb3JlL3NyYy9zdHIvcGF0dGVybi5ycwAvcnVzdGMvMjk0ODM4ODNlZWQ2OWQ1ZmI0ZGIwMTk2NGNkZjJhZjRkODZlOWNiMi9saWJyYXJ5L2NvcmUvc3JjL29wcy9mdW5jdGlvbi5ycwBsaWJyYXJ5L2NvcmUvc3JjL251bS9mbHQyZGVjL3N0cmF0ZWd5L2RyYWdvbi5ycwBsaWJyYXJ5L2NvcmUvc3JjL251bS9iaWdudW0ucnMAbGlicmFyeS9zdGQvc3JjL2lvL2J1ZmZlcmVkL2xpbmV3cml0ZXJzaGltLnJzAC9Vc2Vycy9hc3VuZHF1aS8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvc3RkL3NyYy90aHJlYWQvbG9jYWwucnMAbGlicmFyeS9zdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzAGxpYnJhcnkvc3RkL3NyYy9zeW5jL3JlZW50cmFudF9sb2NrLnJzAC9Vc2Vycy9hc3VuZHF1aS8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAvVXNlcnMvYXN1bmRxdWkvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9taW5pel9veGlkZS0wLjguOS9zcmMvaW5mbGF0ZS9jb3JlLnJzAGxpYnJhcnkvY29yZS9zcmMvdW5pY29kZS9wcmludGFibGUucnMAc3BhcmstaW50ZXJuYWwtcnMvc3JjL2xvZF90cmVlLnJzAHNwYXJrLWxpYi9zcmMvc3BsYXRfZW5jb2RlLnJzAGxpYnJhcnkvc3RkL3NyYy9zeW5jL3BvaXNvbi9vbmNlLnJzAC9Vc2Vycy9hc3VuZHF1aS8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJzAGxpYnJhcnkvc3RkL3NyYy9iYWNrdHJhY2UucnMAL3J1c3QvZGVwcy9oYXNoYnJvd24tMC4xNS40L3NyYy9yYXcvbW9kLnJzAGxpYnJhcnkvY29yZS9zcmMvZm10L21vZC5ycwBsaWJyYXJ5L2NvcmUvc3JjL3N0ci9tb2QucnMAL1VzZXJzL2FzdW5kcXVpLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvYmluYXJ5X2hlYXAvbW9kLnJzAGxpYnJhcnkvc3RkL3NyYy9pby9tb2QucnMAbGlicmFyeS9zdGQvc3JjLy4uLy4uL2JhY2t0cmFjZS9zcmMvc3ltYm9saXplL21vZC5ycwBsaWJyYXJ5L3N0ZC9zcmMvdGhyZWFkL21vZC5ycwAvVXNlcnMvYXN1bmRxdWkvLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjL21vZC5ycwAvVXNlcnMvYXN1bmRxdWkvLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy92ZWMvbW9kLnJzAGxpYnJhcnkvY29yZS9zcmMvbnVtL2ZsdDJkZWMvbW9kLnJzAHNwYXJrLWxpYi9zcmMvcXVpY2tfbG9kLnJzAC9ydXN0L2RlcHMvZGxtYWxsb2MtMC4yLjkvc3JjL2RsbWFsbG9jLnJzAHNwYXJrLWludGVybmFsLXJzL3NyYy9saWIucnMAL1VzZXJzL2FzdW5kcXVpLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvanMtc3lzLTAuMy43Ny9zcmMvbGliLnJzAC9ydXN0L2RlcHMvcnVzdGMtZGVtYW5nbGUtMC4xLjI1L3NyYy9saWIucnMAL1VzZXJzL2FzdW5kcXVpLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvc2VyZGUtd2FzbS1iaW5kZ2VuLTAuNi41L3NyYy9saWIucnMAL1VzZXJzL2FzdW5kcXVpLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvb25jZV9jZWxsLTEuMjEuMy9zcmMvbGliLnJzAC9Vc2Vycy9hc3VuZHF1aS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3NtYWxsdmVjLTEuMTUuMS9zcmMvbGliLnJzAGxpYnJhcnkvY29yZS9zcmMvdW5pY29kZS91bmljb2RlX2RhdGEucnMAc3BhcmstbGliL3NyYy9zeW1tYXQzLnJzAC9ydXN0L2RlcHMvcnVzdGMtZGVtYW5nbGUtMC4xLjI1L3NyYy92MC5y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AgYBAWUBAQECBAEFAAkBAgACAQEEAZAEAgIEASAKKAYCBAgBCQYCAy4NAQIABwEGAQFSFgIHAQIBAnoGAwEBAgEHAQFIAgMBAQEAAgsCNAUFAQEBFwEAEQYPAAwDAwAFOwcJBAADKAIAAT8RQAIBAgAEAQcBAgACAQQALgIXAAMJEAIHHgSUAwA3BDIIAQ4BFgUBDwAHARECBwECAQUFPiEBoA4AAT0EAAX+AgAHbQgABQABHmCA8ABBGgYaLwEKAQQBBRcBHwHDAQQE0AEkBwIeBWABKgQCAgIEAQEGAQEDAQEBFAFTAYsIpgEmCSkAJgEBBQECKwEEAFYCBgALBSsCA0DAQAACBgImAgYCCAEBAQEBAQEfAjUBBwEBAwMBBwMEAgYEDQUDAQd0AQ0BEA1lAQQBAgoBAQMFBgEBAQEBAQQBBgQBAgQFBQQBESADAgA0AOUGBAMCDCYBAQUBAC4SHoRmAwQBPgICAQEBCBUFAQMAKwEOBlAABwwFABoGGgBQYCQEJHQLAQ8BBwECAQsBDwEHAQIAAQIDASoBCQAzDTNdFgoWAEAAQABVAUcBAgIBAgICBAEMAQEBBwFBAQQCCAEHARwBBAEFAQEDBwEAAhkBGQEfARkBHwEZAR8BGQEfARkBCAAKARQGBgA+AEQAGgYaBhoAAHAABwAtAQEBAgECAQFICzAVEAFlBwIGAgIBBCMBHhtbCzoJCQEYBAEJAQMBBSsDOwkqGAEgNwEBAQQIBAEDBwoCHQE6AQEBAgQIAQkBCgIaAQICOQEEAgQCAgMDAR4CAwELAjkBBAUBAgQBFAIWBgEBOgEBAgEECAEHAwoCHgE7AQEBDAEJASgBAwE3AQEDBQMBBAcCCwIdAToBAgIBAQMDAQQHAgsCHAI5AgEBAgQIAQkBCgIdAUgBBAECAwEBCAFRAQIHDAhiAQIJCwdJAhsBAQEBATcOAQUBAgULASQJAWYEAQYBAgICGQIEAxAEDQECAgYBDwEAAwAEHAMdAh4CQAIBBwgBAgsJAS0DAQF1AiIBdgMEAgkBBgPbAgIBOgEBBwEBAQECCAYKAgEwHzEEMAoEAyYJDAIgBAIGOAEBAgMBAQU4CAICmAMBDQEHBAEGAQMCxkAAAcMhAAONAWAgAAZpAgAEAQogAlACAAEDAQQBGQIFAZcCGhINASYIGQsBASwDMAECBAIC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AQAAAgEAAAMBAAAEAQAABQEAAAYBAAAHAQAACAEAAAkBAAAKAQAACwEAAAwBAAANAQAADgEAAA8BAAAQAQAAEQEAABIBAAATAQAAFAEAABUBAAAWAQAAFwEAABgBAAAZAQAAGgEAABsBAAAcAQAAHQEAAB4BAAAfAQAAIAEAACEBAAAiAQAAIwEAACQBAAAlAQAAJgEAACcBAAAoAQAAKQEAACoBAAArAQAALAEAAC0BAAAuAQAALwEAADABAAAAAEAAMgEAADMBAAA0AQAANQEAADYBAAA3AQAAOQEAADoBAAA7AQAAPAEAAD0BAAA+AQAAPwEAAEABAABBAQAAQgEAAEMBAABEAQAARQEAAEYBAABHAQAASAEAAEoBAABLAQAATAEAAE0BAABOAQAATwEAAFABAABRAQAAUgEAAFMBAABUAQAAVQEAAFYBAABXAQAAWAEAAFkBAABaAQAAWwEAAFwBAABdAQAAXgEAAF8BAABgAQAAYQEAAGIBAABjAQAAZAEAAGUBAABmAQAAZwEAAGgBAABpAQAAagEAAGsBAABsAQAAbQEAAG4BAABvAQAAcAEAAHEBAAByAQAAcwEAAHQBAAB1AQAAdgEAAHcBAAB4AQAA/wAAAHkBAAB6AQAAewEAAHwBAAB9AQAAfgEAAIEBAABTAgAAggEAAIMBAACEAQAAhQEAAIYBAABUAgAAhwEAAIgBAACJAQAAVgIAAIoBAABXAgAAiwEAAIwBAACOAQAA3QEAAI8BAABZAgAAkAEAAFsCAACRAQAAkgEAAJMBAABgAgAAlAEAAGMCAACWAQAAaQIAAJcBAABoAgAAmAEAAJkBAACcAQAAbwIAAJ0BAAByAgAAnwEAAHUCAACgAQAAoQEAAKIBAACjAQAApAEAAKUBAACmAQAAgAIAAKcBAACoAQAAqQEAAIMCAACsAQAArQEAAK4BAACIAgAArwEAALABAACxAQAAigIAALIBAACLAgAAswEAALQBAAC1AQAAtgEAALcBAACSAgAAuAEAALkBAAC8AQAAvQEAAMQBAADGAQAAxQEAAMYBAADHAQAAyQEAAMgBAADJAQAAygEAAMwBAADLAQAAzAEAAM0BAADOAQAAzwEAANABAADRAQAA0gEAANMBAADUAQAA1QEAANYBAADXAQAA2AEAANkBAADaAQAA2wEAANwBAADeAQAA3wEAAOABAADhAQAA4gEAAOMBAADkAQAA5QEAAOYBAADnAQAA6AEAAOkBAADqAQAA6wEAAOwBAADtAQAA7gEAAO8BAADxAQAA8wEAAPIBAADzAQAA9AEAAPUBAAD2AQAAlQEAAPcBAAC/AQAA+AEAAPkBAAD6AQAA+wEAAPwBAAD9AQAA/gEAAP8BAAAAAgAAAQIAAAICAAADAgAABAIAAAUCAAAGAgAABwIAAAgCAAAJAgAACgIAAAsCAAAMAgAADQIAAA4CAAAPAgAAEAIAABECAAASAgAAEwIAABQCAAAVAgAAFgIAABcCAAAYAgAAGQIAABoCAAAbAgAAHAIAAB0CAAAeAgAAHwIAACACAACeAQAAIgIAACMCAAAkAgAAJQIAACYCAAAnAgAAKAIAACkCAAAqAgAAKwIAACwCAAAtAgAALgIAAC8CAAAwAgAAMQIAADICAAAzAgAAOgIAAGUsAAA7AgAAPAIAAD0CAACaAQAAPgIAAGYsAABBAgAAQgIAAEMCAACAAQAARAIAAIkCAABFAgAAjAIAAEYCAABHAgAASAIAAEkCAABKAgAASwIAAEwCAABNAgAATgIAAE8CAABwAwAAcQMAAHIDAABzAwAAdgMAAHcDAAB/AwAA8wMAAIYDAACsAwAAiAMAAK0DAACJAwAArgMAAIoDAACvAwAAjAMAAMwDAACOAwAAzQMAAI8DAADOAwAAkQMAALEDAACSAwAAsgMAAJMDAACzAwAAlAMAALQDAACVAwAAtQMAAJYDAAC2AwAAlwMAALcDAACYAwAAuAMAAJkDAAC5AwAAmgMAALoDAACbAwAAuwMAAJwDAAC8AwAAnQMAAL0DAACeAwAAvgMAAJ8DAAC/AwAAoAMAAMADAAChAwAAwQMAAKMDAADDAwAApAMAAMQDAAClAwAAxQMAAKYDAADGAwAApwMAAMcDAACoAwAAyAMAAKkDAADJAwAAqgMAAMoDAACrAwAAywMAAM8DAADXAwAA2AMAANkDAADaAwAA2wMAANwDAADdAwAA3gMAAN8DAADgAwAA4QMAAOIDAADjAwAA5AMAAOUDAADmAwAA5wMAAOgDAADpAwAA6gMAAOsDAADsAwAA7QMAAO4DAADvAwAA9AMAALgDAAD3AwAA+AMAAPkDAADyAwAA+gMAAPsDAAD9AwAAewMAAP4DAAB8AwAA/wMAAH0DAAAABAAAUAQAAAEEAABRBAAAAgQAAFIEAAADBAAAUwQAAAQEAABUBAAABQQAAFUEAAAGBAAAVgQAAAcEAABXBAAACAQAAFgEAAAJBAAAWQQAAAoEAABaBAAACwQAAFsEAAAMBAAAXAQAAA0EAABdBAAADgQAAF4EAAAPBAAAXwQAABAEAAAwBAAAEQQAADEEAAASBAAAMgQAABMEAAAzBAAAFAQAADQEAAAVBAAANQQAABYEAAA2BAAAFwQAADcEAAAYBAAAOAQAABkEAAA5BAAAGgQAADoEAAAbBAAAOwQAABwEAAA8BAAAHQQAAD0EAAAeBAAAPgQAAB8EAAA/BAAAIAQAAEAEAAAhBAAAQQQAACIEAABCBAAAIwQAAEMEAAAkBAAARAQAACUEAABFBAAAJgQAAEYEAAAnBAAARwQAACgEAABIBAAAKQQAAEkEAAAqBAAASgQAACsEAABLBAAALAQAAEwEAAAtBAAATQQAAC4EAABOBAAALwQAAE8EAABgBAAAYQQAAGIEAABjBAAAZAQAAGUEAABmBAAAZwQAAGgEAABpBAAAagQAAGsEAABsBAAAbQQAAG4EAABvBAAAcAQAAHEEAAByBAAAcwQAAHQEAAB1BAAAdgQAAHcEAAB4BAAAeQQAAHoEAAB7BAAAfAQAAH0EAAB+BAAAfwQAAIAEAACBBAAAigQAAIsEAACMBAAAjQQAAI4EAACPBAAAkAQAAJEEAACSBAAAkwQAAJQEAACVBAAAlgQAAJcEAACYBAAAmQQAAJoEAACbBAAAnAQAAJ0EAACeBAAAnwQAAKAEAAChBAAAogQAAKMEAACkBAAApQQAAKYEAACnBAAAqAQAAKkEAACqBAAAqwQAAKwEAACtBAAArgQAAK8EAACwBAAAsQQAALIEAACzBAAAtAQAALUEAAC2BAAAtwQAALgEAAC5BAAAugQAALsEAAC8BAAAvQQAAL4EAAC/BAAAwAQAAM8EAADBBAAAwgQAAMMEAADEBAAAxQQAAMYEAADHBAAAyAQAAMkEAADKBAAAywQAAMwEAADNBAAAzgQAANAEAADRBAAA0gQAANMEAADUBAAA1QQAANYEAADXBAAA2AQAANkEAADaBAAA2wQAANwEAADdBAAA3gQAAN8EAADgBAAA4QQAAOIEAADjBAAA5AQAAOUEAADmBAAA5wQAAOgEAADpBAAA6gQAAOsEAADsBAAA7QQAAO4EAADvBAAA8AQAAPEEAADyBAAA8wQAAPQEAAD1BAAA9gQAAPcEAAD4BAAA+QQAAPoEAAD7BAAA/AQAAP0EAAD+BAAA/wQAAAAFAAABBQAAAgUAAAMFAAAEBQAABQUAAAYFAAAHBQAACAUAAAkFAAAKBQAACwUAAAwFAAANBQAADgUAAA8FAAAQBQAAEQUAABIFAAATBQAAFAUAABUFAAAWBQAAFwUAABgFAAAZBQAAGgUAABsFAAAcBQAAHQUAAB4FAAAfBQAAIAUAACEFAAAiBQAAIwUAACQFAAAlBQAAJgUAACcFAAAoBQAAKQUAACoFAAArBQAALAUAAC0FAAAuBQAALwUAADEFAABhBQAAMgUAAGIFAAAzBQAAYwUAADQFAABkBQAANQUAAGUFAAA2BQAAZgUAADcFAABnBQAAOAUAAGgFAAA5BQAAaQUAADoFAABqBQAAOwUAAGsFAAA8BQAAbAUAAD0FAABtBQAAPgUAAG4FAAA/BQAAbwUAAEAFAABwBQAAQQUAAHEFAABCBQAAcgUAAEMFAABzBQAARAUAAHQFAABFBQAAdQUAAEYFAAB2BQAARwUAAHcFAABIBQAAeAUAAEkFAAB5BQAASgUAAHoFAABLBQAAewUAAEwFAAB8BQAATQUAAH0FAABOBQAAfgUAAE8FAAB/BQAAUAUAAIAFAABRBQAAgQUAAFIFAACCBQAAUwUAAIMFAABUBQAAhAUAAFUFAACFBQAAVgUAAIYFAACgEAAAAC0AAKEQAAABLQAAohAAAAItAACjEAAAAy0AAKQQAAAELQAApRAAAAUtAACmEAAABi0AAKcQAAAHLQAAqBAAAAgtAACpEAAACS0AAKoQAAAKLQAAqxAAAAstAACsEAAADC0AAK0QAAANLQAArhAAAA4tAACvEAAADy0AALAQAAAQLQAAsRAAABEtAACyEAAAEi0AALMQAAATLQAAtBAAABQtAAC1EAAAFS0AALYQAAAWLQAAtxAAABctAAC4EAAAGC0AALkQAAAZLQAAuhAAABotAAC7EAAAGy0AALwQAAAcLQAAvRAAAB0tAAC+EAAAHi0AAL8QAAAfLQAAwBAAACAtAADBEAAAIS0AAMIQAAAiLQAAwxAAACMtAADEEAAAJC0AAMUQAAAlLQAAxxAAACctAADNEAAALS0AAKATAABwqwAAoRMAAHGrAACiEwAAcqsAAKMTAABzqwAApBMAAHSrAAClEwAAdasAAKYTAAB2qwAApxMAAHerAACoEwAAeKsAAKkTAAB5qwAAqhMAAHqrAACrEwAAe6sAAKwTAAB8qwAArRMAAH2rAACuEwAAfqsAAK8TAAB/qwAAsBMAAICrAACxEwAAgasAALITAACCqwAAsxMAAIOrAAC0EwAAhKsAALUTAACFqwAAthMAAIarAAC3EwAAh6sAALgTAACIqwAAuRMAAImrAAC6EwAAiqsAALsTAACLqwAAvBMAAIyrAAC9EwAAjasAAL4TAACOqwAAvxMAAI+rAADAEwAAkKsAAMETAACRqwAAwhMAAJKrAADDEwAAk6sAAMQTAACUqwAAxRMAAJWrAADGEwAAlqsAAMcTAACXqwAAyBMAAJirAADJEwAAmasAAMoTAACaqwAAyxMAAJurAADMEwAAnKsAAM0TAACdqwAAzhMAAJ6rAADPEwAAn6sAANATAACgqwAA0RMAAKGrAADSEwAAoqsAANMTAACjqwAA1BMAAKSrAADVEwAApasAANYTAACmqwAA1xMAAKerAADYEwAAqKsAANkTAACpqwAA2hMAAKqrAADbEwAAq6sAANwTAACsqwAA3RMAAK2rAADeEwAArqsAAN8TAACvqwAA4BMAALCrAADhEwAAsasAAOITAACyqwAA4xMAALOrAADkEwAAtKsAAOUTAAC1qwAA5hMAALarAADnEwAAt6sAAOgTAAC4qwAA6RMAALmrAADqEwAAuqsAAOsTAAC7qwAA7BMAALyrAADtEwAAvasAAO4TAAC+qwAA7xMAAL+rAADwEwAA+BMAAPETAAD5EwAA8hMAAPoTAADzEwAA+xMAAPQTAAD8EwAA9RMAAP0TAACJHAAAihwAAJAcAADQEAAAkRwAANEQAACSHAAA0hAAAJMcAADTEAAAlBwAANQQAACVHAAA1RAAAJYcAADWEAAAlxwAANcQAACYHAAA2BAAAJkcAADZEAAAmhwAANoQAACbHAAA2xAAAJwcAADcEAAAnRwAAN0QAACeHAAA3hAAAJ8cAADfEAAAoBwAAOAQAAChHAAA4RAAAKIcAADiEAAAoxwAAOMQAACkHAAA5BAAAKUcAADlEAAAphwAAOYQAACnHAAA5xAAAKgcAADoEAAAqRwAAOkQAACqHAAA6hAAAKscAADrEAAArBwAAOwQAACtHAAA7RAAAK4cAADuEAAArxwAAO8QAACwHAAA8BAAALEcAADxEAAAshwAAPIQAACzHAAA8xAAALQcAAD0EAAAtRwAAPUQAAC2HAAA9hAAALccAAD3EAAAuBwAAPgQAAC5HAAA+RAAALocAAD6EAAAvRwAAP0QAAC+HAAA/hAAAL8cAAD/EAAAAB4AAAEeAAACHgAAAx4AAAQeAAAFHgAABh4AAAceAAAIHgAACR4AAAoeAAALHgAADB4AAA0eAAAOHgAADx4AABAeAAARHgAAEh4AABMeAAAUHgAAFR4AABYeAAAXHgAAGB4AABkeAAAaHgAAGx4AABweAAAdHgAAHh4AAB8eAAAgHgAAIR4AACIeAAAjHgAAJB4AACUeAAAmHgAAJx4AACgeAAApHgAAKh4AACseAAAsHgAALR4AAC4eAAAvHgAAMB4AADEeAAAyHgAAMx4AADQeAAA1HgAANh4AADceAAA4HgAAOR4AADoeAAA7HgAAPB4AAD0eAAA+HgAAPx4AAEAeAABBHgAAQh4AAEMeAABEHgAARR4AAEYeAABHHgAASB4AAEkeAABKHgAASx4AAEweAABNHgAATh4AAE8eAABQHgAAUR4AAFIeAABTHgAAVB4AAFUeAABWHgAAVx4AAFgeAABZHgAAWh4AAFseAABcHgAAXR4AAF4eAABfHgAAYB4AAGEeAABiHgAAYx4AAGQeAABlHgAAZh4AAGceAABoHgAAaR4AAGoeAABrHgAAbB4AAG0eAABuHgAAbx4AAHAeAABxHgAAch4AAHMeAAB0HgAAdR4AAHYeAAB3HgAAeB4AAHkeAAB6HgAAex4AAHweAAB9HgAAfh4AAH8eAACAHgAAgR4AAIIeAACDHgAAhB4AAIUeAACGHgAAhx4AAIgeAACJHgAAih4AAIseAACMHgAAjR4AAI4eAACPHgAAkB4AAJEeAACSHgAAkx4AAJQeAACVHgAAnh4AAN8AAACgHgAAoR4AAKIeAACjHgAApB4AAKUeAACmHgAApx4AAKgeAACpHgAAqh4AAKseAACsHgAArR4AAK4eAACvHgAAsB4AALEeAACyHgAAsx4AALQeAAC1HgAAth4AALceAAC4HgAAuR4AALoeAAC7HgAAvB4AAL0eAAC+HgAAvx4AAMAeAADBHgAAwh4AAMMeAADEHgAAxR4AAMYeAADHHgAAyB4AAMkeAADKHgAAyx4AAMweAADNHgAAzh4AAM8eAADQHgAA0R4AANIeAADTHgAA1B4AANUeAADWHgAA1x4AANgeAADZHgAA2h4AANseAADcHgAA3R4AAN4eAADfHgAA4B4AAOEeAADiHgAA4x4AAOQeAADlHgAA5h4AAOceAADoHgAA6R4AAOoeAADrHgAA7B4AAO0eAADuHgAA7x4AAPAeAADxHgAA8h4AAPMeAAD0HgAA9R4AAPYeAAD3HgAA+B4AAPkeAAD6HgAA+x4AAPweAAD9HgAA/h4AAP8eAAAIHwAAAB8AAAkfAAABHwAACh8AAAIfAAALHwAAAx8AAAwfAAAEHwAADR8AAAUfAAAOHwAABh8AAA8fAAAHHwAAGB8AABAfAAAZHwAAER8AABofAAASHwAAGx8AABMfAAAcHwAAFB8AAB0fAAAVHwAAKB8AACAfAAApHwAAIR8AACofAAAiHwAAKx8AACMfAAAsHwAAJB8AAC0fAAAlHwAALh8AACYfAAAvHwAAJx8AADgfAAAwHwAAOR8AADEfAAA6HwAAMh8AADsfAAAzHwAAPB8AADQfAAA9HwAANR8AAD4fAAA2HwAAPx8AADcfAABIHwAAQB8AAEkfAABBHwAASh8AAEIfAABLHwAAQx8AAEwfAABEHwAATR8AAEUfAABZHwAAUR8AAFsfAABTHwAAXR8AAFUfAABfHwAAVx8AAGgfAABgHwAAaR8AAGEfAABqHwAAYh8AAGsfAABjHwAAbB8AAGQfAABtHwAAZR8AAG4fAABmHwAAbx8AAGcfAACIHwAAgB8AAIkfAACBHwAAih8AAIIfAACLHwAAgx8AAIwfAACEHwAAjR8AAIUfAACOHwAAhh8AAI8fAACHHwAAmB8AAJAfAACZHwAAkR8AAJofAACSHwAAmx8AAJMfAACcHwAAlB8AAJ0fAACVHwAAnh8AAJYfAACfHwAAlx8AAKgfAACgHwAAqR8AAKEfAACqHwAAoh8AAKsfAACjHwAArB8AAKQfAACtHwAApR8AAK4fAACmHwAArx8AAKcfAAC4HwAAsB8AALkfAACxHwAAuh8AAHAfAAC7HwAAcR8AALwfAACzHwAAyB8AAHIfAADJHwAAcx8AAMofAAB0HwAAyx8AAHUfAADMHwAAwx8AANgfAADQHwAA2R8AANEfAADaHwAAdh8AANsfAAB3HwAA6B8AAOAfAADpHwAA4R8AAOofAAB6HwAA6x8AAHsfAADsHwAA5R8AAPgfAAB4HwAA+R8AAHkfAAD6HwAAfB8AAPsfAAB9HwAA/B8AAPMfAAAmIQAAyQMAACohAABrAAAAKyEAAOUAAAAyIQAATiEAAGAhAABwIQAAYSEAAHEhAABiIQAAciEAAGMhAABzIQAAZCEAAHQhAABlIQAAdSEAAGYhAAB2IQAAZyEAAHchAABoIQAAeCEAAGkhAAB5IQAAaiEAAHohAABrIQAAeyEAAGwhAAB8IQAAbSEAAH0hAABuIQAAfiEAAG8hAAB/IQAAgyEAAIQhAAC2JAAA0CQAALckAADRJAAAuCQAANIkAAC5JAAA0yQAALokAADUJAAAuyQAANUkAAC8JAAA1iQAAL0kAADXJAAAviQAANgkAAC/JAAA2SQAAMAkAADaJAAAwSQAANskAADCJAAA3CQAAMMkAADdJAAAxCQAAN4kAADFJAAA3yQAAMYkAADgJAAAxyQAAOEkAADIJAAA4iQAAMkkAADjJAAAyiQAAOQkAADLJAAA5SQAAMwkAADmJAAAzSQAAOckAADOJAAA6CQAAM8kAADpJAAAACwAADAsAAABLAAAMSwAAAIsAAAyLAAAAywAADMsAAAELAAANCwAAAUsAAA1LAAABiwAADYsAAAHLAAANywAAAgsAAA4LAAACSwAADksAAAKLAAAOiwAAAssAAA7LAAADCwAADwsAAANLAAAPSwAAA4sAAA+LAAADywAAD8sAAAQLAAAQCwAABEsAABBLAAAEiwAAEIsAAATLAAAQywAABQsAABELAAAFSwAAEUsAAAWLAAARiwAABcsAABHLAAAGCwAAEgsAAAZLAAASSwAABosAABKLAAAGywAAEssAAAcLAAATCwAAB0sAABNLAAAHiwAAE4sAAAfLAAATywAACAsAABQLAAAISwAAFEsAAAiLAAAUiwAACMsAABTLAAAJCwAAFQsAAAlLAAAVSwAACYsAABWLAAAJywAAFcsAAAoLAAAWCwAACksAABZLAAAKiwAAFosAAArLAAAWywAACwsAABcLAAALSwAAF0sAAAuLAAAXiwAAC8sAABfLAAAYCwAAGEsAABiLAAAawIAAGMsAAB9HQAAZCwAAH0CAABnLAAAaCwAAGksAABqLAAAaywAAGwsAABtLAAAUQIAAG4sAABxAgAAbywAAFACAABwLAAAUgIAAHIsAABzLAAAdSwAAHYsAAB+LAAAPwIAAH8sAABAAgAAgCwAAIEsAACCLAAAgywAAIQsAACFLAAAhiwAAIcsAACILAAAiSwAAIosAACLLAAAjCwAAI0sAACOLAAAjywAAJAsAACRLAAAkiwAAJMsAACULAAAlSwAAJYsAACXLAAAmCwAAJksAACaLAAAmywAAJwsAACdLAAAniwAAJ8sAACgLAAAoSwAAKIsAACjLAAApCwAAKUsAACmLAAApywAAKgsAACpLAAAqiwAAKssAACsLAAArSwAAK4sAACvLAAAsCwAALEsAACyLAAAsywAALQsAAC1LAAAtiwAALcsAAC4LAAAuSwAALosAAC7LAAAvCwAAL0sAAC+LAAAvywAAMAsAADBLAAAwiwAAMMsAADELAAAxSwAAMYsAADHLAAAyCwAAMksAADKLAAAyywAAMwsAADNLAAAziwAAM8sAADQLAAA0SwAANIsAADTLAAA1CwAANUsAADWLAAA1ywAANgsAADZLAAA2iwAANssAADcLAAA3SwAAN4sAADfLAAA4CwAAOEsAADiLAAA4ywAAOssAADsLAAA7SwAAO4sAADyLAAA8ywAAECmAABBpgAAQqYAAEOmAABEpgAARaYAAEamAABHpgAASKYAAEmmAABKpgAAS6YAAEymAABNpgAATqYAAE+mAABQpgAAUaYAAFKmAABTpgAAVKYAAFWmAABWpgAAV6YAAFimAABZpgAAWqYAAFumAABcpgAAXaYAAF6mAABfpgAAYKYAAGGmAABipgAAY6YAAGSmAABlpgAAZqYAAGemAABopgAAaaYAAGqmAABrpgAAbKYAAG2mAACApgAAgaYAAIKmAACDpgAAhKYAAIWmAACGpgAAh6YAAIimAACJpgAAiqYAAIumAACMpgAAjaYAAI6mAACPpgAAkKYAAJGmAACSpgAAk6YAAJSmAACVpgAAlqYAAJemAACYpgAAmaYAAJqmAACbpgAAIqcAACOnAAAkpwAAJacAACanAAAnpwAAKKcAACmnAAAqpwAAK6cAACynAAAtpwAALqcAAC+nAAAypwAAM6cAADSnAAA1pwAANqcAADenAAA4pwAAOacAADqnAAA7pwAAPKcAAD2nAAA+pwAAP6cAAECnAABBpwAAQqcAAEOnAABEpwAARacAAEanAABHpwAASKcAAEmnAABKpwAAS6cAAEynAABNpwAATqcAAE+nAABQpwAAUacAAFKnAABTpwAAVKcAAFWnAABWpwAAV6cAAFinAABZpwAAWqcAAFunAABcpwAAXacAAF6nAABfpwAAYKcAAGGnAABipwAAY6cAAGSnAABlpwAAZqcAAGenAABopwAAaacAAGqnAABrpwAAbKcAAG2nAABupwAAb6cAAHmnAAB6pwAAe6cAAHynAAB9pwAAeR0AAH6nAAB/pwAAgKcAAIGnAACCpwAAg6cAAISnAACFpwAAhqcAAIenAACLpwAAjKcAAI2nAABlAgAAkKcAAJGnAACSpwAAk6cAAJanAACXpwAAmKcAAJmnAACapwAAm6cAAJynAACdpwAAnqcAAJ+nAACgpwAAoacAAKKnAACjpwAApKcAAKWnAACmpwAAp6cAAKinAACppwAAqqcAAGYCAACrpwAAXAIAAKynAABhAgAAracAAGwCAACupwAAagIAALCnAACeAgAAsacAAIcCAACypwAAnQIAALOnAABTqwAAtKcAALWnAAC2pwAAt6cAALinAAC5pwAAuqcAALunAAC8pwAAvacAAL6nAAC/pwAAwKcAAMGnAADCpwAAw6cAAMSnAACUpwAAxacAAIICAADGpwAAjh0AAMenAADIpwAAyacAAMqnAADLpwAAZAIAAMynAADNpwAA0KcAANGnAADWpwAA16cAANinAADZpwAA2qcAANunAADcpwAAmwEAAPWnAAD2pwAAIf8AAEH/AAAi/wAAQv8AACP/AABD/wAAJP8AAET/AAAl/wAARf8AACb/AABG/wAAJ/8AAEf/AAAo/wAASP8AACn/AABJ/wAAKv8AAEr/AAAr/wAAS/8AACz/AABM/wAALf8AAE3/AAAu/wAATv8AAC//AABP/wAAMP8AAFD/AAAx/wAAUf8AADL/AABS/wAAM/8AAFP/AAA0/wAAVP8AADX/AABV/wAANv8AAFb/AAA3/wAAV/8AADj/AABY/wAAOf8AAFn/AAA6/wAAWv8AAAAEAQAoBAEAAQQBACkEAQACBAEAKgQBAAMEAQArBAEABAQBACwEAQAFBAEALQQBAAYEAQAuBAEABwQBAC8EAQAIBAEAMAQBAAkEAQAxBAEACgQBADIEAQALBAEAMwQBAAwEAQA0BAEADQQBADUEAQAOBAEANgQBAA8EAQA3BAEAEAQBADgEAQARBAEAOQQBABIEAQA6BAEAEwQBADsEAQAUBAEAPAQBABUEAQA9BAEAFgQBAD4EAQAXBAEAPwQBABgEAQBABAEAGQQBAEEEAQAaBAEAQgQBABsEAQBDBAEAHAQBAEQEAQAdBAEARQQBAB4EAQBGBAEAHwQBAEcEAQAgBAEASAQBACEEAQBJBAEAIgQBAEoEAQAjBAEASwQBACQEAQBMBAEAJQQBAE0EAQAmBAEATgQBACcEAQBPBAEAsAQBANgEAQCxBAEA2QQBALIEAQDaBAEAswQBANsEAQC0BAEA3AQBALUEAQDdBAEAtgQBAN4EAQC3BAEA3wQBALgEAQDgBAEAuQQBAOEEAQC6BAEA4gQBALsEAQDjBAEAvAQBAOQEAQC9BAEA5QQBAL4EAQDmBAEAvwQBAOcEAQDABAEA6AQBAMEEAQDpBAEAwgQBAOoEAQDDBAEA6wQBAMQEAQDsBAEAxQQBAO0EAQDGBAEA7gQBAMcEAQDvBAEAyAQBAPAEAQDJBAEA8QQBAMoEAQDyBAEAywQBAPMEAQDMBAEA9AQBAM0EAQD1BAEAzgQBAPYEAQDPBAEA9wQBANAEAQD4BAEA0QQBAPkEAQDSBAEA+gQBANMEAQD7BAEAcAUBAJcFAQBxBQEAmAUBAHIFAQCZBQEAcwUBAJoFAQB0BQEAmwUBAHUFAQCcBQEAdgUBAJ0FAQB3BQEAngUBAHgFAQCfBQEAeQUBAKAFAQB6BQEAoQUBAHwFAQCjBQEAfQUBAKQFAQB+BQEApQUBAH8FAQCmBQEAgAUBAKcFAQCBBQEAqAUBAIIFAQCpBQEAgwUBAKoFAQCEBQEAqwUBAIUFAQCsBQEAhgUBAK0FAQCHBQEArgUBAIgFAQCvBQEAiQUBALAFAQCKBQEAsQUBAIwFAQCzBQEAjQUBALQFAQCOBQEAtQUBAI8FAQC2BQEAkAUBALcFAQCRBQEAuAUBAJIFAQC5BQEAlAUBALsFAQCVBQEAvAUBAIAMAQDADAEAgQwBAMEMAQCCDAEAwgwBAIMMAQDDDAEAhAwBAMQMAQCFDAEAxQwBAIYMAQDGDAEAhwwBAMcMAQCIDAEAyAwBAIkMAQDJDAEAigwBAMoMAQCLDAEAywwBAIwMAQDMDAEAjQwBAM0MAQCODAEAzgwBAI8MAQDPDAEAkAwBANAMAQCRDAEA0QwBAJIMAQDSDAEAkwwBANMMAQCUDAEA1AwBAJUMAQDVDAEAlgwBANYMAQCXDAEA1wwBAJgMAQDYDAEAmQwBANkMAQCaDAEA2gwBAJsMAQDbDAEAnAwBANwMAQCdDAEA3QwBAJ4MAQDeDAEAnwwBAN8MAQCgDAEA4AwBAKEMAQDhDAEAogwBAOIMAQCjDAEA4wwBAKQMAQDkDAEApQwBAOUMAQCmDAEA5gwBAKcMAQDnDAEAqAwBAOgMAQCpDAEA6QwBAKoMAQDqDAEAqwwBAOsMAQCsDAEA7AwBAK0MAQDtDAEArgwBAO4MAQCvDAEA7wwBALAMAQDwDAEAsQwBAPEMAQCyDAEA8gwBAFANAQBwDQEAUQ0BAHENAQBSDQEAcg0BAFMNAQBzDQEAVA0BAHQNAQBVDQEAdQ0BAFYNAQB2DQEAVw0BAHcNAQBYDQEAeA0BAFkNAQB5DQEAWg0BAHoNAQBbDQEAew0BAFwNAQB8DQEAXQ0BAH0NAQBeDQEAfg0BAF8NAQB/DQEAYA0BAIANAQBhDQEAgQ0BAGINAQCCDQEAYw0BAIMNAQBkDQEAhA0BAGUNAQCFDQEAoBgBAMAYAQChGAEAwRgBAKIYAQDCGAEAoxgBAMMYAQCkGAEAxBgBAKUYAQDFGAEAphgBAMYYAQCnGAEAxxgBAKgYAQDIGAEAqRgBAMkYAQCqGAEAyhgBAKsYAQDLGAEArBgBAMwYAQCtGAEAzRgBAK4YAQDOGAEArxgBAM8YAQCwGAEA0BgBALEYAQDRGAEAshgBANIYAQCzGAEA0xgBALQYAQDUGAEAtRgBANUYAQC2GAEA1hgBALcYAQDXGAEAuBgBANgYAQC5GAEA2RgBALoYAQDaGAEAuxgBANsYAQC8GAEA3BgBAL0YAQDdGAEAvhgBAN4YAQC/GAEA3xgBAEBuAQBgbgEAQW4BAGFuAQBCbgEAYm4BAENuAQBjbgEARG4BAGRuAQBFbgEAZW4BAEZuAQBmbgEAR24BAGduAQBIbgEAaG4BAEluAQBpbgEASm4BAGpuAQBLbgEAa24BAExuAQBsbgEATW4BAG1uAQBObgEAbm4BAE9uAQBvbgEAUG4BAHBuAQBRbgEAcW4BAFJuAQBybgEAU24BAHNuAQBUbgEAdG4BAFVuAQB1bgEAVm4BAHZuAQBXbgEAd24BAFhuAQB4bgEAWW4BAHluAQBabgEAem4BAFtuAQB7bgEAXG4BAHxuAQBdbgEAfW4BAF5uAQB+bgEAX24BAH9uAQAA6QEAIukBAAHpAQAj6QEAAukBACTpAQAD6QEAJekBAATpAQAm6QEABekBACfpAQAG6QEAKOkBAAfpAQAp6QEACOkBACrpAQAJ6QEAK+kBAArpAQAs6QEAC+kBAC3pAQAM6QEALukBAA3pAQAv6QEADukBADDpAQAP6QEAMekBABDpAQAy6QEAEekBADPpAQAS6QEANOkBABPpAQA16QEAFOkBADbpAQAV6QEAN+kBABbpAQA46QEAF+kBADnpAQAY6QEAOukBABnpAQA76QEAGukBADzpAQAb6QEAPekBABzpAQA+6QEAHekBAD/pAQAe6QEAQOkBAB/pAQBB6QEAIOkBAELpAQAh6QEAQ+kBAFZlYzNBSGFzaCB0YWJsZSBjYXBhY2l0eSBvdmVyZmxvdwAAAHF3EAAcAAAA6QkQACsAAAAlAAAAKAAAAGNsb3N1cmUgaW52b2tlZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkAACqDBAAXgAAAPsYAAABAAAAZGVzdCBpcyBvdXQgb2YgYm91bmRzAAAA7HcQABUAAACRABAAdAAAAFIDAAAyAAAAEBESAAgHCQYKBQsEDAMNAg4BDwBoCBAAawAAABECAAAoAAAAaAgQAGsAAACGAgAAHQAAAAAAAIAAQADAACAAoABgAOAAEACQAFAA0AAwALAAcADwAAgAiABIAMgAKACoAGgA6AAYAJgAWADYADgAuAB4APgABACEAEQAxAAkAKQAZADkABQAlABUANQANAC0AHQA9AAMAIwATADMACwArABsAOwAHACcAFwA3AA8ALwAfAD8AAIAggBCAMIAIgCiAGIA4gASAJIAUgDSADIAsgByAPIACgCKAEoAygAqAKoAagDqABoAmgBaANoAOgC6AHoA+gAGAIYARgDGACYApgBmAOYAFgCWAFYA1gA2ALYAdgD2AA4AjgBOAM4ALgCuAG4A7gAeAJ4AXgDeAD4AvgB+AP4AAQCBAEEAwQAhAKEAYQDhABEAkQBRANEAMQCxAHEA8QAJAIkASQDJACkAqQBpAOkAGQCZAFkA2QA5ALkAeQD5AAUAhQBFAMUAJQClAGUA5QAVAJUAVQDVADUAtQB1APUADQCNAE0AzQAtAK0AbQDtAB0AnQBdAN0APQC9AH0A/QADAIMAQwDDACMAowBjAOMAEwCTAFMA0wAzALMAcwDzAAsAiwBLAMsAKwCrAGsA6wAbAJsAWwDbADsAuwB7APsABwCHAEcAxwAnAKcAZwDnABcAlwBXANcANwC3AHcA9wAPAI8ATwDPAC8ArwBvAO8AHwCfAF8A3wA/AL8AfwD/gACAgIBAgMCAIICggGCA4IAQgJCAUIDQgDCAsIBwgPCACICIgEiAyIAogKiAaIDogBiAmIBYgNiAOIC4gHiA+IAEgISARIDEgCSApIBkgOSAFICUgFSA1IA0gLSAdID0gAyAjIBMgMyALICsgGyA7IAcgJyAXIDcgDyAvIB8gPyAAoCCgEKAwoAigKKAYoDigBKAkoBSgNKAMoCygHKA8oAKgIqASoDKgCqAqoBqgOqAGoCagFqA2oA6gLqAeoD6gAaAhoBGgMaAJoCmgGaA5oAWgJaAVoDWgDaAtoB2gPaADoCOgE6AzoAugK6AboDugB6AnoBegN6APoC+gH6A/oABgIGAQYDBgCGAoYBhgOGAEYCRgFGA0YAxgLGAcYDxgAmAiYBJgMmAKYCpgGmA6YAZgJmAWYDZgDmAuYB5gPmABYCFgEWAxYAlgKWAZYDlgBWAlYBVgNWANYC1gHWA9YANgI2ATYDNgC2ArYBtgO2AHYCdgF2A3YA9gL2AfYD9gAOAg4BDgMOAI4CjgGOA44ATgJOAU4DTgDOAs4BzgPOAC4CLgEuAy4ArgKuAa4DrgBuAm4BbgNuAO4C7gHuA+4AHgIeAR4DHgCeAp4BngOeAF4CXgFeA14A3gLeAd4D3gA+Aj4BPgM+AL4CvgG+A74AfgJ+AX4DfgD+Av4B/gP9oCBAAawAAACIEAAAUAAAAaAgQAGsAAAAjBAAAEgAAAGFzc2VydGlvbiBmYWlsZWQ6IG91dF9wb3MgKyAzIDwgb3V0X3NsaWNlLmxlbigpAGgIEABrAAAANgQAAA0AAABhc3NlcnRpb24gZmFpbGVkOiAoc291cmNl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IHBsYXRmb3JtUJUQACgAAAAkAAAAAAAAAAIAAAB4lRAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAMwJEAAdAAAAigEAAB0AAAC5AAAAEAAAAAQAAAC6AAAAuwAAAAEAAAAAAAAAbWlkID4gbGVuAAAA5JUQAAkAAAANBxAALgAAABYBAAApAAAAZW50aXR5IG5vdCBmb3VuZHBlcm1pc3Npb24gZGVuaWVkY29ubmVjdGlvbiByZWZ1c2VkY29ubmVjdGlvbiByZXNldGhvc3QgdW5yZWFjaGFibGVuZXR3b3JrIHVucmVhY2hhYmxlY29ubmVjdGlvbiBhYm9ydGVkbm90IGNvbm5lY3RlZGFkZHJlc3MgaW4gdXNlYWRkcmVzcyBub3QgYXZhaWxhYmxlbmV0d29yayBkb3duYnJva2VuIHBpcGVlbnRpdHkgYWxyZWFkeSBleGlzdHNvcGVyYXRpb24gd291bGQgYmxvY2tub3QgYSBkaXJlY3RvcnlpcyBhIGRpcmVjdG9yeWRpcmVjdG9yeSBub3QgZW1wdHlyZWFkLW9ubHkgZmlsZXN5c3RlbSBvciBzdG9yYWdlIG1lZGl1bWZpbGVzeXN0ZW0gbG9vcCBvciBpbmRpcmVjdGlvbiBsaW1pdCAoZS5nLiBzeW1saW5rIGxvb3Apc3RhbGUgbmV0d29yayBmaWxlIGhhbmRsZWludmFsaWQgaW5wdXQgcGFyYW1ldGVyaW52YWxpZCBkYXRhdGltZWQgb3V0d3JpdGUgemVyb25vIHN0b3JhZ2Ugc3BhY2VzZWVrIG9uIHVuc2Vla2FibGUgZmlsZXF1b3RhIGV4Y2VlZGVkZmlsZSB0b28gbGFyZ2VyZXNvdXJjZSBidXN5ZXhlY3V0YWJsZSBmaWxlIGJ1c3lkZWFkbG9ja2Nyb3NzLWRldmljZSBsaW5rIG9yIHJlbmFtZXRvbyBtYW55IGxpbmtzaW52YWxpZCBmaWxlbmFtZWFyZ3VtZW50IGxpc3QgdG9vIGxvbmdvcGVyYXRpb24gaW50ZXJydXB0ZWR1bnN1cHBvcnRlZHVuZXhwZWN0ZWQgZW5kIG9mIGZpbGVvdXQgb2YgbWVtb3J5aW4gcHJvZ3Jlc3NvdGhlciBlcnJvcnVuY2F0ZWdvcml6ZWQgZXJy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", self.location.href);\n    }\n    const imports = __wbg_get_imports();\n    if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {\n      module_or_path = fetch(module_or_path);\n    }\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n    return __wbg_finalize_init(instance, module);\n  }\n  const rpcHandlers = {\n    sortSplats16,\n    sortSplats32,\n    loadSplats,\n    quickLod,\n    initLodTree,\n    disposeLodTree,\n    insertLodTrees,\n    clearLodTrees,\n    traverseLodTrees\n  };\n  async function onMessage(event) {\n    const {\n      id,\n      name,\n      args\n    } = event.data;\n    try {\n      const handler = rpcHandlers[name];\n      if (!handler) {\n        throw new Error(`Unknown worker RPC: ${name}`);\n      }\n      const sendStatus = (data) => {\n        self.postMessage(\n          { id, status: data },\n          { transfer: getArrayBuffers(data) }\n        );\n      };\n      const result = await handler(args, { sendStatus });\n      self.postMessage({ id, result }, { transfer: getArrayBuffers(result) });\n    } catch (error) {\n      console.warn(`Worker error: ${error}`);\n      self.postMessage({ id, error }, { transfer: getArrayBuffers(error) });\n    }\n  }\n  function sortSplats16({\n    numSplats,\n    readback,\n    ordering\n  }) {\n    const activeSplats = sort_splats(numSplats, readback, ordering);\n    return { activeSplats, readback, ordering };\n  }\n  function sortSplats32({\n    numSplats,\n    readback,\n    ordering\n  }) {\n    const activeSplats = sort32_splats(numSplats, readback, ordering);\n    return { activeSplats, readback, ordering };\n  }\n  async function decodeBytesUrl({\n    decoder,\n    fileBytes,\n    url,\n    // baseUri,\n    requestHeader,\n    withCredentials,\n    sendStatus\n  }) {\n    let decodeDuration = 0;\n    if (fileBytes) {\n      const start = performance.now();\n      decoder.push(fileBytes);\n      decodeDuration += performance.now() - start;\n    } else if (url) {\n      const request = new Request(url, {\n        headers: requestHeader ? new Headers(requestHeader) : void 0,\n        credentials: withCredentials ? "include" : "same-origin"\n      });\n      const response = await fetch(request);\n      if (!response.ok || !response.body) {\n        throw new Error(\n          `Failed to fetch: ${response.status} ${response.statusText}`\n        );\n      }\n      const reader = response.body.getReader();\n      const contentLength = Number.parseInt(\n        response.headers.get("Content-Length") || "0"\n      );\n      const total = Number.isNaN(contentLength) ? 0 : contentLength;\n      let loaded = 0;\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          break;\n        }\n        loaded += value.length;\n        sendStatus({ loaded, total });\n        const start = performance.now();\n        decoder.push(value);\n        decodeDuration += performance.now() - start;\n      }\n    } else {\n      throw new Error("No url or fileBytes provided");\n    }\n    const decoded = decoder.finish();\n    return decoded;\n  }\n  function toPackedResult(packed) {\n    return {\n      numSplats: packed.numSplats,\n      packedArray: packed.packed,\n      extra: {\n        sh1: packed.sh1,\n        sh2: packed.sh2,\n        sh3: packed.sh3,\n        lodTree: packed.lodTree\n      },\n      splatEncoding: packed.splatEncoding\n    };\n  }\n  async function loadSplats({\n    url,\n    // baseUri,\n    requestHeader,\n    withCredentials,\n    fileBytes,\n    fileType,\n    pathName,\n    lod,\n    lodBase,\n    encoding,\n    nonLod\n  }, {\n    sendStatus\n  }) {\n    if (!lod) {\n      const decoder2 = decode_to_packedsplats(fileType, pathName ?? url);\n      const decoded2 = await decodeBytesUrl({\n        decoder: decoder2,\n        fileBytes,\n        url,\n        // baseUri,\n        requestHeader,\n        withCredentials,\n        sendStatus\n      });\n      const result = toPackedResult(decoded2);\n      if (result.splatEncoding.lodOpacity) {\n        return { lodSplats: result };\n      }\n      return result;\n    }\n    const decoder = decode_to_gsplatarray(fileType, pathName ?? url);\n    const decoded = await decodeBytesUrl({\n      decoder,\n      fileBytes,\n      url,\n      // baseUri,\n      requestHeader,\n      withCredentials,\n      sendStatus\n    });\n    if (decoded.has_lod()) {\n      return {\n        lodSplats: toPackedResult(decoded.to_packedsplats_lod())\n      };\n    }\n    if (nonLod) {\n      const initialConvertStart = performance.now();\n      const packed = decoded.to_packedsplats();\n      performance.now() - initialConvertStart;\n      sendStatus({ orig: toPackedResult(packed) });\n    }\n    const initialSplats = decoded.len();\n    const base = Math.max(1.1, Math.min(2, lodBase ?? 1.5));\n    const lodStart = performance.now();\n    decoded.quick_lod(base);\n    const lodDuration = performance.now() - lodStart;\n    console.log(\n      `Quick LoD: ${initialSplats} -> ${decoded.len()} (${lodDuration} ms)`\n    );\n    const convertStart = performance.now();\n    const lodPacked = decoded.to_packedsplats_lod();\n    const convertDuration = performance.now() - convertStart;\n    console.log(`Convert to packedsplats in ${convertDuration} ms`);\n    return { lodSplats: toPackedResult(lodPacked) };\n  }\n  async function quickLod({\n    numSplats,\n    packedArray,\n    extra,\n    lodBase\n  }) {\n    const base = Math.max(1.1, Math.min(2, lodBase ?? 1.5));\n    const lodStart = performance.now();\n    const decoded = quick_lod_packedsplats(numSplats, packedArray, extra, base);\n    const lodDuration = performance.now() - lodStart;\n    const result = toPackedResult(decoded);\n    console.log(\n      `Quick LoD: ${numSplats} -> ${result.numSplats} (${lodDuration} ms)`\n    );\n    return result;\n  }\n  function initLodTree({\n    numSplats,\n    lodTree\n  }) {\n    const { lodId, chunkToPage } = init_lod_tree(numSplats, lodTree);\n    return { lodId, chunkToPage };\n  }\n  function disposeLodTree({ lodId }) {\n    dispose_lod_tree(lodId);\n  }\n  function insertLodTrees({ ranges }) {\n    console.log("insertLodTrees", ranges);\n    const lodIds = new Uint32Array(ranges.map(({ lodId }) => lodId));\n    const pageBases = new Uint32Array(ranges.map(({ pageBase }) => pageBase));\n    const chunkBases = new Uint32Array(ranges.map(({ chunkBase }) => chunkBase));\n    const counts = new Uint32Array(ranges.map(({ count }) => count));\n    const lodTreeData = ranges.map(({ lodTreeData: lodTreeData2 }) => lodTreeData2);\n    const lodIdToChunkToPages = insert_lod_trees(lodIds, pageBases, chunkBases, counts, lodTreeData);\n    console.log("=> done insertLodTrees", lodIdToChunkToPages);\n    return lodIdToChunkToPages;\n  }\n  function clearLodTrees({ ranges }) {\n    const lodIds = new Uint32Array(ranges.map(({ lodId }) => lodId));\n    const pageBases = new Uint32Array(ranges.map(({ pageBase }) => pageBase));\n    const chunkBases = new Uint32Array(ranges.map(({ chunkBase }) => chunkBase));\n    const counts = new Uint32Array(ranges.map(({ count }) => count));\n    const lodIdToChunkToPages = clear_lod_trees(lodIds, pageBases, chunkBases, counts);\n    return lodIdToChunkToPages;\n  }\n  function traverseLodTrees({\n    maxSplats,\n    pixelScaleLimit,\n    fovXdegrees,\n    fovYdegrees,\n    instances\n  }) {\n    const keyInstances = Object.entries(instances);\n    const lodIds = new Uint32Array(\n      keyInstances.map(([_key, instance]) => instance.lodId)\n    );\n    const viewToObjects = new Float32Array(\n      keyInstances.flatMap(([_key, instance]) => {\n        if (instance.viewToObjectCols.length !== 16) {\n          throw new Error("Incorrect array size for viewToObjectCols");\n        }\n        return instance.viewToObjectCols;\n      })\n    );\n    const lodScales = new Float32Array(\n      keyInstances.map(([_key, instance]) => instance.lodScale)\n    );\n    const outsideFoveates = new Float32Array(\n      keyInstances.map(([_key, instance]) => instance.outsideFoveate)\n    );\n    const behindFoveates = new Float32Array(\n      keyInstances.map(([_key, instance]) => instance.behindFoveate)\n    );\n    const { instanceIndices, chunks } = traverse_lod_trees(\n      maxSplats,\n      pixelScaleLimit,\n      fovXdegrees,\n      fovYdegrees,\n      lodIds,\n      viewToObjects,\n      lodScales,\n      outsideFoveates,\n      behindFoveates\n    );\n    const indices = keyInstances.reduce(\n      (indices2, [key, _instance], index) => {\n        indices2[key] = instanceIndices[index];\n        return indices2;\n      },\n      {}\n    );\n    return {\n      keyIndices: indices,\n      // chunks: chunks.map(([instIndex, chunk]) => [keyInstances[instIndex][0], chunk]),\n      chunks\n    };\n  }\n  function getArrayBuffers(ctx) {\n    const buffers = [];\n    const seen = /* @__PURE__ */ new Set();\n    function traverse(obj) {\n      if (obj && typeof obj === "object" && !seen.has(obj)) {\n        seen.add(obj);\n        if (obj instanceof ArrayBuffer) {\n          buffers.push(obj);\n        } else if (ArrayBuffer.isView(obj)) {\n          buffers.push(obj.buffer);\n        } else if (Array.isArray(obj)) {\n          obj.forEach(traverse);\n        } else {\n          Object.values(obj).forEach(traverse);\n        }\n      }\n    }\n    traverse(ctx);\n    return buffers;\n  }\n  async function initialize() {\n    const pending = [];\n    const bufferMessage = (event) => {\n      pending.push(event);\n    };\n    self.addEventListener("message", bufferMessage);\n    await __wbg_init();\n    self.removeEventListener("message", bufferMessage);\n    self.addEventListener("message", onMessage);\n    for (const event of pending) {\n      onMessage(event);\n    }\n    pending.length = 0;\n  }\n  initialize().catch(console.error);\n})();\n//# sourceMappingURL=newWorker-kJP9WzNa.js.map\n';
const blob$1 = typeof self !== "undefined" && self.Blob && new Blob([jsContent$1], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper$1(options) {
  let objURL;
  try {
    objURL = blob$1 && (self.URL || self.webkitURL).createObjectURL(blob$1);
    if (!objURL) throw "";
    const worker = new Worker(objURL, {
      name: options == null ? void 0 : options.name
    });
    worker.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(objURL);
    });
    return worker;
  } catch (e) {
    return new Worker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(jsContent$1),
      {
        name: options == null ? void 0 : options.name
      }
    );
  } finally {
    objURL && (self.URL || self.webkitURL).revokeObjectURL(objURL);
  }
}
const LN_SCALE_MIN = -12;
const LN_SCALE_MAX = 9;
const SCALE_MIN = Math.exp(LN_SCALE_MIN);
const SCALE_MAX = Math.exp(LN_SCALE_MAX);
const LN_SCALE_ZERO = -30;
const SCALE_ZERO = Math.exp(LN_SCALE_ZERO);
const SPLAT_TEX_WIDTH_BITS = 11;
const SPLAT_TEX_HEIGHT_BITS = 11;
const SPLAT_TEX_DEPTH_BITS = 11;
const SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;
const SPLAT_TEX_WIDTH = 1 << SPLAT_TEX_WIDTH_BITS;
const SPLAT_TEX_HEIGHT = 1 << SPLAT_TEX_HEIGHT_BITS;
const SPLAT_TEX_DEPTH = 1 << SPLAT_TEX_DEPTH_BITS;
const SPLAT_TEX_MIN_HEIGHT = 1;
const SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1;
const SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1;
const SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1;
const SPLAT_PAGED_WIDTH_BITS = 12;
const SPLAT_PAGED_HEIGHT_BITS = 12;
const SPLAT_PAGED_WIDTH = 1 << SPLAT_PAGED_WIDTH_BITS;
const SPLAT_PAGED_HEIGHT = 1 << SPLAT_PAGED_HEIGHT_BITS;
const WASM_SPLAT_SORT = true;
const USE_COMPILED_PARSER_FUNCTION = true;
const defines = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LN_SCALE_MAX,
  LN_SCALE_MIN,
  LN_SCALE_ZERO,
  SCALE_MAX,
  SCALE_MIN,
  SCALE_ZERO,
  SPLAT_PAGED_HEIGHT,
  SPLAT_PAGED_HEIGHT_BITS,
  SPLAT_PAGED_WIDTH,
  SPLAT_PAGED_WIDTH_BITS,
  SPLAT_TEX_DEPTH,
  SPLAT_TEX_DEPTH_BITS,
  SPLAT_TEX_DEPTH_MASK,
  SPLAT_TEX_HEIGHT,
  SPLAT_TEX_HEIGHT_BITS,
  SPLAT_TEX_HEIGHT_MASK,
  SPLAT_TEX_LAYER_BITS,
  SPLAT_TEX_MIN_HEIGHT,
  SPLAT_TEX_WIDTH,
  SPLAT_TEX_WIDTH_BITS,
  SPLAT_TEX_WIDTH_MASK,
  USE_COMPILED_PARSER_FUNCTION,
  WASM_SPLAT_SORT
}, Symbol.toStringTag, { value: "Module" }));
function isBoolType(type) {
  return type === "bool" || type === "bvec2" || type === "bvec3" || type === "bvec4";
}
function isScalarType(type) {
  return type === "int" || type === "uint" || type === "float";
}
function isIntType(type) {
  return type === "int" || type === "ivec2" || type === "ivec3" || type === "ivec4";
}
function isUintType(type) {
  return type === "uint" || type === "uvec2" || type === "uvec3" || type === "uvec4";
}
function isFloatType(type) {
  return type === "float" || type === "vec2" || type === "vec3" || type === "vec4";
}
function isMatFloatType(type) {
  return type === "mat2" || type === "mat2x2" || type === "mat2x3" || type === "mat2x4" || type === "mat3" || type === "mat3x2" || type === "mat3x3" || type === "mat3x4" || type === "mat4" || type === "mat4x2" || type === "mat4x3" || type === "mat4x4";
}
function isAllFloatType(type) {
  return isFloatType(type) || isMatFloatType(type);
}
function isVector2Type(type) {
  return type === "vec2" || type === "ivec2" || type === "uvec2";
}
function isVector3Type(type) {
  return type === "vec3" || type === "ivec3" || type === "uvec3";
}
function isVector4Type(type) {
  return type === "vec4" || type === "ivec4" || type === "uvec4";
}
function isVectorType(type) {
  return isVector2Type(type) || isVector3Type(type) || isVector4Type(type);
}
function isMat2(type) {
  return type === "mat2" || type === "mat2x2";
}
function isMat3(type) {
  return type === "mat3" || type === "mat3x3";
}
function isMat4(type) {
  return type === "mat4" || type === "mat4x4";
}
function vectorElementType(type) {
  switch (type) {
    case "vec2":
      return "float";
    case "vec3":
      return "float";
    case "vec4":
      return "float";
    case "ivec2":
      return "int";
    case "ivec3":
      return "int";
    case "ivec4":
      return "int";
    case "uvec2":
      return "uint";
    case "uvec3":
      return "uint";
    case "uvec4":
      return "uint";
    default:
      throw new Error(`Invalid vector type: ${type}`);
  }
}
function vectorDim(type) {
  switch (type) {
    case "vec2":
    case "ivec2":
    case "uvec2":
      return 2;
    case "vec3":
    case "ivec3":
    case "uvec3":
      return 3;
    case "vec4":
    case "ivec4":
    case "uvec4":
      return 4;
    default:
      throw new Error(`Invalid vector type: ${type}`);
  }
}
function sameSizeVec(type) {
  if (isScalarType(type)) {
    return "float";
  }
  if (isVector2Type(type)) {
    return "vec2";
  }
  if (isVector3Type(type)) {
    return "vec3";
  }
  if (isVector4Type(type)) {
    return "vec4";
  }
  throw new Error(`Invalid vector type: ${type}`);
}
function sameSizeUvec(type) {
  if (isScalarType(type)) {
    return "uint";
  }
  if (isVector2Type(type)) {
    return "uvec2";
  }
  if (isVector3Type(type)) {
    return "uvec3";
  }
  if (isVector4Type(type)) {
    return "uvec4";
  }
  throw new Error(`Invalid vector type: ${type}`);
}
function sameSizeIvec(type) {
  if (isScalarType(type)) {
    return "int";
  }
  if (isVector2Type(type)) {
    return "ivec2";
  }
  if (isVector3Type(type)) {
    return "ivec3";
  }
  if (isVector4Type(type)) {
    return "ivec4";
  }
  throw new Error(`Invalid vector type: ${type}`);
}
function typeLiteral(type) {
  if (typeof type === "string") {
    return type;
  }
  if (typeof type === "object" && type.type) {
    return type.type;
  }
  throw new Error(`Invalid DynoType: ${String(type)}`);
}
function numberAsInt(value) {
  return Math.trunc(value).toString();
}
function numberAsUint(value) {
  const v = Math.max(0, Math.trunc(value));
  return `${v.toString()}u`;
}
function numberAsFloat(value) {
  return value === Number.POSITIVE_INFINITY ? "INFINITY" : value === Number.NEGATIVE_INFINITY ? "-INFINITY" : Number.isInteger(value) ? value.toFixed(1) : value.toString();
}
function valType(val) {
  if (val instanceof DynoValue) {
    return val.type;
  }
  const value = val.dynoOut();
  return value.type;
}
class DynoValue {
  constructor(type) {
    this.__isDynoValue = true;
    this.type = type;
  }
}
class DynoOutput extends DynoValue {
  constructor(dyno2, key) {
    super(dyno2.outTypes[key]);
    this.dyno = dyno2;
    this.key = key;
  }
}
class DynoLiteral extends DynoValue {
  constructor(type, literal) {
    super(type);
    this.literal = literal;
  }
  getLiteral() {
    return this.literal;
  }
}
function dynoLiteral(type, literal) {
  return new DynoLiteral(type, literal);
}
class DynoConst extends DynoLiteral {
  constructor(type, value) {
    super(type, "");
    this.value = value;
  }
  getLiteral() {
    const { type, value } = this;
    switch (type) {
      case "bool":
        return value ? "true" : "false";
      case "uint":
        return numberAsUint(value);
      case "int":
        return numberAsInt(value);
      case "float":
        return numberAsFloat(value);
      case "bvec2": {
        const v = value;
        return `bvec2(${v[0]}, ${v[1]})`;
      }
      case "uvec2": {
        if (value instanceof THREE.Vector2) {
          return `uvec2(${numberAsUint(value.x)}, ${numberAsUint(value.y)})`;
        }
        const v = value;
        return `uvec2(${numberAsUint(v[0])}, ${numberAsUint(v[1])})`;
      }
      case "ivec2": {
        if (value instanceof THREE.Vector2) {
          return `ivec2(${numberAsInt(value.x)}, ${numberAsInt(value.y)})`;
        }
        const v = value;
        return `ivec2(${numberAsInt(v[0])}, ${numberAsInt(v[1])})`;
      }
      case "vec2": {
        if (value instanceof THREE.Vector2) {
          return `vec2(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)})`;
        }
        const v = value;
        return `vec2(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])})`;
      }
      case "bvec3": {
        const v = value;
        return `bvec3(${v[0]}, ${v[1]}, ${v[2]})`;
      }
      case "uvec3": {
        if (value instanceof THREE.Vector3) {
          return `uvec3(${numberAsUint(value.x)}, ${numberAsUint(value.y)}, ${numberAsUint(value.z)})`;
        }
        const v = value;
        return `uvec3(${numberAsUint(v[0])}, ${numberAsUint(v[1])}, ${numberAsUint(v[2])})`;
      }
      case "ivec3": {
        if (value instanceof THREE.Vector3) {
          return `ivec3(${numberAsInt(value.x)}, ${numberAsInt(value.y)}, ${numberAsInt(value.z)})`;
        }
        const v = value;
        return `ivec3(${numberAsInt(v[0])}, ${numberAsInt(v[1])}, ${numberAsInt(v[2])})`;
      }
      case "vec3": {
        if (value instanceof THREE.Vector3) {
          return `vec3(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)})`;
        }
        const v = value;
        return `vec3(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])}, ${numberAsFloat(v[2])})`;
      }
      case "bvec4": {
        const v = value;
        return `bvec4(${v[0]}, ${v[1]}, ${v[2]}, ${v[3]})`;
      }
      case "uvec4": {
        if (value instanceof THREE.Vector4) {
          return `uvec4(${numberAsUint(value.x)}, ${numberAsUint(value.y)}, ${numberAsUint(value.z)}, ${numberAsUint(value.w)})`;
        }
        const v = value;
        return `uvec4(${numberAsUint(v[0])}, ${numberAsUint(v[1])}, ${numberAsUint(v[2])}, ${numberAsUint(v[3])})`;
      }
      case "ivec4": {
        if (value instanceof THREE.Vector4) {
          return `ivec4(${numberAsInt(value.x)}, ${numberAsInt(value.y)}, ${numberAsInt(value.z)}, ${numberAsInt(value.w)})`;
        }
        const v = value;
        return `ivec4(${numberAsInt(v[0])}, ${numberAsInt(v[1])}, ${numberAsInt(v[2])}, ${numberAsInt(v[3])})`;
      }
      case "vec4": {
        if (value instanceof THREE.Vector4) {
          return `vec4(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)}, ${numberAsFloat(value.w)})`;
        }
        if (value instanceof THREE.Quaternion) {
          return `vec4(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)}, ${numberAsFloat(value.w)})`;
        }
        const v = value;
        return `vec4(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])}, ${numberAsFloat(v[2])}, ${numberAsFloat(v[3])})`;
      }
      case "mat2":
      case "mat2x2": {
        const m = value;
        const e = m instanceof THREE.Matrix2 ? m.elements : value;
        const arg = new Array(4).fill(0).map((_, i) => numberAsFloat(e[i]));
        return `${type}(${arg.join(", ")})`;
      }
      case "mat2x3": {
        const e = value;
        const arg = new Array(6).fill(0).map((_, i) => numberAsFloat(e[i]));
        return `${type}(${arg.join(", ")})`;
      }
      case "mat2x4": {
        const e = value;
        const arg = new Array(8).fill(0).map((_, i) => numberAsFloat(e[i]));
        return `${type}(${arg.join(", ")})`;
      }
      case "mat3":
      case "mat3x3": {
        const m = value;
        const e = m instanceof THREE.Matrix3 ? m.elements : value;
        const arg = new Array(9).fill(0).map((_, i) => numberAsFloat(e[i]));
        return `${type}(${arg.join(", ")})`;
      }
      case "mat3x2": {
        const e = value;
        const arg = new Array(6).fill(0).map((_, i) => numberAsFloat(e[i]));
        return `${type}(${arg.join(", ")})`;
      }
      case "mat3x4": {
        const e = value;
        const arg = new Array(12).fill(0).map((_, i) => numberAsFloat(e[i]));
        return `${type}(${arg.join(", ")})`;
      }
      case "mat4":
      case "mat4x4": {
        const m = value;
        const e = m instanceof THREE.Matrix4 ? m.elements : value;
        const arg = new Array(16).fill(0).map((_, i) => numberAsFloat(e[i]));
        return `${type}(${arg.join(", ")})`;
      }
      case "mat4x2": {
        const e = value;
        const arg = new Array(8).fill(0).map((_, i) => numberAsFloat(e[i]));
        return `${type}(${arg.join(", ")})`;
      }
      case "mat4x3": {
        const e = value;
        const arg = new Array(12).fill(0).map((_, i) => numberAsFloat(e[i]));
        return `${type}(${arg.join(", ")})`;
      }
      default:
        throw new Error(`Type not implemented: ${String(type)}`);
    }
  }
}
function dynoConst(type, value) {
  return new DynoConst(type, value);
}
function literalZero(type) {
  const typeString = String(type);
  if (isBoolType(type)) {
    return `${typeString}(false)`;
  }
  if (isAllFloatType(type)) {
    return `${typeString}(0.0)`;
  }
  if (isIntType(type)) {
    return `${typeString}(0)`;
  }
  if (isUintType(type)) {
    return `${typeString}(0u)`;
  }
  throw new Error(`Type not implemented: ${typeString}`);
}
function literalOne(type) {
  const typeString = String(type);
  if (isBoolType(type)) {
    return `${typeString}(true)`;
  }
  if (isAllFloatType(type)) {
    return `${typeString}(1.0)`;
  }
  if (isIntType(type)) {
    return `${typeString}(1)`;
  }
  if (isUintType(type)) {
    return `${typeString}(1u)`;
  }
  throw new Error(`Type not implemented: ${typeString}`);
}
function literalNegOne(type) {
  const typeString = String(type);
  if (isBoolType(type)) {
    return `${typeString}(true)`;
  }
  if (isAllFloatType(type)) {
    return `${typeString}(-1.0)`;
  }
  if (isIntType(type)) {
    return `${typeString}(-1)`;
  }
  if (isUintType(type)) {
    return `${typeString}(0xFFFFFFFFu)`;
  }
  throw new Error(`Type not implemented: ${typeString}`);
}
const DEFAULT_INDENT = "    ";
class Compilation {
  constructor({ indent } = {}) {
    this.globals = /* @__PURE__ */ new Set();
    this.statements = [];
    this.uniforms = {};
    this.declares = /* @__PURE__ */ new Set();
    this.updaters = [];
    this.sequence = 0;
    this.indent = DEFAULT_INDENT;
    this.indent = indent ?? DEFAULT_INDENT;
  }
  nextSequence() {
    return this.sequence++;
  }
}
class Dyno {
  constructor({
    inTypes,
    outTypes,
    inputs,
    update,
    globals,
    statements,
    generate
  }) {
    this.inTypes = inTypes ?? {};
    this.outTypes = outTypes ?? {};
    this.inputs = inputs ?? {};
    this.update = update;
    this.globals = globals;
    this.statements = statements;
    this.generate = generate ?? (({ inputs: inputs2, outputs, compile }) => {
      var _a2, _b2;
      return {
        globals: (_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs: inputs2, outputs, compile }),
        statements: (_b2 = this.statements) == null ? void 0 : _b2.call(this, { inputs: inputs2, outputs, compile })
      };
    });
  }
  get outputs() {
    const outputs = {};
    for (const key in this.outTypes) {
      outputs[key] = new DynoOutput(this, key);
    }
    return outputs;
  }
  apply(inputs) {
    Object.assign(this.inputs, inputs);
    return this.outputs;
  }
  compile({
    inputs,
    outputs,
    compile
  }) {
    const result = [
      `// ${this.constructor.name}(${Object.values(inputs).join(", ")}) => (${Object.values(outputs).join(", ")})`
    ];
    const declares = [];
    for (const key in outputs) {
      const name = outputs[key];
      if (name && !compile.declares.has(name)) {
        compile.declares.add(name);
        declares.push(key);
      }
    }
    const { globals, statements, uniforms } = this.generate({
      inputs,
      outputs,
      compile
    });
    for (const global of globals ?? []) {
      compile.globals.add(global);
    }
    for (const key in uniforms) {
      compile.uniforms[key] = uniforms[key];
    }
    if (this.update) {
      compile.updaters.push(this.update);
    }
    for (const key of declares) {
      const name = outputs[key];
      if (name) {
        if (!compile.uniforms[name]) {
          result.push(`${dynoDeclare(name, this.outTypes[key])};`);
        }
      }
    }
    if (statements == null ? void 0 : statements.length) {
      result.push("{");
      result.push(...statements.map((line) => compile.indent + line));
      result.push("}");
    }
    return result;
  }
}
class DynoBlock extends Dyno {
  constructor({
    inTypes,
    outTypes,
    inputs,
    update,
    globals,
    construct
  }) {
    super({
      inTypes,
      outTypes,
      inputs,
      update,
      globals,
      generate: (args) => this.generateBlock(args)
    });
    this.construct = construct;
  }
  generateBlock({
    inputs,
    outputs,
    compile
  }) {
    var _a2, _b2;
    const blockInputs = {};
    const blockOutputs = {};
    for (const key in inputs) {
      if (inputs[key] != null) {
        blockInputs[key] = new DynoLiteral(this.inTypes[key], inputs[key]);
      }
    }
    for (const key in outputs) {
      if (outputs[key] != null) {
        blockOutputs[key] = new DynoValue(this.outTypes[key]);
      }
    }
    const options = { roots: [] };
    const returned = this.construct(blockInputs, blockOutputs, options);
    for (const global of ((_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs, outputs, compile })) ?? []) {
      compile.globals.add(global);
    }
    const ordering = [];
    const nodeOuts = /* @__PURE__ */ new Map();
    function visit(node, outKey, outName) {
      let outs = nodeOuts.get(node);
      if (!outs) {
        outs = {
          sequence: compile.nextSequence(),
          outNames: /* @__PURE__ */ new Map(),
          newOuts: /* @__PURE__ */ new Set()
        };
        nodeOuts.set(node, outs);
        for (const key in node.inputs) {
          let input = node.inputs[key];
          while (input) {
            if (input instanceof DynoValue) {
              if (input instanceof DynoOutput) {
                visit(input.dyno, input.key);
              }
              break;
            }
            input = input.dynoOut();
          }
        }
        ordering.push(node);
      }
      if (outKey) {
        if (!outName) {
          outs.newOuts.add(outKey);
        }
        outs.outNames.set(outKey, outName ?? `${outKey}_${outs.sequence}`);
      }
    }
    for (const root of options.roots) {
      visit(root);
    }
    for (const key in blockOutputs) {
      let value = (returned == null ? void 0 : returned[key]) ?? blockOutputs[key];
      while (value) {
        if (value instanceof DynoValue) {
          if (value instanceof DynoOutput) {
            visit(value.dyno, value.key, outputs[key]);
          }
          break;
        }
        value = value.dynoOut();
      }
      blockOutputs[key] = value;
    }
    const steps = [];
    for (const dyno2 of ordering) {
      const inputs2 = {};
      const outputs2 = {};
      for (const key in dyno2.inputs) {
        let value = dyno2.inputs[key];
        while (value) {
          if (value instanceof DynoValue) {
            if (value instanceof DynoLiteral) {
              inputs2[key] = value.getLiteral();
            } else if (value instanceof DynoOutput) {
              const source = (_b2 = nodeOuts.get(value.dyno)) == null ? void 0 : _b2.outNames.get(value.key);
              if (!source) {
                throw new Error(
                  `Source not found for ${value.dyno.constructor.name}.${value.key}`
                );
              }
              inputs2[key] = source;
            }
            break;
          }
          value = value.dynoOut();
        }
      }
      const outs = nodeOuts.get(dyno2) ?? { outNames: /* @__PURE__ */ new Map() };
      for (const [key, name] of outs.outNames.entries()) {
        outputs2[key] = name;
      }
      const newSteps = dyno2.compile({ inputs: inputs2, outputs: outputs2, compile });
      steps.push(newSteps);
    }
    const literalOutputs = [];
    for (const key in outputs) {
      if (blockOutputs[key] instanceof DynoLiteral) {
        literalOutputs.push(
          `${outputs[key]} = ${blockOutputs[key].getLiteral()};`
        );
      }
    }
    if (literalOutputs.length > 0) {
      steps.push(literalOutputs);
    }
    const statements = steps.flatMap((step2, index) => {
      return index === 0 ? step2 : ["", ...step2];
    });
    return { statements };
  }
}
function dynoBlock(inTypes, outTypes, construct, { update, globals } = {}) {
  return new DynoBlock({ inTypes, outTypes, construct, update, globals });
}
function dyno$1({
  inTypes,
  outTypes,
  inputs,
  update,
  globals,
  statements,
  generate
}) {
  return new Dyno({
    inTypes,
    outTypes,
    inputs,
    update,
    globals,
    statements,
    generate
  });
}
function dynoDeclare(name, type, count) {
  const typeStr = typeof type === "string" ? type : type.type;
  if (!typeStr) {
    throw new Error(`Invalid DynoType: ${String(type)}`);
  }
  return `${typeStr} ${name}${count != null ? `[${count}]` : ""}`;
}
function unindentLines(s) {
  var _a2;
  let seenNonEmpty = false;
  const lines = s.split("\n").map((line) => {
    const trimmedLine = line.trimEnd();
    if (seenNonEmpty) {
      return trimmedLine;
    }
    if (trimmedLine.length > 0) {
      seenNonEmpty = true;
      return trimmedLine;
    }
    return null;
  }).filter((line) => line != null);
  while (lines.length > 0 && lines[lines.length - 1].length === 0) {
    lines.pop();
  }
  if (lines.length === 0) {
    return [];
  }
  const indent = (_a2 = lines[0].match(/^\s*/)) == null ? void 0 : _a2[0];
  if (!indent) {
    return lines;
  }
  const regex = new RegExp(`^${indent}`);
  return lines.map((line) => line.replace(regex, ""));
}
function unindent(s) {
  return unindentLines(s).join("\n");
}
class UnaryOp extends Dyno {
  constructor({
    a,
    outKey,
    outTypeFunc
  }) {
    const inTypes = { a: valType(a) };
    const outType = outTypeFunc(valType(a));
    const outTypes = { [outKey]: outType };
    super({ inTypes, outTypes, inputs: { a } });
    this.outKey = outKey;
  }
  dynoOut() {
    return new DynoOutput(this, this.outKey);
  }
}
class BinaryOp extends Dyno {
  constructor({
    a,
    b,
    outKey,
    outTypeFunc
  }) {
    const inTypes = { a: valType(a), b: valType(b) };
    const outType = outTypeFunc(valType(a), valType(b));
    const outTypes = { [outKey]: outType };
    super({ inTypes, outTypes, inputs: { a, b } });
    this.outKey = outKey;
  }
  dynoOut() {
    return new DynoOutput(this, this.outKey);
  }
}
class TrinaryOp extends Dyno {
  constructor({
    a,
    b,
    c,
    outKey,
    outTypeFunc
  }) {
    const inTypes = { a: valType(a), b: valType(b), c: valType(c) };
    const outType = outTypeFunc(valType(a), valType(b), valType(c));
    const outTypes = { [outKey]: outType };
    super({ inTypes, outTypes, inputs: { a, b, c } });
    this.outKey = outKey;
  }
  dynoOut() {
    return new DynoOutput(this, this.outKey);
  }
}
const threeRevision = Number.parseInt(THREE.REVISION);
const threeMrtArray = threeRevision >= 179;
const f32buffer = new Float32Array(1);
const u32buffer = new Uint32Array(f32buffer.buffer);
const supportsFloat16Array = "Float16Array" in globalThis;
const f16buffer = supportsFloat16Array ? new globalThis["Float16Array"](1) : null;
const u16buffer = new Uint16Array(f16buffer == null ? void 0 : f16buffer.buffer);
function normalize$1(vec) {
  const norm = Math.sqrt(vec.reduce((acc, v) => acc + v * v, 0));
  return vec.map((v) => v / norm);
}
function floatBitsToUint$1(f) {
  f32buffer[0] = f;
  return u32buffer[0];
}
function uintBitsToFloat$1(u) {
  u32buffer[0] = u;
  return f32buffer[0];
}
const toHalf = supportsFloat16Array ? toHalfNative : toHalfJS;
const fromHalf = supportsFloat16Array ? fromHalfNative : fromHalfJS;
function toHalfNative(f) {
  f16buffer[0] = f;
  return u16buffer[0];
}
function toHalfJS(f) {
  f32buffer[0] = f;
  const bits2 = u32buffer[0];
  const sign2 = bits2 >> 31 & 1;
  const exp3 = bits2 >> 23 & 255;
  const frac = bits2 & 8388607;
  const halfSign = sign2 << 15;
  if (exp3 === 255) {
    if (frac !== 0) {
      return halfSign | 32767;
    }
    return halfSign | 31744;
  }
  const newExp = exp3 - 127 + 15;
  if (newExp >= 31) {
    return halfSign | 31744;
  }
  if (newExp <= 0) {
    if (newExp < -10) {
      return halfSign;
    }
    const subFrac = (frac | 8388608) >> 1 - newExp + 13;
    return halfSign | subFrac;
  }
  const halfFrac = frac >> 13;
  return halfSign | newExp << 10 | halfFrac;
}
function fromHalfNative(u) {
  u16buffer[0] = u;
  return f16buffer[0];
}
function fromHalfJS(h) {
  const sign2 = h >> 15 & 1;
  const exp3 = h >> 10 & 31;
  const frac = h & 1023;
  let f32bits;
  if (exp3 === 0) {
    if (frac === 0) {
      f32bits = sign2 << 31;
    } else {
      let mant = frac;
      let e = -14;
      while ((mant & 1024) === 0) {
        mant <<= 1;
        e--;
      }
      mant &= 1023;
      const newExp = e + 127;
      const newFrac = mant << 13;
      f32bits = sign2 << 31 | newExp << 23 | newFrac;
    }
  } else if (exp3 === 31) {
    if (frac === 0) {
      f32bits = sign2 << 31 | 2139095040;
    } else {
      f32bits = sign2 << 31 | 2143289344;
    }
  } else {
    const newExp = exp3 - 15 + 127;
    const newFrac = frac << 13;
    f32bits = sign2 << 31 | newExp << 23 | newFrac;
  }
  u32buffer[0] = f32bits;
  return f32buffer[0];
}
function floatToUint8(v) {
  return Math.max(0, Math.min(255, Math.round(v * 255)));
}
function floatToSint8(v) {
  return Math.max(-127, Math.min(127, Math.round(v * 127)));
}
function Uint8ToFloat(v) {
  return v / 255;
}
function Sint8ToFloat(v) {
  return v / 127;
}
class DataCache {
  // Create a DataCache with a given function that fetches data not in the cache.
  constructor({
    asyncFetch,
    maxItems = 5
  }) {
    this.asyncFetch = asyncFetch;
    this.maxItems = maxItems;
    this.items = [];
  }
  // Fetch data for the key, returning cached data if available.
  async getFetch(key) {
    const index = this.items.findIndex((item) => item.key === key);
    if (index >= 0) {
      const item = this.items.splice(index, 1)[0];
      this.items.push(item);
      return item.data;
    }
    const data = await this.asyncFetch(key);
    this.items.push({ key, data });
    while (this.items.length > this.maxItems) {
      this.items.shift();
    }
    return data;
  }
}
function mapObject(obj, fn) {
  const entries = Object.entries(obj).map(([key, value]) => [
    key,
    fn(value, key)
  ]);
  return Object.fromEntries(entries);
}
function mapFilterObject(obj, fn) {
  const entries = Object.entries(obj).map(([key, value]) => [key, fn(value, key)]).filter(([_, value]) => value !== void 0);
  return Object.fromEntries(entries);
}
function getArrayBuffers(ctx) {
  const buffers = [];
  const seen = /* @__PURE__ */ new Set();
  function traverse(obj) {
    if (obj && typeof obj === "object" && !seen.has(obj)) {
      seen.add(obj);
      if (obj instanceof ArrayBuffer) {
        buffers.push(obj);
      } else if (ArrayBuffer.isView(obj)) {
        buffers.push(obj.buffer);
      } else if (Array.isArray(obj)) {
        obj.forEach(traverse);
      } else {
        Object.values(obj).forEach(traverse);
      }
    }
  }
  traverse(ctx);
  return buffers;
}
function newArray(n, initFunction) {
  return new Array(n).fill(null).map((_, i) => initFunction(i));
}
class FreeList {
  constructor({
    // Allocate a new item with the given args
    allocate,
    // Dispose of an item (optional, if GC is enough)
    dispose,
    // Check if an existing item in the list is valid for the given args,
    // allowing you to store heterogeneous items in the list.
    valid
  }) {
    this.items = [];
    this.allocate = allocate;
    this.dispose = dispose;
    this.valid = valid;
  }
  // Allocate a new item from the free list, first checking if a existing item
  // on the freelist is valid for the given args.
  alloc(args) {
    while (true) {
      const item = this.items.pop();
      if (!item) {
        break;
      }
      if (this.valid(item, args)) {
        return item;
      }
      if (this.dispose) {
        this.dispose(item);
      }
    }
    return this.allocate(args);
  }
  free(item) {
    this.items.push(item);
  }
  disposeAll() {
    let item;
    item = this.items.pop();
    while (item) {
      if (this.dispose) {
        this.dispose(item);
      }
      item = this.items.pop();
    }
  }
}
function setPackedSplat(packedSplats, index, x, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b, encoding) {
  const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;
  const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;
  const rgbRange = rgbMax - rgbMin;
  const uR = floatToUint8((r - rgbMin) / rgbRange);
  const uG = floatToUint8((g - rgbMin) / rgbRange);
  const uB = floatToUint8((b - rgbMin) / rgbRange);
  const uA = floatToUint8((encoding == null ? void 0 : encoding.lodOpacity) ? 0.5 * opacity : opacity);
  const uQuat = encodeQuatOctXy88R8(
    tempQuaternion.set(quatX, quatY, quatZ, quatW)
  );
  const uQuatX = uQuat & 255;
  const uQuatY = uQuat >>> 8 & 255;
  const uQuatZ = uQuat >>> 16 & 255;
  const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;
  const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;
  const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);
  const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1
    )
  );
  const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1
    )
  );
  const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1
    )
  );
  const uCenterX = toHalf(x);
  const uCenterY = toHalf(y);
  const uCenterZ = toHalf(z);
  const i4 = index * 4;
  packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;
  packedSplats[i4 + 1] = uCenterX | uCenterY << 16;
  packedSplats[i4 + 2] = uCenterZ | uQuatX << 16 | uQuatY << 24;
  packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | uQuatZ << 24;
}
function setPackedSplatCenter(packedSplats, index, x, y, z) {
  const uCenterX = toHalf(x);
  const uCenterY = toHalf(y);
  const uCenterZ = toHalf(z);
  const i4 = index * 4;
  packedSplats[i4 + 1] = uCenterX | uCenterY << 16;
  packedSplats[i4 + 2] = uCenterZ | packedSplats[i4 + 2] & 4294901760;
}
function setPackedSplatScales(packedSplats, index, scaleX, scaleY, scaleZ, encoding) {
  const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;
  const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;
  const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);
  const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1
    )
  );
  const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1
    )
  );
  const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1
    )
  );
  const i4 = index * 4;
  packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | packedSplats[i4 + 3] & 4278190080;
}
const tempQuaternion = new THREE.Quaternion();
function setPackedSplatQuat(packedSplats, index, quatX, quatY, quatZ, quatW) {
  const uQuat = encodeQuatOctXy88R8(
    tempQuaternion.set(quatX, quatY, quatZ, quatW)
  );
  const uQuatX = uQuat & 255;
  const uQuatY = uQuat >>> 8 & 255;
  const uQuatZ = uQuat >>> 16 & 255;
  const i4 = index * 4;
  packedSplats[i4 + 2] = packedSplats[i4 + 2] & 65535 | uQuatX << 16 | uQuatY << 24;
  packedSplats[i4 + 3] = packedSplats[i4 + 3] & 16777215 | uQuatZ << 24;
}
function setPackedSplatRgba(packedSplats, index, r, g, b, a, encoding) {
  const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;
  const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;
  const rgbRange = rgbMax - rgbMin;
  const uR = floatToUint8((r - rgbMin) / rgbRange);
  const uG = floatToUint8((g - rgbMin) / rgbRange);
  const uB = floatToUint8((b - rgbMin) / rgbRange);
  const uA = floatToUint8((encoding == null ? void 0 : encoding.lodOpacity) ? 0.5 * a : a);
  const i4 = index * 4;
  packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;
}
function setPackedSplatRgb(packedSplats, index, r, g, b, encoding) {
  const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;
  const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;
  const rgbRange = rgbMax - rgbMin;
  const uR = floatToUint8((r - rgbMin) / rgbRange);
  const uG = floatToUint8((g - rgbMin) / rgbRange);
  const uB = floatToUint8((b - rgbMin) / rgbRange);
  const i4 = index * 4;
  packedSplats[i4] = uR | uG << 8 | uB << 16 | packedSplats[i4] & 4278190080;
}
function setPackedSplatOpacity(packedSplats, index, opacity) {
  const uA = floatToUint8(opacity);
  const i4 = index * 4;
  packedSplats[i4] = packedSplats[i4] & 16777215 | uA << 24;
}
const packedCenter = new THREE.Vector3();
const packedScales = new THREE.Vector3();
const packedQuaternion = new THREE.Quaternion();
const packedColor = new THREE.Color();
const packedFields = {
  center: packedCenter,
  scales: packedScales,
  quaternion: packedQuaternion,
  color: packedColor,
  opacity: 0
};
function unpackSplat(packedSplats, index, encoding) {
  const result = packedFields;
  const i4 = index * 4;
  const word0 = packedSplats[i4];
  const word1 = packedSplats[i4 + 1];
  const word2 = packedSplats[i4 + 2];
  const word3 = packedSplats[i4 + 3];
  const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;
  const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;
  const rgbRange = rgbMax - rgbMin;
  result.color.set(
    rgbMin + (word0 & 255) / 255 * rgbRange,
    rgbMin + (word0 >>> 8 & 255) / 255 * rgbRange,
    rgbMin + (word0 >>> 16 & 255) / 255 * rgbRange
  );
  result.opacity = (word0 >>> 24 & 255) / 255;
  if (encoding == null ? void 0 : encoding.lodOpacity) {
    result.opacity = 2 * result.opacity;
  }
  result.center.set(
    fromHalf(word1 & 65535),
    fromHalf(word1 >>> 16 & 65535),
    fromHalf(word2 & 65535)
  );
  const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;
  const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;
  const lnScaleScale = (lnScaleMax - lnScaleMin) / 254;
  const uScalesX = word3 & 255;
  result.scales.x = uScalesX === 0 ? 0 : Math.exp(lnScaleMin + (uScalesX - 1) * lnScaleScale);
  const uScalesY = word3 >>> 8 & 255;
  result.scales.y = uScalesY === 0 ? 0 : Math.exp(lnScaleMin + (uScalesY - 1) * lnScaleScale);
  const uScalesZ = word3 >>> 16 & 255;
  result.scales.z = uScalesZ === 0 ? 0 : Math.exp(lnScaleMin + (uScalesZ - 1) * lnScaleScale);
  const uQuat = word2 >>> 16 & 65535 | word3 >>> 8 & 16711680;
  decodeQuatOctXy88R8(uQuat, result.quaternion);
  return result;
}
function getTextureSize(numSplats) {
  const width = SPLAT_TEX_WIDTH;
  const height = Math.max(
    SPLAT_TEX_MIN_HEIGHT,
    Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))
  );
  const depth = Math.ceil(numSplats / (width * height));
  const maxSplats = width * height * depth;
  return { width, height, depth, maxSplats };
}
function computeMaxSplats(numSplats) {
  const width = SPLAT_TEX_WIDTH;
  const height = Math.max(
    SPLAT_TEX_MIN_HEIGHT,
    Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))
  );
  const depth = Math.ceil(numSplats / (width * height));
  return width * height * depth;
}
function isMobile() {
  if (navigator.maxTouchPoints > 0) {
    return true;
  }
  return /Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile/.test(
    navigator.userAgent
  );
}
function isAndroid() {
  return /Android/.test(navigator.userAgent) || /Tizen/.test(navigator.userAgent);
}
function isOculus() {
  return /Oculus/.test(navigator.userAgent);
}
function isIos() {
  return /iPhone|iPad/.test(navigator.userAgent);
}
function isVisionPro() {
  return /Safari/.test(navigator.userAgent) && isMobile();
}
function flipPixels(pixels, width, height) {
  const tempLine = new Uint8Array(width * 4);
  for (let y = 0; y < height / 2; y++) {
    const topOffset = y * width * 4;
    const bottomOffset = (height - 1 - y) * width * 4;
    tempLine.set(pixels.subarray(topOffset, topOffset + width * 4));
    pixels.set(
      pixels.subarray(bottomOffset, bottomOffset + width * 4),
      topOffset
    );
    pixels.set(tempLine, bottomOffset);
  }
  return pixels;
}
function pixelsToPngUrl(pixels, width, height) {
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    throw new Error("Can't get 2d context");
  }
  const imageData = ctx.createImageData(width, height);
  imageData.data.set(pixels);
  ctx.putImageData(imageData, 0, 0);
  return canvas.toDataURL("image/png");
}
function cloneClock(clock) {
  const newClock = new THREE.Clock(clock.autoStart);
  newClock.startTime = clock.startTime;
  newClock.oldTime = clock.oldTime;
  newClock.elapsedTime = clock.elapsedTime;
  newClock.running = clock.running;
  return newClock;
}
function omitUndefined(obj) {
  return Object.fromEntries(
    Object.entries(obj).filter(([_, value]) => value !== void 0)
  );
}
const IDENT_VERTEX_SHADER = unindent(`
  precision highp float;

  in vec3 position;

  void main() {
    gl_Position = vec4(position.xy, 0.0, 1.0);
  }
`);
function averagePositions(positions) {
  const sum = new THREE.Vector3();
  for (const position of positions) {
    sum.add(position);
  }
  return sum.divideScalar(positions.length);
}
function averageQuaternions(quaternions) {
  if (quaternions.length === 0) {
    return new THREE.Quaternion();
  }
  const sum = quaternions[0].clone();
  for (let i = 1; i < quaternions.length; i++) {
    if (quaternions[i].dot(quaternions[0]) < 0) {
      sum.x -= quaternions[i].x;
      sum.y -= quaternions[i].y;
      sum.z -= quaternions[i].z;
      sum.w -= quaternions[i].w;
    } else {
      sum.x += quaternions[i].x;
      sum.y += quaternions[i].y;
      sum.z += quaternions[i].z;
      sum.w += quaternions[i].w;
    }
  }
  return sum.normalize();
}
function coinciDist(matrix1, matrix2) {
  const origin1 = new THREE.Vector3(0, 0, 0).applyMatrix4(matrix1);
  const origin2 = new THREE.Vector3(0, 0, 0).applyMatrix4(matrix2);
  const direction1 = new THREE.Vector3(0, 0, -1).applyMatrix4(matrix1).sub(origin1).normalize();
  const direction2 = new THREE.Vector3(0, 0, -1).applyMatrix4(matrix2).sub(origin2).normalize();
  const distance2 = origin1.distanceTo(origin2);
  const coincidence = direction1.dot(direction2);
  return { distance: distance2, coincidence };
}
function withinDist({
  matrix1,
  matrix2,
  maxDistance
}) {
  const origin1 = new THREE.Vector3(0, 0, 0).applyMatrix4(matrix1);
  const origin2 = new THREE.Vector3(0, 0, 0).applyMatrix4(matrix2);
  return origin1.distanceTo(origin2) <= maxDistance;
}
function withinCoinciDist({
  matrix1,
  matrix2,
  maxDistance,
  minCoincidence
}) {
  const { distance: distance2, coincidence } = coinciDist(matrix1, matrix2);
  return distance2 <= maxDistance && (minCoincidence == null || coincidence >= minCoincidence);
}
function coorientDist(matrix1, matrix2) {
  const [origin1, rotate1] = [new THREE.Vector3(), new THREE.Quaternion()];
  const [origin2, rotate2] = [new THREE.Vector3(), new THREE.Quaternion()];
  matrix1.decompose(origin1, rotate1, new THREE.Vector3());
  matrix2.decompose(origin2, rotate2, new THREE.Vector3());
  const distance2 = origin1.distanceTo(origin2);
  const coorient = Math.abs(rotate1.dot(rotate2));
  return { distance: distance2, coorient };
}
function withinCoorientDist({
  matrix1,
  matrix2,
  maxDistance,
  minCoorient
}) {
  const { distance: distance2, coorient } = coorientDist(matrix1, matrix2);
  return distance2 <= maxDistance && (minCoorient == null || coorient >= minCoorient);
}
function epsilonSign(value, epsilon = 1e-3) {
  if (Math.abs(value) < epsilon) {
    return 0;
  }
  return Math.sign(value);
}
function encodeQuatXyz888(q) {
  const negQuat = q.w < 0;
  const iQuatX = floatToSint8(negQuat ? -q.x : q.x);
  const iQuatY = floatToSint8(negQuat ? -q.y : q.y);
  const iQuatZ = floatToSint8(negQuat ? -q.z : q.z);
  const uQuatX = iQuatX & 255;
  const uQuatY = iQuatY & 255;
  const uQuatZ = iQuatZ & 255;
  return uQuatX | uQuatY << 8 | uQuatZ << 16;
}
function decodeQuatXyz888(encoded, out) {
  const iQuatX = encoded << 24 >> 24;
  const iQuatY = encoded << 16 >> 24;
  const iQuatZ = encoded << 8 >> 24;
  out.set(iQuatX / 127, iQuatY / 127, iQuatZ / 127, 0);
  const dotSelf = out.x * out.x + out.y * out.y + out.z * out.z;
  out.w = Math.sqrt(Math.max(0, 1 - dotSelf));
  return out;
}
const tempNormalizedQuaternion = new THREE.Quaternion();
const tempAxis = new THREE.Vector3();
function encodeQuatOctXy88R8(q) {
  const qnorm = tempNormalizedQuaternion.copy(q).normalize();
  if (qnorm.w < 0) {
    qnorm.set(-qnorm.x, -qnorm.y, -qnorm.z, -qnorm.w);
  }
  const theta = 2 * Math.acos(qnorm.w);
  const xyz_norm = Math.sqrt(
    qnorm.x * qnorm.x + qnorm.y * qnorm.y + qnorm.z * qnorm.z
  );
  const axis = xyz_norm < 1e-6 ? tempAxis.set(1, 0, 0) : tempAxis.set(qnorm.x, qnorm.y, qnorm.z).divideScalar(xyz_norm);
  const sum = Math.abs(axis.x) + Math.abs(axis.y) + Math.abs(axis.z);
  let p_x = axis.x / sum;
  let p_y = axis.y / sum;
  if (axis.z < 0) {
    const tmp = p_x;
    p_x = (1 - Math.abs(p_y)) * (p_x >= 0 ? 1 : -1);
    p_y = (1 - Math.abs(tmp)) * (p_y >= 0 ? 1 : -1);
  }
  const u_f = p_x * 0.5 + 0.5;
  const v_f = p_y * 0.5 + 0.5;
  const quantU = Math.round(u_f * 255);
  const quantV = Math.round(v_f * 255);
  const angleInt = Math.round(theta * (255 / Math.PI));
  return angleInt << 16 | quantV << 8 | quantU;
}
function decodeQuatOctXy88R8(encoded, out) {
  const quantU = encoded & 255;
  const quantV = encoded >>> 8 & 255;
  const angleInt = encoded >>> 16 & 255;
  const u_f = quantU / 255;
  const v_f = quantV / 255;
  let f_x = (u_f - 0.5) * 2;
  let f_y = (v_f - 0.5) * 2;
  const f_z = 1 - (Math.abs(f_x) + Math.abs(f_y));
  const t = Math.max(-f_z, 0);
  f_x += f_x >= 0 ? -t : t;
  f_y += f_y >= 0 ? -t : t;
  const axis = tempAxis.set(f_x, f_y, f_z).normalize();
  const theta = angleInt / 255 * Math.PI;
  const halfTheta = theta * 0.5;
  const s = Math.sin(halfTheta);
  const w = Math.cos(halfTheta);
  out.set(axis.x * s, axis.y * s, axis.z * s, w);
  return out;
}
function encodeQuatEulerXyz888(q) {
  const qNorm = q.clone().normalize();
  const sinr_cosp = 2 * (qNorm.w * qNorm.x + qNorm.y * qNorm.z);
  const cosr_cosp = 1 - 2 * (qNorm.x * qNorm.x + qNorm.y * qNorm.y);
  const roll = Math.atan2(sinr_cosp, cosr_cosp);
  const sinp = 2 * (qNorm.w * qNorm.y - qNorm.z * qNorm.x);
  const pitch = Math.abs(sinp) >= 1 ? Math.sign(sinp) * (Math.PI / 2) : Math.asin(sinp);
  const siny_cosp = 2 * (qNorm.w * qNorm.z + qNorm.x * qNorm.y);
  const cosy_cosp = 1 - 2 * (qNorm.y * qNorm.y + qNorm.z * qNorm.z);
  const yaw = Math.atan2(siny_cosp, cosy_cosp);
  const normRoll = (roll + Math.PI) / (2 * Math.PI);
  const normPitch = (pitch + Math.PI) / (2 * Math.PI);
  const normYaw = (yaw + Math.PI) / (2 * Math.PI);
  const rollQ = Math.round(normRoll * 255);
  const pitchQ = Math.round(normPitch * 255);
  const yawQ = Math.round(normYaw * 255);
  return yawQ << 16 | pitchQ << 8 | rollQ;
}
function decodeQuatEulerXyz888(encoded, out) {
  const rollQ = encoded & 255;
  const pitchQ = encoded >>> 8 & 255;
  const yawQ = encoded >>> 16 & 255;
  const normRoll = rollQ / 255;
  const normPitch = pitchQ / 255;
  const normYaw = yawQ / 255;
  const roll = normRoll * (2 * Math.PI) - Math.PI;
  const pitch = normPitch * (2 * Math.PI) - Math.PI;
  const yaw = normYaw * (2 * Math.PI) - Math.PI;
  const cr = Math.cos(roll * 0.5);
  const sr = Math.sin(roll * 0.5);
  const cp = Math.cos(pitch * 0.5);
  const sp = Math.sin(pitch * 0.5);
  const cy = Math.cos(yaw * 0.5);
  const sy = Math.sin(yaw * 0.5);
  out.w = cr * cp * cy + sr * sp * sy;
  out.x = sr * cp * cy - cr * sp * sy;
  out.y = cr * sp * cy + sr * cp * sy;
  out.z = cr * cp * sy - sr * sp * cy;
  out.normalize();
  return out;
}
function packSint8Bytes(b0, b1, b22, b3) {
  const clampedB0 = Math.round(Math.max(-127, Math.min(127, b0 * 127)));
  const clampedB1 = Math.round(Math.max(-127, Math.min(127, b1 * 127)));
  const clampedB2 = Math.round(Math.max(-127, Math.min(127, b22 * 127)));
  const clampedB3 = Math.round(Math.max(-127, Math.min(127, b3 * 127)));
  return clampedB0 & 255 | (clampedB1 & 255) << 8 | (clampedB2 & 255) << 16 | (clampedB3 & 255) << 24;
}
function encodeSh1Rgb(sh1Array, index, sh1Rgb, encoding) {
  const sh1Min = (encoding == null ? void 0 : encoding.sh1Min) ?? -1;
  const sh1Max = (encoding == null ? void 0 : encoding.sh1Max) ?? 1;
  const sh1Mid = 0.5 * (sh1Min + sh1Max);
  const sh1Scale = 126 / (sh1Max - sh1Min);
  const base = index * 2;
  for (let i = 0; i < 9; ++i) {
    const s = (sh1Rgb[i] - sh1Mid) * sh1Scale;
    const value = Math.round(Math.max(-63, Math.min(63, s))) & 127;
    const bitStart = i * 7;
    const bitEnd = bitStart + 7;
    const wordStart = Math.floor(bitStart / 32);
    const bitOffset = bitStart - wordStart * 32;
    const firstWord = value << bitOffset & 4294967295;
    sh1Array[base + wordStart] |= firstWord;
    if (bitEnd > wordStart * 32 + 32) {
      const secondWord = value >>> 32 - bitOffset & 4294967295;
      sh1Array[base + wordStart + 1] |= secondWord;
    }
  }
}
function encodeSh2Rgb(sh2Array, index, sh2Rgb, encoding) {
  const sh2Min = (encoding == null ? void 0 : encoding.sh2Min) ?? -1;
  const sh2Max = (encoding == null ? void 0 : encoding.sh2Max) ?? 1;
  const sh2Mid = 0.5 * (sh2Min + sh2Max);
  const sh2Scale = 2 / (sh2Max - sh2Min);
  sh2Array[index * 4 + 0] = packSint8Bytes(
    (sh2Rgb[0] - sh2Mid) * sh2Scale,
    (sh2Rgb[1] - sh2Mid) * sh2Scale,
    (sh2Rgb[2] - sh2Mid) * sh2Scale,
    (sh2Rgb[3] - sh2Mid) * sh2Scale
  );
  sh2Array[index * 4 + 1] = packSint8Bytes(
    (sh2Rgb[4] - sh2Mid) * sh2Scale,
    (sh2Rgb[5] - sh2Mid) * sh2Scale,
    (sh2Rgb[6] - sh2Mid) * sh2Scale,
    (sh2Rgb[7] - sh2Mid) * sh2Scale
  );
  sh2Array[index * 4 + 2] = packSint8Bytes(
    (sh2Rgb[8] - sh2Mid) * sh2Scale,
    (sh2Rgb[9] - sh2Mid) * sh2Scale,
    (sh2Rgb[10] - sh2Mid) * sh2Scale,
    (sh2Rgb[11] - sh2Mid) * sh2Scale
  );
  sh2Array[index * 4 + 3] = packSint8Bytes(
    (sh2Rgb[12] - sh2Mid) * sh2Scale,
    (sh2Rgb[13] - sh2Mid) * sh2Scale,
    (sh2Rgb[14] - sh2Mid) * sh2Scale,
    0
  );
}
function encodeSh3Rgb(sh3Array, index, sh3Rgb, encoding) {
  const sh3Min = (encoding == null ? void 0 : encoding.sh3Min) ?? -1;
  const sh3Max = (encoding == null ? void 0 : encoding.sh3Max) ?? 1;
  const sh3Mid = 0.5 * (sh3Min + sh3Max);
  const sh3Scale = 62 / (sh3Max - sh3Min);
  const base = index * 4;
  for (let i = 0; i < 21; ++i) {
    const s = (sh3Rgb[i] - sh3Mid) * sh3Scale;
    const value = Math.round(Math.max(-31, Math.min(31, s))) & 63;
    const bitStart = i * 6;
    const bitEnd = bitStart + 6;
    const wordStart = Math.floor(bitStart / 32);
    const bitOffset = bitStart - wordStart * 32;
    const firstWord = value << bitOffset & 4294967295;
    sh3Array[base + wordStart] |= firstWord;
    if (bitEnd > wordStart * 32 + 32) {
      const secondWord = value >>> 32 - bitOffset & 4294967295;
      sh3Array[base + wordStart + 1] |= secondWord;
    }
  }
}
function decompressPartialGzip(fileBytes, numBytes) {
  const chunks = [];
  let totalBytes = 0;
  let result = null;
  const gunzip = new Gunzip((data, final) => {
    chunks.push(data);
    totalBytes += data.length;
    if (final || totalBytes >= numBytes) {
      const allBytes = new Uint8Array(totalBytes);
      let offset2 = 0;
      for (const chunk of chunks) {
        allBytes.set(chunk, offset2);
        offset2 += chunk.length;
      }
      result = allBytes.slice(0, numBytes);
    }
  });
  const CHUNK_SIZE = 1024;
  let offset = 0;
  while (result == null && offset < fileBytes.length) {
    const chunk = fileBytes.slice(offset, offset + CHUNK_SIZE);
    gunzip.push(chunk, false);
    offset += CHUNK_SIZE;
  }
  if (result == null) {
    gunzip.push(new Uint8Array(), true);
    if (result == null) {
      throw new Error("Failed to decompress partial gzip");
    }
  }
  return result;
}
class GunzipReader {
  constructor({
    fileBytes,
    chunkBytes = 64 * 1024
  }) {
    this.fileBytes = fileBytes;
    this.chunkBytes = chunkBytes;
    this.chunks = [];
    this.totalBytes = 0;
    const ds = new DecompressionStream("gzip");
    const decompressionStream = new Blob([fileBytes]).stream().pipeThrough(ds);
    this.reader = decompressionStream.getReader();
  }
  async read(numBytes) {
    while (this.totalBytes < numBytes) {
      const { value: chunk, done: readerDone } = await this.reader.read();
      if (readerDone) {
        break;
      }
      this.chunks.push(chunk);
      this.totalBytes += chunk.length;
    }
    if (this.totalBytes < numBytes) {
      throw new Error(
        `Unexpected EOF: needed ${numBytes}, got ${this.totalBytes}`
      );
    }
    const allBytes = new Uint8Array(this.totalBytes);
    let outOffset = 0;
    for (const chunk of this.chunks) {
      allBytes.set(chunk, outOffset);
      outOffset += chunk.length;
    }
    const result = allBytes.subarray(0, numBytes);
    this.chunks = [allBytes.subarray(numBytes)];
    this.totalBytes -= numBytes;
    return result;
  }
}
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DataCache,
  FreeList,
  GunzipReader,
  IDENT_VERTEX_SHADER,
  Sint8ToFloat,
  Uint8ToFloat,
  averagePositions,
  averageQuaternions,
  cloneClock,
  coinciDist,
  computeMaxSplats,
  coorientDist,
  decodeQuatEulerXyz888,
  decodeQuatOctXy88R8,
  decodeQuatXyz888,
  decompressPartialGzip,
  encodeQuatEulerXyz888,
  encodeQuatOctXy88R8,
  encodeQuatXyz888,
  encodeSh1Rgb,
  encodeSh2Rgb,
  encodeSh3Rgb,
  epsilonSign,
  flipPixels,
  floatBitsToUint: floatBitsToUint$1,
  floatToSint8,
  floatToUint8,
  fromHalf,
  getArrayBuffers,
  getTextureSize,
  isAndroid,
  isIos,
  isMobile,
  isOculus,
  isVisionPro,
  mapFilterObject,
  mapObject,
  newArray,
  normalize: normalize$1,
  omitUndefined,
  pixelsToPngUrl,
  setPackedSplat,
  setPackedSplatCenter,
  setPackedSplatOpacity,
  setPackedSplatQuat,
  setPackedSplatRgb,
  setPackedSplatRgba,
  setPackedSplatScales,
  threeMrtArray,
  threeRevision,
  toHalf,
  uintBitsToFloat: uintBitsToFloat$1,
  unpackSplat,
  withinCoinciDist,
  withinCoorientDist,
  withinDist
}, Symbol.toStringTag, { value: "Module" }));
const _NewSplatWorker = class _NewSplatWorker {
  constructor() {
    this.queue = null;
    this.messages = {};
    this.worker = new WorkerWrapper$1();
    this.worker.onmessage = (event) => this.onMessage(event);
  }
  onMessage(event) {
    var _a2;
    const { id, result, error, status } = event.data;
    const promise = this.messages[id];
    if (promise) {
      if (error !== void 0) {
        delete this.messages[id];
        promise.reject(error);
      } else if (status !== void 0) {
        (_a2 = promise.onStatus) == null ? void 0 : _a2.call(promise, status);
      } else {
        delete this.messages[id];
        promise.resolve(result);
      }
    }
  }
  tryExclusive(callback) {
    return this.queue == null ? this.exclusive(callback) : null;
  }
  async exclusive(callback) {
    const queue = this.queue;
    if (queue != null) {
      await new Promise((resolve) => {
        queue.push(() => resolve(void 0));
      });
    } else {
      this.queue = [];
    }
    try {
      return await callback(this);
    } finally {
      if (this.queue != null) {
        if (this.queue.length === 0) {
          this.queue = null;
        } else {
          const waiter = this.queue.shift();
          waiter();
        }
      }
    }
  }
  async call(name, args, options = {}) {
    const id = ++_NewSplatWorker.currentId;
    const promise = new Promise((resolve, reject) => {
      this.messages[id] = { resolve, reject, onStatus: options.onStatus };
    });
    this.worker.postMessage(
      { id, name, args },
      { transfer: getArrayBuffers(args) }
    );
    return await promise;
  }
};
_NewSplatWorker.currentId = 0;
let NewSplatWorker = _NewSplatWorker;
class NewSplatWorkerPool {
  constructor(maxWorkers2 = 4) {
    this.numWorkers = 0;
    this.freelist = [];
    this.queue = [];
    this.maxWorkers = maxWorkers2;
  }
  async withWorker(callback) {
    const worker = await this.allocWorker();
    try {
      return await callback(worker);
    } finally {
      this.freeWorker(worker);
    }
  }
  async allocWorker() {
    const worker = this.freelist.pop();
    if (worker) {
      return worker;
    }
    if (this.numWorkers < this.maxWorkers) {
      const worker2 = new NewSplatWorker();
      this.numWorkers += 1;
      return worker2;
    }
    return new Promise((resolve) => {
      this.queue.push(resolve);
    });
  }
  freeWorker(worker) {
    if (this.numWorkers > this.maxWorkers) {
      this.numWorkers -= 1;
      return;
    }
    const waiter = this.queue.shift();
    if (waiter) {
      waiter(worker);
      return;
    }
    this.freelist.push(worker);
  }
}
const workerPool = new NewSplatWorkerPool();
let wasm;
function addToExternrefTable0(obj) {
  const idx = wasm.__externref_table_alloc();
  wasm.__wbindgen_export_2.set(idx, obj);
  return idx;
}
function handleError(f, args) {
  try {
    return f.apply(this, args);
  } catch (e) {
    const idx = addToExternrefTable0(e);
    wasm.__wbindgen_exn_store(idx);
  }
}
function debugString(val) {
  const type = typeof val;
  if (type == "number" || type == "boolean" || val == null) {
    return `${val}`;
  }
  if (type == "string") {
    return `"${val}"`;
  }
  if (type == "symbol") {
    const description = val.description;
    if (description == null) {
      return "Symbol";
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type == "function") {
    const name = val.name;
    if (typeof name == "string" && name.length > 0) {
      return `Function(${name})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length2 = val.length;
    let debug = "[";
    if (length2 > 0) {
      debug += debugString(val[0]);
    }
    for (let i = 1; i < length2; i++) {
      debug += ", " + debugString(val[i]);
    }
    debug += "]";
    return debug;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches && builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
let WASM_VECTOR_LEN = 0;
let cachedUint8ArrayMemory0 = null;
function getUint8ArrayMemory0() {
  if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
    cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8ArrayMemory0;
}
const cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} };
const encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8ArrayMemory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127) break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
    ptr = realloc(ptr, len, offset, 1) >>> 0;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
let cachedDataViewMemory0 = null;
function getDataViewMemory0() {
  if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
    cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
  }
  return cachedDataViewMemory0;
}
const cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
if (typeof TextDecoder !== "undefined") {
  cachedTextDecoder.decode();
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}
function takeFromExternrefTable0(idx) {
  const value = wasm.__wbindgen_export_2.get(idx);
  wasm.__externref_table_dealloc(idx);
  return value;
}
function raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid, ln_scale_min, ln_scale_max) {
  const ret = wasm.raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid, ln_scale_min, ln_scale_max);
  return ret;
}
typeof FinalizationRegistry === "undefined" ? {} : new FinalizationRegistry((ptr) => wasm.__wbg_chunkdecoder_free(ptr >>> 0, 1));
const GsplatArrayFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm.__wbg_gsplatarray_free(ptr >>> 0, 1));
class GsplatArray {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(GsplatArray.prototype);
    obj.__wbg_ptr = ptr;
    GsplatArrayFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    GsplatArrayFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_gsplatarray_free(ptr, 0);
  }
  /**
   * @returns {number}
   */
  get numSplats() {
    const ret = wasm.__wbg_get_gsplatarray_numSplats(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {number} arg0
   */
  set numSplats(arg0) {
    wasm.__wbg_set_gsplatarray_numSplats(this.__wbg_ptr, arg0);
  }
  /**
   * @returns {number}
   */
  get maxShDegree() {
    const ret = wasm.__wbg_get_gsplatarray_maxShDegree(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {number} arg0
   */
  set maxShDegree(arg0) {
    wasm.__wbg_set_gsplatarray_maxShDegree(this.__wbg_ptr, arg0);
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm.gsplatarray_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @returns {boolean}
   */
  has_lod() {
    const ret = wasm.gsplatarray_has_lod(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @param {number} lod_base
   */
  quick_lod(lod_base) {
    wasm.gsplatarray_quick_lod(this.__wbg_ptr, lod_base);
  }
  /**
   * @returns {object}
   */
  to_packedsplats() {
    const ret = wasm.gsplatarray_to_packedsplats(this.__wbg_ptr);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return takeFromExternrefTable0(ret[0]);
  }
  /**
   * @returns {object}
   */
  to_packedsplats_lod() {
    const ret = wasm.gsplatarray_to_packedsplats_lod(this.__wbg_ptr);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return takeFromExternrefTable0(ret[0]);
  }
}
async function __wbg_load(module, imports) {
  if (typeof Response === "function" && module instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module, imports);
      } catch (e) {
        if (module.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
        } else {
          throw e;
        }
      }
    }
    const bytes = await module.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module };
    } else {
      return instance;
    }
  }
}
function __wbg_get_imports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {
    const ret = arg0.buffer;
    return ret;
  };
  imports.wbg.__wbg_get_67b2ba62fc30de12 = function() {
    return handleError(function(arg0, arg1) {
      const ret = Reflect.get(arg0, arg1);
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_get_b9b93047fe3cf45b = function(arg0, arg1) {
    const ret = arg0[arg1 >>> 0];
    return ret;
  };
  imports.wbg.__wbg_gsplatarray_new = function(arg0) {
    const ret = GsplatArray.__wrap(arg0);
    return ret;
  };
  imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {
    const ret = arg0.length;
    return ret;
  };
  imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {
    const ret = arg0.length;
    return ret;
  };
  imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {
    const ret = arg0.length;
    return ret;
  };
  imports.wbg.__wbg_length_a446193dc22c12f8 = function(arg0) {
    const ret = arg0.length;
    return ret;
  };
  imports.wbg.__wbg_length_e2d2a49132c1b256 = function(arg0) {
    const ret = arg0.length;
    return ret;
  };
  imports.wbg.__wbg_new_405e22f390576ce2 = function() {
    const ret = new Object();
    return ret;
  };
  imports.wbg.__wbg_new_78feb108b6472713 = function() {
    const ret = new Array();
    return ret;
  };
  imports.wbg.__wbg_new_9fee97a409b32b68 = function(arg0) {
    const ret = new Uint16Array(arg0);
    return ret;
  };
  imports.wbg.__wbg_new_a12002a7f91c75be = function(arg0) {
    const ret = new Uint8Array(arg0);
    return ret;
  };
  imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {
    const ret = new Uint32Array(arg0);
    return ret;
  };
  imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(arg0, arg1, arg2) {
    const ret = new Float32Array(arg0, arg1 >>> 0, arg2 >>> 0);
    return ret;
  };
  imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(arg0, arg1, arg2) {
    const ret = new Uint32Array(arg0, arg1 >>> 0, arg2 >>> 0);
    return ret;
  };
  imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {
    const ret = new Float32Array(arg0 >>> 0);
    return ret;
  };
  imports.wbg.__wbg_newwithlength_bd3de93688d68fbc = function(arg0) {
    const ret = new Uint32Array(arg0 >>> 0);
    return ret;
  };
  imports.wbg.__wbg_push_737cfc8c1432c2c6 = function(arg0, arg1) {
    const ret = arg0.push(arg1);
    return ret;
  };
  imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {
    arg0.set(arg1, arg2 >>> 0);
  };
  imports.wbg.__wbg_set_3f1d0b984ed272ed = function(arg0, arg1, arg2) {
    arg0[arg1] = arg2;
  };
  imports.wbg.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {
    arg0.set(arg1, arg2 >>> 0);
  };
  imports.wbg.__wbg_set_bb8cecf6a62b9f46 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = Reflect.set(arg0, arg1, arg2);
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_set_d23661d19148b229 = function(arg0, arg1, arg2) {
    arg0.set(arg1, arg2 >>> 0);
  };
  imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {
    arg0.set(arg1, arg2 >>> 0);
  };
  imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {
    const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);
    return ret;
  };
  imports.wbg.__wbg_subarray_769e1e0f81bb259b = function(arg0, arg1, arg2) {
    const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);
    return ret;
  };
  imports.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(arg0, arg1, arg2) {
    const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);
    return ret;
  };
  imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
    const ret = debugString(arg1);
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbindgen_init_externref_table = function() {
    const table = wasm.__wbindgen_export_2;
    const offset = table.grow(4);
    table.set(0, void 0);
    table.set(offset + 0, void 0);
    table.set(offset + 1, null);
    table.set(offset + 2, true);
    table.set(offset + 3, false);
  };
  imports.wbg.__wbindgen_is_falsy = function(arg0) {
    const ret = !arg0;
    return ret;
  };
  imports.wbg.__wbindgen_memory = function() {
    const ret = wasm.memory;
    return ret;
  };
  imports.wbg.__wbindgen_number_new = function(arg0) {
    const ret = arg0;
    return ret;
  };
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return ret;
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  return imports;
}
function __wbg_finalize_init(instance, module) {
  wasm = instance.exports;
  __wbg_init.__wbindgen_wasm_module = module;
  cachedDataViewMemory0 = null;
  cachedUint8ArrayMemory0 = null;
  wasm.__wbindgen_start();
  return wasm;
}
async function __wbg_init(module_or_path) {
  if (wasm !== void 0) return wasm;
  if (typeof module_or_path !== "undefined") {
    if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
      ({ module_or_path } = module_or_path);
    } else {
      console.warn("using deprecated parameters for the initialization function; pass a single object instead");
    }
  }
  if (typeof module_or_path === "undefined") {
    module_or_path = new URL("data:application/wasm;base64,AGFzbQEAAAAB+ANEYAN/f38Bf2ACf38Bf2ACf38AYAF/AGABfwF/YAN/f38AYAADf39/YAR/f39/AGAFf39/f38AYAF9AX1gAABgAW8Bf2AGf39/f39/AGAAAX9gA29/fwFvYAV/f39/fwF/YAFvAW9gA29vfwBgBH9/f38Bf2ADf35+AGADf35+AX9gAX8Bb2AAAW9gB39/f39/f38AYAF/A39/f2ACf30AYAR/fX9/AX9gB39/f39/f38Bf2AGf39/f39/AX9gBH9/f38Df39/YAN/b28Bf2ACfX0BfWAAAn9/YAJ/fwFvYANvb28Bf2ABfAFvYANvb28AYAJvfwFvYAJvbwF/YAJvbwFvYAJ/bwBgCX9/f39/f39/fwBgBn9/fX9/fwBgBH9/fX0BfWACf34AYAN/fX8Bf2AEfn5/fwF+YAF/AX1gCX9/f39/f35+fgBgA39+fwBgAn9+AX9gA319fQF9YAF+AX9gDn99fX1/f39/f39/f39/A39/f2AJf39/f39/f39vA39/f2AIf39/f39/f38Df39/YA19fX19fX19fX9vf319AW9gBH9vf30Df39/YAN/b38Df39/YAJ/bwN/f39gAn9vAn9/YAV/f31/fwBgBH99f38AYAV/f3x/fwBgBH98f38AYAV/f35/fwBgBH9+f38AYAF8AX8CwQkjA3diZxVfX3diZ19nc3BsYXRhcnJheV9uZXcAFQN3YmcVX193YmluZGdlbl9zdHJpbmdfbmV3ACEDd2JnGl9fd2JnX3NldF9iYjhjZWNmNmE2MmI5ZjQ2ACIDd2JnH19fd2JnX3N1YmFycmF5XzNhYWVlYzg5YmIyNTQ0ZjAADgN3YmcaX193YmdfbmV3XzQwNWUyMmYzOTA1NzZjZTIAFgN3YmcVX193YmluZGdlbl9udW1iZXJfbmV3ACMDd2JnGl9fd2JnX3NldF8zZjFkMGI5ODRlZDI3MmVkACQDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfYmQzZGU5MzY4OGQ2OGZiYwAVA3diZx1fX3diZ19sZW5ndGhfYTQ0NjE5M2RjMjJjMTJmOAALA3diZx9fX3diZ19zdWJhcnJheV9hYTkwNjVmYTlkYzVkZjk2AA4Dd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABYDd2JnHV9fd2JnX2J1ZmZlcl82MDljYzNlZWU1MWVkMTU4ABADd2JnGl9fd2JnX25ld19hMTIwMDJhN2Y5MWM3NWJlABADd2JnGl9fd2JnX3NldF82NTU5NWJkZDg2OGIzMDA5ABEDd2JnHV9fd2JnX2xlbmd0aF9lMmQyYTQ5MTMyYzFiMjU2AAsDd2JnGl9fd2JnX2dldF9iOWI5MzA0N2ZlM2NmNDViACUDd2JnGl9fd2JnX25ld183OGZlYjEwOGI2NDcyNzEzABYDd2JnG19fd2JnX3B1c2hfNzM3Y2ZjOGMxNDMyYzJjNgAmA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAALA3diZx9fX3diZ19zdWJhcnJheV83NjllMWUwZjgxYmIyNTliAA4Dd2JnGl9fd2JnX25ld185ZmVlOTdhNDA5YjMyYjY4ABADd2JnGl9fd2JnX3NldF9mNGYxZjBkYWEzMDY5NmZjABEDd2JnHV9fd2JnX2xlbmd0aF82Y2E1Mjc2NjVkODk2OTRkAAsDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfNWE1ZWZlMzEzY2ZkNTlmMQAVA3diZx1fX3diZ19sZW5ndGhfM2I0ZjAyMjE4OGFlOGRiNgALA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9lNmI3ZTY5YWNkNGM3MzU0AA4Dd2JnGl9fd2JnX3NldF8xMGJhZDliZWUwZTljNThiABEDd2JnGl9fd2JnX2dldF82N2IyYmE2MmZjMzBkZTEyACcDd2JnE19fd2JpbmRnZW5faXNfZmFsc3kACwN3YmcaX193YmdfbmV3X2UzYjMyMWRjZmVmODlmYzcAEAN3YmcaX193Ymdfc2V0X2QyMzY2MWQxOTE0OGIyMjkAEQN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZjFkZWFkNDRkMWZjNzIxMgAOA3diZxBfX3diaW5kZ2VuX3Rocm93AAIDd2JnF19fd2JpbmRnZW5fZGVidWdfc3RyaW5nACgDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFibGUACgOxA68DBRkIAAQXAwMaBQIEAAoHASkBFwcEBAoHBAcFBwUIAQUBDAIIAgQEBQMCAwgBBwECBCoCKwkICQcDBAEH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g0IIhoSEICFCCIhCgICA+A+DICFCGIhCgID8B4OEICFCKIhCgP4DgyAhQjiIhISEICBC2KLR78Kp5b8tfoUiIEI4hiAgQoD+A4NCKIaEICBCgID8B4NCGIYgIEKAgID4D4NCCIaEhCAgQgiIQoCAgPgPgyAgQhiIQoCA/AeDhCAgQiiIQoD+A4MgIEI4iISEhEKOip+43Pep+HF+IiFCOIYgIUKA/gODQiiGhCAhQoCA/AeDQhiGICFCgICA+A+DQgiGhIQgIUIIiEKAgID4D4MgIUIYiEKAgPwHg4QgIUIoiEKA/gODICFCOIiEhIQgIEKOnuCShIe+nXF+hSAgiTcDcAJAIAMoAlgiBCADKAJUTwRAQv///////////wAhLUKAgICAgICAgIB/IS5CgICAgICAgICAfyEvQoCAgICAgICAgH8hMEL///////////8AITFC////////////ACEyDAELQoCAgICAgICAgH8hMEL///////////8AITJC////////////ACExQv///////////wAhLUKAgICAgICAgIB/IS9CgICAgICAgICAfyEuAkADQCAAKAIUIgIgBEsEQCAAKAIQIARB0ABsai4BTCADLgFSSg0DIAQgACgCCCICTw0CIAMpA3ghIyADKQNwISUgAyAAKAIEIARBMGxq/QAEACAD/QkCXP3nAf1oIjf9HwH8BCIqNwOIAiADKQOAASEgIAMgN/0fAvwEIis3A5ACIAMpA4gBISEgAyA3/R8A/AQiJzcDgAIgJSAlICNCA4UiIkI4hiAiQoD+A4NCKIaEICJCgID8B4NCGIYgIkKAgID4D4NCCIaEhCAjQgiIQoCAgPgPgyAjQhiIQoCA/AeDhCAjQiiIQoD+A4MgI0I4iISEhELSgaqbq/qC16d/fiIjQjiGICNCgP4Dg0IohoQgI0KAgPwHg0IYhiAjQoCAgPgPg0IIhoSEICNCCIhCgICA+A+DICNCGIhCgID8B4OEICNCKIhCgP4DgyAjQjiIhISEICJC2KLR78Kp5b8tfoVCrf7V5NSF/ajYAH58QrjYj/Dyh7nXxwB8ICAgKoUiKEI4hiAoQoD+A4NCKIaEIChCgID8B4NCGIYgKEKAgID4D4NCCIaEhCAoQgiIQoCAgPgPgyAoQhiIQoCA/AeDhCAoQiiIQoD+A4MgKEI4iISE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ASIGQQlPBEAgAygCZCEFIAMoAmghByAIDAELIAYhBSAIIQdBCCEGIAsLIQIgBCgCACEKIAUgBkYEQCADQeAAahCNAiADKAJkIQUgAygCaCEHIAghAgsgByAFQQJ0aiAKNgIAIAIgAigCAEEBajYCACATIARBBGoiBEcNAAsMAQsgDyACNgIACyADQcgCaiADQYABaikCADcDACADQbgCaiADQfAAav0AAgD9CwMAIAMgA/0AAmD9CwOoAgJAAkACQAJ/An8CQCADKALMAiIGQQlJIgxFBEAgAygCrAIiAg0BQQEMAwsgDiAGIgINARpBAQwCCyADKAKwAgsiBCgCACIFIAAoAhQiD08NASAAKAIQIgogBUHQAGxqLwFMIQUgAkEBRwRAIARBBGohBCACQQFrQf////8DcSECA0AgBCgCACIHIA9PDQQgCiAHQdAAbGouAUwiByAFwSIFIAUgB0gbIQUgBEEEaiEEIAJBAWsiAg0ACwsgBcEgAy8BUkECa8FKBEAgAyADKAK8ASIFIAMoArABIgJGBH8gA0GwAWpBuJ/CABD7ASADKAK8ASEFIAMoArABBSACCyADKAK4AUEBayIEaiICIAQgAiAESRsiAjYCuAEgAygCtAEgAkEsbGoiAiAWNgIAIAIgAykDqAI3AgQgAkEMaiADQbACav0AAwD9CwIAIAJBHGogA0HAAmr9AAMA/QsCACADIAVBAWo2ArwBQQAMAQsgAygCrAEiAiADKAKgASIERgRAIANBoAFqQcifwgAQ+wEgAygCoAEhBCADKAKsASECCyADKAKkASADKAKoASACaiIFIARBACAEIAVNG2tBLGxqIgUgFjYCACAFIAMpA6gCNwIEIAVBDGogA0GwAmr9AAMA/QsCACAFQRxqIANBwAJq/QADAP0LAgAgAyACQQFqNgKsAUEACyADKAKcASIKIAMoApQBRgRAQQAhByMAQSBrIhIkAAJAAkAgA0GUAWoiEygCACIPQf////8BSw0AQQQgD0EBdCICIAJBBE0bIgVBAnQiAkH8////B0sNACASIA8EfyASIA9BAnQ2AhwgEiATKAIENgIUQQQFQQALNgIYIBJBCGpBBCACIBJBFGoQiAIgEigCCEEBRw0BIBIoAhAaIBIoAgwhBwsgB0HYn8IAEIMDAAsgEigCDCECIBMgBTYCACATIAI2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yMIAIAQ2AgBBpMjCAEGkyMIAKAIAIAVqIgA2AgAgBCAAQQFyNgIEDAULQajIwgAgBDYCAEGgyMIAQaDIwgAoAgAgBWoiADYCACAEIABBAXI2AgQgACAEaiAANgIADAQLQQAhA0GkyMIAKAIAIgAgBU0NAEGkyMIAIAAgBWsiATYCAEGsyMIAQazIwgAoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQgAEEIag8LIAMPC0GcyMIAQZzIwgAoAgBBfiACKAIcd3E2AgALAkAgA0EQTwRAIAIgBUEDcjYCBCACIAVqIgEgA0EBcjYCBCABIANqIAM2AgAgA0GAAk8EQCABIAMQywEMAgsgA0H4AXFBkMbCAGohAAJ/QZjIwgAoAgAiBEEBIANBA3Z0IgNxRQRAQZjIwgAgAyAEcjYCACAADAELIAAoAggLIQMgACABNgIIIAMgATYCDCABIAA2AgwgASADNgIIDAELIAIgAyAFaiIAQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIECyACQQhqDwsgAUEIagvuFwIbfwJ8IwBBsARrIgMkACADQgA3A5gBIANCADcDkAEgA0IANwOIASADQgA3A4ABIANCADcDeCADQgA3A3AgA0IANwNoIANCADcDYCADQgA3A1ggA0IANwNQIANCADcDSCADQgA3A0AgA0IANwM4IANCADcDMCADQgA3AyggA0IANwMgIANCADcDGCADQgA3AxAgA0IANwMIIANCADcDACADQgA3A7gCIANCADcDsAIgA0IANwOoAiADQgA3A6ACIANCADcDmAIgA0IANwOQAiADQgA3A4gCIANCADcDgAIgA0IANwP4ASADQgA3A/ABIANCADcD6AEgA0IANwPgASADQgA3A9gBIANCADcD0AEgA0IANwPIASADQgA3A8ABIANCADcDuAEgA0IANwOwASADQgA3A6gBIANCADcDoAEgA0IANwPYAyADQgA3A9ADIANCADcDyAMgA0IANwPAAyADQgA3A7gDIANCADcDsAMgA0IANwOoAyADQgA3A6ADIANCADcDmAMgA0IANwOQAyADQgA3A4gDIANCADcDgAMgA0IANwP4AiADQgA3A/ACIANCADcD6AIgA0IANwPgAiADQgA3A9gCIANCADcD0AIgA0IANwPIAiADQgA3A8ACIANB4ANqQQBB0AD8CwBBgL/CACgCACIKIQYgAkEDa0EYbSIFQQAgBUEAShsiCyEFIAtBAnRBkL/CAGohCANAIAMgBEEDdGogBUEASAR8RAAAAAAAAAAABSAIKAIAtws5AwAgBCAGSSIMBEAgCEEEaiEIIAVBAWohBSAEIAxqIgQgBk0NAQsLIAJBGGshBkEAIQUDQEEAIQQgA0HAAmogBUEDdGogHiAAIARBA3RqKwMAIAMgBSAEa0EDdGorAwCioDkDACAFIApJIgQEQCAEIAVqIgUgCk0NAQsLRAAAAAAAAPB/RAAAAAAAAOB/IAYgC0FobCIVaiIHQf4PSyIQG0QAAAAAAAAAAEQAAAAAAABgAyAHQblwSSIRG0QAAAAAAADwPyAHQYJ4SCISGyAHQf8HSiITG0H9FyAHIAdB/RdPG0H+D2sgB0H/B2sgEBsiFkHwaCAHIAdB8GhNG0GSD2ogB0HJB2ogERsiFyAHIBIbIBMbQf8Haq1CNIa/oiEfIANB3ANqIg8gCkECdGohDEEXIAdrQR9xIRhBGCAHa0EfcSEUIANBuAJqIRkgB0EASiEaIAdBAWshGyAKIQUCQANAIANBwAJqIAUiBkEDdGorAwAhHgJAIAZFDQAgA0HgA2ohCSAGIQQDQCAJIB4gHkQAAAAAAABwPqL8ArciHkQAAAAAAABwwaKg/AI2AgAgGSAEQQN0aisDACAeoCEeIARBAUYiBQ0BIAlBBGohCUEBIARBAWsgBRsiBA0ACwsCfwJAIBNFBEAgEg0BIAcMAgsgHkQAAAAAAADgf6IiHkQAAAAAAADgf6IgHiAQGyEeIBYMAQsgHkQAAAAAAABgA6IiHkQAAAAAAABgA6IgHiARGyEeIBcLIQUgHiAFQf8Haq1CNIa/oiIeIB5EAAAAAAAAwD+inEQAAAAAAAAgwKKgIh4gHvwCIg23oSEeAn8CQAJAAkACfyAaRQRAIAdFBEAgDyAGQQJ0aigCAEEXdQwCC0ECIQ5BACAeRAAAAAAAAOA/ZkUNBRoMAgsgDyAGQQJ0aiIFIAUoAgAiBSAFIBR1IgUgFHRrIgQ2AgAgBSANaiENIAQgGHULIg5BAEwNAQtBASEJAkAgBkUNAEEAIQUgBkEBRwRAIAZBHnEhHEEAIQggA0HgA2ohBANAIAQoAgAhCQJ/AkAgBCAIBH9B////BwUgCUUNAUGAgIAICyAJazYCAEEADAELQQELIQkgBEEEaiIdKAIAIQgCfwJAIB0gCQR/IAhFDQFBgICACAVB////BwsgCGs2AgBBACEJQQEMAQtBASEJQQALIQggBEEIaiEEIBwgBUECaiIFRw0ACwsgBkEBcUUNACADQeADaiAFQQJ0aiIEKAIAIQUCQCAEIAkEfyAFRQ0BQYCAgAgFQf///wcLIAVrNgIAQQAhCQwBC0EBIQkLAkAgB0EATA0AQf///wMhBAJAAkAgGw4CAQACC0H///8BIQQLIA8gBkECdGoiBSAFKAIAIARxNgIACyANQQFqIQ0gDkECRg0BCyAODAELRAAAAAAAAPA/IB6hIh4gHiAfoSAJQQFxGyEeQQILIQ4gHkQAAAAAAAAAAGEEQCAMIQQgBiEFAkAgCiAGQQFrIglLDQBBACEIA0ACQCADQeADaiAJQQJ0aigCACAIciEIIAkgCk0NACAKIAkgCSAKS2siCU0NAQsLIAYhBSAIRQ0AIAZBAnQgA2pB3ANqIQQDQCAGQQFrIQYgB0EYayEHIAQoAgAgBEEEayEERQ0ACwwDCwNAIAVBAWohBSAEKAIAIARBBGshBEUNAAsgBSAGTQ0BIAZBAWohCANAIAMgCEEDdGogCCALakECdEGQv8IAaigCALc5AwBBACEERAAAAAAAAAAAIR4gA0HAAmogCEEDdGogHiAAIARBA3RqKwMAIAMgCCAEa0EDdGorAwCioDkDACAFIAhNDQIgCCAFIAhLaiIGIQggBSAGTw0ACwwBCwsCQAJAAkBBACAHayIEQf8HTARAIARBgnhODQMgHkQAAAAAAABgA6IhHiAEQbhwTQ0BQckHIAdrIQQMAwsgHkQAAAAAAADgf6IhHiAEQf4PSw0BQYF4IAdrIQQMAgsgHkQAAAAAAABgA6IhHkHwaCAEIARB8GhNG0GSD2ohBAwBCyAeRAAAAAAAAOB/oiEeQf0XIAQgBEH9F08bQf4PayEECyAeIARB/wdqrUI0hr+iIh5EAAAAAAAAcEFmBEAgA0HgA2ogBkECdGogHiAeRAAAAAAAAHA+ovwCtyIeRAAAAAAAAHDBoqD8AjYCACACIBVqIQcgBkEBaiEGCyADQeADaiAGQQJ0aiAe/AI2AgALAnwCQAJAIAdB/wdMBEAgB0GCeEgNAUQAAAAAAADwPwwDCyAHQf4PSw0BIAdB/wdrIQdEAAAAAAAA4H8MAgsgB0G4cEsEQCAHQckHaiEHRAAAAAAAAGADDAILQfBoIAcgB0HwaE0bQZIPaiEHRAAAAAAAAAAADAELQf0XIAcgB0H9F08bQf4PayEHRAAAAAAAAPB/CyAHQf8Haq1CNIa/oiEeIAZBAXEEfyAGBSADQcACaiAGQQN0aiAeIANB4ANqIAZBAnRqKAIAt6I5AwAgHkQAAAAAAABwPqIhHiAGQQFrCyEAIAYEQCAAQQN0IANqQbgCaiEEIABBAnQgA2pB3ANqIQIDQCAEIB5EAAAAAAAAcD6iIh8gAigCALeiOQMAIARBCGogHiACQQRqKAIAt6I5AwAgBEEQayEEIAJBCGshAiAfRAAAAAAAAHA+oiEeIABBAUcgAEECayEADQALCyAGQQFqIQwgA0HAAmogBkEDdGohCSAGIQQDQAJAIAogBiAEIgBrIgUgBSAKSxsiCEUEQEEAIQJEAAAAAAAAAAAhHgwBCyAIQQFqQX5xIQdEAAAAAAAAAAAhHkEAIQRBACECA0AgHiAEQZjBwgBqKwMAIAQgCWoiCysDAKKgIARBoMHCAGorAwAgC0EIaisDAKKgIR4gBEEQaiEEIAcgAkECaiICRw0ACwsgA0GgAWogBUEDdGogCEEBcQR8IB4FIB4gAkEDdEGYwcIAaisDACADQcACaiAAIAJqQQN0aisDAKKgCzkDACAJQQhrIQkgAEEBayEEIAANAAsCQCAMQQNxIgBFBEBEAAAAAAAAAAAhHiAGIQIMAQsgA0GgAWogBkEDdGohBEQAAAAAAAAAACEeIAYhAgNAIAJBAWshAiAeIAQrAwCgIR4gBEEIayEEIABBAWsiAA0ACwsgBkEDTwRAIAJBA3QgA2pBiAFqIQQDQCAeIARBGGorAwCgIARBEGorAwCgIARBCGorAwCgIAQrAwCgIR4gBEEgayEEIAJBA0cgAkEEayECDQALCyABIB6aIB4gDhs5AwAgA0GwBGokACANQQdxC7gbAgR+D38jAEEgayIMJABBpMTCACgCACIERQRAENUBIQQLIAQoAgAgBCgCBCgCDBEEACEEQajCwgApAwAhA0GowsIAQgE3AwBB7MLCACgCACEPQejCwgBC6Ac3AwBB8MLCACgCACEQQfDCwgBCBDcDAEH4wsIAKAIAIRFB/MLCACgCACESQfjCwgBCgICAgMAANwMAIAxB2JLCAP0AAwD9CwIQQbzCwgAoAgAhC0G4wsIAKAIAIQdBtMLCACAM/QACDP0LAgBBxMLCACgCACENQcTCwgAgDEEcaigCADYCAEHIwsIAIAStQt/ll8Luio2qRoUiAUI4hiABQoD+A4NCKIaEIAFCgID8B4NCGIYgAUKAgID4D4NCCIaEhELGqdGxBYRC0oGqm6v6gtenf34iAEKAlAKDQiiGIABCgICwAoNCGIYgAEKAgIDoBoNCCIaEhCAAQgiIQoCAgPgPgyAAQhiIQoCA/AeDhCAAQiiIQoD+A4MgAEI4iISEhEKAgICAgICAgOwAhCABQtii0e/CqeW/LX6FIgJCkfqOpPHPk/fFAIUiAELYotHvwqnlvy1+IABCOIYgAEKA/gODQiiGhCAAQoCA/AeDQhiGIABCgICA+A+DQgiGhIQgAEIIiEKAgID4D4MgAEIYiEKAgPwHg4QgAEIoiEKA/gODIABCOIiEhIRC0oGqm6v6gtenf34iAEI4hiAAQoD+A4NCKIaEIABCgID8B4NCGIYgAEKAgID4D4NCCIaEhCAAQgiIQoCAgPgPgyAAQhiIQoCA/AeDhCAAQiiIQoD+A4MgAEI4iISEhIUiAUKizpaa4I+i+gCFIgBCOIYgAEKA/gODQiiGhCAAQoCA/AeDQhiGIABCgICA+A+DQgiGhIQgAEIIiEKAgID4D4MgAEIYiEKAgPwHg4QgAEIoiEKA/gODIAFCOIiEhIRC0oGqm6v6gtenf34iAUI4hiABQoD+A4NCKIaEIAFCgID8B4NCGIYgAUKAgID4D4NCCIaEhCABQgiIQoCAgPgPgyABQhiIQoCA/AeDhCABQiiIQoD+A4MgAUI4iISEhCAAQtii0e/CqeW/LX6FIgBCOIYgAEKA/gODQiiGhCAAQoCA/AeDQhiGIABCgICA+A+DQgiGhIQgAEIIiEKAgID4D4MgAEIYiEKAgPwHg4QgAEIoiEKA/gODIABCOIiEhIRCjoqfuNz3qfhxfiIBQjiGIAFCgP4Dg0IohoQgAUKAgPwHg0IYhiABQoCAgPgPg0IIhoSEIAFCCIhCgICA+A+DIAFCGIhCgID8B4OEIAFCKIhCgP4DgyABQjiIhISEIABCjp7gkoSHvp1xfoUgAIk3AwBB0MLCACACQvO7tfGA/c+x0QCFIgBC2KLR78Kp5b8tfiAAQjiGIABCgP4Dg0IohoQgAEKAgPwHg0IYhiAAQoCAgPgPg0IIhoSEIABCCIhCgICA+A+DIABCGIhCgID8B4OEIABCKIhCgP4DgyAAQjiIhISEQtKBqpur+oLXp39+IgBCOIYgAEKA/gODQiiGhCAAQoCA/AeDQhiGIABCgICA+A+DQgiGhIQgAEIIiEKAgID4D4MgAEIYiEKAgPwHg4QgAEIoiEKA/gODIABCOIiEhISFQvGxzPG5irjsfoUiAEI4hiAAQoD+A4NCKIaEIABCgID8B4NCGIYgAEKAgID4D4NCCIaEhCAAQgiIQoCAgPgPgyAAQhiIQoCA/AeDhCAAQiiIQoD+A4MgAEI4iISEhELSgaqbq/qC16d/fiIBQjiGIAFCgP4Dg0IohoQgAUKAgPwHg0IYhiABQoCAgPgPg0IIhoSEIAFCCIhCgICA+A+DIAFCGIhCgID8B4OEIAFCKIhCgP4DgyABQjiIhISEIABC2KLR78Kp5b8tfoUiAEI4hiAAQoD+A4NCKIaEIABCgID8B4NCGIYgAEKAgID4D4NCCIaEhCAAQgiIQoCAgPgPgyAAQhiIQoCA/AeDhCAAQiiIQoD+A4MgAEI4iISEhEKOip+43Pep+HF+IgFCOIYgAUKA/gODQiiGhCABQoCA/AeDQhiGIAFCgICA+A+DQgiGhIQgAUIIiEKAgID4D4MgAUIYiEKAgPwHg4QgAUIoiEKA/gODIAFCOIiEhIQgAEKOnuCShIe+nXF+hSAAiTcDAEHYwsIAIAJCos6WmuCPovoAhSIAQtii0e/CqeW/LX4gAEI4hiAAQoD+A4NCKIaEIABCgID8B4NCGIYgAEKAgID4D4NCCIaEhCAAQgiIQoCAgPgPgyAAQhiIQoCA/AeDhCAAQiiIQoD+A4MgAkI4iISEhELSgaqbq/qC16d/fiIAQjiGIABCgP4Dg0IohoQgAEKAgPwHg0IYhiAAQoCAgPgPg0IIhoSEIABCCIhCgICA+A+DIABCGIhCgID8B4OEIABCKIhCgP4DgyAAQjiIhISEhULzu7XxgP3PsdEAhSIAQjiGIABCgP4Dg0IohoQgAEKAgPwHg0IYhiAAQoCAgPgPg0IIhoSEIABCCIhCgICA+A+DIABCGIhCgID8B4OEIABCKIhCgP4DgyAAQjiIhISEQtKBqpur+oLXp39+IgFCOIYgAUKA/gODQiiGhCABQoCA/AeDQhiGIAFCgICA+A+DQgiGhIQgAUIIiEKAgID4D4MgAUIYiEKAgPwHg4QgAUIoiEKA/gODIAFCOIiEhIQgAELYotHvwqnlvy1+hSIAQjiGIABCgP4Dg0IohoQgAEKAgPwHg0IYhiAAQoCAgPgPg0IIhoSEIABCCIhCgICA+A+DIABCGIhCgID8B4OEIABCKIhCgP4DgyAAQjiIhISEQo6Kn7jc96n4cX4iAUI4hiABQoD+A4NCKIaEIAFCgID8B4NCGIYgAUKAgID4D4NCCIaEhCABQgiIQoCAgPgPgyABQhiIQoCA/AeDhCABQiiIQoD+A4MgAUI4iISEhCAAQo6e4JKEh76dcX6FIACJNwMAQeDCwgAgAkLxsczxuYq47H6FIgBC2KLR78Kp5b8tfiAAQjiGIABCgP4Dg0IohoQgAEKAgPwHg0IYhiAAQoCAgPgPg0IIhoSEIABCCIhCgICA+A+DIABCGIhCgID8B4OEIABCKIhCgP4DgyAAQjiIhISEQtKBqpur+oLXp39+IgBCOIYgAEKA/gODQiiGhCAAQoCA/AeDQhiGIABCgICA+A+DQgiGhIQgAEIIiEKAgID4D4MgAEIYiEKAgPwHg4QgAEIoiEKA/gODIABCOIiEhISFQpH6jqTxz5P3xQCFIgBCOIYgAEKA/gODQiiGhCAAQoCA/AeDQhiGIABCgICA+A+DQgiGhIQgAEIIiEKAgID4D4MgAEIYiEKAgPwHg4QgAEIoiEKA/gODIABCOIiEhIRC0oGqm6v6gtenf34iAUI4hiABQoD+A4NCKIaEIAFCgID8B4NCGIYgAUKAgID4D4NCCIaEhCABQgiIQoCAgPgPgyABQhiIQoCA/AeDhCABQiiIQoD+A4MgAUI4iISEhCAAQtii0e/CqeW/LX6FIgBCOIYgAEKA/gODQiiGhCAAQoCA/AeDQhiGIABCgICA+A+DQgiGhIQgAEIIiEKAgID4D4MgAEIYiEKAgPwHg4QgAEIoiEKA/gODIABCOIiEhIRCjoqfuNz3qfhxfiIBQjiGIAFCgP4Dg0IohoQgAUKAgPwHg0IYhiABQoCAgPgPg0IIhoSEIAFCCIhCgICA+A+DIAFCGIhCgID8B4OEIAFCKIhCgP4DgyABQjiIhISEIABCjp7gkoSHvp1xfoUgAIk3AwBBsMLCAEEANgIAQYDDwgBBADYCAAJAAkACQCADUA0AAkAgC0UNACANBEAgB0EIaiEEIAcpAwBCf4VCgIGChIiQoMCAf4MhACAHIQUDQCAAUARAA0AgBUHAAmshBSAEKQMAIARBCGohBEKAgYKEiJCgwIB/gyIAQoCBgoSIkKDAgH9RDQALIABCgIGChIiQoMCAf4UhAAsgBSAAeqdBA3ZBWGxqIghBJGsoAgAiBgRAIAhBIGsoAgAiCkEEaygCACIJQXhxIg4gBkEEdCIGQQRBCCAJQQNxIgkbckkNBSAJQQAgDiAGQSdqSxsNBiAKEFsLIAhBGGsoAgAiBgRAIAhBFGsoAgAiCkEEaygCACIJQXhxIg4gBkECdCIGQQRBCCAJQQNxIgkbakkNBSAJQQAgDiAGQSdqSxsNBiAKEFsLIAhBDGsoAgAiBgRAIAhBCGsoAgAiCEEEaygCACIKQXhxIgkgBkECdCIGQQRBCCAKQQNxIgobakkNBSAKQQAgCSAGQSdqSxsNBiAIEFsLIABCAX0gAIMhACANQQFrIg0NAAsLIAtBKWwiBEExaiIFRQ0AIAcgC0FYbGoiB0EsaygCACIIQXhxIgsgBUEEQQggCEEDcSIFG2pJDQIgBUEAIAsgBEHYAGpLGw0DIAdBKGsQWwsgDwRAIBBBBGsoAgAiBEF4cSIHIA9BDGwiBUEEQQggBEEDcSIEG2pJDQIgBEEAIAcgBUEnaksbDQMgEBBbCyARRQ0AIBJBBGsoAgAiBEF4cSIHIBFBAnQiBUEEQQggBEEDcSIEG2pJDQEgBEEAIAcgBUEnaksbDQIgEhBbCyAMQSBqJAAPC0HYqMIAQS5BiKnCABDEAgALQZipwgBBLkHIqcIAEMQCAAuxGQEhfyMAQYABayIeJAACQAJAAkAgAUEhTwRAA0AgA0UEQCABIgIgAkEBdmoiBQRAA0ACQAJ/IAIgBUEBayIFTQRAIAUgAmsMAQsgACgCACEBIAAgACAFQQJ0aiIDKAIANgIAIAMgATYCAEEACyIDQQF0IglBAXIiASACIAUgAiAFSRsiBE8NAANAIAlBAmoiCSAESQRAIAEgACABQQJ0aigCACAAIAlBAnRqKAIASWohAQsgACADQQJ0aiIDKAIAIgkgACABQQJ0aiIHKAIAIgZPDQEgByAJNgIAIAMgBjYCACABIQMgAUEBdCIJQQFyIgEgBEkNAAsLIAUNAAsLDAULIAAgAUEDdiIEQRxsaiEFIAAgBEEEdGohCSADQQFrIQMCfyABQcAATwRAIAAgCSAFIAQQhwIMAQsgACAFIAkgACgCACIEIAkoAgAiCUkiByAJIAUoAgAiBUlzGyAHIAQgBUlzGwsgAGshBQJ/An8CQAJAIAIEQCAAIAVqIgkoAgAiBCACKAIATQ0BCyAFQQJ2IAFPDQYgACgCACEJIAAgACAFaiIFKAIANgIAIAUgCTYCACAAKAIAIQQgACgCBCEWQQAhBiAAQQRqIgcgAEEIaiIFIAAgAUECdGoiCkEEayIJTw0CGgNAIAVBBGsgByAGQQJ0aiIIKAIANgIAIAggBSgCACIINgIAIAUgByAGIAQgCEtqIgZBAnRqIggoAgA2AgAgCCAFQQRqKAIAIgg2AgAgBiAEIAhLaiEGIAVBCGoiBSAJSQ0ACwwBCyAAKAIAIQIgACAENgIAIAkgAjYCACAAQQRqIQIgACgCACEEIAAoAgQhB0EAIQYgAEEIaiIFIAAgAUECdGoiFkEEayIJTwR/IAIFA0AgBUEEayACIAZBAnRqIgooAgA2AgAgCiAFKAIAIgo2AgAgBSACIAYgBCAKT2oiBkECdGoiCigCADYCACAKIAVBBGooAgAiCjYCACAGIAQgCk9qIQYgBUEIaiIFIAlJDQALIAVBBGsLIQkgBSAWRwR/A0AgCSACIAZBAnRqIgkoAgA2AgAgCSAFKAIAIgk2AgAgBiAEIAlPaiEGIAUhCSAFQQRqIgUgFkcNAAsgBUEEawUgCQsgAiAGQQJ0aiICKAIANgIAIAIgBzYCACAGIAQgB09qIgIgAU8NBSAAKAIAIQUgACAAIAJBAnRqIgkoAgA2AgAgCSAFNgIAIAEgAkEBaiICayEBIAAgAkECdGohAEEADAILIAVBBGsLIQkgBSAKRwR/A0AgCSAHIAZBAnRqIgkoAgA2AgAgCSAFKAIAIgk2AgAgBiAEIAlLaiEGIAUhCSAFQQRqIgUgCkcNAAsgBUEEawUgCQsgByAGQQJ0aiIFKAIANgIAIAUgFjYCACAGIAQgFktqIgUgAU8NAyAAKAIAIQQgACAAIAVBAnRqIgkoAgA2AgAgCSAENgIAIAAgBSACIAMQMSABIAVBf3NqIQEgCUEEaiEAIAkLIQIgAUEhTw0ACwsgAUECSQ0CIAEgAUEBdiIWIAFBEkkiJBshBSABIBZrIQkgACAWQQJ0aiEDIAAhAgNAAn8gBUEMTQRAQQEgBUEITQ0BGiACIAIoAiAiBCACKAIQIgcgBCAHSxsiBiACKAIMIgogAigCACIIIAggCkkbIgsgBiALSxsiDCACKAIcIg0gAigCBCIQIA0gEEsbIg4gCiAIIAggCksbIgogCiAOSRsiCCAIIAxJGyISIAIoAhgiEyACKAIUIg8gAigCCCIRIA8gEUsbIhQgEyAUSxsiFSAGIAsgBiALSRsiBiANIBAgDSAQSRsiCyAGIAtLGyINIA0gFUkbIhAgECASSRs2AiAgAiATIBQgEyAUSRsiEyAEIAcgBCAHSRsiBCAPIBEgDyARSRsiByAEIAdLGyIPIA8gE0sbIhEgBiALIAYgC0kbIgYgBiARSxsiCyAEIAcgBCAHSRsiBCAOIAogCiAOSxsiByAEIAdJGyIKIAogC0sbNgIAIAIgDCAIIAggDEsbIgggEyAPIA8gE0kbIgwgCCAMSxsiDiASIBAgECASSxsiECAOIBBLGzYCHCACIA4gECAOIBBJGyIQIAggDCAIIAxJGyIIIBUgDSANIBVLGyIMIAggDEsbIg0gESAGIAYgEUkbIgYgBCAHIAQgB0sbIgQgBCAGSRsiByAHIA1JGyIOIA4gEEkbNgIYIAIgECAOIA4gEEsbNgIUIAIgDSAHIAcgDUsbIgcgCCAMIAggDEkbIgggBiAEIAQgBksbIgQgBCAISRsiBiAGIAdJGzYCECACIAcgBiAGIAdLGzYCDCACIAggBCAEIAhLGyIEIAsgCiAKIAtJGyIHIAQgB0sbNgIIIAIgBCAHIAQgB0kbNgIEQQkMAQsgAiACKAIwIgQgAigCACIHIAQgB0sbIgYgAigCLCIKIAIoAhQiCCAIIApJGyILIAIoAhAiDCALIAxLGyINIAYgDUkbIhAgAigCKCIOIAIoAgQiEiAOIBJLGyITIAIoAiAiDyACKAIYIhEgDyARSxsiFCATIBRJGyIVIAIoAiQiFyACKAIIIhggFyAYSxsiGiACKAIcIhkgAigCDCIbIBkgG0sbIhwgGiAcSRsiHyAVIB9LGyIgIBAgIEsbIh0gDyARIA8gEUkbIg8gDiASIA4gEkkbIg4gDiAPSRsiEiAZIBsgGSAbSRsiESAXIBggFyAYSRsiFyARIBdLGyIYIBIgGEsbIhkgCyAMIAsgDEkbIgsgBCAHIAQgB0kbIgQgBCALSRsiByAHIBlJGyIMIAwgHUkbIhsgBiANIAYgDUsbIiEgEyAUIBMgFEsbIgYgGiAcIBogHEsbIg0gBiANSxsiGiAaICFLGyITIAYgDSAGIA1JGyIGIAogCCAIIApLGyIKIAYgCksbIgggCCATSRsiHCAbIBxJGyIiIBMgCCAIIBNLGyIIIB0gDCAMIB1LGyIMIAggDEsbIh0gHSAiSxsiIyAQICAgECAgSRsiDSASIBggEiAYSRsiECANIBBLGyISIBUgHyAVIB9JGyITIBkgByAHIBlLGyIHIAcgE0kbIhQgEiAUSxsiFSAIIAwgCCAMSRsiCCAGIAogBiAKSRsiBiALIAQgBCALSxsiBCAEIAZJGyIKIBEgFyARIBdJGyILIA8gDiAOIA9LGyIMIAsgDEsbIg4gCiAOSxsiDyAIIA9LGyIRIBEgFUkbIhcgFyAjSxs2AiAgAiASIBQgEiAUSRsiEiAIIA8gCCAPSRsiCCAIIBJJGyIPIBUgESARIBVLGyIRIA8gEUsbNgIcIAIgDyARIA8gEUkbIg8gEiAIIAggEksbIgggEyAHIAcgE0sbIgcgCiAOIAogDkkbIgogByAKSxsiDiANIBAgDSAQSRsiDSALIAwgCyAMSRsiECAGIAQgBCAGSxsiEiAQIBJLGyIEIAQgDUkbIgYgBiAOSRsiCyAIIAtLGyIMIAwgD0kbNgIYIAIgDyAMIAwgD0sbNgIUIAIgCCALIAggC0kbIgggDiAGIAYgDksbIgYgByAKIAcgCkkbIgcgDSAEIAQgDUsbIgQgBCAHSRsiCiAGIApLGyILIAggC0sbNgIQIAIgEP0RIAf9HAEgBv0cAiAI/RwDIBL9ESAE/RwBIAr9HAIgC/0cA/23Af0LAgAgAiAj/REgIv0cASAb/RwCICH9HAMgF/0RIB39HAEgHP0cAiAa/RwD/bkB/QsCJEENCyIEIAVLDQEgBCAFRwRAIAIgBUECdGohCCACIARBAnQiB2ohBANAIAQoAgAiCiAEQQRrKAIAIgZJBEAgByEFAn8DQCACIAVqIgsgBjYCACACIAVBBEYNARogBUEEayEFIAogC0EIaygCACIGSQ0ACyACIAVqCyAKNgIACyAHQQRqIQcgBEEEaiIEIAhHDQALCyAkDQMgACACRiAJIQUgAyECDQALIAJBBGshAiAAIAFBAnRBBGsiBWohCSAFIB5qIQcgHiEEIAAhBQNAIAQgAygCACIIIAUoAgAiCyAIIAtJIgwbNgIAIAcgCSgCACIGIAIoAgAiCiAGIApLGzYCACAHQQRrIQcgBEEEaiEEIAJBfEEAIAYgCkkbaiECIAlBfEEAIAYgCk8baiEJIAUgCCALT0ECdGohBSADIAxBAnRqIQMgFkEBayIWDQALIAJBBGohAiABQQFxBH8gBCAFIAMgAiAFSyIEGygCADYCACADIAIgBU1BAnRqIQMgBSAEQQJ0agUgBQsgAkcgAyAJQQRqR3INASABQQJ0IgFFDQIgACAeIAH8CgAADAILAAsQzAIACyAeQYABaiQAC6MYAhN/AX4jAEEgayILJAACQAJAAkAgACgCACIHKAIAIgBFBEAgC0EANgIcIAsgATYCGCALQgA3AhAgCyAHKQIENwIIIAtBCGpBARBBIQgMAQsgBygCCCERIAcoAgQhDgJAA0AgESAUIgdNBEBBACEIDAMLAkACQCAORQ0AIAdBAWoiEiAHIAcgEUkbIRQgDkEBayEIQQAhAiAALQAAIgohBCAOIQUCQAJAA0ACQAJAIATAQQBIBEAgBEEfcSEPIAAgAmoiBkEBai0AAEE/cSEJIARB/wFxIgNB3wFLDQEgD0EGdCAJciEDDAILIARB/wFxIQMMAQsgBkECai0AAEE/cSAJQQZ0ciEJIANB8AFJBEAgCSAPQQx0ciEDDAELIA9BEnRBgIDwAHEgBkEDai0AAEE/cSAJQQZ0cnIiA0GAgMQARg0ECyAAIAJqIgYhCSADQTBrQQpJBEAgAiAIRg0EIAZBAWosAAAiBEG/f0wNAiACQQFqIQIgBUEBayEFDAELCyAOIAVrIgINAUEAIQMMCAsgCSAFQQEgBUHggsIAEJUDAAsgACACaiwAAEG/f0oNASAAIA5BACACQfCCwgAQlQMAC0HQgsIAEKsDAAsCQAJAAkACQCACQQFGBEBBASEDIApBK2sOAwkBCQELIApBK0YEQCACQQFrIQMgAEEBaiEAIAJBCkkNAQwCCyACIgNBCU8NAQtBACECA0AgAC0AAEEwayIIQQlLDQIgAEEBaiEAIAggAkEKbGohAiADQQFrIgMNAAsMAgtBACECIAMhCANAIAhFDQIgAC0AAEEwayIKQQlLDQFBAiEDIAKtQgp+IhVCIIinDQcgAEEBaiEAIAhBAWshCCAKIBWnIgZqIgIgBk8NAAsMBgtBASEDDAULAkAgAkUNACACIAVPBEAgAiAFRg0BDAULIAIgCWosAABBv39MDQQLIAIgCWohAAJAIBEgEkcNACACRSABKAIIQYCAgARxRSAEQf8BcUHoAEdycg0AAkAgAkEBRwRAIAksAAFBQEgNAQsgCUEBaiEEA0BBACEIIAAgBEYNBQJ/IAQsAAAiCkEATgRAIApB/wFxIQMgBEEBagwBCyAELQABQT9xIQMgCkEfcSEGIApBX00EQCAGQQZ0IANyIQMgBEECagwBCyAELQACQT9xIANBBnRyIQMgCkFwSQRAIAMgBkEMdHIhAyAEQQNqDAELIAZBEnRBgIDwAHEgBC0AA0E/cSADQQZ0cnIiA0GAgMQARg0GIARBBGoLIQQgA0HBAGtBXnFBCmogA0EwayADQTlLG0EPTQ0ACwwBCyAJIAJBASACQcCCwgAQlQMACyAHBEAgASgCAEGQg8IAQQIgASgCBCgCDBEAAA0CCwJ/AkAgAkECSQ0AIAkvAABB38gARw0AIAksAAFBv39KBEAgCUEBaiEJIAJBAWsMAgsgCSACQQEgAkGUg8IAEJUDAAsgAgshBCAFIAJrIQ4gASgCBCENIAEoAgAhDANAAkAgCSEHAkACQAJAAkAgBCIGRQ0AAkACQAJAAkACQAJAAn8CQAJAAkAgBy0AACIEQSRHBEAgBEEuRw0LIAZBAUYNASAHLAABIgJBv39MDQIgAkEASA0DIAJB/wFxDAQLIAZBAUcEQCAHLAABQb9/TA0ICyAHQQFqIQUgBkEBayEIQQAhAwNAIAMgBWohCQJAIAggA2siBEEHTQRAIAMgCEYNDkEAIQIDQCACIAlqLQAAQSRGDQIgBCACQQFqIgJHDQALDA4LIAtBJCAJIAQQ0gEgCygCAEEBcUUNDSALKAIEIQILAkAgAiADaiICIAhPDQAgAiAFai0AAEEkRw0AIAJBAWohBAJAAkACQCAFLQAAIgjAIgNBQEgNAAJAIAQgBk8EQCAEIAZHDQIgAkECaiIEDQFBfiECIAYhBCAHIQkMBAsgAkECaiEECwJAIAQgBk8EQCAEIAZGDQEMAwsgBCAHaiwAAEFASA0CCyAEIAdqIQkgBiAEayEEAn8CQAJAAkAgAg4DFAEABgtBjoTCACAFLwAAQdOgAUYNAhpBjYTCACAFLwAAQcKgAUYNAhpBjITCACAFLwAAQdKMAUYNAhpBi4TCACAFLwAAQcyoAUYNAhpBioTCACAFLwAAQceoAUYNAhpBiYTCACAFLwAAQcygAUYNAhogBS8AAEHSoAFGDQFBAiECDAULIAhBwwBHDQ9BiITCAAwBC0HauMIACyECQQEhCCAMIAJBASANKAIMEQAARQ0UDBcLIAcgBkEBIARB1IPCABCVAwALIAcgBiAEIAZB5IPCABCVAwALIANB9QBHDQ0gBywAAkG/f0oNCyAFIAJBASACQfiDwgAQlQMACyAIIAJBAWoiA08NAAsMCwtBASEIIAxBsITCAEEBIA0oAgwRAABFDQMMEQsgByAGQQEgBkGQhMIAEJUDAAsgBy0AAkE/cSEEIAJBH3EhAyADQQZ0IARyIAJBX00NABogBy0AA0E/cSAEQQZ0ciEEIAQgA0EMdHIgAkFwSQ0AGiADQRJ0QYCA8ABxIActAARBP3EgBEEGdHJyCyANKAIMIQRBLkYNAUEBIQggDEGwhMIAQQEgBBEAAA0OIAcsAAFBQEgNAgsgB0EBaiEJIAZBAWshBAwKCyAMQZCDwgBBAiAEEQAADQsCQCAGQQNPBEAgBywAAkFASA0BCyAHQQJqIQkgBkECayEEDAoLIAcgBkECIAZBoITCABCVAwALIAcgBkEBIAZBtITCABCVAwALIAcgBkEBIAZBxIPCABCVAwALIAhB9QBHDQJBASECCyACIAVqIRIgAkEBayEKIAdBAmoiCCEFAkADQEEAIQ8gBSASRg0BAn8gBSwAACIQQQBOBEAgEEH/AXEhAyAFQQFqDAELIAUtAAFBP3EhAyAQQR9xIRMgEEFfTQRAIBNBBnQgA3IhAyAFQQJqDAELIAUtAAJBP3EgA0EGdHIhAyAQQXBJBEAgAyATQQx0ciEDIAVBA2oMAQsgE0ESdEGAgPAAcSAFLQADQT9xIANBBnRyciIDQYCAxABGDQIgBUEEagshBSADQTprQXVLIANB5wBrQXlLcg0AC0EBIQ8LQQEhAwJAAkACQAJAAkACQCACQQFrDgIFAAELIAgtAABBK2sOAwQBBAELAkAgCC0AAEErRgRAIAJBAmshAyAHQQNqIQggAkELTw0BDAILIAohAyACQQpJDQELQQAhBQNAIAVB/////wBLDQMgCC0AACICQcEAa0FfcUEKaiACQTBrIAJBOUsbIgJBEE8NAyAIQQFqIQggAiAFQQR0ciEFIANBAWsiAw0ACwwBC0EAIQUDQCAILQAAIgJBwQBrQV9xQQpqIAJBMGsgAkE5SxsiAkEPSw0CIAhBAWohCCACIAVBBHRyIQUgA0EBayIDDQALC0EAIQMMAQtBASEDC0GAgMQAQYCAxAAgBSAFQYCwA3NBgIDEAGtBgJC8f0kbIAMbIgNBgIDEAEYgA0EgSXIgD3IgA0H/AGtBIUlyDQEgAyABENcBRQ0FDAcLIAYgB2ohCUEAIQggByECA0AgCCEDIAIgCUYNAQJ/IAIsAAAiCkEATgRAIAJBAWohBSAKQf8BcQwBCyACLQABQT9xIQQgCkEfcSEIIApBX00EQCACQQJqIQUgCEEGdCAEcgwBCyACLQACQT9xIARBBnRyIQQgCkFwSQRAIAJBA2ohBSAEIAhBDHRyDAELIAJBBGohBSAIQRJ0QYCA8ABxIAItAANBP3EgBEEGdHJyCyIEQS5HBEAgAyACayAFaiEIIAUhAiAEQSRHDQELCwJAAkAgAwRAIAMgBkkNASADIAZHDQIgDCAHIAYgDSgCDBEAAA0JDAULIAwgB0EAIA0oAgwRAAANCAwECyADIAdqIgQsAABBv39KDQILIAcgBkEAIANBpIPCABCVAwALIAwgByAGIA0oAgwRAABFDQQMBQsgDCAHIAMgDSgCDBEAAA0EIAQsAABBQEgNAQsgAyAHaiEJIAYgA2shBAwBCwsLIAcgBiADIAZBtIPCABCVAwALQQEhCAsgC0EgaiQAIAgPCyAJIAUgAiAFQYCDwgAQlQMACyALIAM6AAhBqI3CAEErIAtBCGpBxITCAEHUhMIAEJMCAAvyFwMOfwJ7AX4jAEHgAGsiDiQAAkACQAJAIARFIAJFcg0AIAAoAjxFDQAgACgCICITIAFrIg1BACANIBNNGyEVIAAoAhwhFgNAIAEgEGohDSAQIBVGDQIgEEEJbEEJaiIJIARLDQMgEEEBaiEQIBYgDUESbGohFEEAIRIgAyENA0AgDSgCACILQf///wNxIQogC0GAgICAeHEhDAJAIAtBgICA/AdxIglBgICA/AdGBEAgCkENdiAMQRB2ciAKQQBHQQl0ckGA+AFyIQwMAQsgDEEQdiEMIAlBgICAuARNBEAgCUGAgIDEA08EQCALQQx2IAtB/98AcUEAR3EgCUENdiAKQQ12akGAgAFqIAxyaiEMDAILIAlBgICAmANJDQEgCkGAgIAEciILQR4gCUEXdiIKa3YhCSALQR0gCmsiCnZBAXEEfyAJQQMgCnRBAWsgC3FBAEdqBSAJCyAMciEMDAELIAxBgPgBciEMCyANQQRqKAIAIgpB////A3EhDyAKQYCAgIB4cSELAkAgCkGAgID8B3EiCUGAgID8B0cEQCALQRB2IQsgCUGAgIC4BE0EQCAJQYCAgMQDTwRAIApBDHYgCkH/3wBxQQBHcSAJQQ12IA9BDXZqQYCAAWogC3JqIQsMAwsgCUGAgICYA0kNAiAPQYCAgARyIgpBHiAJQRd2Ig9rdiEJIApBHSAPayIPdkEBcQR/IAlBAyAPdEEBayAKcUEAR2oFIAkLIAtyIQsMAgsgC0GA+AFyIQsMAQsgD0ENdiALQRB2ciAPQQBHQQl0ckGA+AFyIQsLIA1BCGooAgAiD0H///8DcSERIA9BgICAgHhxIQoCQCAPQYCAgPwHcSIJQYCAgPwHRwRAIApBEHYhCiAJQYCAgLgETQRAIAlBgICAxANPBEAgD0EMdiAPQf/fAHFBAEdxIAlBDXYgEUENdmpBgIABaiAKcmohCgwDCyAJQYCAgJgDSQ0CIBFBgICABHIiD0EeIAlBF3YiEWt2IQkgD0EdIBFrIhF2QQFxBH8gCUEDIBF0QQFrIA9xQQBHagUgCQsgCnIhCgwCCyAKQYD4AXIhCgwBCyARQQ12IApBEHZyIBFBAEdBCXRyQYD4AXIhCgsgDkE2aiASaiIJIAw7AQAgCUEEaiAKOwEAIAlBAmogCzsBACANQQxqIQ0gEkEGaiISQRJHDQALIA5BGGogDkHGAGovAQAiDTsBACAOIA79AAE2Ihf9CwMIIBRBEGogDTsBACAUIBf9CwEAIANBJGohAyACIBBHDQALCwJAAkACQCAGRSACRXINACAAKAI8QQJJDQAgACgCLCIRIAFrIgNBACADIBFNGyETIAAoAighFEEAIRADQCABIBBqIQMgECATRg0CIBBBD2xBD2oiBCAGSw0DIBBBAWohECAUIANBHmxqIQ9BACESIAUhDQNAIA0oAgAiBEH///8DcSEJIARBgICAgHhxIQwCQCAEQYCAgPwHcSIDQYCAgPwHRgRAIAlBDXYgDEEQdnIgCUEAR0EJdHJBgPgBciEMDAELIAxBEHYhDCADQYCAgLgETQRAIANBgICAxANPBEAgBEEMdiAEQf/fAHFBAEdxIANBDXYgCUENdmpBgIABaiAMcmohDAwCCyADQYCAgJgDSQ0BIAlBgICABHIiBEEeIANBF3YiA2t2IQkgBEEdIANrIgN2QQFxBH8gCUEDIAN0QQFrIARxQQBHagUgCQsgDHIhDAwBCyAMQYD4AXIhDAsgDUEEaigCACIEQf///wNxIQkgBEGAgICAeHEhCwJAIARBgICA/AdxIgNBgICA/AdHBEAgC0EQdiELIANBgICAuARNBEAgA0GAgIDEA08EQCAEQQx2IARB/98AcUEAR3EgA0ENdiAJQQ12akGAgAFqIAtyaiELDAMLIANBgICAmANJDQIgCUGAgIAEciIEQR4gA0EXdiIDa3YhCSAEQR0gA2siA3ZBAXEEfyAJQQMgA3RBAWsgBHFBAEdqBSAJCyALciELDAILIAtBgPgBciELDAELIAlBDXYgC0EQdnIgCUEAR0EJdHJBgPgBciELCyANQQhqKAIAIgRB////A3EhCSAEQYCAgIB4cSEKAkAgBEGAgID8B3EiA0GAgID8B0cEQCAKQRB2IQogA0GAgIC4BE0EQCADQYCAgMQDTwRAIARBDHYgBEH/3wBxQQBHcSADQQ12IAlBDXZqQYCAAWogCnJqIQoMAwsgA0GAgICYA0kNAiAJQYCAgARyIgRBHiADQRd2IgNrdiEJIARBHSADayIDdkEBcQR/IAlBAyADdEEBayAEcUEAR2oFIAkLIApyIQoMAgsgCkGA+AFyIQoMAQsgCUENdiAKQRB2ciAJQQBHQQl0ckGA+AFyIQoLIA5BNmogEmoiAyAMOwEAIANBBGogCjsBACADQQJqIAs7AQAgDUEMaiENIBJBBmoiEkEeRw0ACyAOQR5qIgMgDkHMAGopAQA3AQAgDkEYaiIEIA5BxgBqKQEANwMAIA4gDv0AATYiF/0LAwggD0EWaiADKQEANwEAIA9BEGogBCkDADcBACAPIBf9CwEAIAVBPGohBSACIBBHDQALCwJAAkACQCAIRSACRXINACAAKAI8QQNJDQAgACgCOCIGIAFrIgNBACADIAZNGyEPIAAoAjQhEUEAIRADQCABIBBqIQAgDyAQRg0CIBBBFWxBFWoiAyAISw0DIBBBAWohECARIABBKmxqIQNBACESIAchDQNAIA0oAgAiBEH///8DcSEFIARBgICAgHhxIQkCQCAEQYCAgPwHcSIAQYCAgPwHRgRAIAVBDXYgCUEQdnIgBUEAR0EJdHJBgPgBciEMDAELIAlBEHYhDCAAQYCAgLgETQRAIABBgICAxANPBEAgBEEMdiAEQf/fAHFBAEdxIABBDXYgBUENdmpBgIABaiAMcmohDAwCCyAAQYCAgJgDSQ0BIAVBgICABHIiBEEeIABBF3YiAGt2IQkgBEEdIABrIgB2QQFxBH8gCUEDIAB0QQFrIARxQQBHagUgCQsgDHIhDAwBCyAMQYD4AXIhDAsgDUEEaigCACIEQf///wNxIQUgBEGAgICAeHEhCQJAIARBgICA/AdxIgBBgICA/AdHBEAgCUEQdiELIABBgICAuARNBEAgAEGAgIDEA08EQCAEQQx2IARB/98AcUEAR3EgAEENdiAFQQ12akGAgAFqIAtyaiELDAMLIABBgICAmANJDQIgBUGAgIAEciIEQR4gAEEXdiIAa3YhCSAEQR0gAGsiAHZBAXEEfyAJQQMgAHRBAWsgBHFBAEdqBSAJCyALciELDAILIAtBgPgBciELDAELIAVBDXYgCUEQdnIgBUEAR0EJdHJBgPgBciELCyANQQhqKAIAIgRB////A3EhBSAEQYCAgIB4cSEJAkAgBEGAgID8B3EiAEGAgID8B0cEQCAJQRB2IQogAEGAgIC4BE0EQCAAQYCAgMQDTwRAIARBDHYgBEH/3wBxQQBHcSAAQQ12IAVBDXZqQYCAAWogCnJqIQoMAwsgAEGAgICYA0kNAiAFQYCAgARyIgRBHiAAQRd2IgBrdiEJIARBHSAAayIAdkEBcQR/IAlBAyAAdEEBayAEcUEAR2oFIAkLIApyIQoMAgsgCkGA+AFyIQoMAQsgBUENdiAJQRB2ciAFQQBHQQl0ckGA+AFyIQoLIA5BNmogEmoiACAMOwEAIABBBGogCjsBACAAQQJqIAs7AQAgDUEMaiENIBJBBmoiEkEqRw0ACyAOQTBqIA5B3gBqLwEAIgA7AQAgDkEoaiAOQdYAaikBACIZNwMAIA5BGGogDkHGAGr9AAEAIhf9CwMAIA4gDv0AATYiGP0LAwggA0EoaiAAOwEAIANBIGogGTcBACADQRBqIBf9CwEAIAMgGP0LAQAgB0HUAGohByACIBBHDQALCyAOQeAAaiQADwsgACAGQcCZwgAQnQIACyADIAhB0JnCABCsAwALIAMgEUGgmcIAEJ0CAAsgBCAGQbCZwgAQrAMACyANIBNBgJnCABCdAgALIAkgBEGQmcIAEKwDAAu/FwIOfwJ7IwBBEGsiByQAA0ACQCABIApJDQAgCiECA0AgACACaiEIAkAgASACayIGQQdNBEAgASACRg0DQQAhBANAIAQgCGotAABBLkYNAiAGIARBAWoiBEcNAAsMAwsCQAJAIAhBA2pBfHEiAyAIayIFBEBBACEEA0AgBCAIai0AAEEuRg0EIAUgBEEBaiIERw0ACyAFIAZBCGsiDEsNAgwBCyAGQQhrIQxBACEFCwNAQYCChAggAygCACIEQa7cuPECc2sgBHJBgIKECCADQQRqKAIAIgRBrty48QJzayAEcnFBgIGChHhxQYCBgoR4Rw0BIANBCGohAyAFQQhqIgUgDE0NAAsLIAUgBkYNAiAFIAhqIQMgASAFayACayEIQQAhBANAIAMgBGotAABBLkcEQCAIIARBAWoiBEcNAQwECwsgBCAFaiEECyACIARqIgVBAWohAgJAIAEgBU0NACAAIAVqLQAAQS5HDQAgAiEKDAMLIAEgAk8NAAsLCwJAAkACQCABIAprIghBAE4EQAJAIAhFBEBBACEFQQEhBgwBCyAIEC4iBkUNAiAAIApqIgshBCAGIQNBACEKAkAgCCICQRBJDQAgAkHw////B3EhCkEAIQUDQCAFIAZqIQMgBSALaiIE/QAAACIR/Qz//////////////////////SciEP0WAUEBcSAQ/RYAQQFxaiAQ/RYCQQFxaiAQ/RYDQQFxaiAQ/RYEQQFxaiAQ/RYFQQFxaiAQ/RYGQQFxaiAQ/RYHQQFxaiAQ/RYIQQFxaiAQ/RYJQQFxaiAQ/RYKQQFxaiAQ/RYLQQFxaiAQ/RYMQQFxaiAQ/RYNQQFxaiAQ/RYOQQFxaiAQ/RYPQQFxakH/AXFBEEcEQCAFIQoMAgsgA/0MICAgICAgICAgICAgICAgIP0MAAAAAAAAAAAAAAAAAAAAACAR/Qy/v7+/v7+/v7+/v7+/v7+//W79DBoaGhoaGhoaGhoaGhoaGhr9Jv1SIBH9UP0LAAAgBUEQaiEFIAJBEGsiAkEPSw0ACyACRQRAIAohBQwCCyAFIAtqIQQgBSAGaiEDCyACIApqIQUDQCAELAAAIglBAE4EQCADIAlBwQBrQf8BcUEaSUEFdCAJcjoAACADQQFqIQMgBEEBaiEEIApBAWohCiACQQFrIgINAQwCCwsgByAKNgIMIAcgBjYCCCAHIAg2AgQgACABaiEOIAIgBGohDyAKIQVBACECA0ACfwJ/AkACQAJAIAQsAAAiAEEASARAIAQtAAFBP3EhAyAAQR9xIQECfyAAQV9NBEAgAUEGdCADciEDIARBAmoMAQsgBC0AAkE/cSADQQZ0ciEDIABBcEkEQCADIAFBDHRyIQMgBEEDagwBCyABQRJ0QYCA8ABxIAQtAANBP3EgA0EGdHJyIQMgBEEEagsiASACIARraiEAIANBowdGBEACQCACIApqIgZFDQAgBiAITwRAIAYgCEYNAQwOCyAGIAtqLAAAQUBIDQ0LIAYgC2ohBEEAIQkCQANAQYMBIQwgBCALRg0BIARBAWsiAiwAACIDQQBIBEAgA0E/cQJ/IARBAmsiAi0AACIDwCINQUBOBEAgA0EfcQwBCyANQT9xAn8gBEEDayICLQAAIgPAIg1Bv39KBEAgA0EPcQwBCyANQT9xIARBBGsiAi0AAEEHcUEGdHILQQZ0cgtBBnRyIgNBgIDEAEYNAgsCfwJAIAkNACADELgBRQ0AQYCAxAAhA0EADAELQQELIQkgAiEEIANBgIDEAEYNAAsgAxC9AUUNAAJAIAZBAmoiAkUNACACIAhPBEAgAiAIRg0BDA4LIAIgC2osAABBQEgNDQsgAiALaiEEQQAhAgNAQYIBIQwgBCAORg0BAn8gBCwAACIDQQBOBEAgA0H/AXEhAyAEQQFqDAELIAQtAAFBP3EhCSADQR9xIQYgA0FfTQRAIAZBBnQgCXIhAyAEQQJqDAELIAQtAAJBP3EgCUEGdHIhCSADQXBJBEAgCSAGQQx0ciEDIARBA2oMAQsgBkESdEGAgPAAcSAELQADQT9xIAlBBnRyciIDQYCAxABGDQIgBEEEagshBAJ/AkAgAkEBcQ0AIAMQuAFFDQBBgIDEACEDQQAMAQtBAQshAiADQYCAxABGDQALQYN/QYJ/IAMQvQEbIQwLIAcoAgQgBSIEa0EBTQR/IAdBBGogBEECEO0BIAcoAgwFIAQLIAcoAggiBmoiAiAMOgABIAJBzwE6AAAgBUECagwGCyADQYABSQ0BQc0FQQAgA0HSPU8bIgIgAkHmAmoiAiACQQN0QZyVwQBqKAIAIANLGyICIAJBswFqIgIgAkEDdEGclcEAaigCACADSxsiAiACQdoAaiICIAJBA3RBnJXBAGooAgAgA0sbIgIgAkEtaiICIAJBA3RBnJXBAGooAgAgA0sbIgIgAkEWaiICIAJBA3RBnJXBAGooAgAgA0sbIgIgAkELaiICIAJBA3RBnJXBAGooAgAgA0sbIgIgAkEGaiICIAJBA3RBnJXBAGooAgAgA0sbIgIgAkEDaiICIAJBA3RBnJXBAGooAgAgA0sbIgIgAkEBaiICIAJBA3RBnJXBAGooAgAgA0sbIgIgAkEBaiICIAJBA3RBnJXBAGooAgAgA0sbIgJBA3RBnJXBAGooAgAiBCADRg0CDAMLIABB/wFxIQMgBEEBaiIBIAIgBGtqIQALIANBwQBrQRpJQQV0IANyIQNBASEJQQEMAgsCQCACIAMgBEtqIgJBmQtNBEBB6QAgAkEDdEGglcEAaigCACICIAJBgLADc0GAgMQAa0GAkLx/SSICGyEDIAINAUEBIQkgA0GAAU8NAkEBDAMLQZoLQZoLQYyVwQAQnQIACyAFIQICf0EBIANBgAFJIgkNABpBAiADQYAQSQ0AGkEDQQQgA0GAgARJGwsiBCAHKAIEIAVrSwR/IAdBBGogBSAEEO0BIAcoAgghBiAHKAIMBSACCyAGaiECAkACQCAJRQRAIANBgBBJDQEgA0GAgARPBEAgAiADQT9xQYABcjoAAyACIANBEnZB8AFyOgAAIAIgA0EGdkE/cUGAAXI6AAIgAiADQQx2QT9xQYABcjoAAQwDCyACIANBP3FBgAFyOgACIAIgA0EMdkHgAXI6AAAgAiADQQZ2QT9xQYABcjoAAQwCCyACIAM6AAAMAQsgAiADQT9xQYABcjoAASACIANBBnZBwAFyOgAACyAHIAQgBWoiBTYCDCAHKAIEIAUiA2tBAU0EfyAHQQRqIANBAhDtASAHKAIMBSADCyAHKAIIIgZqQcyPAjsAACAFQQJqDAILQQAhCUECIANBgBBJDQAaQQNBBCADQYCABEkbCyIEIAcoAgQgBSICa0sEfyAHQQRqIAIgBBDtASAHKAIIIQYgBygCDAUgAgsgBmohAgJAAkACQCAJRQRAIANBgBBJDQEgA0GAgARJDQIgAiADQT9xQYABcjoAAyACIANBEnZB8AFyOgAAIAIgA0EGdkE/cUGAAXI6AAIgAiADQQx2QT9xQYABcjoAAQwDCyACIAM6AAAMAgsgAiADQT9xQYABcjoAASACIANBBnZBwAFyOgAADAELIAIgA0E/cUGAAXI6AAIgAiADQQx2QeABcjoAACACIANBBnZBP3FBgAFyOgABCyAEIAVqCyEFIAAhAiAHIAU2AgwgASIEIA9HDQALIAcoAgghBiAHKAIEIQgLAn9BAiAFQQNHDQAaQQAgBkH0pcIAQQMQugJFDQAaQQJBASAGQfelwgBBAxC6AhsLIQQCQAJAIAgEQCAGQQRrKAIAIgBBeHEiAUEEQQggAEEDcSIAGyAIakkNASAAQQAgASAIQSdqSxsNAiAGEFsLIAdBEGokACAEDwtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgALQYTNwAAQzQILAAsgCyAIIAIgCEH0zMAAEJUDAAsgCyAIQQAgBkHkzMAAEJUDAAuiFwEPfyMAQSBrIhAkAAJAAkAgAUEhSQRAIAAhCyABIQoMAQsgAkEEayESIAJBEGshEwNAIARFBEAgACABIAIgA0EBIAYQRAwDCyAAIAFBA3YiC0EcbGohByAAIAtBBHRqIQkCQCABQcAATwRAIAAgCSAHIAsgBhD2ASEMDAELIAYoAgBBBGoiCygCACAAIgwoAgAiCCAJKAIAIgoQigEiDSALKAIAIAggBygCACIIEIoBRw0AIAcgCSALKAIAIAogCBCKASANcxshDAsgBEEBayEEIBAgDCgCACIHNgIEIAwgAGtBAnYhCwJAAkACQCAFBEAgBigCAEEEaigCACAFKAIAIAcQigFFDQELIAEgA0sNASAGKAIAIQ4gAiABQQJ0IhVqIQhBACEKIAAhByALIQkDQCAAIAlBA2siDUEAIAkgDU8bQQJ0aiIPIAdLBEADQCAKQQJ0IAIgCEEEayAOQQRqIg0oAgAgBygCACAMKAIAEIoBIhEbaiAHKAIANgIAIAogEWoiCkECdCACIAhBCGsgDSgCACAHQQRqIhEoAgAgDCgCABCKASIUG2ogESgCADYCACAKIBRqIgpBAnQgAiAIQQxrIA0oAgAgB0EIaiIRKAIAIAwoAgAQigEiFBtqIBEoAgA2AgAgCiAUaiIKQQJ0IAIgCEEQayIIIA0oAgAgB0EMaiINKAIAIAwoAgAQigEiERtqIA0oAgA2AgAgCiARaiEKIAdBEGoiByAPSQ0ACwsgACAJQQJ0aiINIAdLBEADQCAKQQJ0IAIgCEEEayIIIA5BBGooAgAgBygCACAMKAIAEIoBIg8baiAHKAIANgIAIAogD2ohCiAHQQRqIgcgDUkNAAsLIAEgCUcEQCAIQQRrIgggCkECdGogBygCADYCACAHQQRqIQcgASEJDAELCyAKQQJ0Ig4EQCAAIAIgDvwKAAALIAEgCmshDwJAIAEgCkYNAEEAIQ0gD0EETwRAIAAgDmohByATIBVqIQggD0F8cSINIQkDQCAHIAj9AAIA/QwAAAAAAAAAAAAAAAAAAAAA/Q0MDQ4PCAkKCwQFBgcAAQID/QsCACAHQRBqIQcgCEEQayEIIAlBBGsiCQ0ACyANIA9GDQELIBIgFSANQQJ0IglraiEHIAAgCWogDmohCCANIAFrIApqIQkDQCAIIAcoAgA2AgAgB0EEayEHIAhBBGohCCAJQQFqIgkNAAsLIApFDQAgASAKTw0CIBBBADYCGCAQQQE2AgwgEEHwq8IANgIIIBBCBDcCECAQQQhqQaSMwgAQ2gIACyABIANLDQAgAiABQQJ0Ig5qIQhBACEJIAAhBwNAIAAgC0EDayIFQQAgBSALTRtBAnRqIgUgB0sEQANAIAlBAnQgCEEEayACIAYoAgBBBGooAgAgDCgCACAHKAIAEIoBIgobaiAHKAIANgIAIAkgCkEBc2oiCUECdCAIQQhrIAIgBigCAEEEaigCACAMKAIAIAdBBGoiCigCABCKASING2ogCigCADYCACAJIA1BAXNqIglBAnQgCEEMayACIAYoAgBBBGooAgAgDCgCACAHQQhqIgooAgAQigEiDRtqIAooAgA2AgAgCSANQQFzaiIJQQJ0IAhBEGsiCCACIAYoAgBBBGooAgAgDCgCACAHQQxqIgooAgAQigEiDRtqIAooAgA2AgAgCSANQQFzaiEJIAdBEGoiByAFSQ0ACwsgACALQQJ0aiIFIAdLBEADQCAJQQJ0IAhBBGsiCCACIAYoAgBBBGooAgAgDCgCACAHKAIAEIoBIgobaiAHKAIANgIAIAkgCkEBc2ohCSAHQQRqIgcgBUkNAAsLIAEgC0cEQCACIAlBAnRqIAcoAgA2AgAgB0EEaiEHIAlBAWohCSAIQQRrIQggASELDAELCyAJQQJ0Ig0EQCAAIAIgDfwKAAALIAEgCUYNBCAAIA1qIQtBACEFAkAgASAJayIKQQRPBEAgDiATaiEHIApBfHEiBSEMIAshCANAIAggB/0AAgD9DAAAAAAAAAAAAAAAAAAAAAD9DQwNDg8ICQoLBAUGBwABAgP9CwIAIAhBEGohCCAHQRBrIQcgDEEEayIMDQALIAUgCkYNAQsgEiAFQQJ0IghrIA5qIQcgACAIaiANaiEIIAUgAWsgCWohDANAIAggBygCADYCACAHQQRrIQcgCEEEaiEIIAxBAWoiDA0ACwsgASAJTwRAQQAhBSALIQAgCiIBQSFJDQQMAwsgCSABQbSMwgAQrgMACwALIAAgDmogDyACIAMgBCAQQQRqIAYQNSAKIgFBIU8NAAsgACELCyAKQQJJDQAgBigCACEEIApBAXYhAwJ/IApBD00EQCAKQQdLBEAgBEEEaiIAKAIAIAsoAgQgCygCABCKASEFIAAoAgAgCygCDCALKAIIEIoBIQYgACgCACALQQxBCCAGG2oiBygCACIMIAsgBUECdGoiDSgCACIOEIoBIQEgACgCACALQQhBDCAGG2oiCCgCACIPIAsgBUEBc0ECdGoiBigCACISEIoBIQUgACgCACAIIAYgByABGyAFGygCACIIIA0gByAGIAUbIAEbKAIAIgYQigEhByACIBIgDyAFGzYCDCACIAwgDiABGzYCACACIAYgCCAHGzYCCCACIAggBiAHGzYCBCAAKAIAIAsgA0ECdCIMaiIBKAIEIAEoAgAQigEhBiAAKAIAIAEoAgwgASgCCBCKASEHIAAoAgAgAUEMQQggBxtqIggoAgAiDSABIAZBAnRqIg4oAgAiDxCKASEFIAAoAgAgAUEIQQwgBxtqIgcoAgAiEiABIAZBAXNBAnRqIgYoAgAiExCKASEBIAAoAgAgByAGIAggBRsgARsoAgAiByAOIAggBiABGyAFGygCACIGEIoBIQggAiAMaiIAIBMgEiABGzYCDCAAIA0gDyAFGzYCACAAIAYgByAIGzYCCCAAIAcgBiAIGzYCBEEEDAILIAIgCygCADYCACACIANBAnQiAGogACALaigCADYCAEEBDAELIAsgAiACIApBAnRqIgAgBBBfIAsgA0ECdCIBaiABIAJqIABBIGogBBBfQQgLIglBAWohACADIAlLBEAgCUECdCENIARBBGohBSAAIQcgCSEIA0AgByEBIAIgCEECdCIHaiIGIAcgC2ooAgAiBzYCACAFKAIAIAcgBkEEaygCABCKAQRAIAYoAgAhBiANIQcCfwNAIAIgB2oiCCAIQQRrKAIANgIAIAIgB0EERg0BGiAHQQRrIQcgBSgCACAGIAhBCGsoAgAQigENAAsgAiAHagsgBjYCAAsgDUEEaiENIAEgASADSSIGaiEHIAEhCCAGDQALCyACIANBAnQiAWohDCAKIANrIgggCUsEQCABIAtqIQ0gCUECdCEBIARBBGohBQNAIAwgCUECdCIHaiIGIAcgDWooAgAiBzYCACAFKAIAIAcgBkEEaygCABCKAQRAIAYoAgAhBiABIQcCfwNAIAcgDGoiCSAJQQRrKAIANgIAIAwgB0EERg0BGiAHQQRrIQcgBSgCACAGIAlBCGsoAgAQigENAAsgByAMagsgBjYCAAsgAUEEaiEBIAAgACIJIAhJIgZqIQAgBg0ACwsgDEEEayEHIAsgCkECdEEEayIAaiEJIAAgAmohCANAIAsgDCgCACIAIAIoAgAiASAEQQRqIgUoAgAgACABEIoBIgAbNgIAIAkgBygCACIBIAgoAgAiBiAFKAIAIAYgARCKASIBGzYCACAJQQRrIQkgC0EEaiELIAwgAEECdGohDCACIABBAXNBAnRqIQIgByABQQJ0IgBrIQcgACAIakEEayEIIANBAWsiAw0ACyAHQQRqIQAgCkEBcQR/IAsgAiAMIAAgAksiARsoAgA2AgAgDCAAIAJNQQJ0aiEMIAIgAUECdGoFIAILIABGIAwgCEEEakZxDQAQzAIACyAQQSBqJAALhhoCJH8TfSMAQRBrIgwkACACQQJ0Ig0gACgCKCIKSwRAIA0gCiIEayIGIAAoAiAgBGtLBEAgAEEgaiAEIAZBBEEEENkBIAAoAighBAsgACgCJCIJIARBAnRqIQggBkECTwR/IA0gCkF/c2pBAnQiCgRAIAhBACAK/AsACyAEIAZqIgpBAWshBCAJIApBAnRqQQRrBSAIC0EANgIAIARBAWohDQsgACANNgIoIAAoAnwgAUECdCIbIAEgAmpBAnQiHBD6AiEUAkAgAkUEQCAAKAIkIREMAQsgAkEMbCEdIAAqAlAgACoCTCItkyEuIAAqAkggACoCRCIvkyEwIAAoAiQhESADKAIkIQ4gAygCICEeIAMoAhwhEiADKAIYIR8gAygCFCETIAMoAhAhICADKAIIISEgAygCBCEPIAMoAgAhIiAALQBsQQFxISMgAygCDCIaIRVBACEEAkACQAJAA0ACQAJAAkAgDSAEQQRqIgpPBEACQAJAIAcgD08NACAPIAdrIgZBACAGIA9NGyIGQQFHBEAgBkECRw0CIAdBAmohBwwBCyAHQQFqIQcLIAcgD0GgvsAAEJ0CAAsgFQRAAkACQCAHIBNPDQACQAJAIBMgFmpBAWsOAgABAwsgB0EBaiEHDAELIAdBAmohBwsgByATQbC+wAAQnQIACwJAAkAgByASTw0AAkACQCASIBZqQQFrDgIAAQMLIAdBAWohBwwBCyAHQQJqIQcLIAcgEkHAvsAAEJ0CAAsgBCAOTw0IAkAgDiAEayIGQQAgBiAOTRtBAWsOAwUHCAALIBAgImoiBigCACEIIAZBCGooAgAhCyAGQQRqKAIAIQkgBCAhaioCACEoIBAgIGoiBCoCACEqIARBCGoqAgAhKSAEQQRqKgIAISsgECAfaiIEKgIAITIgBEEIaioCACEzIARBBGoqAgAhNCAXIB5qIgQqAgAhLCAMIARBBGoqAgA4AgQgDCAsOAIAIAwgBEEIaikCADcCCEMAAH9DQwAAAAAgKEMAAAA/lCAoICMbQwAAf0OUIiggKEMAAAAAXRsiKCAoQwAAf0NeGxCtAiEsQwAAf0NDAAAAACArIC+TIDCVQwAAf0OUIiggKEMAAAAAXRsiKCAoQwAAf0NeGxCtAiI1QwAAAABgISQgNfwBISVDAAB/Q0MAAAAAICkgL5MgMJVDAAB/Q5QiKCAoQwAAAABdGyIoIChDAAB/Q14bEK0CIjZDAAAAAGAhJiA2/AEhJ0MAAH9DQwAAAAAgKiAvkyAwlUMAAH9DlCIoIChDAAAAAF0bIiggKEMAAH9DXhsQrQIhKyAIQf///wNxIQUgCEGAgICAeHEhBiAIQYCAgPwHcSIEQYCAgPwHRgRAIAZBEHYgBUENdnIgBUEAR0EJdHJBgPgBciEGDAQLIAZBEHYhBiAEQYCAgLgESw0CIARBgICAxANPBEAgCEEMdiAIQf/fAHFBAEdxIARBDXYgBUENdmpBgIABaiAGcmohBgwECyAEQYCAgJgDSQ0DIAVBgICABHIiCEEeIARBF3YiBWt2IQQgCEEdIAVrIgV2QQFxBH8gBEEDIAV0QQFrIAhxQQBHagUgBAsgBnIhBgwDCyAaIBpBkL7AABCdAgALIAogDUGAvsAAEKwDAAsgBkGA+AFyIQYLIAlB////A3EhBSAJQYCAgIB4cSEIAkAgCUGAgID8B3EiBEGAgID8B0cEQCAIQRB2IQggBEGAgIC4BE0EQCAEQYCAgMQDTwRAIAlBDHYgCUH/3wBxQQBHcSAEQQ12IAVBDXZqQYCAAWogCHJqIQgMAwsgBEGAgICYA0kNAiAFQYCAgARyIglBHiAEQRd2IgVrdiEEIAlBHSAFayIFdkEBcQR/IARBAyAFdEEBayAJcUEAR2oFIAQLIAhyIQgMAgsgCEGA+AFyIQgMAQsgCEEQdiAFQQ12ciAFQQBHQQl0ckGA+AFyIQgLIAtB////A3EhBSALQYCAgIB4cSEJAkAgC0GAgID8B3EiBEGAgID8B0cEQCAJQRB2IQkgBEGAgIC4BE0EQCAEQYCAgMQDTwRAIAtBDHYgC0H/3wBxQQBHcSAEQQ12IAVBDXZqQYCAAWogCXJqIQkMAwsgBEGAgICYA0kNAiAFQYCAgARyIgtBHiAEQRd2IgVrdiEEIAtBHSAFayIFdkEBcQR/IARBAyAFdEEBayALcUEAR2oFIAQLIAlyIQkMAgsgCUGA+AFyIQkMAQsgBUENdiAJQRB2ciAFQQBHQQl0ckGA+AFyIQkLQwAAAAAhKEMAAAAAISoCfSAMKgIMIilDAAAAAF1FBEAgDCoCBCE3IAwqAgAhOCAMKgIIDAELICmMISkgDCoCBIwhNyAMKgIAjCE4IAwqAgiMCyE5QwAAgD8hMUMAAIA/ICkgKUMAAIA/XhsQwwEiKSApkiI6QwAAAD+UEFciKYtDvTeGNV1FBEAgNyAplSEqIDggKZUhMSA5ICmVISgLICogKosgMYuSICiLkiIplSEqIDEgKZUhKQJAIChDAAAAAF1FBEAgKiEoDAELQwAAgD8gKYuTIiggKIwgKkMAAAAAYBshKEMAAIA/ICqLkyIqICqMIClDAAAAAGAbISkLQf8BQwAAf0NDAAAAACA6Q9sPSUCVQwAAf0OUIiogKkMAAAAAXRsiKiAqQwAAf0NeGxCtAiIq/AFBACAqQwAAAABgGyAqQwAAf0NeG0EQdEH/AUMAAH9DQwAAAAAgKEMAAIA/kkMAAAA/lEMAAH9DlCIoIChDAAAAAF0bIiggKEMAAH9DXhsQrQIiKPwBQQAgKEMAAAAAYBsgKEMAAH9DXhtBCHRyQf8BQwAAf0NDAAAAACApQwAAgD+SQwAAAD+UQwAAf0OUIiggKEMAAAAAXRsiKCAoQwAAf0NeGxCtAiIo/AFBACAoQwAAAABgGyAoQwAAf0NeG3IhC0EAIRhBACEZIDJDAAAAAFwEQEH/AUMAAIA/QwAAAAAgMhDkASAtkyAulSIoIChDAAAAAF0bIiggKEMAAIA/XhtDAAB+Q5QQrQIiKPwBQQAgKEMAAAAAYBsgKEMAAH9DXhtBAWpB/wFxIRkLIDRDAAAAAFwEQEH/AUMAAIA/QwAAAAAgNBDkASAtkyAulSIoIChDAAAAAF0bIiggKEMAAIA/XhtDAAB+Q5QQrQIiKPwBQQAgKEMAAAAAYBsgKEMAAH9DXhtBAWpB/wFxQQh0IRgLQQAhBCAzQwAAAABcBEBB/wFDAACAP0MAAAAAIDMQ5AEgLZMgLpUiKCAoQwAAAABdGyIoIChDAACAP14bQwAAfkOUEK0CIij8AUEAIChDAAAAAGAbIChDAAB/Q14bQQFqQf8BcUEQdCEECyARIBdqIgVBBGogBkH//wNxIAhBEHRyNgIAIAVB/wEgJUEAICQbIDVDAAB/Q14bQQh0Qf8BICdBACAmGyA2QwAAf0NeG0EQdHJB/wEgK/wBQQAgK0MAAAAAYBsgK0MAAH9DXhtyQf8BICz8AUEAICxDAAAAAGAbICxDAAB/Q14bQRh0cjYCACAFQQxqIBkgC0EIdEGAgIB4cXIgBCAYcmo2AgAgBUEIaiAJQf//A3EgC0EQdHJB////B3EgC0GA/v8HcUEIdkEYdHI2AgAgF0EQaiEXIBZBA2shFiAHQQNqIQcgFUEBayEVIAohBCAQQQxqIhAgHUcNAQwFCwsgBEEBaiEEDAILIARBAmohBAwBCyAEQQNqIQQLIAQgDkHQvsAAEJ0CAAsgFCARIA0QgQIgAygCPCEEIAMoAjghBiADKAI0IQogAygCMCEIIAMoAiwiBwRAIAAgASACIAMoAiggBxBOCyAKBEAgACABIAIgCCAKEEALIAQEQCAAIAEgAiAGIAQQbAsCQCADKAJEIglFDQAgAygCTCILRQ0AIAAoAhhBAUcNACAAKAIoIQ4gACgCJCEGAkACQAJAAkACQAJAIAIEQCACQQJ0IREgAygCSCESIAMoAkAhDSADKAIYIQEgAygCHCEQIAMoAgghEyADKAIMIQ8gAygCACEEIAMoAgQhBUEAIQIgBiEKQQMhB0EAIQMDQCACQQRqIgggDksNAyAFIAdJDQQgAyAPRg0GIAcgEEsNBSADIAlGDQcgAyALRg0CIAogBCACIBNqKgIAIAEgDS8BACACIBJqKAIAEFQgA0EBaiEDIApBEGohCiAHQQNqIQcgAUEMaiEBIARBDGohBCANQQJqIQ0gCCICIBFHDQALCyAAKAIcIBsgHBD6AiIAIAYgDhCBAiAAQYQBSQ0GIAAQtQIMBgsgCyALQfC9wAAQnQIACyAIIA5BoL3AABCsAwALIAcgBUGwvcAAEKwDAAsgByAQQdC9wAAQrAMACyAPIA9BwL3AABCdAgALIAkgCUHgvcAAEJ0CAAsgFEGEAU8EQCAUELUCCyAMQRBqJAAL1BcDC38BfgF7IwBBoAtrIgEkAEGAgICAeCEDAkACQAJAIAAoAtwFQYCAgIB4RwRAIAAQKQwBCwJAAn8CQAJAIAAoAvAFIgJBBEkNAAJAIAAoAuwFIgQvAAAgBC0AAkEQdHJB8NjlA0YEQCACQQtJDQIgAkEKayEFA0AgBCAGakGAqcAAQQsQugJFDQIgBSAGQQFqIgZHDQALIAJB//8DTQ0CIAFBADYCkAYgAUEBNgKEBiABQfiowAA2AoAGIAFCBDcCiAYgAUGABmoQnwIhBAwGCyABQQA2ApAGIAFBATYChAYgAUH0o8AANgKABiABQgQ3AogGIAFBgAZqEJ8CIQQMBQsgAiAGTwRAIAFBgAZqIAQgBhB6IAEpAoQGIQwgASgCgAYEQCAMELQCIQQMBgsgDEIgiKchAiAMpyEDIAECe0HQyMIAKAIAQQFGBEBB2MjCAP0AAwAMAQsgAUGABmoQgwJB0MjCAEIBNwMAQeDIwgAgASkDiAY3AwAgAf0ABIAGCyIN/QsDMEHYyMIAIA39HQBCAXw3AwAgAUHYksIA/QADAP0LAyAgAUEANgKoBiABQQA7AaQGIAEgAjYCoAYgAUEANgKcBiABQQE6AJgGIAFBCjYClAYgASACNgKQBiABQQA2AowGIAEgAjYCiAYgASADNgKEBiABQQo2AoAGAkADQCABQRhqIAFBgAZqEG0CQAJAAkACQAJAAkACQAJAAkAgASgCGCICBEACQCABKAIcIgNFBEBBACEDDAELIANBAWsiBSACaiIELQAAQQpHDQACfyAFRQRAQQAhBEF/DAELIAJBACAEQQFrLQAAQQ1GGyEEIANBAmsLIAUgBBshAyAEIAIgBBshAgsgASABKAKoBiIEQQFqNgKoBiABQRBqIAIgAxB7IAEgASgCFCICNgJIIAEgASgCECIDNgJEIAQNASACQQNGBEAgA0H0pcIAQQMQugJFDQsLIAFBADYCkAsgAUEBNgKECyABQdymwAA2AoALIAFCBDcCiAsgAUGAC2oQnwIhBAwQCyAKRQ0BIAFBgAZqIgIgCCAHIAFBIGoQOiABKAKABiEEIAEoAtwKIgNBgICAgHhGDQIgAUGAAmogAkEEckGABPwKAAAgASgChAohByABQagBaiABQYgKakHUAPwKAAAgASkD4AohDCABQQA6AIgGIAEgBzYChAYgASAINgKABiAAIAIQqAEgACgC8AUiBSAGQQtqIgJJDQMgAEEANgLwBSACIAVHBEAgBSACayIFBEAgACgC7AUiBiACIAZqIAX8CgAACyAAIAU2AvAFCyAAKALcBUGAgICAeEcEQCAAQYABahBLCyAAIAQ2AoABIABBhAFqIAFBgAJqQYAE/AoAACAAIAc2AoQFIABBiAVqIAFBqAFqQdQA/AoAACAAIAw3A+AFIAAgAzYC3AUMDAsgAkUNCCABQQE7AWggAUEANgJkIAEgAzYCXCABIAI2AlggASADNgJUIAEgAjYCUCABQQA2AkwgASACIANqNgJgIAFBCGogAUHMAGoQkQECQCABKAIIIgIEQCABKAIMIQNBIBAuIgRFDQUgBCADNgIEIAQgAjYCAEEBIQMgAUEBNgL4CiABIAQ2AvQKIAFBBDYC8AogAUGQC2ogAUHcAGr9AAIA/QsDACABIAH9AAJM/QsDgAtBDCECA0AgASABQYALahCRASABKAIAIgVFDQIgASgCBCEJIAEoAvAKIANGBEAgAUHwCmogA0EBQQRBCBDZASABKAL0CiEECyACIARqIgsgCTYCACALQQRrIAU2AgAgASADQQFqIgM2AvgKIAJBCGohAgwACwALQQBBAEHkpsAAEJ0CAAsgASgC8AohCSABKAL0CiIFKAIAIQICQAJAAkACQAJAAkAgBSgCBEEGaw4DAAIBEgsgAkH0psAAQQYQugIgA0EDR3INESAFQQhqIQIgBSgCDEEURw0EIAIoAgBB5KfAAEEUELoCDQQgBUEQaiECIAUoAhRBA0YEQCACKAIAQfinwABBAxC6AkUNDQsgAUEBNgKECyABQZSowAA2AoALIAFCATcCjAsgASACrUKAgICA0ACENwPwCiABIAFB8ApqNgKICyABQfgAaiIAIAFBgAtqEP4BIAAQnAIMEgsgA0EDRw0QIAIpAABC8OS9g9fMnLr5AFINECAFKAIMQQVGBEAgBSgCCCICQYinwABBBRC6AiIDRQ0CIAJBjafAAEEFELoCRQ0CCyABQQE2AoQLIAFBtKfAADYCgAsgAUIBNwKMCyABIAVBCGqtQoCAgIDQAIQ3A/AKIAEgAUHwCmo2AogLIAFBkAFqIgAgAUGAC2oQ/gEgABCcAgwRCyACQfqmwABBBxC6AkUNASACQYGnwABBBxC6AkUNCgwPCyAFKAIUIgJBAEgNBiAFKAIQIQsCQCACRQRAQQEhBAwBCyACEC4iBEUNBgsgAgRAIAQgCyAC/AoAAAsgASACNgKICyABIAQ2AoQLIAEgAjYCgAsgAUEgaiABQYALaiAHIANBAEcQhQFBAUEEIAMbIAdqIQcMCQsgA0EDRw0NIAVBCGohAgJAIAUoAgxBBkcNACACKAIAQbynwABBBhC6Ag0AIAUoAhAhA0EAIQICQAJAAkAgBSgCFCIEDgILAAELQQEhAiADLQAAQStrDgMKAQoBCyADLQAAQStGBEAgBEEBayECIANBAWohAyAEQQpJDQEMCQsgBCICQQlPDQgLQQAhCANAIAMtAABBMGsiBEEJTQRAQQEhCiADQQFqIQMgBCAIQQpsaiEIIAJBAWsiAg0BDAsLC0EBELMCDA8LIAFBATYChAsgAUHcp8AANgKACyABQgE3AowLIAEgAq1CgICAgNAAhDcD8AogASABQfAKajYCiAsgAUGEAWoiACABQYALahD+ASAAEJwCDA4LIAFBATYChAsgAUG0qMAANgKACyABQgE3AowLIAEgAq1CgICAgNAAhDcD8AogASABQfAKajYCiAsgAUHsAGoiACABQYALahD+ASAAEJwCDA0LIAFBADYCkAYgAUEBNgKEBiABQcCmwAA2AoAGIAFCBDcCiAYgAUGABmoQnwIhBAwNCyAEDQ0gACgC3AUhAwwJCyACIAVB+IzCABCsAwsAC0HQkcIAEM0CAAtBACEIIAIhBANAIARFBEBBASEKDAMLIAMtAABBMGsiCkEJSwRAQQEQswIMCQtBAiECIAitQgp+IgxCIIinDQEgA0EBaiEDIARBAWshBCAKIAynIgtqIgggC08NAAsLIAIQswIMBgsgCUUNACAFQQRrKAIAIgJBeHEiAyAJQQN0IgRBBEEIIAJBA3EiAhtqTwRAIAJBACADIARBJ2pLGw0CIAUQWwwBCwtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgALIAYgAkGEpsAAEKwDAAtBACEEIANBgICAgHhGDQMgABApDAMLIAFBATYChAsgAUHcqMAANgKACyABQgE3AowLIAEgAUHEAGqtQoCAgIDQAIQ3A/AKIAEgAUHwCmo2AogLIAFBnAFqIgAgAUGAC2oQ/gEgABCcAgshBCAJRQ0AIAUgCUEDdBClAgsgASgCJCIARQ0AIAEoAiwiBQRAIAEoAiAiAkEIaiEDIAIpAwBCf4VCgIGChIiQoMCAf4MhDANAIAxQBEADQCACQaABayECIAMpAwAgA0EIaiEDQoCBgoSIkKDAgH+DIgxCgIGChIiQoMCAf1ENAAsgDEKAgYKEiJCgwIB/hSEMCyACIAx6p0EDdkFsbGoiCEEUaygCACIGBEAgCEEQaygCACIIQQRrKAIAIgdBeHEiCUEEQQggB0EDcSIHGyAGakkNBCAHQQAgCSAGQSdqSxsNBSAIEFsLIAxCAX0gDIMhDCAFQQFrIgUNAAsLIAAgAEEUbEEbakF4cSICakEJaiIARQ0AIAEoAiAgAmsgABClAgsgAUGgC2okACAEDwtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgAL0RcDC38BfgF7IwBBoAtrIgEkAEGAgICAeCEDAkACQAJAIAAoApwFQYCAgIB4RwRAIAAQKgwBCwJAAn8CQAJAIAAoArAFIgJBBEkNAAJAIAAoAqwFIgQvAAAgBC0AAkEQdHJB8NjlA0YEQCACQQtJDQIgAkEKayEFA0AgBCAGakGAqcAAQQsQugJFDQIgBSAGQQFqIgZHDQALIAJB//8DTQ0CIAFBADYCkAYgAUEBNgKEBiABQfiowAA2AoAGIAFCBDcCiAYgAUGABmoQnwIhBAwGCyABQQA2ApAGIAFBATYChAYgAUH0o8AANgKABiABQgQ3AogGIAFBgAZqEJ8CIQQMBQsgAiAGTwRAIAFBgAZqIAQgBhB6IAEpAoQGIQwgASgCgAYEQCAMELQCIQQMBgsgDEIgiKchAiAMpyEDIAECe0HQyMIAKAIAQQFGBEBB2MjCAP0AAwAMAQsgAUGABmoQgwJB0MjCAEIBNwMAQeDIwgAgASkDiAY3AwAgAf0ABIAGCyIN/QsDMEHYyMIAIA39HQBCAXw3AwAgAUHYksIA/QADAP0LAyAgAUEANgKoBiABQQA7AaQGIAEgAjYCoAYgAUEANgKcBiABQQE6AJgGIAFBCjYClAYgASACNgKQBiABQQA2AowGIAEgAjYCiAYgASADNgKEBiABQQo2AoAGAkADQCABQRhqIAFBgAZqEG0CQAJAAkACQAJAAkACQAJAAkAgASgCGCICBEACQCABKAIcIgNFBEBBACEDDAELIANBAWsiBSACaiIELQAAQQpHDQACfyAFRQRAQQAhBEF/DAELIAJBACAEQQFrLQAAQQ1GGyEEIANBAmsLIAUgBBshAyAEIAIgBBshAgsgASABKAKoBiIEQQFqNgKoBiABQRBqIAIgAxB7IAEgASgCFCICNgJIIAEgASgCECIDNgJEIAQNASACQQNGBEAgA0H0pcIAQQMQugJFDQsLIAFBADYCkAsgAUEBNgKECyABQdymwAA2AoALIAFCBDcCiAsgAUGAC2oQnwIhBAwQCyAKRQ0BIAFBgAZqIgIgCCAHIAFBIGoQOiABKAKABiEEIAEoAtwKIgNBgICAgHhGDQIgAUGAAmogAkEEckGABPwKAAAgASgChAohByABQagBaiABQYgKakHUAPwKAAAgASkD4AohDCABQQA6AIgGIAEgBzYChAYgASAINgKABiAAIAIQRSAAKAKwBSIFIAZBC2oiAkkNAyAAQQA2ArAFIAIgBUcEQCAFIAJrIgUEQCAAKAKsBSIGIAIgBmogBfwKAAALIAAgBTYCsAULIAAoApwFQYCAgIB4RwRAIABBQGsQSwsgACAENgJAIABBxABqIAFBgAJqQYAE/AoAACAAIAc2AsQEIABByARqIAFBqAFqQdQA/AoAACAAIAw3A6AFIAAgAzYCnAUMDAsgAkUNCCABQQE7AWggAUEANgJkIAEgAzYCXCABIAI2AlggASADNgJUIAEgAjYCUCABQQA2AkwgASACIANqNgJgIAFBCGogAUHMAGoQkQECQCABKAIIIgIEQCABKAIMIQNBIBAuIgRFDQUgBCADNgIEIAQgAjYCAEEBIQMgAUEBNgL4CiABIAQ2AvQKIAFBBDYC8AogAUGQC2ogAUHcAGr9AAIA/QsDACABIAH9AAJM/QsDgAtBDCECA0AgASABQYALahCRASABKAIAIgVFDQIgASgCBCEJIAEoAvAKIANGBEAgAUHwCmogA0EBQQRBCBDZASABKAL0CiEECyACIARqIgsgCTYCACALQQRrIAU2AgAgASADQQFqIgM2AvgKIAJBCGohAgwACwALQQBBAEHkpsAAEJ0CAAsgASgC8AohCSABKAL0CiIFKAIAIQICQAJAAkACQAJAAkAgBSgCBEEGaw4DAAIBEgsgAkH0psAAQQYQugIgA0EDR3INESAFQQhqIQIgBSgCDEEURw0EIAIoAgBB5KfAAEEUELoCDQQgBUEQaiECIAUoAhRBA0YEQCACKAIAQfinwABBAxC6AkUNDQsgAUEBNgKECyABQZSowAA2AoALIAFCATcCjAsgASACrUKAgICA0ACENwPwCiABIAFB8ApqNgKICyABQfgAaiIAIAFBgAtqEP4BIAAQnAIMEgsgA0EDRw0QIAIpAABC8OS9g9fMnLr5AFINECAFKAIMQQVGBEAgBSgCCCICQYinwABBBRC6AiIDRQ0CIAJBjafAAEEFELoCRQ0CCyABQQE2AoQLIAFBtKfAADYCgAsgAUIBNwKMCyABIAVBCGqtQoCAgIDQAIQ3A/AKIAEgAUHwCmo2AogLIAFBkAFqIgAgAUGAC2oQ/gEgABCcAgwRCyACQfqmwABBBxC6AkUNASACQYGnwABBBxC6AkUNCgwPCyAFKAIUIgJBAEgNBiAFKAIQIQsCQCACRQRAQQEhBAwBCyACEC4iBEUNBgsgAgRAIAQgCyAC/AoAAAsgASACNgKICyABIAQ2AoQLIAEgAjYCgAsgAUEgaiABQYALaiAHIANBAEcQhQFBAUEEIAMbIAdqIQcMCQsgA0EDRw0NIAVBCGohAgJAIAUoAgxBBkcNACACKAIAQbynwABBBhC6Ag0AIAUoAhAhA0EAIQICQAJAAkAgBSgCFCIEDgILAAELQQEhAiADLQAAQStrDgMKAQoBCyADLQAAQStGBEAgBEEBayECIANBAWohAyAEQQpJDQEMCQsgBCICQQlPDQgLQQAhCANAIAMtAABBMGsiBEEJTQRAQQEhCiADQQFqIQMgBCAIQQpsaiEIIAJBAWsiAg0BDAsLC0EBELMCDA8LIAFBATYChAsgAUHcp8AANgKACyABQgE3AowLIAEgAq1CgICAgNAAhDcD8AogASABQfAKajYCiAsgAUGEAWoiACABQYALahD+ASAAEJwCDA4LIAFBATYChAsgAUG0qMAANgKACyABQgE3AowLIAEgAq1CgICAgNAAhDcD8AogASABQfAKajYCiAsgAUHsAGoiACABQYALahD+ASAAEJwCDA0LIAFBADYCkAYgAUEBNgKEBiABQcCmwAA2AoAGIAFCBDcCiAYgAUGABmoQnwIhBAwNCyAEDQ0gACgCnAUhAwwJCyACIAVB+IzCABCsAwsAC0HQkcIAEM0CAAtBACEIIAIhBANAIARFBEBBASEKDAMLIAMtAABBMGsiCkEJSwRAQQEQswIMCQtBAiECIAitQgp+IgxCIIinDQEgA0EBaiEDIARBAWshBCAKIAynIgtqIgggC08NAAsLIAIQswIMBgsgCUUNACAFQQRrKAIAIgJBeHEiAyAJQQN0IgRBBEEIIAJBA3EiAhtqTwRAIAJBACADIARBJ2pLGw0CIAUQWwwBCwtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgALIAYgAkGEpsAAEKwDAAtBACEEIANBgICAgHhGDQMgABAqDAMLIAFBATYChAsgAUHcqMAANgKACyABQgE3AowLIAEgAUHEAGqtQoCAgIDQAIQ3A/AKIAEgAUHwCmo2AogLIAFBnAFqIgAgAUGAC2oQ/gEgABCcAgshBCAJRQ0AIAUgCUEDdBClAgsgASgCJCIARQ0AIAEoAiwiBQRAIAEoAiAiAkEIaiEDIAIpAwBCf4VCgIGChIiQoMCAf4MhDANAIAxQBEADQCACQaABayECIAMpAwAgA0EIaiEDQoCBgoSIkKDAgH+DIgxCgIGChIiQoMCAf1ENAAsgDEKAgYKEiJCgwIB/hSEMCyACIAx6p0EDdkFsbGoiCEEUaygCACIGBEAgCEEQaygCACIIQQRrKAIAIgdBeHEiCUEEQQggB0EDcSIHGyAGakkNBCAHQQAgCSAGQSdqSxsNBSAIEFsLIAxCAX0gDIMhDCAFQQFrIgUNAAsLIAAgAEEUbEEbakF4cSICakEJaiIARQ0AIAEoAiAgAmsgABClAgsgAUGgC2okACAEDwtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgALmRUDBH4QfwF7IwBBIGsiCyQAAkACQAJAAkACQAJAQcTCwgAoAgAiBUF/RwRAQbzCwgAoAgAiDCAMQQFqIgpBA3YiB0EHbCAMQQhJGyIGQQF2IAVNBEACQAJAAkACQAJ/IAYgBSAFIAZJGyIGQQ5PBEAgBkH+////AUsNDUF/IAZBA3RBCGpBB25BAWtndkEBagwBC0EEQQhBECAGQQdJGyAGQQNJGwsiBq1CKH4iAEIgiKcNACAApyIEIAZBCGoiCGoiByAESSAHQfj///8HS3INACAHEC4iB0UNASAEIAdqIQogCARAIApB/wEgCPwLAAsgBkEBayINIAZBA3ZBB2wgDUEISRshDyAFDQJBuMLCACgCACEHDAMLIAtBADYCGCALQQE2AgwgC0GQ78EANgIIIAtCBDcCECALQQhqQZjvwQAQ2gILAAsgCkEIaiEQQbjCwgAoAgAiB0EoayERIAcpAwBCf4VCgIGChIiQoMCAf4MhA0EAIQQgBSEIIAchBgNAIANQBEADQCAEQQhqIQQgBkEIaiIGKQMAQoCBgoSIkKDAgH+DIgBCgIGChIiQoMCAf1ENAAsgAEKAgYKEiJCgwIB/hSEDCyAKIA1B0MLCACkDACIAIBEgA3qnQQN2IARqIhJBWGxqNQIAhSIBQjiGIAFCgP4Dg0IohoQgAUKAgPwHg0IYhiABQoCAgPgPg0IIhoSEIABCCIhCgICA+A+DIABCGIhCgID8B4OEIABCKIhCgP4DgyAAQjiIhISEQtKBqpur+oLXp39+IgBCOIYgAEKA/gODQiiGhCAAQoCA/AeDQhiGIABCgICA+A+DQgiGhIQgAEIIiEKAgID4D4MgAEIYiEKAgPwHg4QgAEIoiEKA/gODIABCOIiEhIQgAULYotHvwqnlvy1+hSIAQjiGIABCgP4Dg0IohoQgAEKAgPwHg0IYhiAAQoCAgPgPg0IIhoSEIABCCIhCgICA+A+DIABCGIhCgID8B4OEIABCKIhCgP4DgyAAQjiIhISEQcjCwgApAwAiAUJ/hX4iAkI4hiACQoD+A4NCKIaEIAJCgID8B4NCGIYgAkKAgID4D4NCCIaEhCACQgiIQoCAgPgPgyACQhiIQoCA/AeDhCACQiiIQoD+A4MgAkI4iISEhCAAIAFCOIYgAUKA/gODQiiGhCABQoCA/AeDQhiGIAFCgICA+A+DQgiGhIQgAUIIiEKAgID4D4MgAUIYiEKAgPwHg4QgAUIoiEKA/gODIAFCOIiEhIR+hSAAiaciE3EiCWopAABCgIGChIiQoMCAf4MiAFAEQEEIIQ4DQCAJIA5qIQkgDkEIaiEOIAogCSANcSIJaikAAEKAgYKEiJCgwIB/gyIAUA0ACwsgA0IBfSADgyEDIAogAHqnQQN2IAlqIA1xIglqLAAAQQBOBEAgCikDAEKAgYKEiJCgwIB/g3qnQQN2IQkLIAkgCmogE0EZdiIOOgAAIBAgCUEIayANcWogDjoAACAKIAlBf3NBKGxqIglBIGogByASQX9zQShsaiIOQSBqKQAANwAAIAlBEGogDkEQav0AAAD9CwAAIAkgDv0AAAD9CwAAIAhBAWsiCA0ACwtBvMLCACANNgIAQbjCwgAgCjYCAEHAwsIAIA8gBWs2AgAgDEUNBiAMIAxBKGxBL2pBeHEiBGpBCWoiBkUNBiAHIARrIgRBBGsoAgAiBUF4cSIIQQRBCCAFQQNxIgUbIAZqSQ0CIAVBACAIIAZBJ2pLGw0DIAQQWwwGC0G4wsIAKAIAIQggByAKQQdxQQBHaiIHRQ0EQQEhBiAHQQFGDQMgB0EBcSEGIAghBCAHQf7///8DcSIJIQUDQCAEIAT9AAMAIhT9TUEH/c0B/QwBAQEBAQEBAQEBAQEBAQEB/U4gFP0Mf39/f39/f39/f39/f39/f/1Q/c4B/QsDACAEQRBqIQQgBUECayIFDQALIAcgCUYNBCAJQQN0IQQMAwsMBQtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgALIAQgCGohBANAIAQgBCkDACIAQn+FQgeIQoGChIiQoMCAAYMgAEL//v379+/fv/8AhHw3AwAgBEEIaiEEIAZBAWsiBg0ACwtBwMLCAAJ/AkAgCkEITwRAIAggCmogCCkAADcAAAwBCyAKBEAgCEEIaiAIIAr8CgAACyAKDQBBAAwBC0EBIQVBACEGA0AgBiEHIAUhBgJAIAdBuMLCACgCACIFai0AAEGAAUcNACAFIAdBf3NBKGxqIQ0gB0FYbCEPA0BBvMLCACgCACIJQdDCwgApAwAiACAFIA9qQShrNQIAhSIBQjiGIAFCgP4Dg0IohoQgAUKAgPwHg0IYhiABQoCAgPgPg0IIhoSEIABCCIhCgICA+A+DIABCGIhCgID8B4OEIABCKIhCgP4DgyAAQjiIhISEQtKBqpur+oLXp39+IgBCOIYgAEKA/gODQiiGhCAAQoCA/AeDQhiGIABCgICA+A+DQgiGhIQgAEIIiEKAgID4D4MgAEIYiEKAgPwHg4QgAEIoiEKA/gODIABCOIiEhIQgAULYotHvwqnlvy1+hSIAQjiGIABCgP4Dg0IohoQgAEKAgPwHg0IYhiAAQoCAgPgPg0IIhoSEIABCCIhCgICA+A+DIABCGIhCgID8B4OEIABCKIhCgP4DgyAAQjiIhISEQcjCwgApAwAiAUJ/hX4iAkI4hiACQoD+A4NCKIaEIAJCgID8B4NCGIYgAkKAgID4D4NCCIaEhCACQgiIQoCAgPgPgyACQhiIQoCA/AeDhCACQiiIQoD+A4MgAkI4iISEhCAAIAFCOIYgAUKA/gODQiiGhCABQoCA/AeDQhiGIAFCgICA+A+DQgiGhIQgAUIIiEKAgID4D4MgAUIYiEKAgPwHg4QgAUIoiEKA/gODIAFCOIiEhIR+hSAAiaciDnEiDCEIIAUgDGopAABCgIGChIiQoMCAf4MiAFAEQEEIIQQDQCAEIAhqIQggBEEIaiEEIAUgCCAJcSIIaikAAEKAgYKEiJCgwIB/gyIAUA0ACwsgBSAAeqdBA3YgCGogCXEiCGosAABBAE4EQCAFKQMAQoCBgoSIkKDAgH+DeqdBA3YhCAsgCCAMayAHIAxrcyAJcUEITwRAIAUgCGoiBC0AACAEIA5BGXYiBDoAAEG4wsIAKAIAIAhBCGsgCXFqQQhqIAQ6AAAgBSAIQX9zQShsaiEEQf8BRgRAQbzCwgAoAgAhBUG4wsIAKAIAIAdqQf8BOgAAQbjCwgAoAgAgBSAHQQhrcWpBCGpB/wE6AAAgBEEgaiANQSBqKQAANwAAIARBEGogDUEQav0AAAD9CwAAIAQgDf0AAAD9CwAADAMLIA0gBEEoELABQbjCwgAoAgAhBQwBCwsgBSAHaiAOQRl2IgQ6AABBuMLCACgCACAJIAdBCGtxakEIaiAEOgAACyAGIAYgCkkiBGohBSAEDQALQbzCwgAoAgAiBiAGQQFqQQN2QQdsIAZBCEkbC0HEwsIAKAIAazYCAAsgC0EgaiQADwsgC0EANgIYIAtBATYCDCALQZDvwQA2AgggC0IENwIQIAtBCGpBmO/BABDaAgAL4B4CL38BfiMAQbAEayIFJAAgA0GwoMIAQQEQfCEEIAVBADYCmAMgBUEBNgKMAyAFQcSgwgA2AogDIAVCBDcCkAMgBUGIA2oQoAIhBgJAAkACQAJAAkACQAJAAkAgBEUEQCAAQYCAgIB4NgLcBCAAIAY2AgAMAQsgBiAGKAIAKAIAEQMAIAQtABAhFSAEKAIMIRYgA0HMoMIAQQEQfCEEIAVBADYCmAMgBUEBNgKMAyAFQeCgwgA2AogDIAVCBDcCkAMgBUGIA2oQoAIhBiAERQRAIABBgICAgHg2AtwEIAAgBjYCAAwBCyAGIAYoAgAoAgARAwAgBC0AECEXIAQoAgwhGCADQeigwgBBARB8IQQgBUEANgKYAyAFQQE2AowDIAVB/KDCADYCiAMgBUIENwKQAyAFQYgDahCgAiEGIARFBEAgAEGAgICAeDYC3AQgACAGNgIADAELIAYgBigCACgCABEDACAELQAQIRkgBCgCDCEaIANBhKHCAEEHEHwhBCAFQQA2ApgDIAVBATYCjAMgBUGkocIANgKIAyAFQgQ3ApADIAVBiANqEKACIQYgBEUEQCAAQYCAgIB4NgLcBCAAIAY2AgAMAQsgBiAGKAIAKAIAEQMAIAQtABAhGyAEKAIMIRwgA0GsocIAQQcQfCEEIAVBADYCmAMgBUEBNgKMAyAFQcyhwgA2AogDIAVCBDcCkAMgBUGIA2oQoAIhBiAERQRAIABBgICAgHg2AtwEIAAgBjYCAAwBCyAGIAYoAgAoAgARAwAgBC0AECEdIAQoAgwhHiADQdShwgBBBxB8IQQgBUEANgKYAyAFQQE2AowDIAVB9KHCADYCiAMgBUIENwKQAyAFQYgDahCgAiEGIARFBEAgAEGAgICAeDYC3AQgACAGNgIADAELIAYgBigCACgCABEDACAELQAQIR8gBCgCDCEgIANB/KHCAEEFEHwhBCAFQQA2ApgDIAVBATYCjAMgBUGYosIANgKIAyAFQgQ3ApADIAVBiANqEKACIQYgBEUEQCAAQYCAgIB4NgLcBCAAIAY2AgAMAQsgBiAGKAIAKAIAEQMAIAQtABAhISAEKAIMISIgA0GgosIAQQUQfCEEIAVBADYCmAMgBUEBNgKMAyAFQbyiwgA2AogDIAVCBDcCkAMgBUGIA2oQoAIhBiAERQRAIABBgICAgHg2AtwEIAAgBjYCAAwBCyAGIAYoAgAoAgARAwAgBC0AECEjIAQoAgwhJCADQcSiwgBBBRB8IQQgBUEANgKYAyAFQQE2AowDIAVB4KLCADYCiAMgBUIENwKQAyAFQYgDahCgAiEGIARFBEAgAEGAgICAeDYC3AQgACAGNgIADAELIAYgBigCACgCABEDACAELQAQISUgBCgCDCEmIANB6KLCAEEFEHwhBCAFQQA2ApgDIAVBATYCjAMgBUGEo8IANgKIAyAFQgQ3ApADIAVBiANqEKACIQYgBEUEQCAAQYCAgIB4NgLcBCAAIAY2AgAMAQsgBiAGKAIAKAIAEQMAIAQtABAhJyAEKAIMISggA0GMo8IAQQcQfCEEIAVBADYCmAMgBUEBNgKMAyAFQayjwgA2AogDIAVCBDcCkAMgBUGIA2oQoAIhBiAERQRAIABBgICAgHg2AtwEIAAgBjYCAAwBCyAGIAYoAgAoAgARAwAgBC0AECEpIAQoAgwhKiADQbSjwgBBBhB8IQQgBUEANgKYAyAFQQE2AowDIAVB1KPCADYCiAMgBUIENwKQAyAFQYgDahCgAiEGIARFBEAgAEGAgICAeDYC3AQgACAGNgIADAELIAYgBigCACgCABEDACAELQAQISsgBCgCDCEsIANB3KPCAEEGEHwhBCAFQQA2ApgDIAVBATYCjAMgBUH8o8IANgKIAyAFQgQ3ApADIAVBiANqEKACIQYgBEUEQCAAQYCAgIB4NgLcBCAAIAY2AgAMAQsgBiAGKAIAKAIAEQMAIAQtABAhLSAEKAIMIS4gA0GEpMIAQQYQfCEEIAVBADYCmAMgBUEBNgKMAyAFQaSkwgA2AogDIAVCBDcCkAMgBUGIA2oQoAIhBiAERQRAIABBgICAgHg2AtwEIAAgBjYCAAwBCyAGIAYoAgAoAgARAwAgBUEEaq1CgICAgLABhCEzIAQtABAhLyAEKAIMITBBACEGA0ACQCAFIAY2AgQgBUEBNgKMAyAFQbSkwgA2AogDIAVCATcClAMgBSAzNwMYIAUgBUEYajYCkAMgBUEIaiAFQYgDahD+ASAFKAIIIQQgAyAFKAIMIgYgBSgCEBB8RQ0AIAQEQCAGIAQQpQILIAUoAgRBAWohBgwBCwsgBARAIAYgBBClAgtBASEGQQIhCkECIQxBAiELAkACQCAFKAIEIgQOGQYBAQEBAQEBAQUBAQEBAQEBAQEBAQEBAQMACyAEQS1GDQMLIAVBATYCjAMgBUHkpMIANgKIAyAFQgE3ApQDIAUgMzcDCCAFIAVBCGo2ApADIAVBIGoiASAFQYgDahD+ASABEJ4CIQEgAEGAgICAeDYC3AQgACABNgIACyADKAIEIgFFDQQgAygCDCICBEAgAygCACIGQQhqIQAgBikDAEJ/hUKAgYKEiJCgwIB/gyEzA0AgM1AEQANAIAZBoAFrIQYgACkDACAAQQhqIQBCgIGChIiQoMCAf4MiM0KAgYKEiJCgwIB/UQ0ACyAzQoCBgoSIkKDAgH+FITMLIAYgM3qnQQN2QWxsaiIHQRRrKAIAIgQEQCAHQRBrKAIAIgdBBGsoAgAiCEF4cSIKQQRBCCAIQQNxIggbIARqSQ0IIAhBACAKIARBJ2pLGw0JIAcQWwsgM0IBfSAzgyEzIAJBAWsiAg0ACwsgASABQRRsQRtqQXhxIgJqQQlqIgBFDQQgAygCACACayIBQQRrKAIAIgJBeHEiA0EEQQggAkEDcSICGyAAakkNBSACQQAgAyAAQSdqSxsNBiABEFsMBAtBAiEGQQEhCQwBC0EDIQZBASEJQQEhEwsgBUGIA2ohECMAQYABayIEJAAgBEH8AGqtQoCAgIDgAIQhMyAGQQJ0QYi7wgBqKAIAIREgBEEEaiEIAkACQANAIARBATYCXCAEQbSkwgA2AlggBEIBNwJkIAQgMzcDcCAEIBEgByAHQf8BcUEDbiIMQQNsa0H/AXFsIAxqNgJ8IAQgBEHwAGo2AmAgBEHMAGogBEHYAGoQrQEgAyAEKAJQIgwgBCgCVBB8Ig1FDQEgDS0AECEOIA0oAgwhEiAEKAJMIg0EQCAMQQRrKAIAIg9BeHEiFEEEQQggD0EDcSIPGyANakkNBiAPQQAgFCANQSdqSxsNByAMEFsLIAggEjYCACAIQQRqIA46AAAgCEEIaiEIIAdBAWoiB0EJRw0ACyAQIARBBGpByAD8CgAAIARBgAFqJAAMAQtB7KTCABCrAwALIAUtAIwDIQwgBSgCiAMhDSAFQS9qIAVBjQNqQcMA/AoAACAJRQRAQQEhBAwBCyAFQYgDaiEQIwBBsAFrIgQkACAEQawBaq1CgICAgOAAhCEzIAZBAnRBlLvCAGooAgAhEUEAIQcgBEEEaiEIAkACQANAIARBATYCjAEgBEG0pMIANgKIASAEQgE3ApQBIAQgMzcDoAEgBCAHQf8BcUEDbiIKIBEgByAKQQNsa0H/AXFsakEDajYCrAEgBCAEQaABajYCkAEgBEH8AGogBEGIAWoQrQEgAyAEKAKAASIKIAQoAoQBEHwiCUUNASAJLQAQIQ4gCSgCDCESIAQoAnwiCQRAIApBBGsoAgAiD0F4cSIUQQRBCCAPQQNxIg8bIAlqSQ0GIA9BACAUIAlBJ2pLGw0HIAoQWwsgCCASNgIAIAhBBGogDjoAACAIQQhqIQggB0EBaiIHQQ9HDQALIBAgBEEEakH4APwKAAAgBEGwAWokAAwBC0H8pMIAEKsDAAsgBS0AjAMhCiAFKAKIAyExIAVB8gBqIAVBjQNqQfMA/AoAACATRQRAQQIhBAwBCyAFQYgDaiEJIwBB4AFrIgQkACAEQdwBaq1CgICAgOAAhCEzIAZBAnRBoLvCAGooAgAhE0EAIQYgBEEEaiEHAkACQANAIARBATYCvAEgBEG0pMIANgK4ASAEQgE3AsQBIAQgMzcD0AEgBCAGQf8BcUEDbiIIIBMgBiAIQQNsa0H/AXFsakEIajYC3AEgBCAEQdABajYCwAEgBEGsAWogBEG4AWoQrQEgAyAEKAKwASIIIAQoArQBEHwiC0UNASALLQAQIRAgCygCDCERIAQoAqwBIgsEQCAIQQRrKAIAIg5BeHEiEkEEQQggDkEDcSIOGyALakkNBiAOQQAgEiALQSdqSxsNByAIEFsLIAcgETYCACAHQQRqIBA6AAAgB0EIaiEHIAZBAWoiBkEVRw0ACyAJIARBBGpBqAH8CgAAIARB4AFqJAAMAQtBjKXCABCrAwALIAUtAIwDIQsgBSgCiAMhMiAFQeUBaiAFQY0DakGjAfwKAABBAyEECyAAIAs6AEQgACAyNgJAIAAgJzoAPCAAICg2AjggACAlOgA0IAAgJjYCMCAAICM6ACwgACAkNgIoIAAgIToAJCAAICI2AiAgACAD/QADAP0LAwAgAEEQaiADQRBq/QADAP0LAwAgAEHFAGogBUHlAWpBowH8CgAAIAAgCjoA7AEgACAxNgLoASAAQe0BaiAFQfIAakHzAPwKAAAgACAMOgDkAiAAIA02AuACIABB5QJqIAVBL2pBwwD8CgAAIABCBDcD4AQgAEIANwPYBCAAQoCAgIDAADcD0AQgAEIENwPIBCAAQgA3A8AEIABCgICAgMAANwO4BCAAQgQ3A7AEIABCADcDqAQgAEKAgICAwAA3A6AEIABCBDcDmAQgAEIANwOQBCAAQoCAgIDAADcDiAQgACAENgKEBCAAQQA2AoAEIAAgAjYC/AMgACABNgL4AyAAICk6APQDIAAgKjYC8AMgACAvOgDsAyAAIDA2AugDIAAgLToA5AMgACAuNgLgAyAAICs6ANwDIAAgLDYC2AMgACAfOgDUAyAAICA2AtADIAAgHToAzAMgACAeNgLIAyAAIBs6AMQDIAAgHDYCwAMgACAZOgC8AyAAIBo2ArgDIAAgFzoAtAMgACAYNgKwAyAAIBU6AKwDIAAgFjYCqAMLIAVBsARqJAAPC0HYqMIAQS5BiKnCABDEAgALQZipwgBBLkHIqcIAEMQCAAvYDgIcfwV9IwBBMGsiBiQAAkACQAJAAkACQCAAKAIsIgJBgICAgHhGIAAoAjgiA0GAgICAeEZxRQRAIAJBgICAgHhHIANBgICAgHhHcUUEQCAGQQA2AhwgBkEBNgIQIAZBmL3AADYCDCAGQgQ3AhQgBkEMahCfAiECDAQLQYCABCEKIAAoAigiA0H//wNNBEBBgIAEIAMiAmsiASAAKAIgIAJrSwRAIABBIGogAiABQQRBBBDZASAAKAIoIQILIAAoAiQiBCACQQJ0aiEHIANB//8DRwR/Qfz/DyADQQJ0ayIBBEAgB0EAIAH8CwALIAIgA2siA0H//wNqIQIgBCADQQJ0akH8/w9qBSAHC0EANgIAIAJBAWohCgsgACgCdCILQQJ0EJMDIRECQCAAKAIYRQ0AIAAoAhwiA0GEAUkNACADELUCCyAAIBE2AhwgAEEBNgIYIAAoAiwiEkGAgICAeEYNAiAAKAI4IhNBgICAgHhGDQECQCALRQ0AQwAAAEBDAACAPyAALQBsQQFxGyEhIAAqAlAgACoCTCIdk0MAAH5DlSEeIAAoAjAhFyAAKAI8IRggACgCQCEUIAAoAjQhFSAAKAJ8IRkgACgCJCEOQQAhAgJAAkADQEGAgAEgCyACayIDIANBgIABTxsiBEECdCIJIApLDQIgGSACQQJ0IhYgAiAEaiIDQQJ0IhoQ+gIiASAOIAkQhAIgAUGEAU8EQCABELUCCwJAIAIgC0cEQCAEQQR0IRsgFiAYaiEPIBcgAkEBdGohEEEBIAQgBEEBTRtBBHQhHEEAIQwDQAJ/AkAgDCAbRwRAIAwgDmoiDUEEaigCACIFQf//AXFFBEAgBUEQdAwDCyAFQf8HcSEHIAVBgIACcSEBIAVBgPgBcSIEQYD4AUYEQCABQRB0IgFBgICA/AdyIAdFDQMaIAEgB0ENdHJBgICA/gdyDAMLIAFBEHQhASAERQ0BIARBDXRBgICA/ABxIAdBDXRyQYCAgMADaiABcgwCCyAJQQRqIAlBxLzAABCsAwALIAFBgICA2ANyIAdnQRBrIgFBF3RrIAcgAUH//wNxQQhqdEH///8DcXILIQcCfyAFQYCAfHEgBUEQdiIIQf//AXFFDQAaIAhB/wdxIQUgCEGAgAJxIQEgCEGA+AFxIgRBgPgBRgRAIAFBEHQiAUGAgID8B3IgBUUNARogASAIQQ10ckGAgID+B3IMAQsgAUEQdCIBIARBDXRBgICA/ABxIAVBDXRyQYCAgMADanIgBA0AGiABQYCAgNgDciAFZ0EQayIBQRd0ayAFIAFB//8DcUEIanRB////A3FyCyEEIAYCfyANQQhqKAIAIgVB//8BcUUEQCAFQRB0DAELIAVB/wdxIQggBUGAgAJxIQEgBUGA+AFxIgVBgPgBRgRAIAFBEHQiAUGAgID8B3IgCEUNARogASAIQQ10ckGAgID+B3IMAQsgAUEQdCIBIAVBDXRBgICA/ABxIAhBDXRyQYCAgMADanIgBQ0AGiABQYCAgNgDciAIZ0EQayIBQRd0ayAIIAFB//8DcUEIanRB////A3FyCzYCLCAGIAQ2AiggBiAHNgIkIA0tAAMhBCANQQxqKAIAIgdBCHYhAUMAAAAAIR8gB0H/AXEEQCAdIB4gB0EBa0H/AXGzlJIQnAEhHwtDAAAAACEgIAFB/wFxBEAgHSAeIAFBAWtB/wFxs5SSEJwBISALIAYgB0EQdiIBQf8BcQR9IB0gHiABQQFrQf8BcbOUkhCcAQVDAAAAAAs4AhQgBiAgOAIQIAYgHzgCDCACIBVPDQIgAiAUTw0EIA0gBkEkaiAhIASzQwAAf0OVlEMAAAAAkiAGQQxqIBAvAQAgDygCABBUIA9BBGohDyAQQQJqIRAgAkEBaiECIBwgDEEQaiIMRw0ACwsgESAWIBoQ+gIiAiAOIAkQgQIgAkGEAU8EQCACELUCCyADIgIgC0kNAQwECwsgAiAVQdS8wAAQnQIACyACIBRB5LzAABCdAgALIAkgCkG0vMAAEKwDAAsgE0GAgICAeHJBgICAgHhHBEAgACgCPCIEQQRrKAIAIgNBeHEiASATQQJ0IgJBBEEIIANBA3EiAxtqSQ0FIANBACABIAJBJ2pLGw0GIAQQWwsgAEGAgICAeDYCOCASQYCAgIB4ckGAgICAeEcEQCAAKAIwIgRBBGsoAgAiA0F4cSIBIBJBAXQiAkEEQQggA0EDcSIDG2pJDQUgA0EAIAEgAkEnaksbDQYgBBBbCyAAQYCAgIB4NgIsC0EAIQIgAEEANgIoIAAoAiQhBCAAKAIgIQMgAEKAgICAwAA3AiAgA0UNAiAEQQRrKAIAIgBBeHEiASADQQJ0IgNBBEEIIABBA3EiABtqSQ0DIABBACABIANBJ2pLGw0EIAQQWwwCC0GkvMAAEKsDAAtBlLzAABCrAwALIAZBMGokACACDwtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgAL7QwDEH8BfgFvIwBB4AZrIgEkACABQagBaiIHIAIgAygCDBECAAJAAkACQAJAAkACQAJAIAEpA6gBQrqmpIKd+5PCMVINACABKQOwAUK/oP7znarQ8zBSDQAgAUE4aiACQfAA/AoAACABKAKcASIDRQ0BIAcgAyABKAKgASIHKAIMEQIAAkACQCABKQOoAULunNvFps+Qq+sAUQRAIAEpA7ABQpPk6KLrzqb00ABRDQELIAFBqAFqIAMgBygCDBECACABKQOoAULlqveJiuyMxKd/UQRAIAEpA7ABQq+R5bTB5MiUe1ENAgsgAUEANgK4ASABQQE2AqwBIAFBjLXAADYCqAEgAUIENwKwASABQagBakGUtcAAENoCAAsgAUGoAWogA0G4BfwKAAAgAUEYaiADQRxq/QACAP0LAwAgAUEoaiADQSxq/QACAP0LAwAgASAD/QACDP0LAwggAygCPCEHIAMoAgghCSADKQMAIRQgASgC0AYiBQRAIAEoAtQGIgRBBGsoAgAiBkF4cSIKQQRBCCAGQQNxIgYbIAVqSQ0IIAZBACAKIAVBJ2pLGw0HIAQQWwsgASgCxAZBgICAgHhHBEAgAUHoAWoQSwsgA0EEaygCACIFQXhxQbwFQcAFIAVBA3EiBBtJDQcgBEUNBCAFQeAFTw0GDAQLIAFBGGogA0Ecav0AAgD9CwMAIAFBKGogA0Esav0AAgD9CwMAIAEgA/0AAgz9CwMIIAMoAoABIQogAygCfCEOIAMoAnQhDyADKAJwIRAgAygCaCERIAMoAmQhBSADKAJcIRIgAygCWCEEIAMoAlAhCyADKAJMIQYgAygCPCEHIAMoAgghCSADKQIAIRQgAygCQCIIBEAgAygCRCIMQQRrKAIAIg1BeHEiE0EEQQggDUEDcSINGyAIakkNByANQQAgEyAIQSdqSxsNBiAMEFsLIAYEQCALQQRrKAIAIghBeHEiDEEEQQggCEEDcSIIGyAGakkNByAIQQAgDCAGQSdqSxsNBiALEFsLIAQEQCASQQRrKAIAIgZBeHEiC0EEQQggBkEDcSIGGyAEakkNByAGQQAgCyAEQSdqSxsNBiASEFsLAkAgBUGAgICAeEYNACAFBEAgEUEEaygCACIEQXhxIgYgBUECdCIFQQRBCCAEQQNxIgQbakkNCCAEQQAgBiAFQSdqSxsNByAREFsLIBAEQCAPQQRrKAIAIgVBeHEiBCAQQQF0IgZBBEEIIAVBA3EiBRtqSQ0IIAVBACAEIAZBJ2pLGw0HIA8QWwsgDkUNACAKQQRrKAIAIgVBeHEiBCAOQQJ0IgZBBEEIIAVBA3EiBRtqSQ0HIAVBACAEIAZBJ2pLGw0GIAoQWwsgA0EEaygCACIFQXhxQazTAEGw0wAgBUEDcSIEG0kNAiAERSAFQdDTAElyDQMMBQsgASADNgKsASABIAI2AqgBQaiNwgBBKyABQagBakHUycAAQZzKwAAQkwIAC0HotMAAEKsDAAtB2KjCAEEuQYipwgAQxAIMAQsgAxBbIAEoAkQiA0GAgICAeHJBgICAgHhHBEAgASgCSCIFQQRrKAIAIgRBeHEiBkEEQQggBEEDcSIEGyADakkNAyAEQQAgBiADQSdqSxsNAiAFEFsLIAEoAlBBgICAgHhHBEAgAUHQAGoQeQsgASgCOCIDBEAgASgCPCIFQQRrKAIAIgRBeHEiBkEEQQggBEEDcSIEGyADakkNAyAEQQAgBiADQSdqSxsNAiAFEFsLAkAgASgCkAEiA0GAgICAeHJBgICAgHhHBEAgASgClAEiBUEEaygCACIEQXhxIgZBBEEIIARBA3EiBBsgA2pJDQQgBEEAIAYgA0EnaksbDQEgBRBbC0HUABAuIgNFDQEgAyAJNgIUIAMgFDcCDCADQQA2AgggA0KBgICAEDcCACADIAH9AAMI/QsCGCADIAc2AlAgAyAJNgJMIAMgBzYCSCADQShqIAFBGGr9AAMA/QsCACADQThqIAFBKGr9AAMA/QsCACADQQhqEAAhFRCeASIHIBUmASACQQRrKAIAIgNBeHFB9ABB+AAgA0EDcSIJG0kNAyAJQQAgA0GYAU8bDQIgAhBbIAAgBzYCBCAAQQA2AgAgAUHgBmokAA8LDAELAAtBmKnCAEEuQcipwgAQxAIAC0HYqMIAQS5BiKnCABDEAgAL2g8DD38DewJ+IwBBgAFrIgUkACAFIAI2AgggBSAAKAIIIgg2AgwCQAJAAkACQCACIAhGBEAgAkUEQEEEIQgMAwsgAkECdCIDEC4iBkUNASAGQQRrIg8tAABBA3FFIANFckUEQCAGQQAgA/wLAAtBACEIIAMhBAJAAkADQCABKAIAIgcgAk8NASAGIAdBAnRqIAg2AgAgAUEEaiEBIAhBAWohCCAEQQRrIgQNAAtBACEEIAVBADYCGCAFQoCAgIDAADcCEEEEIQdBACEIDAELIAcgAkG0msIAEJ0CAAsDQAJAIAYgCEECdGoiDSgCACIBIAhGDQAgBEEDdCEKA0AgBSgCECAERgRAIwBBIGsiByQAAkACQCAFQRBqIgkoAgAiC0H/////AEsNAEEEIAtBAXQiDCAMQQRNGyIMQQN0IhBB/P///wdLDQAgByALBH8gByALQQN0NgIcIAcgCSgCBDYCFEEEBUEACzYCGCAHQQhqQQQgECAHQRRqEIgCIAcoAghBAUcNASAHKAIQGiAHKAIMIQ4LIA5BxJrCABCDAwALIAcoAgwhCyAJIAw2AgAgCSALNgIEIAdBIGokACAFKAIUIQcLIAcgCmoiCSAINgIAIAlBBGogATYCACAFIARBAWoiBDYCGCABIAJJBEAgDSgCACEJIA0gBiABQQJ0aiIBKAIANgIAIAEgCTYCACAKQQhqIQogDSgCACIBIAhGDQIMAQsLIAEgAkHUmsIAEJ0CAAsgCEEBaiIIIAJHDQALAkACQAJAAkACQAJAAkACQCAPKAIAIgFBeHEiB0EEQQggAUEDcSIBGyADak8EQCAFKAIUIQggBSgCECENIAFBACAHIANBJ2pLGw0BIAYQWyAERQ0LIAggBEEDdGohByAAKAIEIQYgCCEEA0AgBCgCACIBIAJPDQMgBEEEaigCACIDIAJPDQ4gBUEwaiIKIAYgAUEwbGoiAUEgaiIJ/QAEAP0LBAAgBUEgaiILIAFBEGoiDv0ABAD9CwQAIAH9AAQAIRIgBiADQTBsaiIDQRBqIg8pAwAhFSADQSBqIgwpAwAhFiABIAMpAwA3AwAgCSAWNwMAIA4gFTcDACADQRhqKQMAIRUgA0EoaikDACEWIAFBCGogA0EIaikDADcDACABQShqIBY3AwAgAUEYaiAVNwMAIAUgEv0LBBAgDCAK/QAEAP0LBAAgDyAL/QAEAP0LBAAgAyAF/QAEEP0LBAAgBEEIaiIEIAdHDQALIAAoAhQiAgRAIAAoAhAhBCAIIQEDQCABKAIAIgMgAk8NDyABQQRqKAIAIgYgAk8NBSAEIANB0ABsaiEDIAVBEGogA0HQAPwKAAAgAyAEIAZB0ABsaiIGQdAA/AoAACAGIAVBEGpB0AD8CgAAIAFBCGoiASAHRw0ACwsgACgCICICBEAgACgCHCEEIAghAQNAIAEoAgAiAyACTw0PIAFBBGooAgAiBiACTw0GIAQgA0ESbGoiA0EQaiIKLwEAIQkgBCAGQRJsaiIG/QABACESIAogBkEQaiIKLwEAOwEAIAP9AAEAIRMgAyAS/QsBACAKIAk7AQAgBiAT/QsBACABQQhqIgEgB0cNAAsLIAAoAiwiAwRAIAAoAighBiAIIQQDQCAEKAIAIgEgA08NByAEQQRqKAIAIgIgA08NCCAGIAFBHmxqIgFBEGoiCikBACEVIAFBFmopAQAhFiAGIAJBHmxqIgJBHGovAQAhCSACQRhqKAEAIQsgAv0AAQAhEiAKIAJBEGoiCikBADcBACAB/QABACETIAEgEv0LAQAgAUEYaiALNgEAIAFBHGogCTsBACAFQSZqIgEgFjcBACAFQSBqIgkgFTcDACACIBP9CwEAIAogCSkDADcBACACQRZqIAEpAQA3AQAgBEEIaiIEIAdHDQALCyAAKAI4IgFFDQwgACgCNCEDIAghBANAIAQoAgAiACABTw0IIARBBGooAgAiAiABTw0JIAVBOGoiBiADIABBKmxqIgBBKGoiCi8BADsBACAFQTBqIgkgAEEgaiILKQEANwMAIAVBIGoiDiAAQRBqIg/9AAEA/QsDACADIAJBKmxqIgJBEGoiDP0AAQAhEiAC/QABACETIAJBKGoiEC8BACERIAsgAkEgaiILKQEANwEAIAogETsBACAA/QABACEUIAAgE/0LAQAgDyAS/QsBACAFIBT9CwMQIAsgCSkDADcBACAQIAYvAQA7AQAgAiAF/QADEP0LAQAgDCAO/QADAP0LAQAgBEEIaiIEIAdHDQALDAwLQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIACyABIAJB5JrCABCdAgALIAYgAkHkmsIAEJ0CAAsgBiACQeSawgAQnQIACyABIANB5JrCABCdAgALIAIgA0HkmsIAEJ0CAAsgACABQeSawgAQnQIACyACIAFB5JrCABCdAgALIAVBADYCECAFQQhqIAVBDGogBUEQakHglsIAEM8CCwALIAAoAjgaCwJAAkAgDQRAIAhBBGsoAgAiAEF4cSIBIA1BA3QiAkEEQQggAEEDcSIAG2pJDQEgAEEAIAEgAkEnaksbDQIgCBBbCyAFQYABaiQADwtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgALIAMgAkHkmsIAEJ0CAAuvDAEPfyMAQbAIayIBJAAgAUG4AmoiBCACIAMoAgwRAgACQAJAAkACQAJAIAEpA7gCQqrw772fo9aPCFINACABKQPAAkKHsdGcrZOvpCBSDQAgAi0ArAEiEUECRwRAIAFBiAFqIAJBsAH8CgAAIAEoAqwCIgNFDQIgBCADIAEoArACIgQoAgwRAgACQAJAIAEpA7gCQr+pgr3ynrnznX9RBEAgASkDwAJCxbvZi/zX3IRZUQ0BCyABQbgCaiADIAQoAgwRAgAgASkDuAJC1/Xd04v0kYhmUQRAIAEpA8ACQuT6mvW1u/Cb2QBRDQILIAFBADYCyAIgAUEBNgK8AiABQYy1wAA2ArgCIAFCBDcCwAIgAUG4AmpBlLXAABDaAgALIAFBuAJqIANB+AX8CgAAIAFBCGogA0GAAfwKAAAgASgCoAgiBARAIAEoAqQIIgVBBGsoAgAiBkF4cSIIQQRBCCAGQQNxIgYbIARqSQ0HIAZBACAIIARBJ2pLGw0GIAUQWwsgASgClAhBgICAgHhHBEAgAUG4A2oQSwsgA0EEaygCACIEQXhxQfwFQYAGIARBA3EiBRtJDQYgBUUNBCAEQaAGTw0FDAQLIAFBCGogA0GAAfwKAAAgAygCwAEhCCADKAK8ASEMIAMoArQBIQ0gAygCsAEhDiADKAKoASEPIAMoAqQBIQQgAygCnAEhECADKAKYASEFIAMoApABIQkgAygCjAEhBiADKAKAASIHBEAgAygChAEiCkEEaygCACILQXhxIhJBBEEIIAtBA3EiCxsgB2pJDQYgC0EAIBIgB0EnaksbDQUgChBbCyAGBEAgCUEEaygCACIHQXhxIgpBBEEIIAdBA3EiBxsgBmpJDQYgB0EAIAogBkEnaksbDQUgCRBbCyAFBEAgEEEEaygCACIGQXhxIglBBEEIIAZBA3EiBhsgBWpJDQYgBkEAIAkgBUEnaksbDQUgEBBbCwJAIARBgICAgHhGDQAgBARAIA9BBGsoAgAiBUF4cSIGIARBAnQiBEEEQQggBUEDcSIFG2pJDQcgBUEAIAYgBEEnaksbDQYgDxBbCyAOBEAgDUEEaygCACIEQXhxIgUgDkEBdCIGQQRBCCAEQQNxIgQbakkNByAEQQAgBSAGQSdqSxsNBiANEFsLIAxFDQAgCEEEaygCACIEQXhxIgUgDEECdCIGQQRBCCAEQQNxIgQbakkNBiAEQQAgBSAGQSdqSxsNBSAIEFsLIANBBGsoAgAiBEF4cUHs0wBB8NMAIARBA3EiBRtJDQUgBUUgBEGQ1ABJcg0DDAQLQazJwAAQqwMACyABIAM2ArwCIAEgAjYCuAJBqI3CAEErIAFBuAJqQdTJwABB5MnAABCTAgALQei0wAAQqwMACyADEFsCQCABKAKUAiIDQYCAgIB4ckGAgICAeEcEQCABKAKYAiIEQQRrKAIAIgVBeHEiBkEEQQggBUEDcSIFGyADakkNAyAFQQAgBiADQSdqSxsNAiAEEFsLIAEoAogBQQJHBEAgAUGIAWoQnwELIAEoAogCIgMEQCABKAKMAiIEQQRrKAIAIgVBeHEiBkEEQQggBUEDcSIFGyADakkNAyAFQQAgBiADQSdqSxsNAiAEEFsLIAEoAqACIgNBgICAgHhyQYCAgIB4RwRAIAEoAqQCIgRBBGsoAgAiBUF4cSIGQQRBCCAFQQNxIgUbIANqSQ0DIAVBACAGIANBJ2pLGw0CIAQQWwsgAUEIahBIIgVBvMnAAEEIEIADIgNB96XCAEH0pcIAIBFBAXEbQQMQgAMiBBCXA0HoyMIALQAABEBB6MjCAEEAOgAAQezIwgAoAgAhAEHsyMIAQQA2AgAgASAANgK4AkGojcIAQSsgAUG4AmpBlLrAAEHEycAAEJMCAAtB7MjCAEEANgIAQejIwgBBADoAACAEQYQBTwRAIAQQtQILIANBhAFPBEAgAxC1AgsgAkEEaygCACIDQXhxQbQBQbgBIANBA3EiBBtJDQIgBEEAIANB2AFPGw0AIAIQWyAAIAU2AgQgAEEANgIAIAFBsAhqJAAPCwtBmKnCAEEuQcipwgAQxAIAC0HYqMIAQS5BiKnCABDEAgAL3Q0CF38BeyABQeTRAGohEiABQYAEaiETIAFBgM8AaiEUIAFBgB1qIRUgAUGg0QBqIRYgAUGANmohFyABQe3RAGohGCMAQfAAayIIQTBqIRkgAS0A61EhBCAIQRhqIRECfwNAAkACQAJAAkACQAJAIARB/wFxIgsOAwABAgMLIBH9DAAAAAAAAAAAAAAAAAAAAAAiGv0LAwAgCCAa/QsDCEEAIQUgCEEsakEAQcQA/AsAA0AgASAFaiIDQbAEav0MHgMeAx4DHgMeAx4DHgMeAyIa/QsCACADQaAEaiAa/QsCACADQZAEaiAa/QsCACADQYAEaiAa/QsCACAFQUBrIgVBgBBHDQALQaACIQQgEyEMIBQhDwwDCyAR/QwAAAAAAAAAAAAAAAAAAAAAIhr9CwMAIAggGv0LAwhBACEFIAhBLGpBAEHEAPwLAANAIAEgBWoiA0GwHWr9DB4DHgMeAx4DHgMeAx4DHgMiGv0LAgAgA0GgHWogGv0LAgAgA0GQHWogGv0LAgAgA0GAHWogGv0LAgAgBUFAayIFQYAQRw0AC0EgIQQgFSEMIBYhDwwCCyAR/QwAAAAAAAAAAAAAAAAAAAAAIhr9CwMAIAggGv0LAwhBACEFIAhBLGpBAEHEAPwLAANAIAEgBWoiA0GwNmr9DB4DHgMeAx4DHgMeAx4DHgMiGv0LAgAgA0GgNmogGv0LAgAgA0GQNmogGv0LAgAgA0GANmogGv0LAgAgBUFAayIFQYAQRw0AC0ETIQQgFyEMIBghDwwCC0EDDAMLIAxBgBBqQQBBgAn8CwALQRwhCUEDIBIgC0EBdGovAQAiECAESw0BGiAQBEAgECEFIA8hBANAQQMgBC0AACIDQQ9LDQMaIAhBCGogA0EBdGoiAyADLwEAQQFqOwEAIARBAWohBCAFQQFrIgUNAAsLQQAhBEEBIQNBACEFQQAhCgNAAkACfyADRQRAIARBD0sNAiAEQQFqDAELIARBECAEayIGIAMgAyAGSxsiBiAEaiIHIAQgB0sbIgRBD0sNASAGIANrIQYDQCAGBEAgBkEBaiEGIARBAWoiBEEQRw0BDAMLC0EAIQMgBEEBagsgGSAEQQJ0aiAFIAhBCGogBEEBdGovAQAiBGpBAXQiBTYCACAEIApqIQohBAwBCwsgBUGAgARHBEBBASALQQJGIApB//8DcUEBS3INAhoLIAxBgBBqIQ1B//8DIQlBACEKA0AgCiAQSQRAIApBAWohBANAIAohCyAEIQoCQCALIA9qLQAAIgRBD3EiB0UNACAIQSxqIAdBAnRqIgMgAygCACIDQQFqNgIAAn8gA0F/QQAgB2t2cSIDQYAETwRAIANBCHQgA0GA/gNxQQh2ciIDQQR2QY8ecSADQY8ecUEEdHIiA0ECdkGz5gBxIANBs+YAcUECdHIiA0EBdkHVqgFxIANB1aoBcUEBdHIMAQsgA0EBdEHQ8MEAai8BAAtB//8DcUEAIARrQQ9xdiEFIAdBCk0EQCAFQf8HSw0BIAdBCXQgC3IhA0EBIAd0IgZBAXQhCyAMIAVBAXRqIQQDQCAEIAM7AQAgBCALaiEEIAUgBmoiBUGACEkNAAsMAQsgDCAFQf8HcUEBdGoiAy8BACIGQZ4GRwR/IAkFIAMgCTsBACAJIgZBAmsLIQMCQCAHQQtGBEAgBUEJdiEODAELQQohCUEDIAVBCnYiDkEBcSAGQX9zakH//wNxIgRBvwRLDQYaIA0gBEEBdGoiBC8BACIGBH8gAwUgBCADOwEAIAMhBiADQQJrCyEEIAdBDUkEQCAEIQMMAQtBAyAFQQt2Ig5BAXEgBkF/c2pB//8DcSIDQb8ESw0GGiANIANBAXRqIgMvAQAiBgR/IAQFIAMgBDsBACAEIQYgBEECawshAyAHQQ1GDQBBAyAFQQx2Ig5BAXEgBkF/c2pB//8DcSIEQb8ESw0GGiANIARBAXRqIgQvAQAiBgR/IAMFIAQgAzsBACADIQYgA0ECawshBCAHQQ9HBEAgBCEDDAELQQMgBUENdiIOQQFxIAZBf3NqQf//A3EiA0G/BEsNBhogDSADQQF0aiIDLwEAIgYEQCAEIQMMAQsgAyAEOwEAIARBAmshAyAEIQYLIA5BAXZBAXEgBkF/c2pB//8DcSIEQb8ESwRAQQohCUEDDAYLIA0gBEEBdGogCzsBACADIQkMAwsgCiAKIBBJIgNqIQQgAw0ACwsLAkACQAJAIAEtAOtRIgMOAwABAgELIAJBADYCDEEMIQlBAQwDCyABIANBAWsiBDoA61EMAQsLIAJBADYCDEEKIQlBAQshBCAAIAk6AAEgACAEOgAAC88OAg59CH8gAkECdCIVIAAoAigiF0sEQCAVIBciFGsiEyAAKAIgIBRrSwRAIABBIGogFCATQQRBBBDZASAAKAIoIRQLIAAoAiQiGCAUQQJ0aiEWIBNBAk8EfyAVIBdBf3NqQQJ0IhcEQCAWQQAgF/wLAAsgEyAUaiIWQQFrIRQgGCAWQQJ0akEEawUgFgtBADYCACAUQQFqIRULIAAgFTYCKAJAAkACQAJAAkACQCAAKAIIQQFHDQAgACgCJCEXIAIEQEMAAH5DIAAqAmAiBiAAKgJcIgiTlSEHIAggBpJDAAAAP5QhBiACQTxsIRogFyEWQQAhFEEPIRgDQCAEIBhJDQNDAAD+QkMAAP7CIAcgAyAZaiITQTBqKgIAIAaTlCIIIAhDAAD+wl0bIgggCEMAAP5CXhsQrQIhCEMAAP5CQwAA/sIgByATQTRqKgIAIAaTlCIJIAlDAAD+wl0bIgkgCUMAAP5CXhsQrQIhCUMAAP5CQwAA/sIgByATQThqKgIAIAaTlCIKIApDAAD+wl0bIgogCkMAAP5CXhsQrQIhCkMAAP5CQwAA/sIgByATQSBqKgIAIAaTlCILIAtDAAD+wl0bIgsgC0MAAP5CXhsQrQIhC0MAAP5CQwAA/sIgByATQSRqKgIAIAaTlCIMIAxDAAD+wl0bIgwgDEMAAP5CXhsQrQIhDEMAAP5CQwAA/sIgByATQShqKgIAIAaTlCINIA1DAAD+wl0bIg0gDUMAAP5CXhsQrQIhDUMAAP5CQwAA/sIgByATQSxqKgIAIAaTlCIOIA5DAAD+wl0bIg4gDkMAAP5CXhsQrQIhDkMAAP5CQwAA/sIgByATQRBqKgIAIAaTlCIPIA9DAAD+wl0bIg8gD0MAAP5CXhsQrQIhD0MAAP5CQwAA/sIgByATQRRqKgIAIAaTlCIQIBBDAAD+wl0bIhAgEEMAAP5CXhsQrQIhEEMAAP5CQwAA/sIgByATQRhqKgIAIAaTlCIRIBFDAAD+wl0bIhEgEUMAAP5CXhsQrQIhEUMAAP5CQwAA/sIgByATQRxqKgIAIAaTlCISIBJDAAD+wl0bIhIgEkMAAP5CXhsQrQIhEiAUIBVPDQQgFkH/AEMAAP5CQwAA/sIgByATKgIAIAaTlCIFIAVDAAD+wl0bIgUgBUMAAP5CXhsQrQIiBfwAQYB/IAVDAAAAw2AbIAVDAAD+Ql4bQQAgBSAFWxtB/wFxQf8AQwAA/kJDAAD+wiAHIBNBBGoqAgAgBpOUIgUgBUMAAP7CXRsiBSAFQwAA/kJeGxCtAiIF/ABBgH8gBUMAAADDYBsgBUMAAP5CXhtBACAFIAVbG0H/AXFBCHRyQf8AQwAA/kJDAAD+wiAHIBNBCGoqAgAgBpOUIgUgBUMAAP7CXRsiBSAFQwAA/kJeGxCtAiIF/ABBgH8gBUMAAADDYBsgBUMAAP5CXhtBACAFIAVbG0H/AXFBEHRyQf8AQwAA/kJDAAD+wiAHIBNBDGoqAgAgBpOUIgUgBUMAAP7CXRsiBSAFQwAA/kJeGxCtAiIF/ABBgH8gBUMAAADDYBsgBUMAAP5CXhtBACAFIAVbG0EYdHI2AgAgFEEBaiITIBVPDQUgFkEEakH/ACAP/ABBgH8gD0MAAADDYBsgD0MAAP5CXhtBACAPIA9bG0H/AXFB/wAgEPwAQYB/IBBDAAAAw2AbIBBDAAD+Ql4bQQAgECAQWxtB/wFxQQh0ckH/ACAR/ABBgH8gEUMAAADDYBsgEUMAAP5CXhtBACARIBFbG0H/AXFBEHRyQf8AIBL8AEGAfyASQwAAAMNgGyASQwAA/kJeG0EAIBIgElsbQRh0cjYCACAUQQJqIhMgFU8NBiAWQQhqQf8AIAv8AEGAfyALQwAAAMNgGyALQwAA/kJeG0EAIAsgC1sbQf8BcUH/ACAM/ABBgH8gDEMAAADDYBsgDEMAAP5CXhtBACAMIAxbG0H/AXFBCHRyQf8AIA38AEGAfyANQwAAAMNgGyANQwAA/kJeG0EAIA0gDVsbQf8BcUEQdHJB/wAgDvwAQYB/IA5DAAAAw2AbIA5DAAD+Ql4bQQAgDiAOWxtBGHRyNgIAIBRBA2oiEyAVTw0HIBZBDGpB/wAgCPwAQYB/IAhDAAAAw2AbIAhDAAD+Ql4bQQAgCCAIWxtB/wFxQf8AIAn8AEGAfyAJQwAAAMNgGyAJQwAA/kJeG0EAIAkgCVsbQf8BcUEIdHJB/wAgCvwAQYB/IApDAAAAw2AbIApDAAD+Ql4bQQAgCiAKWxtB/wFxQRB0cjYCACAWQRBqIRYgFEEEaiEUIBhBD2ohGCAaIBlBPGoiGUcNAAsLIAAoAgwgAUECdCABIAJqQQJ0EPoCIgAgFyAVEIECIABBhAFJDQAgABC1AgsPCyAYIARB2KbCABCsAwALIBQgFUHopsIAEJ0CAAsgEyAVQfimwgAQnQIACyATIBVBiKfCABCdAgALIBMgFUGYp8IAEJ0CAAvOEAMHfwF+AXsjAEEwayIDJAACQAJAIAAoAgAiBkUEQCAAKAIQIgBFDQEgAEGticIAQQEQhAEhBAwCCyAAIAAoAgxBAWoiBDYCDAJAAkACQAJAAkACQAJAAkAgBEH1A08EQCAAKAIQIgFFDQEgAUGUicIAQRkQhAFFDQEMCAsCQAJAAkACQCAAKAIIIgIgACgCBCIITwRAIAAoAhAiAUUNASABQYSJwgBBEBCEAQ0MDAELQQEhBCAAIAJBAWoiBzYCCAJAAkACQAJAAkACQCACIAZqLQAAIgVByQBrDgYCAQEBCAUACwJAIAVBwgBrDgIDBAALIAVB2ABrDgIHCwALIAAoAhAiAUUNBCABQYSJwgBBEBCEAUUNBAwRCyAAIAEQQQ0QIAENBgwMCyMAQSBrIgIkAAJAAkAgACgCAEUEQCAAKAIQIgFFDQEgAUGticIAQQEQhAEhAQwCCyACIAAQ/QEgAigCAEUEQCAAKAIQIgUEQEEBIQEgBUGUicIAQYSJwgAgAi0ABEEBcSIFG0EZQRAgBRsQhAENAwsgACAC/QACAP0LAgAMAQsgACgCEEUNACAA/QACACEKIAAgAv0AAgD9CwIAIAIgCv0LAxAgACABQQFxEEEhASAAIAL9AAMQ/QsCAAwBC0EAIQELIAJBIGokACABRQ0MDA8LIANBIGogAEHzABD8ASADLQAgQQFGBEAgAy0AISEBIAAoAhAiAgRAIAJBlInCAEGEicIAIAFBAXEiAhtBGUEQIAIbEIQBDRALIAAgAToABAwKCyAAKAIARQRAIAAoAhAiAEUNDiAAQa2JwgBBARCEASEEDA8LIAMpAyghCSADQSBqIAAQdiADKAIgRQRAIAMtACQhASAAKAIQIgIEQCACQZSJwgBBhInCACABQQFxIgIbQRlBECACGxCEAQ0QCyAAIAE6AAQMCgsgAyAD/QACIP0LAwAgACgCECIBRQ0LIAMgARBRDQwgACgCECIBRSAJUHINCyABKAIIQYCAgARxDQsgASgCAEG3icIAQQEgASgCBCgCDBEAAA0OIAAoAhAjAEGAAWsiAiQAQYEBIQEDQCABIAJqQQJrIAmnQQ9xIgVBMHIgBUHXAGogBUEKSRs6AAAgAUEBayEBIAlCD1YgCUIEiCEJDQALQQFBm4rCAEECIAEgAmpBAWtBgQEgAWsQjgEgAkGAAWokAA0OIAAoAhAiASgCAEG4icIAQQEgASgCBCgCDBEAAA0ODAsLIAcgCEkEQCAAIAJBAmo2AgggBiAHai0AACICQcEAa0H/AXFBGkkNAiACQeEAa0GAgMQAIQJB/wFxQRpJDQILIAAoAhAiAUUNACABQYSJwgBBEBCEAQ0LC0EAIQQgAEEAOgAEIABBADYCAAwMC0EBIQQgACABEEENCwJAIAAoAgANACAAKAIQIgFFDQsgAUGQg8IAQQIQhAENDCAAKAIADQBBACEEIAAoAhAiAEUNDCAAQa2JwgBBARCEASEEDAwLIANBIGogAEHzABD8ASADLQAgQQFGBEAgAy0AISEBIAAoAhAiAgRAIAJBlInCAEGEicIAIAFBAXEiAhtBGUEQIAIbEIQBDQ0LIAAgAToABAwHCyAAKAIARQRAIAAoAhAiAEUNCyAAQa2JwgBBARCEASEEDAwLIAMpAyghCSADQSBqIAAQdiADKAIgRQRAIAMtACQhASAAKAIQIgIEQCACQZSJwgBBhInCACABQQFxIgIbQRlBECACGxCEAQ0NCyAAIAE6AAQMBwsgAyAD/QACIP0LAxACQAJAAkAgAkGAgMQARwRAIAAoAhAiAQRAIAFBuYnCAEEDEIQBDQ4LIAJBwwBGDQEgAkHTAEYNAiAAKAIQIgFFDQMgAiABENcBDQ0MAwsgAygCFCADKAIcckUNCyAAKAIQIgFFDQsgAUGQg8IAQQIQhAENDiAAKAIQIgFFDQsgA0EQaiABEFFFDQsMDgsgACgCECIBRQ0BIAFBvInCAEEHEIQBDQsMAQsgACgCECIBRQ0AIAFBw4nCAEEEEIQBDQoLIAAoAhAhAiADKAIUIAMoAhxyRQ0FIAJFDQggAkG8qMIAQQEQhAENCyAAKAIQIgFFDQggA0EQaiABEFENCyAAKAIQIQIMBQsgA0EgaiAAQfMAEPwBIAMtACBBAUcNAiADLQAhIQEgACgCECICBEAgAkGUicIAQYSJwgAgAUEBcSICG0EZQRAgAhsQhAENCwsgACABOgAEDAULIAAoAhAiAUUNBSABQZCDwgBBAhCEAUUNBQwJCyAAQQE6AAQMAwsjAEEQayIBJAAgACgCECECIABBADYCECAAQQAQQQRAQaiFwgBBPSABQQ9qQZiFwgBB9IjCABCTAgALIAAgAjYCECABQRBqJAALIAAoAhAiAQRAIAFBi4TCAEEBEIQBDQcLIAAQUw0EIAVBzQBHBEAgACgCECIBBEAgAUHIicIAQQQQhAENBgsgAEEAEEENBwsgACgCECIBRQ0DIAFBioTCAEEBEIQBRQ0DDAYLIAJFDQIgAkHHicIAQQEQhAENBSAAKAIQIgJFDQIjAEEgayIBJAAgASAJIAFBDGoQuwEgAkEBQQFBACABKAIAIAEoAgQQjgEgAUEgaiQADQUgACgCECIBRQ0CIAFBoobCAEEBEIQBRQ0CDAULQQAhBCAAQQA2AgAMBAsgACgCECIBBEAgAUGLhMIAQQEQhAENBAsgABDBAUEBcQ0DIAAoAhAiAUUNACABQYqEwgBBARCEAQ0DC0EAIQQgACgCAEUNAiAAIAAoAgxBAWs2AgwMAgtBASEEDAELQQAhBAsgA0EwaiQAIAQLpAwCEn4IfyMAQeAAayIVJAACQAJ/AkACQAJAAkACQAJAAkAgASkDACIDUEUEQCABKQMIIgRQDQEgASkDECIFUA0CIAMgBXwiBSADVA0DIAMgBFQNBCAFQoCAgICAgICAIFoNBSAVIAEvARgiATsBOCAVIAMgBH0iBzcDMCAVIAcgBXkiBIYiCCAEiCIGNwNAIAYgB1INCSAVIAE7ATggFSADNwMwIBUgAyAEQj+DIgeGIgYgB4giBzcDQCADIAdSDQlBoH8gASAEp2siF2vBQdAAbEGwpwVqQc4QbSIBQdEATw0GIBVBIGogAUEEdCIBQeDmwABqKQMAIgMgBSAEhhCSAiAVQRBqIAMgCBCSAiAVIAMgBhCSAkIBQQAgFyABQejmwABqLwEAamtBP3GtIgaGIghCAX0hCiAVKQMQQj+HIQwgFSkDAEI/iCEOIBUpAwghDyABQermwABqLwEAIRcgFSkDGCEQIBUpAygiEyAVKQMgQj+IIhR8IhFCAXwiCSAGiKciFkGQzgBPBEAgFkHAhD1JDQggFkGAwtcvTwRAQQhBCSAWQYCU69wDSSIBGyEZQYDC1y9BgJTr3AMgARsMCgtBBkEHIBZBgK3iBEkiARshGUHAhD1BgK3iBCABGwwJCyAWQeQATwRAQQJBAyAWQegHSSIBGyEZQeQAQegHIAEbDAkLQQpBASAWQQlLIhkbDAgLQbTjwABBHEGA8cAAEMQCAAtB4OPAAEEdQZDxwAAQxAIAC0GQ5MAAQRxBoPHAABDEAgALQbTlwABBNkGg8sAAEMQCAAtB7OTAAEE3QZDywAAQxAIAC0Gw8cAAQS1B4PHAABDEAgALIAFB0QBB8PDAABCdAgALQQRBBSAWQaCNBkkiARshGUGQzgBBoI0GIAEbCyEBIAkgCoMhBCAOIA98IQsgGSAXa0EBaiEbIAwgEH0gCXxCAXwiDSAKgyEFAkACQAJAAkACQAJAAkACQANAIAIgGGogFiABbiIcQTBqIho6AAAgGEEBaiEXAkAgFiABIBxsayIWrSAGhiISIAR8IgMgDVoEQCAYIBlHDQEgFyEBQgEhAwNAIAMhByABQRFGDQUgASACaiAEQgp+IgQgBoinQTBqIhg6AAAgAUEBaiEBIANCCn4hAyAFQgp+IgUgBCAKgyIEWA0ACyADIAkgC31+IgkgA3whBiAFIAR9IAhUIhYNByAEIAkgA30iCVQNAwwHCyANIAN9IgUgAa0gBoYiB1QhASAJIAt9IgZCAXwhCCAFIAdUIAMgBkIBfSIJWnINBCACIBdqQQFrIRggDCARfCAQfSAEIAd8IgQgEnx9QgJ8IQogESALfSADfSELIAQgDnwgD3wgFH0gE30gEnwhBkIAIQQDQCADIAd8IgUgCVQgBCALfCAGWnJFBEBBACEBDAYLIBggGkEBayIaOgAAIAQgCnwiDCAHVCEBIAUgCVoNBiAGIAd8IQYgBCAHfSEEIAUhAyAHIAxYDQALDAULIAFBCkkgFyEYIAFBCm4hAUUNAAtB8PHAABDOAgALIAEgAmpBAWshFyAFIAh9IQsgCCAJfSENQgAgBH0hCgNAIAQgCHwiAyAJVCAJIAp8IAQgDXxackUEQEEAIRYMBQsgFyAYQQFrIhg6AAAgCiALfCIMIAhUIRYgAyAJWg0FIAogCH0hCiADIQQgCCAMWA0ACwwEC0ERQRFBgPLAABCdAgALIAMhBQsCQCAFIAhaIAFyDQAgCCAFIAd8IgNYIAggBX0gAyAIfVRxDQAgAEEANgIADAQLIAUgDUIEfVggBUICWnFFBEAgAEEANgIADAQLIAAgGzsBCCAAIBc2AgQMAgsgBCEDCwJAIAMgBlogFnINACAGIAMgCHwiBFggBiADfSAEIAZ9VHENACAAQQA2AgAMAgsgAyAHQlh+IAV8WCADIAdCFH5acUUEQCAAQQA2AgAMAgsgACAbOwEIIAAgATYCBAsgACACNgIACyAVQeAAaiQADwsgFUEANgJIIwBBEGsiACQAIAAgFUEwajYCDCAAIBVBQGs2AgggAEEIakHM98AAIABBDGpBzPfAACAVQcgAakHg4cAAEMcBAAuzGAMHfwF+AXsjAEEgayIGJAACQAJAIAAoAgAiB0UEQCAAKAIQIgBFDQEgAEGticIAQQEQhAEhBAwCCwJAAkACQAJAAkAgACgCCCIEIAAoAgQiBU8EQCAAKAIQIgFFDQEgAUGEicIAQRAQhAFFDQEMBQsgACAEQQFqIgM2AgggBCAHai0AACECIAAgACgCDEEBaiIINgIMIAhB9QNPBEAgACgCECIBBEAgAUGUicIAQRkQhAENBgsgAEEBOgAEDAILAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAkHRAGsOKQsKAQ8BEAEBAQEBAQEBAQEEBwgBCQEBAwQDAQQDBAMCAQEEAwEBAQQDAAsgAkHBAGsOAg0EAAsgACgCECIBRQ0RIAFBhInCAEEQEIQBDRUMEQsgACgCECIBRQ0TQQEhBCABQa6IwgBBARCEAUUNEwwWCyAAIAIQwgENEwwSCyADIAVPDRAgAyAHai0AAEHuAEYNAQwQCyMAQSBrIgQkAAJAAkAgACgCAEUEQCAAKAIQIgFFDQEgAUGticIAQQEQhAEhAQwCCyAEIAAQ/QEgBCgCAEUEQCAAKAIQIgIEQEEBIQEgAkGUicIAQYSJwgAgBC0ABEEBcSICG0EZQRAgAhsQhAENAwsgACAE/QACAP0LAgAMAQsgACgCEEUNACAA/QACACEKIAAgBP0AAgD9CwIAIAQgCv0LAxAgACABQQFxEEMhASAAIAT9AAMQ/QsCAAwBC0EAIQELIARBIGokACABDREMEAsgACAEQQJqNgIIIAAoAhAiAUUNDkEBIQQgAUGhhsIAQQEQhAFFDQ4MEgsgBkEYaiAAEOUBIAYoAhgiAUUEQCAGLQAcIQEgACgCECICBEBBASEEIAJBlInCAEGEicIAIAFBAXEiAhtBGUEQIAIbEIQBDRMLIAAgAToABAwNCyAGQQhqIAEgBigCHBCzAQJAAkACQCAGKAIIQQFHDQAgBikDECIJQgFWDQAgCadBAWsNAQwCCyAAKAIQIgFFDQ0gAUGEicIAQRAQhAENEQwNCyAAKAIQIgFFDQ8gAUGMisIAQQUQhAENEAwPCyAAKAIQIgFFDQ4gAUGRisIAQQQQhAENDwwOCyAGQRhqIAAQ5QEgBigCGCIBRQRAIAYtABwhASAAKAIQIgIEQEEBIQQgAkGUicIAQYSJwgAgAUEBcSICG0EZQRAgAhsQhAENEgsgACABOgAEDAwLIAZBCGogASAGKAIcELMBAkAgBigCCCAGKQMQIglCgICAgBBUcUUNAEGAgMQAIAmnIgEgAUGAsANzQYCAxABrQYCQvH9JGyIBQYCAxABGDQAgACgCECEHIwBBIGsiAyQAAn9BACAHRQ0AGgJAIAcoAgBBJyAHKAIEKAIQEQEADQADQAJ/AkACQAJAAkACQCABQSJHBEAgAUGAgMQARgRAIAcoAgBBJyAHKAIEKAIQEQEADAoLAkACQAJAAkACQAJAIAFBJkwEQCABQQlrDgUBAwYGAgULIAFBJ0YNAyABQdwARw0FIANCADcBAiADQdy4ATsBAAwLCyADQgA3AQIgA0Hc6AE7AQAMCgsgA0IANwECIANB3OQBOwEADAkLIANCADcBAiADQdzcATsBAAwICyADQgA3AQIgA0HczgA7AQAMBwsgAUUNBQsgAUH/BU0NASABELcBRQ0BDAILQYCAxAAhASAHKAIAQSIgBygCBCgCEBEBAEUNBgwHCyABEPoBDQELIANBEGogARDfASADQQhqIANBGGovAAA7AQAgAyADKQAQNwMAIAMtABshBCADLQAaDAMLIAMgATYCAEGBASEEQYABDAILIANCADcBAiADQdzgADsBAAtBAiEEQQALIANBGGogA0EIai8BADsBACADIAMpAwAiCTcDEEH/AXEiASAEQf8BcSIFIAEgBUsbIQggCachAgNAIAEgCEcEQCACIQQgBUGAAU0EQCADQRBqIAFqLQAAIQQLIAFBAWohASAHKAIAIAQgBygCBCgCEBEBAEUNAQwDCwtBgIDEACEBDAALAAtBAQsgA0EgaiQADQ8MDgsgACgCECIBRQ0KIAFBhInCAEEQEIQBDQ4MCgsCQCABDQAgACgCECICRQ0AQQEhBCACQZWKwgBBARCEAQ0QCyAAKAIQIgIEQEEBIQQgAkGNhMIAQQEQhAENEAsgABBmDQ0MCAsgAyAFTw0AIAMgB2otAABB5QBGDQELAkAgAQ0AIAAoAhAiA0UNAEEBIQQgA0GVisIAQQEQhAENDgsgACgCECIDBEBBASEEIANBjITCAEEBEIQBDQ4LIAJB0gBHDQEMBQsgACAEQQJqNgIIIAAQZg0KDAkLIAAoAhAiBEUNAyAEQc2JwgBBBBCEAQ0JDAMLAkAgAQ0AIAAoAhAiAkUNAEEBIQQgAkGVisIAQQEQhAENCwsgACgCECICBEBBASEEIAJBt4nCAEEBEIQBDQsLQQEhBCAAEIkCQQFxDQogACgCECICRQ0HIAJBuInCAEEBEIQBRQ0DDAoLAkAgAQ0AIAAoAhAiAkUNAEEBIQQgAkGVisIAQQEQhAENCgsgACgCECICBEBBASEEIAJBiYTCAEEBEIQBDQoLQQAhBAJ/AkAgACgCACICRQ0AA0ACQCAAKAIIIgMgACgCBE8NACACIANqLQAAQcUARw0AIAAgA0EBajYCCAwCCwJAIARFDQAgACgCECICRQ0AIAJBtYnCAEECEIQBRQ0AQQEMAwtBASAAQQEQQw0CGiAEQQFqIQQgACgCACICDQALC0EACyECIAYgBDYCBCAGIAI2AgBBASEEIAYoAgBBAXENCSAGKAIEQQFGBEAgACgCECICRQ0HIAJBiITCAEEBEIQBDQoLIAAoAhAiAkUNBiACQdq4wgBBARCEAUUNAgwJCwJAIAENACAAKAIQIgJFDQBBASEEIAJBlYrCAEEBEIQBDQkLQQEhBCAAQQEQQQ0IIAAoAgAiA0UEQCAAKAIQIgBFDQggAEGticIAQQEQhAEhBAwJCyAAKAIIIgIgACgCBE8EQCAAKAIQIgFFDQMgAUGEicIAQRAQhAFFDQMMCQsgACACQQFqNgIIAkACQAJAIAIgA2otAABB0wBrDgMCAQQACyAAKAIQIgFFDQQgAUGEicIAQRAQhAENCAwECyAAKAIQIgIEQCACQYmEwgBBARCEAQ0KCyAAEIkCQQFxDQkgACgCECICRQ0GIAJB2rjCAEEBEIQBRQ0CDAkLIAAoAhAiBARAIARBlorCAEEDEIQBDQcLQQEhBEEAIQcjAEEgayICJAACQAJAAkAgACgCACIDRQ0AA0ACQCAAKAIIIgUgACgCBE8NACADIAVqLQAAQcUARw0AIAAgBUEBajYCCAwCCwJAAkAgB0UNACAAKAIQIgNFDQAgA0G1icIAQQIQhAENBCAAKAIADQAgACgCECIFRQ0BQQEhAyAFQa2JwgBBARCEAUUNAQwFCyACIABB8wAQ/AEgAi0AAEEBRgRAIAItAAEhAyAAKAIQIgUEQCAFQZSJwgBBhInCACADQQFxIgUbQRlBECAFGxCEAQ0FCyAAIAM6AAQgAEEANgIADAELIAAoAgBFBEAgACgCECIFRQ0BQQEhAyAFQa2JwgBBARCEAUUNAQwFCyACIAAQdiACKAIARQRAIAItAAQhAyAAKAIQIgUEQCAFQZSJwgBBhInCACADQQFxIgUbQRlBECAFGxCEAQ0FCyAAIAM6AAQgAEEANgIADAELIAIgAv0AAgD9CwMQAkAgACgCECIDRQ0AIAJBEGogAxBRDQQgACgCECIDRQ0AIANBqqjCAEECEIQBDQQLQQEhAyAAQQEQQw0ECyAHQQFrIQcgACgCACIDDQALC0EAIQMMAQtBASEDCyACQSBqJAAgA0EBcQ0IIAAoAhAiAkUNBSACQZmKwgBBAhCEAUUNAQwIC0EBIQQgAEEBEEMNBwsgAQ0DIAAoAhAiAUUNA0EBIQQgAUGihsIAQQEQhAFFDQMMBgtBACEEIABBADoABCAAQQA2AgAMBQtBACEEIABBADYCAAwECyAAIAIQwgENAQtBACEEIAAoAgBFDQIgACAAKAIMQQFrNgIMDAILQQEhBAwBC0EAIQQLIAZBIGokACAEC4gLAxR/An4BeyMAQdACayIRJAAgAa0iGkL//////////z98IBqAIRoCfyABQYEgTwRAQQFBICABQQFyZ2tBAXYiBnQgASAGdmpBAXYMAQtBwAAgASABQQF2ayIGIAZBwABPGwshEiAAQQRrIRYgAEEQayEXIABBCGohFEEBIQgDQEEBIQtBACEPIAEgDUsEQCAAIA1BAnQiEGohCiANrSIbAn8CQCABIA1rIgcgEkkNAAJAIAdBAkkEQCAHIQsMAQsCQAJAAkACQAJAIAUoAgBBBGoiDygCACAKKAIEIgYgCigCABCKASITRQRAQQIhCyAHQQJGDQYgFCANQQJ0aiEMA0AgDygCACAMKAIAIg4gBhCKAQ0DIAxBBGohDCAOIQYgByALQQFqIgtHDQALDAELIAdBAkYNAkECIQsgFCANQQJ0aiEMA0AgDygCACAMKAIAIg4gBhCKAUUNAiAMQQRqIQwgDiEGIAcgC0EBaiILRw0ACwsgByELCyALIBJJDQQgE0UNAyALQQJPDQFBASELDAMLIApBCGohD0EAIQxBASEOQQIhCwwBCyAKIAtBAnQiBmohD0EAIQwgC0EBdiIOQQRJDQAgFyAGIBBqaiEHIA5B/P///wdxIgwhBgNAIAogB/0AAgAgCv0AAgAiHP0NDA0ODwgJCgsEBQYHAAECA/0LAgAgByAcIBz9DQwNDg8ICQoLBAUGBwABAgP9CwIAIApBEGohCiAHQRBrIQcgBkEEayIGDQALIAwgDkYNAQsgACAMQQJ0IgYgEGpqIQcgDiAMayEMIA8gBmtBBGshBgNAIAcoAgAhDiAHIAYoAgA2AgAgBiAONgIAIAZBBGshBiAHQQRqIQcgDEEBayIMDQALCyALQQF0QQFyDAELIAcgEiAHIBJJG0EBdCAERQ0AGiAKQSAgByAHQSBPGyIGIAIgA0EAQQAgBRA1IAZBAXRBAXILIgtBAXYgDWqtfCAafiANIAhBAXZrrSAbfCAafoV5pyEPCwJAAkAgCUECSQ0AIBYgDUECdCIGaiEMIAAgBmohGANAIAlBAWsiDiARQY4CamotAAAgD0kNAQJ/AkACQAJAIAMgEUEEaiAOQQJ0aigCACIJQQF2IgYgCEEBdiIKaiIQTyAIIAlyQQFxRXFFBEAgACANIBBrQQJ0aiEHIAlBAXFFBEAgByAGIAIgAyAGQQFyZ0EBdEE+c0EAIAUQNQsgCEEBcUUEQCAHIAZBAnRqIAogAiADIApBAXJnQQF0QT5zQQAgBRA1CyAIQQJJIAlBAklyDQMgAyAKIAYgBiAKSyIZGyITSQ0DIAUoAgAhFSAHIAZBAnRqIQggE0ECdCIJBEAgAiAIIAcgGRsgCfwKAAALIAIgCWohCSAGIApLBEAgDCEGA0AgBiAIQQRrIgggCUEEayIJIBVBBGooAgAgCSgCACAIKAIAEIoBIgobKAIANgIAIAkgCkECdGohCSAIIApBAXNBAnRqIgggB0YNAyAGQQRrIQYgAiAJRw0ACwwCCyATRQRAIAIhBgwDCyACIQYDQCAHIAggBiAVQQRqKAIAIAgoAgAgBigCABCKASIKGygCADYCACAHQQRqIQcgBiAKQQFzQQJ0aiIGIAlGDQMgCCAKQQJ0aiIIIBhHDQALDAILIBBBAXQMAwsgCCEHIAIhBgsgCSAGayIIRQ0AIAcgBiAI/AoAAAsgEEEBdEEBcgshCEEBIQcgDiIJQQFLDQALDAELIAkhBwsgEUGOAmogB2ogDzoAACARQQRqIAdBAnRqIAg2AgAgASANSwRAIAdBAWohCSALQQF2IA1qIQ0gCyEIDAELCyAIQQFxRQRAIAAgASACIAMgAUEBcmdBAXRBPnNBACAFEDULIBFB0AJqJAAL3gsDCX8BewJ+IwBBMGsiBiQAIAAgASgCBCICNgI8AkAgASgCACIEIAAoAggiB00EQCAAIAQ2AggMAQsgBCAHIgVrIgMgACgCACAFa0sEQCAAIAUgA0EQQTAQ3gEgACgCCCEFCyAAKAIEIQggA0EBcQRAIAZBHmpCADcBACAGQRBq/QwAAAAAAAAAAAAAAAAAAAAA/QsEACAIIAVBMGxqIgIgC/0LBAAgAkEQakIANwMAIAJBGGogBkEYaikDADcDACACQSBqIAZBIGopAwA3AwAgAkEoaiAGQShqKQMANwMAIAYgC/0LBAAgA0EBayEDIAVBAWohBQsgB0EBaiAERwRAIAggBUEwbGohAiAGQR5qIQggBkEQaiEHA0AgCEIANwEAIAf9DAAAAAAAAAAAAAAAAAAAAAD9CwQAIAZBIGoiCSkDACEMIAZBGGopAwAhDSAIQgA3AQAgByAL/QsEACACQgA3AwAgAkEIaiAL/QsDACACQTBqIAv9CwQAIAJBKGogBkEoaikDADcDACACQRhqIA03AwAgAkEgaiAMNwMAIAJB0ABqIAn9AAQA/QsEACACQUBrIAf9AAQA/QsEACAGIAv9CwQAIAJB4ABqIQIgBUECaiEFIANBAmsiAw0ACwsgACAFNgIIIAAoAjwhAgsgAEEANgIgAkACfwJAAkAgAkUEQCAAQQA2AiwMAQsgBARAQQAhAyAAKAIYIARJBEAgAEEYakEAIARBAkESEN4BIAAoAiAhAyAAKAI8IQILIARBEmwiBQRAIAAoAhwgA0ESbGpBACAF/AsACyAAQQA2AiwgACADIARqNgIgIAJBAU0NAUEAIQMgACgCJCAESQRAIABBJGpBACAEQQJBHhDeASAAKAIsIQMgACgCPCECCyAEQR5sIgUEQCAAKAIoIANBHmxqQQAgBfwLAAsgAEEANgI4IAAgAyAEajYCLCACQQJNDQRBACEDIAAoAjAgBEkEQCAAQTBqQQAgBEECQSoQ3gEgACgCOCEDCyAEQSpsIgUEQCAAKAI0IANBKmxqQQAgBfwLAAsgAyAEaiEDIABBOGoMAwtBACEDIABBADYCLCACQQFHDQELIABBADYCOAwCCyAAQQA2AjggAkECTQ0BIABBOGoLIAM2AgALIAAoAhQhAyAAQQA2AhQgACgCECEHAkACQCADBEAgByECA0AgAkHEAGooAgAiBUEJTwRAIAJBKGooAgAiCEEEaygCACIJQXhxIgogBUECdCIFQQRBCCAJQQNxIgkbakkNAyAJQQAgCiAFQSdqSxsNBCAIEFsLIAJB0ABqIQIgA0EBayIDDQALCwJAIAEtAAhFDQAgBEUEQCAAQQA2AhQMAQtBACEDIAAoAgwgBEkEQCAAQQxqQQAgBEEQQdAAEN4BIAAoAhQhAyAAKAIQIQcLIARBAXEEfyAGQRBqQgA3AwAgByADQdAAbGoiAUIANwMAIAFBADsBTCABQgA3AkQgAUEANgIgIAFBCGr9DAAAAAAAAAAAAAAAAAAAAAD9CwMAIAFBGGogBkEYaikDADcDACAGIAv9CwQAIANBAWohAyAEQQFrBSAECyEFIARBAUcEQCAHIANB0ABsaiECA0AgBkEQaiIBQgA3AwAgBv0MAAAAAAAAAAAAAAAAAAAAAP0LBAAgAkEQakIANwMAIAJCADcDACAGQRhqIgQpAwAhDCACQcwAakEAOwEAIAJBxABqQgA3AgAgAkEgakEANgIAIAJBCGpCADcDACACQRhqIAw3AwAgAUIANwMAIAYgC/0LBAAgBCkDACEMIAJB8ABqQQA2AgAgAkHoAGogDDcDACACQeAAakIANwMAIAJBnAFqQQA7AQAgAkHYAGpCADcDACACQZQBakIANwIAIAJB0ABqQgA3AwAgAkGgAWohAiADQQJqIQMgBUECayIFDQALCyAAIAM2AhQLIAZBMGokAA8LQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIAC8wKAwp/AX4Ce0EBIQ1BASEIAkACQAJAAkACQAJAAkACQAJAIARBAUcEQEEBIQVBASEHA0AgBiAKaiIIIARPDQIgByEJAkAgAyAFai0AACIFIAMgCGotAAAiCEkEQCAGIAdqQQFqIgcgCmshDUEAIQYMAQsgBSAIRwRAQQEhDSAJQQFqIQdBACEGIAkhCgwBC0EAIAZBAWoiByAHIA1GIgUbIQYgB0EAIAUbIAlqIQcLIAYgB2oiBSAESQ0AC0EBIQVBASEHQQAhBkEBIQgDQCAGIAtqIgwgBE8NAyAHIQkCQCADIAVqLQAAIgUgAyAMai0AACIMSwRAIAYgB2pBAWoiByALayEIQQAhBgwBCyAFIAxHBEBBASEIIAlBAWohB0EAIQYgCSELDAELQQAgBkEBaiIHIAcgCEYiBRshBiAHQQAgBRsgCWohBwsgBiAHaiIFIARJDQALCyAEIAogCyAKIAtLIgcbIgtJDQIgDSAIIAcbIgcgC2oiBSAHSQ0DIAQgBUkNBAJ/IAMgAyAHaiALELoCBEACfkIBIAMxAACGIg8gBEEBRg0AGkIBIAMxAAGGIA+EIg8gBEECRg0AGkIBIAMxAAKGIA+EIg8gBEEDRg0AGkIBIAMxAAOGIA+EIg8gBEEERg0AGkIBIAMxAASGIA+EIg8gBEEFRg0AGkIBIAMxAAWGIA+ECyEPIAQgC2siByALIAcgC0sbQQFqIQdBfyEGIAshCkF/DAELQQEhCkEAIQZBASEFQQAhDQNAIAQgBSIJIAZqIgxLBEAgBCAGayAFQX9zaiIFIARPDQggBCAGQX9zaiANayIIIARPDQkCQCADIAVqLQAAIgUgAyAIai0AACIISQRAIAxBAWoiBSANayEKQQAhBgwBCyAFIAhHBEAgCUEBaiEFQQAhBkEBIQogCSENDAELQQAgBkEBaiIFIAUgCkYiCBshBiAFQQAgCBsgCWohBQsgByAKRw0BCwtBASEKQQAhBkEBIQVBACEIA0AgBCAFIgkgBmoiDksEQCAEIAZrIAVBf3NqIgUgBE8NCiAEIAZBf3NqIAhrIgwgBE8NCwJAIAMgBWotAAAiBSADIAxqLQAAIgxLBEAgDkEBaiIFIAhrIQpBACEGDAELIAUgDEcEQCAJQQFqIQVBACEGQQEhCiAJIQgMAQtBACAGQQFqIgUgBSAKRiIMGyEGIAVBACAMGyAJaiEFCyAHIApHDQELCyAEIAggDSAIIA1LG2shCkEAIQYCfwJAAkACQAJAIAcOAgACAQsgBwwDCyAHQX5xIgYhBSADIQkDQEIBIAkvAAD9EP0MPz8/Pz8/Pz8/Pz8/Pz8/P/1O/YkB/akB/ckBIhH9HQCG/RJCASAR/R0Bhv0eASAQ/VAhECAJQQJqIQkgBUECayIFDQALIBAgECAQ/Q0ICQoLDA0ODwABAgMEBQYH/VD9HQAhDyAGIAdGDQELA0BCASADIAZqMQAAhiAPhCEPIAcgBkEBaiIGRw0ACwtBAAshBiAECyEJIAAgBDYCPCAAIAM2AjggACACNgI0IAAgATYCMCAAIAk2AiggACAGNgIkIAAgAjYCICAAQQA2AhwgACAHNgIYIAAgCjYCFCAAIAs2AhAgACAPNwMIIABBATYCAA8LIAggBEGkgcEAEJ0CAAsgDCAEQaSBwQAQnQIACyALIARBhIHBABCsAwALIAcgBUGUgcEAEK0DAAsgBSAEQZSBwQAQrAMACyAFIARBtIHBABCdAgALIAggBEHEgcEAEJ0CAAsgBSAEQbSBwQAQnQIACyAMIARBxIHBABCdAgAL4wkBBn8gAUEDbCIEIAAoApAEIgJLBEAgBCACayIFIAAoAogEIAJrSwRAIABBiARqIAIgBUEEQQQQ3gEgACgCkAQhAgsgACgCjAQiBiACQQJ0aiEDIAVBAk8EfyAFQQJ0QQRrIgcEQCADQQAgB/wLAAsgAiAFaiIDQQFrIQIgBiADQQJ0akEEawUgAwtBADYCACAAIAJBAWo2ApAECyAAKAKcBCICIAFJBEAgASACayIFIAAoApQEIAJrSwRAIABBlARqIAIgBUEEQQQQ3gEgACgCnAQhAgsgACgCmAQiBiACQQJ0aiEDIAVBAk8EfyAFQQJ0QQRrIgcEQCADQQAgB/wLAAsgAiAFaiIDQQFrIQIgBiADQQJ0akEEawUgAwtBADYCACAAIAJBAWo2ApwECyAAKAKoBCICIARJBEAgBCACayIFIAAoAqAEIAJrSwRAIABBoARqIAIgBUEEQQQQ3gEgACgCqAQhAgsgACgCpAQiBiACQQJ0aiEDIAVBAk8EfyAFQQJ0QQRrIgcEQCADQQAgB/wLAAsgAiAFaiIDQQFrIQIgBiADQQJ0akEEawUgAwtBADYCACAAIAJBAWo2AqgECyAAKAK0BCICIARJBEAgBCACayIEIAAoAqwEIAJrSwRAIABBrARqIAIgBEEEQQQQ3gEgACgCtAQhAgsgACgCsAQiBSACQQJ0aiEDIARBAk8EfyAEQQJ0QQRrIgYEQCADQQAgBvwLAAsgAiAEaiIDQQFrIQIgBSADQQJ0akEEawUgAwtBADYCACAAIAJBAWo2ArQECyABQQJ0IgIgACgCwAQiBEsEQCACIARrIgIgACgCuAQgBGtLBEAgAEG4BGogBCACQQRBBBDeASAAKALABCEECyAAKAK8BCIFIARBAnRqIQMgAkECTwR/IAJBAnRBBGsiBgRAIANBACAG/AsACyACIARqIgJBAWshBCAFIAJBAnRqQQRrBSADC0EANgIAIAAgBEEBajYCwAQLAkACQCAAKAKEBCIERQ0AIAFBCWwiAyAAKALMBCICSwRAIAMgAmsiBCAAKALEBCACa0sEQCAAQcQEaiACIARBBEEEEN4BIAAoAswEIQILIAAoAsgEIgUgAkECdGohAyAEQQJPBH8gBEECdEEEayIGBEAgA0EAIAb8CwALIAIgBGoiA0EBayECIAUgA0ECdGpBBGsFIAMLQQA2AgAgACACQQFqNgLMBCAAKAKEBCEECyAEQQFNDQAgAUEPbCIDIAAoAtgEIgJLBH8gAyACayIEIAAoAtAEIAJrSwRAIABB0ARqIAIgBEEEQQQQ3gEgACgC2AQhAgsgACgC1AQiBSACQQJ0aiEDIARBAk8EfyAEQQJ0QQRrIgYEQCADQQAgBvwLAAsgAiAEaiIDQQFrIQIgBSADQQJ0akEEawUgAwtBADYCACAAIAJBAWo2AtgEIAAoAoQEBSAEC0ECTQ0AIAFBFWwiAiAAKALkBCIBSw0BCw8LIAIgAWsiAyAAKALcBCABa0sEQCAAQdwEaiABIANBBEEEEN4BIAAoAuQEIQELIAAoAuAEIgQgAUECdGohAiADQQJPBH8gA0ECdEEEayIFBEAgAkEAIAX8CwALIAEgA2oiAkEBayEBIAQgAkECdGpBBGsFIAILQQA2AgAgACABQQFqNgLkBAu9DQEFfyMAQRBrIgQkABCYAyIFQey5wABBCRCAAyIBIAAoAnC4EJIDIgIQlwMCQAJAAkACQAJAAkACQAJAQejIwgAtAABFBEBB7MjCAEEANgIAQejIwgBBADoAACACQYQBTwRAIAIQtQILIAFBhAFPBEAgARC1AgsgBUH1ucAAQQkQgAMiASAAKAJ0uBCSAyICEJcDQejIwgAtAAANAUHsyMIAQQA2AgBB6MjCAEEAOgAAIAJBhAFPBEAgAhC1AgsgAUGEAU8EQCABELUCCyAFQf65wABBCxCAAyIBIAAoAni4EJIDIgIQlwNB6MjCAC0AAA0CQezIwgBBADYCAEHoyMIAQQA6AAAgAkGEAU8EQCACELUCCyABQYQBTwRAIAEQtQILIAVBibrAAEEGEIADIgEgACgCfBCXA0HoyMIALQAADQNB7MjCAEEANgIAQejIwgBBADoAACABQYQBTwRAIAEQtQILAkAgACgCAEEBRw0AIAVBj7rAAEEDEIADIgEgACgCBBCpAyICEJcDQejIwgAtAAANBUHsyMIAQQA2AgBB6MjCAEEAOgAAIAJBhAFPBEAgAhC1AgsgAUGEAUkNACABELUCCwJAIAAoAghFDQAgBUG0usAAQQMQgAMiASAAKAIMEKkDIgIQlwNB6MjCAC0AAA0GQezIwgBBADYCAEHoyMIAQQA6AAAgAkGEAU8EQCACELUCCyABQYQBSQ0AIAEQtQILAkAgACgCEEUNACAFQci6wABBAxCAAyIBIAAoAhQQqQMiAhCXA0HoyMIALQAADQdB7MjCAEEANgIAQejIwgBBADoAACACQYQBTwRAIAIQtQILIAFBhAFJDQAgARC1AgsCQCAAKAIYRQ0AIAVB3LrAAEEHEIADIgEgACgCHBCpAyICEJcDQejIwgAtAAANCEHsyMIAQQA2AgBB6MjCAEEAOgAAIAJBhAFPBEAgAhC1AgsgAUGEAUkNACABELUCC0H0usAAQQ0QgAMhAhCYAyEBIAAqAkS7EJIDIQMgAUGYtMAAQQYQkAEgAxD7AiAAKgJIuxCSAyEDIAFBnrTAAEEGEJABIAMQ+wIgACoCTLsQkgMhAyABQaS0wABBChCQASADEPsCIAAqAlC7EJIDIQMgAUGutMAAQQoQkAEgAxD7AiAAKgJUuxCSAyEDIAFBuLTAAEEGEJABIAMQ+wIgACoCWLsQkgMhAyABQb60wABBBhCQASADEPsCIAAqAly7EJIDIQMgAUHEtMAAQQYQkAEgAxD7AiAAKgJguxCSAyEDIAFByrTAAEEGEJABIAMQ+wIgACoCZLsQkgMhAyABQdC0wABBBhCQASADEPsCIAAqAmi7EJIDIQMgAUHWtMAAQQYQkAEgAxD7AiAALQBsIQMgAUHctMAAQQoQkAFBggFBgwEgAxsQ+wIgBSACIAEQlwNB6MjCAC0AAA0IQezIwgBBADYCAEHoyMIAQQA6AAAgAUGEAU8EQCABELUCCyACQYQBTwRAIAIQtQILIAAQnwEgBEEQaiQAIAUPC0HoyMIAQQA6AABB7MjCACgCACEAQezIwgBBADYCACAEIAA2AgxBqI3CAEErIARBDGpBlLrAAEHEu8AAEJMCAAtB6MjCAEEAOgAAQezIwgAoAgAhAEHsyMIAQQA2AgAgBCAANgIMQaiNwgBBKyAEQQxqQZS6wABBtLvAABCTAgALQejIwgBBADoAAEHsyMIAKAIAIQBB7MjCAEEANgIAIAQgADYCDEGojcIAQSsgBEEMakGUusAAQaS7wAAQkwIAC0HoyMIAQQA6AABB7MjCACgCACEAQezIwgBBADYCACAEIAA2AgxBqI3CAEErIARBDGpBlLrAAEGUu8AAEJMCAAtB6MjCAEEAOgAAQezIwgAoAgAhAEHsyMIAQQA2AgAgBCAANgIMQaiNwgBBKyAEQQxqQZS6wABBpLrAABCTAgALQejIwgBBADoAAEHsyMIAKAIAIQBB7MjCAEEANgIAIAQgADYCDEGojcIAQSsgBEEMakGUusAAQbi6wAAQkwIAC0HoyMIAQQA6AABB7MjCACgCACEAQezIwgBBADYCACAEIAA2AgxBqI3CAEErIARBDGpBlLrAAEHMusAAEJMCAAtB6MjCAEEAOgAAQezIwgAoAgAhAEHsyMIAQQA2AgAgBCAANgIMQaiNwgBBKyAEQQxqQZS6wABB5LrAABCTAgALQejIwgBBADoAAEHsyMIAKAIAIQBB7MjCAEEANgIAIAQgADYCDEGojcIAQSsgBEEMakGUusAAQYS7wAAQkwIAC6Z9Ax1/CH0BfiMAQfAAayINJAACQAJAIAAtAORTRQRAIA1B0ABqIABBgAFqEK8BIA0tAFAEQCANKAJUIQEMAwsgDS0AUUEBRw0BIABBAToA5FMLIAAoAogBIgNFDQAgAEHcAWohFyANQTxqrUKAgICA4ACEISYgAEGYAWohGANAAkAgACgClAEiBCAAKALgUyICayIBQQAgASAETRtBgIAETwRAIAIhAQwBCyACIAJBgIACayIBQQAgASACTRsiBWshASACIAVGBEAgACABNgLgUwwBCyACIARNBEAgAQRAIAAoApABIgIgAiAFaiAB/AoAAAsgACgCiAEhAyAAIAE2AuBTDAELIAIgBEGIs8AAEKwDAAsCQAJAIAMgEE8EQCANQdAAaiAXIAAoAoQBIBBqIAMgEGsgACgCkAEgACgClAEgARAoIA0gDS0AVCIZOgAPIA0oAlAhFiANKAJYIhQNAQwCCyAQIANBqLPAABCuAwALAkACQAJAIAAoAuBTIgIgFGoiASACTwRAIAEgACgClAEiA0sNASAAKAKQASEDIAAoApgBIAAoAqABIgFrIBRJBEAgGCABIBRBAUEBENkBIAAoAqABIQELIBQEQCAAKAKcASABaiACIANqIBT8CgAACyAAIAEgFGoiBDYCoAEgACAAKALgUyAUajYC4FMgACgCpAFBgICAgHhGBEAgBEEPTQ0FIA0gACgCnAEiASgAACICNgIcIAJBzo7NggVHDQMgDSABKAAEIgU2AiwgBUEEa0F9SQ0EIABBADYCoAEgASwADiEDIAEtAA0hCSABLQAMIQIgASgACCEGIARBEGsiBARAIAQEQCABIAFBEGogBPwKAAALIAAgBDYCoAELIA0gAjYCPAJAIAJBA00EQEGAgBAQLiIBDQEACyANQQE2AlQgDUHspcIANgJQIA1CATcCXCANICY3A2ggDSANQegAajYCWCANQUBrIgAgDUHQAGoQ/gEgABCeAiEBDAkLIAAgAzoA2gEgACAJOgDZASAAQQA6ANgBIABBADYC1AEgACACNgLQASAAIAY2AswBIAAgBTYCyAEgAEEANgLEASAAQoCAgIDAADcCvAEgAEICNwK0ASAAQgA3AqwBIAAgATYCqAEgAEGAgAQ2AqQBIA0gA0GAAXFBB3Y6AFggDSACNgJUIA0gBjYCUCAAIA1B0ABqEKgBIANBAEgEQCAAQQE6AGwLIAAoAqQBQYCAgIB4Rg0FCyMAQRBrIhMkAAJAAkAgACgCpAFBgICAgHhGIgFFBEBBACAAQaQBaiABGyESIABBIGohFSAAQbABaiEaIABBvAFqIRsDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAtANgBQQFrDgkPDg0MAAEGBBACC0EJIQlBBiEBIAAoAtABDgQECgkIAgsgAEEJQQcgACwA2gFBAE4bOgDYAQwaCyAAKAKgAUEGQQkgACgCyAEiAkEBRhsiHG4iASAAKALMASAAKALUAWsiDEkEQCABIgxBgIABSQ0OC0GAgAEgDCAMQYCAAU8bIgpBA2wiAyAAKAKsASIBSwR/IAMgASICayIEIBIoAgAgAWtLBEAgEiABIARBBEEEENkBIAAoAqwBIQILIAAoAqgBIgUgAkECdGohBiAEQQJPBEAgAyABQX9zakECdCIJBEAgBkEAIAn8CwALIAUgAiADaiABa0ECdGpBBGshBiACIARqQQFrIQILIAZBADYCACAAIAJBAWo2AqwBIAAoAsgBBSACC0EBRw0OIAxFDQ9BACEDQQAhAUEAIQdBACECA0ACfwJAIAFBAmoiBCAAKAKgASIFTQRAIAAoApwBIAFqIgRBAWotAABBCHQiBSAELQAAciIEQf//AXFFBEAgBEEQdAwDCyAEQf8HcSEEIAVBgIACcSEGIAVBgPgBcSIFQYD4AUYEQCAGQRB0IgVBgICA/AdyIARFDQMaIARBDXQgBXJBgICA/gdyDAMLIAZBEHQhBiAFRQ0BIAVBDXRBgICA/ABxIARBDXRyQYCAgMADaiAGcgwCCyAEIAVBiKzAABCsAwALIAQgBGdBEGsiBEH//wNxQQhqdEH///8DcSAGQYCAgNgDciAEQRd0a3ILIQQgACgCrAEiBSACTQRAIAIgBUGYrMAAEJ0CAAsgACgCqAEgB2ogBDYCAAJ/AkAgAUEEaiIEIAAoAqABIgVNBEAgACgCnAEgAWoiBEEDai0AAEEIdCIFIARBAmotAAByIgRB//8BcUUEQCAEQRB0DAMLIARB/wdxIQQgBUGAgAJxIQYgBUGA+AFxIgVBgPgBRgRAIAZBEHQiBUGAgID8B3IgBEUNAxogBEENdCAFckGAgID+B3IMAwsgBkEQdCEGIAVFDQEgBUENdEGAgID8AHEgBEENdHJBgICAwANqIAZyDAILIAQgBUGorMAAEKwDAAsgBCAEZ0EQayIEQf//A3FBCGp0Qf///wNxIAZBgICA2ANyIARBF3RrcgshBAJ/AkAgAkEBaiIFIAAoAqwBIgZJBEAgACgCqAEgB2pBBGogBDYCACABQQZqIgQgACgCoAEiBU0EQCAAKAKcASABaiIBQQVqLQAAQQh0IgUgAUEEai0AAHIiAUH//wFxRQRAIAFBEHQMBAsgAUH/B3EhASAFQYCAAnEhBiAFQYD4AXEiBUGA+AFGBEAgBkEQdCIFQYCAgPwHciABRQ0EGiABQQ10IAVyQYCAgP4HcgwECyAGQRB0IQYgBUUNAiAFQQ10QYCAgPwAcSABQQ10ckGAgIDAA2ogBnIMAwsgBCAFQciswAAQrAMACyAFIAZBuKzAABCdAgALIAEgAWdBEGsiAUH//wNxQQhqdEH///8DcSAGQYCAgNgDciABQRd0a3ILIQEgAkECaiIFIAAoAqwBIgZJBEAgACgCqAEgB2pBCGogATYCACAHQQxqIQcgAkEDaiECIAQhASADQQFqIgMgCkkNAQwRCwsgBSAGQdiswAAQnQIAC0GYscAAEM4CAAsgACgCoAEiAkECdiIBIAAoAswBIAAoAtQBayIESQRAIAEhBCACQYCABEkNDAtBgIABIAQgBEGAgAFPGyIMIAAoAsQBIgVLBEAgDCAFIgFrIgMgACgCvAEgAWtLBEAgGyABIANBBEEEENkBIAAoAsQBIQELIAAoAsABIgYgAUECdGohAiADQQJPBEAgDCAFQX9zakECdCIJBEAgAkEAIAn8CwALIAYgASAMaiAFa0ECdGpBBGshAiABIANqQQFrIQELIAJBADYCACAAIAFBAWoiBTYCxAELAkACQAJAAkAgBARAQQEgDCAMQQFNGyEDQQAhAkEEIQEDQCABIAAoAqABIgVLDQMgAiAAKALEASIFTw0CIAAoAsABIAFqQQRrIAAoApwBIAFqQQRrKAAANgIAIAFBBGohASADIAJBAWoiAkcNAAsgACgCxAEhBQsgACgCwAEhAyAAKALUASEKIAAoAjhBgICAgHhHDQMgACgCdCICQf////8DSw0CIAJBAnQiAUH9////B08NAgJ/IAFFBEBBBCEHQQAMAQsgARAuIgdFDQcgB0EEay0AAEEDcUUgAUVyRQRAIAdBACAB/AsACyACCyEBIAAgAjYCQCAAIAc2AjwgACABNgI4DAMLIAIgBUHossAAEJ0CAAsgASAFQdiywAAQrAMAC0HAwMAAEM0CDAMLAkACQAJAAkACQCAEBEBBACEJIAAoAjwhBiAAKAJAIgsgCmsiAUEAIAEgC00bIgEgDEEBayICIAEgAkkbIgEgBSABIAVJG0EBaiICQQRLBEAgBiAKQQJ0aiEBIAIgAkEDcSICQQQgAhtrIgkhByADIQIDQCABIAL9AAIA/QsCACACQRBqIQIgAUEQaiEBIAdBBGsiBw0ACwsgDCAJayEIIAUgCWshASADIAlBAnRqIQcgBiAJIApqIgNBAnRqIQYgCSAKIAsgCiALSRtqIAtrIQIDQCABRQ0CIAJFDQMgBiAHKAIANgIAIAFBAWshASACQQFqIQIgBkEEaiEGIANBAWohAyAHQQRqIQcgCEEBayIIDQALCyAAKAKgASICIAxBAnQiAUkNHiAAQQA2AqABIAIgAWshAyAERQ0CIAEgAkYNBCADRQ0DIAAoApwBIgIgASACaiAD/AoAAAwDCyAFIAVB0MDAABCdAgALIAMgC0HgwMAAEJ0CAAsgASACRg0BCyAAIAM2AqABCyAAIAAoAtQBIAxqIgE2AtQBIAEgACgCzAFHDRcgAEEANgLUAUEJIQELIAAgAToA2AEMFgsgACgCoAEiAkEBdiIBIAAoAswBIAAoAtQBayIESQRAIAEhBCACQYCAAkkNCgtBgIABIAQgBEGAgAFPGyIMIAAoArgBIgVLBEAgDCAFIgFrIgMgACgCsAEgAWtLBEAgGiABIANBAkECENkBIAAoArgBIQELIAAoArQBIgYgAUEBdGohAiADQQJPBEAgDCAFQX9zakEBdCIJBEAgAkEAIAn8CwALIAYgASAMaiAFa0EBdGpBAmshAiABIANqQQFrIQELIAJBADsBACAAIAFBAWoiBTYCuAELIAQEQEEBIAwgDEEBTRshA0EAIQJBAiEBAkADQCAAKAKgASIFIAFJBEAgASAFQbiywAAQrAMACyAAKAK4ASIFIAJLBEAgACgCtAEgAWpBAmsgACgCnAEgAWpBAmsvAAA7AQAgAUECaiEBIAMgAkEBaiICRg0CDAELCyACIAVByLLAABCdAgALIAAoArgBIQULIAAoArQBIQMgACgC1AEhCiAAKAIsQYCAgIB4Rw0BAkAgACgCdCICQQBIDQAgAkEBdCIBQf////8HTw0AAn8gAUUEQEECIQdBAAwBCyABEC4iB0UNAiAHQQRrLQAAQQNxRSABRXJFBEAgB0EAIAH8CwALIAILIQEgACACNgI0IAAgBzYCMCAAIAE2AiwMAgtBkMDAABDNAgALAAsCQAJAAkACQAJAIAQEQEEAIQkgACgCMCEGIAAoAjQiCyAKayIBQQAgASALTRsiASAMQQFrIgIgASACSRsiASAFIAEgBUkbQQFqIgJBCEsEQCAGIApBAXRqIQEgAiACQQdxIgJBCCACG2siCSEHIAMhAgNAIAEgAv0AAQD9CwEAIAJBEGohAiABQRBqIQEgB0EIayIHDQALCyAMIAlrIQggBSAJayEBIAMgCUEBdGohByAGIAkgCmoiA0EBdGohBiAJIAogCyAKIAtJG2ogC2shAgNAIAFFDQIgAkUNAyAGIAcvAQA7AQAgAUEBayEBIAJBAWohAiAGQQJqIQYgA0EBaiEDIAdBAmohByAIQQFrIggNAAsLIAAoAqABIgIgDEEBdCIBSQ0aIABBADYCoAEgAiABayEDIARFDQIgASACRg0EIANFDQMgACgCnAEiAiABIAJqIAP8CgAADAMLIAUgBUGgwMAAEJ0CAAsgAyALQbDAwAAQnQIACyABIAJGDQELIAAgAzYCoAELIAAgACgC1AEgDGoiATYC1AEgASAAKALMAUcNEyAAQQA2AtQBIABBCDoA2AEMEwtBLSEJDAELQRghCQsgACgCoAEgCW4iASAAKALMASAAKALUAWsiDEkEQCABIgxBgIABSQ0FC0GAgAEgDCAMQYCAAU8bIg4gCWwiDyAAKAKsASIBSwRAIAEhAiAPIAFrIgMgEigCACABa0sEQCASIAEgA0EEQQQQ2QEgACgCrAEhAgsgACgCqAEiBCACQQJ0aiEHIANBAk8EQCAPIAFBf3NqQQJ0IgUEQCAHQQAgBfwLAAsgBCACIA9qIAFrQQJ0akEEayEHIAIgA2pBAWshAgsgB0EANgIAIAAgAkEBaiIBNgKsAQsgDkEJbCERAkAgDARAIA5B4ABsIQVBGCEHIA5BGGwhBkEAIQRBASEBAkACQANAIAQhCiABIQQgCSAKbCIBIAAoAqABIgNPDQQCQAJAAkACQCAKQQlsIgIgACgCrAEiA08NACAAKAKoASACQQJ0aiAAKAKcASABai0AALNDAAAAw5JDAAAAPJQ4AgAgAUEBaiIIIAAoAqABIgNPBEAgCCEBDAkLIAJBAWoiCyAAKAKsASIDTwRAIAshAgwBCyAAKAKoASALQQJ0aiAAKAKcASAIai0AALNDAAAAw5JDAAAAPJQ4AgAgAUECaiIIIAAoAqABIgNPBEAgCCEBDAkLIAJBAmoiCyAAKAKsASIDTwRAIAshAgwBCyAAKAKoASALQQJ0aiAAKAKcASAIai0AALNDAAAAw5JDAAAAPJQ4AgAgAUEDaiIIIAAoAqABIgNPBEAgCCEBDAkLIAJBA2oiCyAAKAKsASIDTwRAIAshAgwBCyAAKAKoASALQQJ0aiAAKAKcASAIai0AALNDAAAAw5JDAAAAPJQ4AgAgAUEEaiIIIAAoAqABIgNPBEAgCCEBDAkLIAJBBGoiCyAAKAKsASIDTwRAIAshAgwBCyAAKAKoASALQQJ0aiAAKAKcASAIai0AALNDAAAAw5JDAAAAPJQ4AgAgAUEFaiIIIAAoAqABIgNPBEAgCCEBDAkLIAJBBWoiCyAAKAKsASIDTwRAIAshAgwBCyAAKAKoASALQQJ0aiAAKAKcASAIai0AALNDAAAAw5JDAAAAPJQ4AgAgAUEGaiIIIAAoAqABIgNPBEAgCCEBDAkLIAJBBmoiCyAAKAKsASIDTwRAIAshAgwBCyAAKAKoASALQQJ0aiAAKAKcASAIai0AALNDAAAAw5JDAAAAPJQ4AgAgAUEHaiIIIAAoAqABIgNPBEAgCCEBDAkLIAJBB2oiCyAAKAKsASIDTwRAIAshAgwBCyAAKAKoASALQQJ0aiAAKAKcASAIai0AALNDAAAAw5JDAAAAPJQ4AgAgAUEIaiIIIAAoAqABIgNPBEAgCCEBDAkLIAJBCGoiAiAAKAKsASIDTw0AIAAoAqgBIAJBAnRqIAAoApwBIAhqLQAAs0MAAADDkkMAAAA8lDgCACAAKALQAUEBSw0BDAILIAIgA0GossAAEJ0CAAsCQAJAIAFBCWoiAiAAKAKgASIITw0AIApBD2wgEWoiAyAAKAKsASIITw0FIAAoAqgBIANBAnRqIAAoApwBIAJqLQAAs0MAAADDkkMAAAA8lDgCACABQQpqIgIgACgCoAEiCE8NACADQQFqIgogACgCrAEiCE8EQCAKIQMMBgsgACgCqAEgCkECdGogACgCnAEgAmotAACzQwAAAMOSQwAAADyUOAIAIAFBC2oiAiAAKAKgASIITw0AIANBAmoiCiAAKAKsASIITwRAIAohAwwGCyAAKAKoASAKQQJ0aiAAKAKcASACai0AALNDAAAAw5JDAAAAPJQ4AgAgAUEMaiICIAAoAqABIghPDQAgA0EDaiIKIAAoAqwBIghPBEAgCiEDDAYLIAAoAqgBIApBAnRqIAAoApwBIAJqLQAAs0MAAADDkkMAAAA8lDgCACABQQ1qIgIgACgCoAEiCE8NACADQQRqIgogACgCrAEiCE8EQCAKIQMMBgsgACgCqAEgCkECdGogACgCnAEgAmotAACzQwAAAMOSQwAAADyUOAIAIAFBDmoiAiAAKAKgASIITw0AIANBBWoiCiAAKAKsASIITwRAIAohAwwGCyAAKAKoASAKQQJ0aiAAKAKcASACai0AALNDAAAAw5JDAAAAPJQ4AgAgAUEPaiICIAAoAqABIghPDQAgA0EGaiIKIAAoAqwBIghPBEAgCiEDDAYLIAAoAqgBIApBAnRqIAAoApwBIAJqLQAAs0MAAADDkkMAAAA8lDgCACABQRBqIgIgACgCoAEiCE8NACADQQdqIgogACgCrAEiCE8EQCAKIQMMBgsgACgCqAEgCkECdGogACgCnAEgAmotAACzQwAAAMOSQwAAADyUOAIAIAFBEWoiAiAAKAKgASIITw0AIANBCGoiCiAAKAKsASIITwRAIAohAwwGCyAAKAKoASAKQQJ0aiAAKAKcASACai0AALNDAAAAw5JDAAAAPJQ4AgAgAUESaiICIAAoAqABIghPDQAgA0EJaiIKIAAoAqwBIghPBEAgCiEDDAYLIAAoAqgBIApBAnRqIAAoApwBIAJqLQAAs0MAAADDkkMAAAA8lDgCACABQRNqIgIgACgCoAEiCE8NACADQQpqIgogACgCrAEiCE8EQCAKIQMMBgsgACgCqAEgCkECdGogACgCnAEgAmotAACzQwAAAMOSQwAAADyUOAIAIAFBFGoiAiAAKAKgASIITw0AIANBC2oiCiAAKAKsASIITwRAIAohAwwGCyAAKAKoASAKQQJ0aiAAKAKcASACai0AALNDAAAAw5JDAAAAPJQ4AgAgAUEVaiICIAAoAqABIghPDQAgA0EMaiIKIAAoAqwBIghPBEAgCiEDDAYLIAAoAqgBIApBAnRqIAAoApwBIAJqLQAAs0MAAADDkkMAAAA8lDgCACABQRZqIgIgACgCoAEiCE8NACADQQ1qIgogACgCrAEiCE8EQCAKIQMMBgsgACgCqAEgCkECdGogACgCnAEgAmotAACzQwAAAMOSQwAAADyUOAIAIAFBF2oiAiAAKAKgASIITw0AIANBDmoiAyAAKAKsASIITw0FIAAoAqgBIANBAnRqIAAoApwBIAJqLQAAs0MAAADDkkMAAAA8lDgCACAAKALQAUECTQ0CQQAhASAFIQIMAQsgAiAIQfixwAAQnQIACwNAIAEgB2oiAyAAKAKgASIITw0CIAEgBmoiAyAAKAKsASIISQRAIAAoAqgBIAJqIAAoApwBIAdqIAFqLQAAs0MAAADDkkMAAAA8lDgCACACQQRqIQIgAUEBaiIBQRVHDQEMAgsLIAMgCEHoscAAEJ0CAAsgByAJaiEHIAVB1ABqIQUgBkEVaiEGIAQgBCAOSSICaiEBIAJFDQMMAQsLIAMgCEHYscAAEJ0CAAsgAyAIQYiywAAQnQIACyAAKAKsASEBCwJAAkACQAJAAkACQAJAIAEgEU8EQCAAKAKoASEDIAAoAtQBIQVBACEHQQQhCAJAIAAoAtABIglBAkkEQEEEIQRBACEGDAELIA5BGGwiAiABSw0CIA5BD2whBiADIBFBAnRqIQQgCUECRg0AIAIgD0sNAyABIA9JDQQgDyACayEHIAMgAkECdGohCAsgDARAIAAgBSAOIAMgERBOCyAGBEAgACAFIA4gBCAGEEALIAcEQCAAIAUgDiAIIAcQbAsgACgCoAEiASAPSQ0EIABBADYCoAEgASAPayECIAxFDQUgASAPRg0HIAJFDQYgACgCnAEiASABIA9qIAL8CgAADAYLIBEgAUGoscAAEKwDAAsgAiABQbixwAAQrAMACyACIA9ByLHAABCtAwALIA8gAUHIscAAEKwDAAsgDyABQfiMwgAQrAMACyABIA9GDQELIAAgAjYCoAELIAAgACgC1AEgDmoiATYC1AEgASAAKALMAUcNESAAQQA2AtQBIABBBjoA2AEMEQsgASADQZiywAAQnQIACyAAKAKgAUEEQQMgACgCyAEiAkEDRhsiDm4iASAAKALMASAAKALUAWsiBUkEQCABIgVBgIABSQ0ECwJAAkACQAJAAkACQAJAAkACQAJAAkBBgIABIAUgBUGAgAFPGyIEQQJ0IgwgACgCrAEiAUsEfyAMIAEiAmsiAyASKAIAIAFrSwRAIBIgASADQQRBBBDZASAAKAKsASECCyAAKAKoASIGIAJBAnRqIQcgA0ECTwRAIAwgAUF/c2pBAnQiCQRAIAdBACAJ/AsACyAGIAIgDGogAWtBAnRqQQRrIQcgAiADakEBayECCyAHQQA2AgAgACACQQFqNgKsASAAKALIAQUgAgtBA0cEQCAFRQ0LQQAhA0EAIQdBACECQQAhAQNAIAEgACgCoAEiBk8NAiABQQFqIgkgBk8NAyABQQJqIgkgBk8NBEMAAIA/IAAoApwBIAFqIgYtAACzQwAA/0KVQwAAgL+SIh4gHpQgBkEBai0AALNDAAD/QpVDAACAv5IiHyAflJIgBkECai0AALNDAAD/QpVDAACAv5IiICAglJKTQwAAAAAQ+QIhISACIAAoAqwBIgZPDQUgACgCqAEgB2ogHjgCACACQQFqIgYgACgCrAEiCU8NBiAAKAKoASAHakEEaiAfOAIAIAJBAmoiBiAAKAKsASIJTw0HIAAoAqgBIAdqQQhqICA4AgAgAkEDaiIGIAAoAqwBIglPDQggACgCqAEgB2pBDGogIZE4AgAgB0EQaiEHIAJBBGohAiABQQNqIQEgA0EBaiIDIARJDQALDAsLIAVFDQpBACEHQQEhCEEAIQIDQAJAAkACQAJAIAAoAqABIgEgAksEQCACQQFqIgMgAU8NASACQQJqIgYgAU8NAiACQQNqIgkgAU8NAyAAKAKcASACaiIBQQJqLQAAIQsgAUEDai0AACEKIAEtAAAgAUEBai0AACEPIBP9DAAAAAAAAAAAAAAAAAAAAAD9CwMAIA9BCHRyIhEgC0EQdCAKQRh0cnIhAUMAAAAAIR8CfwJAIApBBnYiC0EDRwRAIBMgEUH/A3GzQwCA/0OVQ/MENT+UIh6MIB4gD0ECcRsiHjgCDCAeIB6UIR8gAUEKdiEBIAtBAkYNAQsgEyABQf8DcbNDAID/Q5VD8wQ1P5QiHowgHiABQYAEcRsiHjgCCCAfIB4gHpSSIR8gAUEKdiIBIAtBAUYNARoLIBMgAUH/A3GzQwCA/0OVQ/MENT+UIh6MIB4gAUGABHEbIh44AgQgHyAeIB6UkiEfIAFBCnYLIQEgEyALQQJ0akMAAIA/IApBwABPBH0gEyABQf8DcbNDAID/Q5VD8wQ1P5QiHowgHiABQYAEcRsiHjgCACAfIB4gHpSSBSAfC5MiHpFDAAAAACAeQwAAAABeGzgCACACIAAoAqwBIgFJDQQgAiABQeivwAAQnQIACyACIAFBqK/AABCdAgALIAMgAUG4r8AAEJ0CAAsgBiABQcivwAAQnQIACyAJIAFB2K/AABCdAgALIAAoAqgBIAdqIBMqAgA4AgAgAyAAKAKsASIBTw0KIAAoAqgBIAdqQQRqIBMqAgQ4AgAgBiAAKAKsASIBTw0JIAAoAqgBIAdqQQhqIBMqAgg4AgAgCSAAKAKsASIBTw0IIAAoAqgBIAdqQQxqIBMqAgw4AgAgB0EQaiEHIAJBBGohAiAEIAhLIAhBAWohCA0ACwwKCyABIAZBqLDAABCdAgALIAkgBkG4sMAAEJ0CAAsgCSAGQciwwAAQnQIACyACIAZB2LDAABCdAgALIAYgCUHosMAAEJ0CAAsgBiAJQfiwwAAQnQIACyAGIAlBiLHAABCdAgALIAkgAUGYsMAAEJ0CAAsgBiABQYiwwAAQnQIACyADIAFB+K/AABCdAgALIAAoAqwBIQkgACgCqAEhCiAAKALUASEIAkAgACgCKCIBIAxPBEAgACgCJCEGDAELIAwgASIDayICIAAoAiAgAWtLBEAgFSABIAJBBEEEENkBIAAoAighAwsgACgCJCIGIANBAnRqIQcgAkECTwR/IAwgAUF/c2pBAnQiAQRAIAdBACAB/AsACyACIANqIgFBAWshAyAGIAFBAnRqQQRrBSAHC0EANgIAIANBAWohDAsgACAMNgIoIAAoAnwgCEECdCAEIAhqQQJ0EPoCIgggBiAMEIQCAkAgBUUNACAEQQJ0IQxBACEBQQAhAgNAIAFBBGoiAyAAKAIoIgZNBEACQAJAAkAgASAJTw0AIAkgAWsiBkEAIAYgCU0bIgZBAUcEQCAGQQJHBEAgBkEDRwRAIAIgCmoiASoCACEhIAFBBGoqAgAhIiABQQhqKgIAISMgAUEMaioCACIfQwAAAABdBEAgI4whIyAijCEiICGMISEgH4whHwsgACgCJCEBQwAAgD8hIEMAAAAAIR5DAAAAACEkQwAAgD8gHyAfQwAAgD9eGxDDASIfIB+SIiVDAAAAP5QQVyIfi0O9N4Y1XUUEQCAjIB+VISQgISAflSEgICIgH5UhHgsgHiAeiyAgi5IgJIuSIh6VIR8gICAelSEgICRDAAAAAF0NBCAfIR4MBQsgAUEDaiEBDAILIAFBAmohAQwBCyABQQFqIQELIAEgCUHwv8AAEJ0CAAtDAACAPyAgi5MiHiAejCAfQwAAAABgGyEeQwAAgD8gH4uTIh8gH4wgIEMAAAAAYBshIAsgASACaiIBQQ9qQf8BQwAAf0NDAAAAACAlQ9sPSUCVQwAAf0OUIh8gH0MAAAAAXRsiHyAfQwAAf0NeGxCtAiIf/AFBACAfQwAAAABgGyAfQwAAf0NeGzoAAEMAAH9DQwAAAAAgHkMAAIA/kkMAAAA/lEMAAH9DlCIeIB5DAAAAAF0bIh4gHkMAAH9DXhsQrQIhHkMAAH9DQwAAAAAgIEMAAIA/kkMAAAA/lEMAAH9DlCIfIB9DAAAAAF0bIh8gH0MAAH9DXhsQrQIhHyABQQhqIgEgAS8BAEH/ASAf/AFBACAfQwAAAABgGyAfQwAAf0NeG0EQdHJB/wEgHvwBQQAgHkMAAAAAYBsgHkMAAH9DXhtBGHRyNgIAIAJBEGohAiADIgEgDEcNAQwCCwsgAyAGQeC/wAAQrAMACyAIIAAoAiQgACgCKBCBAiAIQYQBTwRAIAgQtQILAkACQAJAIAAoAqABIgIgBCAObCIBTwRAIABBADYCoAEgAiABayEDIAVFDQEgASACRg0DIANFDQIgACgCnAEiAiABIAJqIAP8CgAADAILDBQLIAEgAkYNAQsgACADNgKgAQsgACAAKALUASAEaiIBNgLUASABIAAoAswBRw0PIABBADYC1AEgAEEFOgDYAQwPCyAAKAKgASICQQNuIgEgACgCzAEgACgC1AFrIgxJBEAgASEMIAJBgIADSQ0DC0GAgAEgDCAMQYCAAU8bIglBA2wiCiAAKAKsASICSwRAIAogAiIBayIDIBIoAgAgAWtLBEAgEiABIANBBEEEENkBIAAoAqwBIQELIAAoAqgBIgQgAUECdGohByADQQJPBEAgCiACQX9zakECdCIFBEAgB0EAIAX8CwALIAQgASAKaiACa0ECdGpBBGshByABIANqQQFrIQELIAdBADYCACAAIAFBAWoiAjYCrAELAkACQAJAAkACQAJAAkACQAJAAkAgDARAQQEgCSAJQQFNG0EDbCEEQQAhAUEIIQIDQCABIAAoAqABIgNPDQIgASAAKAKsASIDTw0DIAAoAqgBIAJqQQhrIAAoApwBIAFqLQAAs0MAAIA9lEMAACDBkhCcATgCACABQQFqIgMgACgCoAEiBU8NBCADIAAoAqwBIgVPDQUgACgCqAEgAmpBBGsgACgCnAEgAWpBAWotAACzQwAAgD2UQwAAIMGSEJwBOAIAIAFBAmoiAyAAKAKgASIFTw0GIAMgACgCrAEiBU8NByAAKAKoASACaiAAKAKcASABakECai0AALNDAACAPZRDAAAgwZIQnAE4AgAgAkEMaiECIAQgAUEDaiIBRw0ACyAAKAKsASECCyAAKAKoASEBIAAoAtQBIQYCQCAJQQJ0IgcgACgCKCIDTQRAIAAoAiQhCAwBCyAHIAMiBGsiBSAAKAIgIANrSwRAIBUgAyAFQQRBBBDZASAAKAIoIQQLIAAoAiQiCCAEQQJ0aiELIAVBAk8EfyAHIANBf3NqQQJ0IgMEQCALQQAgA/wLAAsgBCAFaiIDQQFrIQQgCCADQQJ0akEEawUgCwtBADYCACAEQQFqIQcLIAAgBzYCKCAAKAJ8IAZBAnQgBiAJakECdBD6AiILIAggBxCEAiAMRQ0JQQwhA0EEIQdBASEGIAkhBQNAIAcgACgCKCIESw0HIAZBAWsiBCACTwRAIAQhBgwKCyACIARrIgRBACACIARPGyIEQQFGDQkgBEECRg0IIAAoAiQhDyABQQhqKgIAISAgAUEEaioCACEhIAAqAlAhHyAAKgJMIR5BACEIQQAhBCABKgIAIiJDAAAAAFwEQEH/AUMAAIA/QwAAAAAgIhDkASAekyAfIB6TlSIiICJDAAAAAF0bIiIgIkMAAIA/XhtDAAB+Q5QQrQIiIvwBQQAgIkMAAAAAYBsgIkMAAH9DXhtBAWpB/wFxIQQLICFDAAAAAFwEQEH/AUMAAIA/QwAAAAAgIRDkASAekyAfIB6TlSIhICFDAAAAAF0bIiEgIUMAAIA/XhtDAAB+Q5QQrQIiIfwBQQAgIUMAAAAAYBsgIUMAAH9DXhtBAWpB/wFxQQh0IQgLIAMgD2oiDyAgQwAAAABcBH9B/wFDAACAP0MAAAAAICAQ5AEgHpMgHyAek5UiHiAeQwAAAABdGyIeIB5DAACAP14bQwAAfkOUEK0CIh78AUEAIB5DAAAAAGAbIB5DAAB/Q14bQQFqQf8BcUEQdAVBAAsgBCAIcnIgDy0AA0EYdHI2AgAgBkEDaiEGIAFBDGohASAHQQRqIQcgA0EQaiEDIAVBAWsiBQ0ACwwJCyABIANByK7AABCdAgALIAEgA0HYrsAAEJ0CAAsgAyAFQeiuwAAQnQIACyADIAVB+K7AABCdAgALIAMgBUGIr8AAEJ0CAAsgAyAFQZivwAAQnQIACyAHIARBwL/AABCsAwALIAZBAWohBgsgBiACQdC/wAAQnQIACyALIAAoAiQgACgCKBCBAiALQYQBTwRAIAsQtQILAkACQAJAIAogACgCoAEiAU0EQCAAQQA2AqABIAEgCmshAiAMRQ0BIAEgCkYNAyACRQ0CIAAoApwBIgEgASAKaiAC/AoAAAwCCyAKIAFB+IzCABCsAwALIAEgCkYNAQsgACACNgKgAQsgACAAKALUASAJaiIBNgLUASABIAAoAswBRw0OIABBADYC1AEgAEEEOgDYAQwOCyAAKAKgASICQQNuIgEgACgCzAEgACgC1AFrIglJBEAgASEJIAJBgIADSQ0CC0GAgAEgCSAJQYCAAU8bIgVBA2wiDCAAKAKsASICSwRAIAwgAiIBayIDIBIoAgAgAWtLBEAgEiABIANBBEEEENkBIAAoAqwBIQELIAAoAqgBIgQgAUECdGohByADQQJPBEAgDCACQX9zakECdCIGBEAgB0EAIAb8CwALIAQgASAMaiACa0ECdGpBBGshByABIANqQQFrIQELIAdBADYCACAAIAFBAWoiAjYCrAELAkACQAJAAkACQAJAAkACQAJAAkAgCQRAQQEgBSAFQQFNG0EDbCEEQQAhAUEIIQIDQCABIAAoAqABIgNPDQIgASAAKAKsASIDTw0DIAAoAqgBIAJqQQhrIAAoApwBIAFqLQAAs0MAAH9DlUMAAAC/kkOMuPA/lEMAAAA/kjgCACABQQFqIgMgACgCoAEiBk8NBCADIAAoAqwBIgZPDQUgACgCqAEgAmpBBGsgACgCnAEgAWpBAWotAACzQwAAf0OVQwAAAL+SQ4y48D+UQwAAAD+SOAIAIAFBAmoiAyAAKAKgASIGTw0GIAMgACgCrAEiBk8NByAAKAKoASACaiAAKAKcASABakECai0AALNDAAB/Q5VDAAAAv5JDjLjwP5RDAAAAP5I4AgAgAkEMaiECIAQgAUEDaiIBRw0ACyAAKAKsASECCyAAKAKoASEBIAAoAtQBIQoCQCAFQQJ0IgcgACgCKCIDTQRAIAAoAiQhCAwBCyAHIAMiBGsiBiAAKAIgIANrSwRAIBUgAyAGQQRBBBDZASAAKAIoIQQLIAAoAiQiCCAEQQJ0aiELIAZBAk8EfyAHIANBf3NqQQJ0IgMEQCALQQAgA/wLAAsgBCAGaiIDQQFrIQQgCCADQQJ0akEEawUgCwtBADYCACAEQQFqIQcLIAAgBzYCKCAAKAJ8IApBAnQgBSAKakECdBD6AiIKIAggBxCEAiAJRQ0JQQAhA0EEIQdBASEGIAUhCANAIAcgACgCKCIESw0HIAZBAWsiBCACTwRAIAQhBgwKCyACIARrIgRBACACIARPGyIEQQFGDQkgBEECRg0IIAAoAiQhBEMAAH9DQwAAAAAgASoCACAAKgJEIh6TIAAqAkggHpMiIJVDAAB/Q5QiHyAfQwAAAABdGyIfIB9DAAB/Q14bEK0CIR8gAyAEaiIEIAQtAANBGHRB/wEgH/wBQQAgH0MAAAAAYBsgH0MAAH9DXhtyQf8BQwAAf0NDAAAAACABQQRqKgIAIB6TICCVQwAAf0OUIh8gH0MAAAAAXRsiHyAfQwAAf0NeGxCtAiIf/AFBACAfQwAAAABgGyAfQwAAf0NeG0EIdHJB/wFDAAB/Q0MAAAAAIAFBCGoqAgAgHpMgIJVDAAB/Q5QiHiAeQwAAAABdGyIeIB5DAAB/Q14bEK0CIh78AUEAIB5DAAAAAGAbIB5DAAB/Q14bQRB0cjYCACAGQQNqIQYgAUEMaiEBIAdBBGohByADQRBqIQMgCEEBayIIDQALDAkLIAEgA0HorcAAEJ0CAAsgASADQfitwAAQnQIACyADIAZBiK7AABCdAgALIAMgBkGYrsAAEJ0CAAsgAyAGQaiuwAAQnQIACyADIAZBuK7AABCdAgALIAcgBEGgv8AAEKwDAAsgBkEBaiEGCyAGIAJBsL/AABCdAgALIAogACgCJCAAKAIoEIECIApBhAFPBEAgChC1AgsCQAJAAkAgDCAAKAKgASIBTQRAIABBADYCoAEgASAMayECIAlFDQEgASAMRg0DIAJFDQIgACgCnAEiASABIAxqIAL8CgAADAILIAwgAUH4jMIAEKwDAAsgASAMRg0BCyAAIAI2AqABCyAAIAAoAtQBIAVqIgE2AtQBIAEgACgCzAFHDQ0gAEEANgLUASAAQQM6ANgBDA0LIAAoAqABIgEgACgCzAEgACgC1AFrIgVJBEAgASIFQYCAAUkNAQtBgIABIAUgBUGAgAFPGyIEIAAoAqwBIglLBEAgBCAJIgFrIgMgEigCACABa0sEQCASIAEgA0EEQQQQ2QEgACgCrAEhAQsgACgCqAEiBiABQQJ0aiECIANBAk8EQCAEIAlBf3NqQQJ0IgwEQCACQQAgDPwLAAsgBiABIARqIAlrQQJ0akEEayECIAEgA2pBAWshAQsgAkEANgIAIAAgAUEBaiIJNgKsAQsCQAJAAkACQAJAAkACQAJAIAUEQEMAAIA/QwAAAEAgACwA2gFBAE4bIR5BASEHQQEgBCAEQQFNGyECQQAhAQNAIAEgACgCoAEiA08NAiABIAAoAqwBIgNPDQMgACgCqAEgAUECdGogHiAAKAKcASABai0AALNDAAB/Q5WUOAIAIAciAUEBaiEHIAEgAkcNAAsgACgCrAEhCQsgACgCqAEhCiAAKALUASEIAkAgBEECdCIBIAAoAigiAk0EQCAAKAIkIQYMAQsgASACIgNrIgwgACgCICACa0sEQCAVIAIgDEEEQQQQ2QEgACgCKCEDCyAAKAIkIgYgA0ECdGohByAMQQJPBH8gASACQX9zakECdCIBBEAgB0EAIAH8CwALIAMgDGoiAUEBayEDIAYgAUECdGpBBGsFIAcLQQA2AgAgA0EBaiEBCyAAIAE2AiggACgCfCAIQQJ0IAQgCGpBAnQQ+gIiDCAGIAEQhAIgBQRAQQAhByAJIQJBACEBIAQhBgNAIAFBBGoiAyAAKAIoIghLDQQgAkUNB0MAAH9DQwAAAAAgASAKaioCACIeQwAAAD+UIB4gAC0AbEEBcRtDAAB/Q5QiHiAeQwAAAABdGyIeIB5DAAB/Q14bEK0CIR4gACgCJCAHakEDakH/ASAe/AFBACAeQwAAAABgGyAeQwAAf0NeGzoAACAHQRBqIQcgAkEBayECIAMhASAGQQFrIgYNAAsLIAwgACgCJCAAKAIoEIECIAxBhAFPBEAgDBC1AgsgACgCoAEiASAESQ0DIABBADYCoAEgASAEayECIAVFDQQgASAERg0HIAJFDQYgACgCnAEiASABIARqIAL8CgAADAYLIAEgA0HIrcAAEJ0CAAsgASADQditwAAQnQIACyADIAhBgL/AABCsAwALIAQgAUH4jMIAEKwDAAsgASAERw0BDAILIAkgCUGQv8AAEJ0CAAsgACACNgKgAQsgACAAKALUASAEaiIBNgLUASABIAAoAswBRw0MIABBADYC1AEgAEECOgDYAQwMCyATQRBqJAAMDgsgDEUNAEEBIAAtANkBdLMhHkEAIQNBACEBQQAhB0EAIQIDQCABQQNqIgQgACgCoAEiBUsNBiACIAAoAqwBIgRPDQQgACgCqAEgB2ogACgCnAEgAWoiBEECai0AACIFQRB0IAQtAAByIARBAWotAABBCHRyIgRBgICAeHIgBCAFwEEASBuyIB6VOAIAIAFBBmoiBCAAKAKgASIFSw0FIAJBAWoiBCAAKAKsASIFTw0CIAAoAqgBIAdqQQRqIAAoApwBIAFqIgRBBWotAAAiBUEQdCAEQQNqLQAAciAEQQRqLQAAQQh0ciIEQYCAgHhyIAQgBcBBAEgbsiAelTgCACABQQlqIgQgACgCoAEiBUsNAyACQQJqIgUgACgCrAEiBk8NByAAKAKoASAHakEIaiAAKAKcASABaiIBQQhqLQAAIgVBEHQgAUEGai0AAHIgAUEHai0AAEEIdHIiAUGAgIB4ciABIAXAQQBIG7IgHpU4AgAgB0EMaiEHIAJBA2ohAiAEIQEgA0EBaiIDIApJDQALCyAAKAKsASEPIAAoAqgBIQEgACgC1AEhBgJAIApBAnQiAiAAKAIoIgNNBEAgACgCJCEIDAELIAIgAyIEayIFIAAoAiAgA2tLBEAgFSADIAVBBEEEENkBIAAoAighBAsgACgCJCIIIARBAnRqIQkgBUECTwR/IAIgA0F/c2pBAnQiAgRAIAlBACAC/AsACyAEIAVqIgJBAWshBCAIIAJBAnRqQQRrBSAJC0EANgIAIARBAWohAgsgACACNgIoIAAoAnwgBkECdCAGIApqQQJ0EPoCIhEgCCACEIQCIAxFDQhBCCEEQQQhA0EBIQggCiEGA0ACQAJAIAAoAigiAiADTwRAIAhBAWsiAiAPTwRAIAIhCAwMCyAPIAJrIgJBACACIA9NGyICQQFGDQsgAkECRg0KIAEoAgAiB0H///8DcSELIAdBgICAgHhxIQkgAUEEaigCACECIAdBgICA/AdxIgVBgICA/AdGBEAgCUEQdiALQQ12ciALQQBHQQl0ckGA+AFyIQkMAwsgCUEQdiEJIAVBgICAuARLDQEgBUGAgIDEA08EQCAHQQx2IAdB/98AcUEAR3EgBUENdiALQQ12akGAgAFqIAlyaiEJDAMLIAVBgICAmANJDQIgC0GAgIAEciIHQR4gBUEXdiILa3YhBSAHQR0gC2siC3ZBAXEEfyAFQQMgC3RBAWsgB3FBAEdqBSAFCyAJciEJDAILIAMgAkHgvsAAEKwDAAsgCUGA+AFyIQkLIAFBCGooAgAhByACQf///wNxIQ4gAkGAgICAeHEhBQJAIAJBgICA/AdxIgtBgICA/AdHBEAgBUEQdiEFIAtBgICAuARNBEAgC0GAgIDEA08EQCACQQx2IAJB/98AcUEAR3EgC0ENdiAOQQ12akGAgAFqIAVyaiEFDAMLIAtBgICAmANJDQIgDkGAgIAEciICQR4gC0EXdiIOa3YhCyACQR0gDmsiDnZBAXEEfyALQQMgDnRBAWsgAnFBAEdqBSALCyAFciEFDAILIAVBgPgBciEFDAELIAVBEHYgDkENdnIgDkEAR0EJdHJBgPgBciEFCyAAKAIkIR0gB0H///8DcSEOIAdBgICAgHhxIQICQCAHQYCAgPwHcSILQYCAgPwHRwRAIAJBEHYhAiALQYCAgLgETQRAIAtBgICAxANPBEAgB0EMdiAHQf/fAHFBAEdxIAtBDXYgDkENdmpBgIABaiACcmohAgwDCyALQYCAgJgDSQ0CIA5BgICABHIiB0EeIAtBF3YiDmt2IQsgB0EdIA5rIg52QQFxBH8gC0EDIA50QQFrIAdxQQBHagUgCwsgAnIhAgwCCyACQYD4AXIhAgwBCyACQRB2IA5BDXZyIA5BAEdBCXRyQYD4AXIhAgsgBCAdaiIHIAI7AQAgB0EEayAJQf//A3EgBUEQdHI2AgAgCEEDaiEIIAFBDGohASADQQRqIQMgBEEQaiEEIAZBAWsiBg0ACwwICyAEIAVBmK3AABCdAgALIAQgBUGorcAAEKwDAAsgAiAEQfiswAAQnQIACyAEIAVBiK3AABCsAwALIAQgBUHorMAAEKwDAAsgBSAGQbitwAAQnQIACyAIQQFqIQgLIAggD0HwvsAAEJ0CAAsgESAAKAIkIAAoAigQgQIgEUGEAU8EQCARELUCCwJAAkACQCAAKAKgASICIAogHGwiAU8EQCAAQQA2AqABIAIgAWshAyAMRQ0BIAEgAkYNAyADRQ0CIAAoApwBIgIgASACaiAD/AoAAAwCCwwFCyABIAJGDQELIAAgAzYCoAELIAAgACgC1AEgCmoiATYC1AEgASAAKALMAUcNACAAQQA2AtQBIABBAToA2AEMAAsAC0Hon8IAQShB+LLAABDEAgALIAEgAkH4jMIAEKwDAAsMBAsgAiABQZizwAAQrQMACyABIANBmLPAABCsAwALIA1BATYCZCANQfCrwAA2AmAgDUEBNgJUIA1B6KvAADYCUCANQQE2AlwgDSANQRxqrUKAgICA8ACENwNAIA0gDUFAazYCWCANQSBqIgAgDUHQAGoQ/gEgABCcAiEBDAQLIA1BATYCVCANQcirwAA2AlAgDUIBNwJcIA0gDUEsaq1CgICAgOAAhDcDQCANIA1BQGs2AlggDUEwaiIAIA1B0ABqEP4BIAAQnAIhAQwDCyAQIBZqIRACQAJAAkACQAJAIBkOAwECAwALIA1BATYCVCANQbCmwgA2AlAgDUIBNwJcIA0gDUEPaq1CgICAgIABhDcDQCANIA1BQGs2AlggDUEQaiIAIA1B0ABqEP4BIAAQnAIhAQwGCyAAQQE6AOVTIBBBCGogECAAKAKIASIBIBBrIgJBACABIAJPG0EHSxshEAwCCyAUIBZyRQ0BCyAQIAAoAogBIgNJDQELCyAQRQ0AIBAgACgCiAEiAk0EQEEAIQEgAEEANgKIASACIBBGDQIgAiAQayICBEAgACgChAEiAyADIBBqIAL8CgAACyAAIAI2AogBDAILIBAgAkH4jMIAEKwDAAtBACEBCyANQfAAaiQAIAELnh8DB34TfwF7AkAgACgCBCILIAFLBEAgACgCCCINKQMYIgMgACgCACABQQJ0aigCACIYrYUiBEI4hiAEQoD+A4NCKIaEIARCgID8B4NCGIYgBEKAgID4D4NCCIaEhCADQgiIQoCAgPgPgyADQhiIQoCA/AeDhCADQiiIQoD+A4MgA0I4iISEhELSgaqbq/qC16d/fiIDQjiGIANCgP4Dg0IohoQgA0KAgPwHg0IYhiADQoCAgPgPg0IIhoSEIANCCIhCgICA+A+DIANCGIhCgID8B4OEIANCKIhCgP4DgyADQjiIhISEIARC2KLR78Kp5b8tfoUiA0I4hiADQoD+A4NCKIaEIANCgID8B4NCGIYgA0KAgID4D4NCCIaEhCADQgiIQoCAgPgPgyADQhiIQoCA/AeDhCADQiiIQoD+A4MgA0I4iISEhCANKQMQIgRCf4V+IgVCOIYgBUKA/gODQiiGhCAFQoCA/AeDQhiGIAVCgICA+A+DQgiGhIQgBUIIiEKAgID4D4MgBUIYiEKAgPwHg4QgBUIoiEKA/gODIAVCOIiEhIQgAyAEQjiGIARCgP4Dg0IohoQgBEKAgPwHg0IYhiAEQoCAgPgPg0IIhoSEIARCCIhCgICA+A+DIARCGIhCgID8B4OEIARCKIhCgP4DgyAEQjiIhISEfoUgA4kiA0IZiCIIQv8Ag0KBgoSIkKDAgAF+IQUgDSgCACIBQRBrIRIgDSgCBCIMIAOnIhtxIgohCwJAAkADQCABIAtqKQAAIgQgBYUiA0J/hSADQoGChIiQoMCAAX2DQoCBgoSIkKDAgH+DIgNQRQRAA0AgEiADeqdBA3YgC2ogDHEiDkEEdGsoAgAgGEYNAyADQgF9IAODIgNQRQ0ACwsgBCAEQgGGg0KAgYKEiJCgwIB/g1AEQCALIBBBCGoiEGogDHEhCwwBCwsgDSgCCEUEQCANQRBqIQwjAEEgayIUJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCANKAIMIhJBf0cEQCANKAIEIhAgEEEBaiIPQQN2IgpBB2wiGSAQQQhJGyIBQQF2IBJNBEAgASASIAEgEksbIgFBDkkNAiABQf7///8BTQRAQX8gAUEDdEEIakEHbkEBa2d2IgFB/v///wBLDQcgAUEBaiEBDAYLDA0LQQAhASANKAIAIQsgCiAPQQdxQQBHaiIRRQ0DQQEhDiARQQFGDQIgEUEBcSEOIAshASARQf7///8DcSITIQoDQCABIAH9AAMAIh39TUEH/c0B/QwBAQEBAQEBAQEBAQEBAQEB/U4gHf0Mf39/f39/f39/f39/f39/f/1Q/c4B/QsDACABQRBqIQEgCkECayIKDQALIBEgE0YNAyATQQN0IQEMAgsMCwtBBEEIQRAgAUEHSRsgAUEDSRshAQwCCyABIAtqIQEDQCABIAEpAwAiA0J/hUIHiEKBgoSIkKDAgAGDIANC//79+/fv37//AIR8NwMAIAFBCGohASAOQQFrIg4NAAsLIA0CfwJAIA9BCE8EQCALIA9qIAspAAA3AAAMAQsgDwRAIAtBCGogCyAP/AoAAAsgDw0AQQAMAQsgDCkDACIDQjiGIANCgP4Dg0IohoQgA0KAgPwHg0IYhiADQoCAgPgPg0IIhoSEIANCCIhCgICA+A+DIANCGIhCgID8B4OEIANCKIhCgP4DgyADQjiIhISEIQYgC0EIaiETIAtBEGshGiADQn+FIQcgDCkDCCEFQQEhCkEAIQEDQCABIQ4gCiEBAkAgCyAOaiIVLQAAQYABRw0AIBogDkEEdGshHCALIA5Bf3NBBHRqIRYDQCAQIAUgHDUCAIUiBEI4hiAEQoD+A4NCKIaEIARCgID8B4NCGIYgBEKAgID4D4NCCIaEhCAFQgiIQoCAgPgPgyAFQhiIQoCA/AeDhCAFQiiIQoD+A4MgBUI4iISEhELSgaqbq/qC16d/fiIDQjiGIANCgP4Dg0IohoQgA0KAgPwHg0IYhiADQoCAgPgPg0IIhoSEIANCCIhCgICA+A+DIANCGIhCgID8B4OEIANCKIhCgP4DgyADQjiIhISEIARC2KLR78Kp5b8tfoUiA0I4hiADQoD+A4NCKIaEIANCgID8B4NCGIYgA0KAgID4D4NCCIaEhCADQgiIQoCAgPgPgyADQhiIQoCA/AeDhCADQiiIQoD+A4MgA0I4iISEhCAHfiIEQjiGIARCgP4Dg0IohoQgBEKAgPwHg0IYhiAEQoCAgPgPg0IIhoSEIARCCIhCgICA+A+DIARCGIhCgID8B4OEIARCKIhCgP4DgyAEQjiIhISEIAMgBn6FIAOJpyIXcSIKIQwgCiALaikAAEKAgYKEiJCgwIB/gyIDUARAQQghEQNAIAwgEWohDCARQQhqIREgCyAMIBBxIgxqKQAAQoCBgoSIkKDAgH+DIgNQDQALCyALIAN6p0EDdiAMaiAQcSIMaiwAAEEATgRAIAspAwBCgIGChIiQoMCAf4N6p0EDdiEMCyAMIAprIA4gCmtzIBBxQQhPBEAgCyAMaiIKLQAAIAogF0EZdiIKOgAAIBMgDEEIayAQcWogCjoAACALIAxBf3NBBHRqIQpB/wFGBEAgFUH/AToAACATIBAgDkEIa3FqQf8BOgAAIAogFv0AAAD9CwAADAMLIBYgCkEQELABDAELCyAVIBdBGXYiCjoAACATIBAgDkEIa3FqIAo6AAALIAEgASAPSSIMaiEKIAwNAAsgECAZIBBBCEkbCyASazYCCAwFCyABQQR0IgsgAUEIaiIKaiIOIAtJIA5B+P///wdLcg0AIA4QLiIORQ0BIAsgDmohDyAKBEAgD0H/ASAK/AsACyABQQFrIhMgAUEDdkEHbCATQQhJGyEVIBINAiANKAIAIQsMAwsgFEEANgIYIBRBATYCDCAUQZDvwQA2AgggFEIENwIQIBRBCGpBmO/BABDaAgsACyAPQQhqIRYgDCkDACIDQjiGIANCgP4Dg0IohoQgA0KAgPwHg0IYhiADQoCAgPgPg0IIhoSEIANCCIhCgICA+A+DIANCGIhCgID8B4OEIANCKIhCgP4DgyADQjiIhISEIQcgA0J/hSEJIA0oAgAiC0EQayEXIAspAwBCf4VCgIGChIiQoMCAf4MhBSAMKQMIIQZBACEBIBIhDCALIQ4DQCAFUARAA0AgAUEIaiEBIA5BCGoiDikDAEKAgYKEiJCgwIB/gyIDQoCBgoSIkKDAgH9RDQALIANCgIGChIiQoMCAf4UhBQsgDyATIAYgFyAFeqdBA3YgAWoiGUEEdGs1AgCFIgRCOIYgBEKA/gODQiiGhCAEQoCA/AeDQhiGIARCgICA+A+DQgiGhIQgBkIIiEKAgID4D4MgBkIYiEKAgPwHg4QgBkIoiEKA/gODIAZCOIiEhIRC0oGqm6v6gtenf34iA0I4hiADQoD+A4NCKIaEIANCgID8B4NCGIYgA0KAgID4D4NCCIaEhCADQgiIQoCAgPgPgyADQhiIQoCA/AeDhCADQiiIQoD+A4MgA0I4iISEhCAEQtii0e/CqeW/LX6FIgNCOIYgA0KA/gODQiiGhCADQoCA/AeDQhiGIANCgICA+A+DQgiGhIQgA0IIiEKAgID4D4MgA0IYiEKAgPwHg4QgA0IoiEKA/gODIANCOIiEhIQgCX4iBEI4hiAEQoD+A4NCKIaEIARCgID8B4NCGIYgBEKAgID4D4NCCIaEhCAEQgiIQoCAgPgPgyAEQhiIQoCA/AeDhCAEQiiIQoD+A4MgBEI4iISEhCADIAd+hSADiaciGnEiCmopAABCgIGChIiQoMCAf4MiA1AEQEEIIREDQCAKIBFqIQogEUEIaiERIA8gCiATcSIKaikAAEKAgYKEiJCgwIB/gyIDUA0ACwsgBUIBfSAFgyEFIA8gA3qnQQN2IApqIBNxIgpqLAAAQQBOBEAgDykDAEKAgYKEiJCgwIB/g3qnQQN2IQoLIAogD2ogGkEZdiIROgAAIBYgCkEIayATcWogEToAACAPIApBf3NBBHRqIAsgGUF/c0EEdGr9AAAA/QsAACAMQQFrIgwNAAsLIA0gEzYCBCANIA82AgAgDSAVIBJrNgIIIBBFDQAgECAQQQR0QRdqQXBxIgpqQQlqIgFFDQAgCyAKayILQQRrKAIAIgpBeHEiDEEEQQggCkEDcSIKGyABakkNASAKQQAgDCABQSdqSxsNAiALEFsLIBRBIGokAAwDC0HYqMIAQS5BiKnCABDEAgALQZipwgBBLkHIqcIAEMQCAAsgFEEANgIYIBRBATYCDCAUQZDvwQA2AgggFEIENwIQIBRBCGpBmO/BABDaAgALIA0oAgQiDCAbcSEKIA0oAgAhAQsgASAKaikAAEKAgYKEiJCgwIB/gyIDUARAQQghCwNAIAogC2ohCiALQQhqIQsgASAKIAxxIgpqKQAAQoCBgoSIkKDAgH+DIgNQDQALCyABIAN6p0EDdiAKaiAMcSILaiwAACIKQQBOBEAgASABKQMAQoCBgoSIkKDAgH+DeqdBA3YiC2otAAAhCgsgASALaiAIp0H/AHEiEjoAACABIAtBCGsgDHFqQQhqIBI6AAAgDSANKAIIIApBAXFrNgIIIA0gDSgCDEEBajYCDCABIAtBBHRrIgFBBGtBADYCACABQQxrQoCAgIAQNwIAIAFBEGsgGDYCAAwBCyABQQAgDmtBBHRqIQELIAJBEHYiAiABQQRrIg0oAgAiC08EQCACIAtrQQFqIgogAUEMayIMKAIAIAtrSwRAIAwgCyAKQQFBARDZASANKAIAIQsLIAFBCGsoAgAiEiALaiEMIApBAk8EfyAKQQFrIgoEQCAMQQAgCvwLAAsgEiAKIAtqIgtqBSAMC0EAOgAAIA0gC0EBaiILNgIACyACIAtPDQEgAUEIaygCACACaiIBLQAARQRAIAFBAToAACAAKAIMIgAoAggiCiAAKAIARgRAQQAhDSMAQSBrIgEkAAJAAkAgACgCACILQf////8ASw0AQQQgC0EBdCIMIAxBBE0bIgxBA3QiEkH8////B0sNACABIAsEfyABIAtBA3Q2AhwgASAAKAIENgIUQQQFQQALNgIYIAFBCGpBBCASIAFBFGoQogIgASgCCEEBRw0BIAEoAhAaIAEoAgwhDQsgDUGkyMAAEIMDAAsgASgCDCELIAAgDDYCACAAIAs2AgQgAUEgaiQACyAAKAIEIApBA3RqIgEgAjYCBCABIBg2AgAgACAKQQFqNgIICw8LIAEgC0GEyMAAEJ0CAAsgAiALQZTIwAAQnQIAC78HAgh/AX4CQAJAAkAgACgCBCICRQ0AIAAoAgwiBARAIAAoAgAiA0EIaiEBIAMpAwBCf4VCgIGChIiQoMCAf4MhCQNAIAlQBEADQCADQaABayEDIAEpAwAgAUEIaiEBQoCBgoSIkKDAgH+DIglCgIGChIiQoMCAf1ENAAsgCUKAgYKEiJCgwIB/hSEJCyADIAl6p0EDdkFsbGoiBUEUaygCACIHBEAgBUEQaygCACIFQQRrKAIAIgZBeHEiCEEEQQggBkEDcSIGGyAHakkNBCAGQQAgCCAHQSdqSxsNBSAFEFsLIAlCAX0gCYMhCSAEQQFrIgQNAAsLIAIgAkEUbEEbakF4cSIDakEJaiIBRQ0AIAAoAgAgA2siA0EEaygCACICQXhxIgRBBEEIIAJBA3EiAhsgAWpJDQEgAkEAIAQgAUEnaksbDQIgAxBbCyAAKAKIBCIBBEAgACgCjAQiA0EEaygCACICQXhxIgQgAUECdCIBQQRBCCACQQNxIgIbakkNASACQQAgBCABQSdqSxsNAiADEFsLIAAoApQEIgEEQCAAKAKYBCIDQQRrKAIAIgJBeHEiBCABQQJ0IgFBBEEIIAJBA3EiAhtqSQ0BIAJBACAEIAFBJ2pLGw0CIAMQWwsgACgCoAQiAQRAIAAoAqQEIgNBBGsoAgAiAkF4cSIEIAFBAnQiAUEEQQggAkEDcSICG2pJDQEgAkEAIAQgAUEnaksbDQIgAxBbCyAAKAKsBCIBBEAgACgCsAQiA0EEaygCACICQXhxIgQgAUECdCIBQQRBCCACQQNxIgIbakkNASACQQAgBCABQSdqSxsNAiADEFsLIAAoArgEIgEEQCAAKAK8BCIDQQRrKAIAIgJBeHEiBCABQQJ0IgFBBEEIIAJBA3EiAhtqSQ0BIAJBACAEIAFBJ2pLGw0CIAMQWwsgACgCxAQiAQRAIAAoAsgEIgNBBGsoAgAiAkF4cSIEIAFBAnQiAUEEQQggAkEDcSICG2pJDQEgAkEAIAQgAUEnaksbDQIgAxBbCyAAKALQBCIBBEAgACgC1AQiA0EEaygCACICQXhxIgQgAUECdCIBQQRBCCACQQNxIgIbakkNASACQQAgBCABQSdqSxsNAiADEFsLIAAoAtwEIgEEQCAAKALgBCIAQQRrKAIAIgNBeHEiAiABQQJ0IgFBBEEIIANBA3EiAxtqSQ0BIANBACACIAFBJ2pLGw0CIAAQWwsPC0HYqMIAQS5BiKnCABDEAgALQZipwgBBLkHIqcIAEMQCAAvzCAIFfwN+AkACQAJAIAFBCE8EQCABQQdxIgJFDQEgACgCoAEiA0EpTw0CIANFBEAgAEEANgKgAQwCCyADQQFrQf////8DcSIFQQFqIgRBA3EhBiACQQJ0QfDhwABqKAIAIAJ2rSEJAkAgBUEDSQRAIAAhAgwBCyAEQfz///8HcSEFIAAhAgNAIAIgAjUCACAJfiAIfCIHPgIAIAJBBGoiBCAENQIAIAl+IAdCIIh8Igc+AgAgAkEIaiIEIAQ1AgAgCX4gB0IgiHwiBz4CACACQQxqIgQgBDUCACAJfiAHQiCIfCIHPgIAIAdCIIghCCACQRBqIQIgBUEEayIFDQALCyAGBEADQCACIAI1AgAgCX4gCHwiBz4CACACQQRqIQIgB0IgiCEIIAZBAWsiBg0ACwsgACAHQoCAgIAQWgR/IANBKEYNBCAAIANBAnRqIAg+AgAgA0EBagUgAws2AqABDAELIAAoAqABIgNBKU8NASADRQRAIABBADYCoAEPCyABQQJ0QfDhwABqNQIAIQkgA0EBa0H/////A3EiAUEBaiICQQNxIQYCQCABQQNJBEAgACECDAELIAJB/P///wdxIQUgACECA0AgAiACNQIAIAl+IAh8Igc+AgAgAkEEaiIBIAE1AgAgCX4gB0IgiHwiBz4CACACQQhqIgEgATUCACAJfiAHQiCIfCIHPgIAIAJBDGoiASABNQIAIAl+IAdCIIh8Igc+AgAgB0IgiCEIIAJBEGohAiAFQQRrIgUNAAsLIAYEQANAIAIgAjUCACAJfiAIfCIHPgIAIAJBBGohAiAHQiCIIQggBkEBayIGDQALCyAAIAdCgICAgBBaBH8gA0EoRg0DIAAgA0ECdGogCD4CACADQQFqBSADCzYCoAEPCwJAIAFBCHEEQCAAKAKgASIDQSlPDQICQCADRQRAQQAhAwwBCyADQQFrQf////8DcSICQQFqIgVBA3EhBgJAIAJBA0kEQEIAIQcgACECDAELIAVB/P///wdxIQVCACEHIAAhAgNAIAIgAjUCAELh6xd+IAd8Igc+AgAgAkEEaiIEIAQ1AgBC4esXfiAHQiCIfCIHPgIAIAJBCGoiBCAENQIAQuHrF34gB0IgiHwiBz4CACACQQxqIgQgBDUCAELh6xd+IAdCIIh8Igg+AgAgCEIgiCEHIAJBEGohAiAFQQRrIgUNAAsLIAYEQANAIAIgAjUCAELh6xd+IAd8Igg+AgAgAkEEaiECIAhCIIghByAGQQFrIgYNAAsLIAhCgICAgBBUDQAgA0EoRg0CIAAgA0ECdGogBz4CACADQQFqIQMLIAAgAzYCoAELIAFBEHEEQCAAQZjiwABBAhB4CyABQSBxBEAgAEGg4sAAQQMQeAsgAUHAAHEEQCAAQaziwABBBRB4CyABQYABcQRAIABBwOLAAEEKEHgLIAFBgAJxBEAgAEHo4sAAQRMQeAsgACABEE8aDwsMAQsgA0EoQZCPwQAQrAMAC0EoQShBkI/BABCdAgALtwkCA34Hf0GowsIAKAIARQRAEDALAkACQEGwwsIAKAIARQRAQbDCwgBBfzYCAEG8wsIAKAIAIgVB0MLCACkDACIBIACthSICQjiGIAJCgP4Dg0IohoQgAkKAgPwHg0IYhiACQoCAgPgPg0IIhoSEIAFCCIhCgICA+A+DIAFCGIhCgID8B4OEIAFCKIhCgP4DgyABQjiIhISEQtKBqpur+oLXp39+IgFCOIYgAUKA/gODQiiGhCABQoCA/AeDQhiGIAFCgICA+A+DQgiGhIQgAUIIiEKAgID4D4MgAUIYiEKAgPwHg4QgAUIoiEKA/gODIAFCOIiEhIQgAkLYotHvwqnlvy1+hSIBQjiGIAFCgP4Dg0IohoQgAUKAgPwHg0IYhiABQoCAgPgPg0IIhoSEIAFCCIhCgICA+A+DIAFCGIhCgID8B4OEIAFCKIhCgP4DgyABQjiIhISEQcjCwgApAwAiAkJ/hX4iA0I4hiADQoD+A4NCKIaEIANCgID8B4NCGIYgA0KAgID4D4NCCIaEhCADQgiIQoCAgPgPgyADQhiIQoCA/AeDhCADQiiIQoD+A4MgA0I4iISEhCABIAJCOIYgAkKA/gODQiiGhCACQoCA/AeDQhiGIAJCgICA+A+DQgiGhIQgAkIIiEKAgID4D4MgAkIYiEKAgPwHg4QgAkIoiEKA/gODIAJCOIiEhIR+hSABiSIBp3EhBCABQhmIQv8Ag0KBgoSIkKDAgAF+IQNBuMLCACgCACIGQShrIQgCQANAAkAgBCAGaikAACICIAOFIgFCf4UgAUKBgoSIkKDAgAF9g0KAgYKEiJCgwIB/gyIBUEUEQANAIAAgCEEAIAF6p0EDdiAEaiAFcSIJayIKQShsaigCAEYNAiABQgF9IAGDIgFQRQ0ACwsgAiACQgGGg0KAgYKEiJCgwIB/g1BFDQIgBCAHQQhqIgdqIAVxIQQMAQsLQYABIQAgBiAJQShsQShtIgRqIgcpAAAiASABQgGGg0KAgYKEiJCgwIB/g3qnQQN2IAYgBEEIayAFcWoiBCkAACIBIAFCAYaDQoCBgoSIkKDAgH+DeadBA3ZqQQdNBEBBwMLCAEHAwsIAKAIAQQFqNgIAQf8BIQALIAcgADoAACAEQQhqIAA6AABBxMLCAEHEwsIAKAIAQQFrNgIAIAYgCkEobGoiAEEkaygCACIEQYCAgIB4Rg0AIABBCGsoAgAhBiAAQQxrKAIAIQUgAEEUaygCACEHIABBGGsoAgAhCCAEBEAgAEEgaygCACIAQQRrKAIAIglBeHEiCiAEQQR0IgRBBEEIIAlBA3EiCRtySQ0DIAlBACAKIARBJ2pLGw0EIAAQWwsgCARAIAdBBGsoAgAiAEF4cSIEIAhBAnQiCEEEQQggAEEDcSIAG2pJDQMgAEEAIAQgCEEnaksbDQQgBxBbCyAFRQ0AIAZBBGsoAgAiAEF4cSIEIAVBAnQiBUEEQQggAEEDcSIAG2pJDQIgAEEAIAQgBUEnaksbDQMgBhBbC0GwwsIAQbDCwgAoAgBBAWo2AgAPC0HMncAAELgCAAtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgAL6AkCBX0JfyACQQJ0IgogACgCKCIMSwRAIAogDCILayINIAAoAiAgC2tLBEAgAEEgaiALIA1BBEEEENkBIAAoAighCwsgACgCJCIPIAtBAnRqIQ4gDUECTwR/IAogDEF/c2pBAnQiDARAIA5BACAM/AsACyALIA1qIgxBAWshCyAPIAxBAnRqQQRrBSAOC0EANgIAIAtBAWohCgsgACAKNgIoAkACQAJAAkAgACgCAEEBRw0AIAJBAXQiDyAKSw0BIAAoAiQhDCACBEBDAAD8QiAAKgJYIgYgACoCVCIFk5UhByAFIAaSQwAAAD+UIQYgAkEkbCERIAwhC0EJIQ5BACENA0AgBCAOSQ0EIA0gEUYNBUMAAHxCQwAAfMIgByADIA1qIgpBIGoqAgAgBpOUIgUgBUMAAHzCXRsiBSAFQwAAfEJeGxCtAiEFQwAAfEJDAAB8wiAHIApBHGoqAgAgBpOUIgggCEMAAHzCXRsiCCAIQwAAfEJeGxCtAiEIQwAAfEJDAAB8wiAHIApBEGoqAgAgBpOUIgkgCUMAAHzCXRsiCSAJQwAAfEJeGxCtAiEJIAtBBGpB/wAgCPwAQYB/IAhDAAAAw2AbIAhDAAD+Ql4bQQAgCCAIWxtB/wBxQRF0Qf8AIAX8AEGAfyAFQwAAAMNgGyAFQwAA/kJeG0EAIAUgBVsbQf8AcUEYdHJB/wBDAAB8QkMAAHzCIAcgCkEUaioCACAGk5QiBSAFQwAAfMJdGyIFIAVDAAB8Ql4bEK0CIgX8AEGAfyAFQwAAAMNgGyAFQwAA/kJeG0EAIAUgBVsbQf8AcUEDdEH/ACAJ/ABBgH8gCUMAAADDYBsgCUMAAP5CXhtBACAJIAlbGyISQfAAcUEEdnJB/wBDAAB8QkMAAHzCIAcgCkEYaioCACAGk5QiBSAFQwAAfMJdGyIFIAVDAAB8Ql4bEK0CIgX8AEGAfyAFQwAAAMNgGyAFQwAA/kJeG0EAIAUgBVsbQf8AcUEKdHJyNgIAIAtB/wBDAAB8QkMAAHzCIAcgCioCACAGk5QiBSAFQwAAfMJdGyIFIAVDAAB8Ql4bEK0CIgX8AEGAfyAFQwAAAMNgGyAFQwAA/kJeG0EAIAUgBVsbQf8AcUH/AEMAAHxCQwAAfMIgByAKQQRqKgIAIAaTlCIFIAVDAAB8wl0bIgUgBUMAAHxCXhsQrQIiBfwAQYB/IAVDAAAAw2AbIAVDAAD+Ql4bQQAgBSAFWxtB/wBxQQd0ckH/AEMAAHxCQwAAfMIgByAKQQhqKgIAIAaTlCIFIAVDAAB8wl0bIgUgBUMAAHxCXhsQrQIiBfwAQYB/IAVDAAAAw2AbIAVDAAD+Ql4bQQAgBSAFWxtB/wBxQQ50ckH/AEMAAHxCQwAAfMIgByAKQQxqKgIAIAaTlCIFIAVDAAB8wl0bIgUgBUMAAHxCXhsQrQIiBfwAQYB/IAVDAAAAw2AbIAVDAAD+Ql4bQQAgBSAFWxtB/wBxQRV0ciASQRx0cjYCACALQQhqIQsgEEECaiEQIA5BCWohDiARIA1BJGoiDUcNAAsLIAAoAgQgAUEBdCABIAJqQQF0EPoCIgAgDCAPEIECIABBhAFJDQAgABC1AgsPCyAPIApBgMDAABCsAwALIA4gBEG4psIAEKwDAAsgECAPQcimwgAQnQIAC/AIAQp/AkAgAUGACkkEQCABQQV2IQYCQAJAIAAoAqABIgUEQCAFQQFrIQMgBUECdCAAakEEayEEIAUgBmpBAnQgAGpBBGshAiAFQSlJIQUDQCAFRQ0CIAMgBmoiB0EoTw0DIAIgBCgCADYCACACQQRrIQIgBEEEayEEIANBAWsiA0F/Rw0ACwsgAUEgSQ0DIABBADYCACAGQQFqIgJBAkYNAyAAQQA2AgQgAkEDRg0DIABBADYCCCACQQRGDQMgAEEANgIMIAJBBUYNAyAAQQA2AhAgAkEGRg0DIABBADYCFCACQQdGDQMgAEEANgIYIAJBCEYNAyAAQQA2AhwgAkEJRg0DIABBADYCICACQQpGDQMgAEEANgIkIAJBC0YNAyAAQQA2AiggAkEMRg0DIABBADYCLCACQQ1GDQMgAEEANgIwIAJBDkYNAyAAQQA2AjQgAkEPRg0DIABBADYCOCACQRBGDQMgAEEANgI8IAJBEUYNAyAAQQA2AkAgAkESRg0DIABBADYCRCACQRNGDQMgAEEANgJIIAJBFEYNAyAAQQA2AkwgAkEVRg0DIABBADYCUCACQRZGDQMgAEEANgJUIAJBF0YNAyAAQQA2AlggAkEYRg0DIABBADYCXCACQRlGDQMgAEEANgJgIAJBGkYNAyAAQQA2AmQgAkEbRg0DIABBADYCaCACQRxGDQMgAEEANgJsIAJBHUYNAyAAQQA2AnAgAkEeRg0DIABBADYCdCACQR9GDQMgAEEANgJ4IAJBIEYNAyAAQQA2AnwgAkEhRg0DIABBADYCgAEgAkEiRg0DIABBADYChAEgAkEjRg0DIABBADYCiAEgAkEkRg0DIABBADYCjAEgAkElRg0DIABBADYCkAEgAkEmRg0DIABBADYClAEgAkEnRg0DIABBADYCmAEgAkEoRg0DIABBADYCnAEgAkEpRg0DQShBKEGQj8EAEJ0CAAsgA0EoQZCPwQAQnQIACyAHQShBkI/BABCdAgALQbqPwQBBHUGQj8EAEMQCAAsgACgCoAEiAyAGaiECIAFBH3EiB0UEQCAAIAI2AqABIAAPCwJAIAJBAWsiBEEnTQRAIAIhBSAAIARBAnRqKAIAQQAgAWsiAXYiBEUNASACQSdNBEAgACACQQJ0aiAENgIAIAJBAWohBQwCCyACQShBkI/BABCdAgALIARBKEGQj8EAEJ0CAAsCQCAGQQFqIgogAk8NACABQR9xIQgCQCADQQFrIglBBEkEQCACIQQMAQsgAiAJQXxxIgFrIQQgAkECdCAAakEUayEDIAEhAgNAIANBBGoiCyAD/QACACAI/a0BIAv9AAIAIAf9qwH9UP0LAgAgA0EQayEDIAJBBGsiAg0ACyABIAlGDQELIARBAnQgAGpBCGshAwNAIANBBGoiASABKAIAIAd0IAMoAgAgCHZyNgIAIANBBGshAyAKIARBAWsiBEkNAAsLIAAgBkECdGoiASABKAIAIAd0NgIAIAAgBTYCoAEgAAvnCAIOfwF+IwBBEGsiDCQAIAwgABB0AkAgDCgCDCIKBEAgCigCACIIIAooAgQiCyAMKAIAIglxIgZqKQAAQoCBgoSIkKDAgH+DIhJQBEBBCCEEA0AgBCAGaiEAIARBCGohBCAIIAAgC3EiBmopAABCgIGChIiQoMCAf4MiElANAAsLIAwoAgghBSAIIBJ6p0EDdiAGaiALcSIGaiwAACIEQQBOBEAgCCAIKQMAQoCBgoSIkKDAgH+DeqdBA3YiBmotAAAhBAsgBiAIaiAJQRl2IgA6AAAgCCAGQQhrIAtxakEIaiAAOgAAIAogCigCCCAEQQFxazYCCCAKIAooAgxBAWo2AgwgCCAGQVhsaiIHQQRrQQA2AgAgB0EMa0KAgICAwAA3AgAgB0EUa0IENwIAIAdBHGtCADcCACAHQSRrQoCAgIDAADcCACAHQShrIAU2AgAMAQsgDCgCACEHC0EAIQBBgMPCACgCAEUEQEH4wsIAKAIAQf//A00EQEH4wsIAQQBBgIAEQQRBBBDZAUGAw8IAKAIAIQALQfzCwgAoAgAgAEECdGoiBUEAQfz/D/wLAEGAw8IAIABBgIAEajYCACAFQfz/D2pBADYCAAsgASACaiIJIAdBHGsiDigCACILSwRAIAkgCyIFQQF0IgAgACAJSRsiCCAFayIEIAdBJGsiACgCACAFa0sEQCAAIAUgBEEEQRAQ2QEgDigCACEFCyAHQSBrKAIAIQogBEEDcSIJBEAgBSAJaiEGIAogBUEEdGohACAJIQQDQCAAQgA3AgAgAEEGakIANwEAIABBEGohACAEQQFrIgQNAAsgCCAJIAtqayEEIAYhBQsgCyAIa0F8TQRAIAogBUEEdGohACAFIQYDQCAAQgA3AgAgAEEGakIANwEAIABBEGpCADcCACAAQRZqQgA3AQAgAEEgakIANwIAIABBJmpCADcBACAAQTBqQgA3AgAgAEE2akIANwEAIABBQGshACAGQQRqIQYgBEEEayIEDQALCyAOIAY2AgALIAIEQCABQQR0IQogB0EgayELQQAhAANAAkBBgIABIAIgACIFayIAIABBgIABTxsiBEECdCIJQYDDwgAoAgAiAE0EQEH8wsIAKAIAIRAgAyAFQQJ0IAQgBWoiAEECdBD6AiIGIBAgCRCEAiAGQYQBTwRAIAYQtQILIAIgBUYNASABIAVqIQcgCiAFQQR0aiEJQQEgBCAEQQFNG0EEdCEGQQAhBANAIA4oAgAiBSAHSwRAIAQgEGoiDygCACERIA9BBGooAgAhCCAPQQhqKAIAIQUgCygCACAJaiAEaiINIA9BDGooAgA2AgAgDUEMaiAFOwEAIA1BCmogCEEQdjsBACANQQhqIAg7AQAgDUEGaiARQRB2OwEAIA1BBGogETsBACAHQQFqIQcgBEEQaiIEIAZHDQEMAwsLIAcgBUHQwsAAEJ0CAAsgCSAAQcDCwAAQrAMACyAAIAJJDQALCyAMQRBqJAALkQgCFH8CfiMAQYAEayILJAAgC0EAQYAE/AsAAkAgACgCDCIRRQRAIAEoAgAgACgCACAAKAIEIAEoAgQoAgwRAAAhAAwBCyAAKAIAIQ0gACgCCCIOLQAAIQwCQAJAIAAoAgQiD0UNACANIA9qIQggCyEDIA0hAANAAn8gACwAACIHQQBOBEAgB0H/AXEhBSAAQQFqDAELIAAtAAFBP3EhBCAHQR9xIQogB0FfTQRAIApBBnQgBHIhBSAAQQJqDAELIAAtAAJBP3EgBEEGdHIhBCAHQXBJBEAgBCAKQQx0ciEFIABBA2oMAQsgCkESdEGAgPAAcSAALQADQT9xIARBBnRyciIFQYCAxABGDQIgAEEEagshACACQYABRg0CIAMgBTYCACADQQRqIQMgAkEBaiECIAAgCEcNAAsLIA4gEWohEiACQQJ0IgcgC2pBBGshCkG8BSETQcgAIRQgDiEJQYABIQgDQCAJQQFqIQlBACEDQSQhAEEBIRVBASEGQQAhBQNAAkAgA0EBcQRAIAkgEkYNBCAJLQAAIQMgCUEBaiEJDAELIAwhAyAVRQ0DCyADQeEAayIEQf8BcUEaTwRAIANBMGtB/wFxQQlLDQMgA0EWayEECyAGrSIXIARB/wFxIgatfiIWQiCIpw0CIBanIAVqIgQgBUkNAiAGQRpBASAAIBRrIgNBACAAIANPGyIDIANBAU0bIgMgA0EaTxsiA08EQCAAQSRqIQAgF0EkIANrrX4iFqchBkEAIRVBASEDIAQhBSAWQiCIUA0BDAMLCyAEIBBqIgUgEEkNASAIIAUgAkEBaiIDbiIMIAhqIghLIAhBgLADc0GAgMQAa0GAkLx/SXIgCEGAgMQARiACQf8AS3JyDQEgCiEAAkAgBSADIAxsayIGIAJPBEAgBkGAAUkNASAGQYABQYiGwgAQnQIACwNAIABBBGogACgCADYCACAAQQRrIQAgAkEBayICIAZLDQALCyALIAZBAnRqIAg2AgAgCSASRwRAIAktAAAhDEEAIQICQCAEIBNuIgAgA24gAGoiAEHIA0kEQCAAIQQMAQsDQCACQSRqIQIgAEHX/ABLIABBI24iBCEADQALCyAGQQFqIRAgAiAEQSRsQfz/A3EgBEEmakH//wNxbmohFCAKQQRqIQogB0EEaiEHQQIhEyADIQIMAQsLIAshAgNAIAIoAgAgARDXASIADQIgAkEEaiECIAciA0EEayEHIAMNAAsMAQtBASEAIAEoAgAiAkGYhsIAQQkgASgCBCgCDCIBEQAADQAgDwRAIAIgDSAPIAERAAANASACQaGGwgBBASABEQAADQELIAIgDiARIAERAAANACACQaKGwgBBASABEQAAIQALIAtBgARqJAAgAAvyBwIFfwN+IAEoAgAiAkH///8DcSEFIAJBgICAgHhxIQYgASgCBCEDAn4gBkEQdiAFQQ12ciAFQQBHQQl0ckGA+AFyrSACQYCAgPwHcSIEQYCAgPwHRg0AGiAGQRB2IQYCQCAEQYCAgLgETQRAIARBDXYgBUENdmpBgIABaiAGcq0gAkEMdiACQf/fAHFBAEdxrXwgBEGAgIDEA08NAhogBEGAgICYA0kNASAFQYCAgARyIgJBHiAEQRd2IgVrdiEEIAJBHSAFayIFdkEBcQR/IARBAyAFdEEBayACcUEAR2oFIAQLIAZyrQwCCyAGQYD4AXKtDAELIAatCyEHIAEoAgghBCADQf///wNxIQUgA0GAgICAeHEhBgJ+IANBgICA/AdxIgJBgICA/AdHBEAgBkEQdiEGIAJBgICAuARNBEAgAkENdiAFQQ12akGAgAFqIAZyrSADQQx2IANB/98AcUEAR3GtfCACQYCAgMQDTw0CGiACQYCAgJgDTwRAIAVBgICABHIiBUEeIAJBF3YiAmt2IQMgBUEdIAJrIgJ2QQFxBH8gA0EDIAJ0QQFrIAVxQQBHagUgAwsgBnKtDAMLIAatDAILIAZBgPgBcq0MAQsgBkEQdiAFQQ12ciAFQQBHQQl0ckGA+AFyrQshCCABKAIMIQEgBEH///8DcSECIARBgICAgHhxIQUCfiAEQYCAgPwHcSIDQYCAgPwHRwRAIAVBEHYhBSADQYCAgLgETQRAIANBDXYgAkENdmpBgIABaiAFcq0gBEEMdiAEQf/fAHFBAEdxrXwgA0GAgIDEA08NAhogA0GAgICYA08EQCACQYCAgARyIgRBHiADQRd2IgJrdiEDIARBHSACayICdkEBcQR/IANBAyACdEEBayAEcUEAR2oFIAMLIAVyrQwDCyAFrQwCCyAFQYD4AXKtDAELIAVBEHYgAkENdnIgAkEAR0EJdHJBgPgBcq0LIQkgAUH///8DcSEEIAFBgICAgHhxIQIgACAHQv//A4MgCEIQhkKAgPz/D4MgCUIghkKAgICA8P8/gwJ+IAFBgICA/AdxIgNBgICA/AdHBEAgAkEQdiECIANBgICAuARNBEAgA0ENdiAEQQ12akGAgAFqIAJyrSABQQx2IAFB/98AcUEAR3GtfCADQYCAgMQDTw0CGiADQYCAgJgDTwRAIARBgICABHIiBEEeIANBF3YiA2t2IQEgBEEdIANrIgN2QQFxBH8gAUEDIAN0QQFrIARxQQBHagUgAQsgAnKtDAMLIAKtDAILIAJBgPgBcq0MAQsgAkEQdiAEQQ12ciAEQQBHQQl0ckGA+AFyrQtCMIaEhIQ3AxALqBADB38CfgF7IwBBIGsiBSQAAkACQCAAKAIAIgJFBEAgACgCECIARQ0BIABBrYnCAEEBEIQBIQIMAgsCQAJAAkACQAJAAkACQCAAKAIIIgQgACgCBCIGTwRAIAAoAhAiAkUNASACQYSJwgBBEBCEAUUNAQwHCyAAIARBAWoiATYCCCAFQQhqIAIgBGotAAAiAxC8AiAFKAIIIgcEQCAAKAIQIgBFDQggACAHIAUoAgwQhAEhAgwJCyAAIAAoAgxBAWoiBzYCDCAHQfUDTwRAIAAoAhAiAgRAIAJBlInCAEEZEIQBDQgLIABBAToABAwGCwJAAkACQAJAAkACQAJAAkACQAJAAkACQCADQcEAaw4UAgYOBQ4EDg4ODg4ODg4BAQAAAgMOCyAAKAIQIgQEQEEBIQIgBEGMhMIAQQEQhAENFCAAKAIAIgJFDQggACgCBCEGIAAoAgghAQsgASAGTw0HIAEgAmotAABBzABHDQcgACABQQFqNgIIIAVBEGogABC5ASAFLQAQRQ0GIAUtABEhASAAKAIQIgMEQEEBIQIgA0GUicIAQYSJwgAgAUEBcSIDG0EZQRAgAxsQhAENFAsgACABOgAEDBALIAAoAhAiAQRAQQEhAiABQY2EwgBBARCEAQ0TCyADQdAARw0HIAAoAhAiAkUNCCACQdGJwgBBBhCEAQ0QDAgLIAAoAhAiAQRAQQEhAiABQbeJwgBBARCEAQ0SC0EBIQIgABBTDREgA0HBAEYEQCAAKAIQIgEEQCABQdeJwgBBAhCEAQ0TCyAAQQEQQw0SCyAAKAIQIgFFDQ0gAUG4icIAQQEQhAENEQwNCyAAKAIQIgEEQEEBIQIgAUGJhMIAQQEQhAENEQsgBSAAEIACQQEhAiAFKAIAQQFxDRAgBSgCBEEBRgRAIAAoAhAiAUUNDSABQYiEwgBBARCEAQ0RCyAAKAIQIgFFDQwgAUHauMIAQQEQhAENEAwMC0EAIQIjAEEQayIBJAACQAJAAkACQCAAKAIARQRAIAAoAhAiAw0BDAQLIAEgAEHHABD8ASABLQAAQQFGBEAgAS0AASEDIAAoAhAiBARAQQEhAiAEQZSJwgBBhInCACADQQFxIgQbQRlBECAEGxCEAQ0FCyAAIAM6AARBACECIABBADYCAAwECyAAKAIQIgIEQCABKQMIIglQDQMgAkGvicIAQQQQhAENAgNAIAggCVEEQCAAKAIQIgNFDQVBASECIANBs4nCAEECEIQBRQ0FDAYLAkAgCFANACAAKAIQIgJFDQAgAkG1icIAQQIQhAENBAtBASECIAAgACgCFEEBajYCFCAIQgF8IQggAEIBEPABRQ0ACwwECyAAEGchAgwDCyADQa2JwgBBARCEASECDAILQQEhAgwBCyAAEGchAiAAIAAoAhQgCadrNgIUCyABQRBqJAAgAg0NDAsLIAAoAhAiAgRAIAJB2YnCAEEEEIQBDQ0LQQEhAkEAIQEjAEEQayIDJAACQAJAAkACQCAAKAIARQRAIAAoAhAiBA0BDAQLIAMgAEHHABD8ASADLQAAQQFGBEAgAy0AASEEIAAoAhAiBgRAQQEhASAGQZSJwgBBhInCACAEQQFxIgYbQRlBECAGGxCEAQ0FCyAAIAQ6AARBACEBIABBADYCAAwECyAAKAIQIgEEQCADKQMIIglQDQMgAUGvicIAQQQQhAENAgNAIAggCVEEQCAAKAIQIgRFDQVBASEBIARBs4nCAEECEIQBRQ0FDAYLAkAgCFANACAAKAIQIgFFDQAgAUG1icIAQQIQhAENBAtBASEBIAAgACgCFEEBajYCFCAIQgF8IQggAEIBEPABRQ0ACwwECyAAEJkBIQEMAwsgBEGticIAQQEQhAEhAQwCC0EBIQEMAQsgABCZASEBIAAgACgCFCAJp2s2AhQLIANBEGokACABQQFxDQ4gACgCACIDRQ0FIAAoAggiASAAKAIETw0FIAEgA2otAABBzABHDQUgACABQQFqNgIIIAVBEGogABC5ASAFLQAQRQ0HIAUtABEhASAAKAIQIgMEQCADQZSJwgBBhInCACABQQFxIgMbQRlBECADGxCEAQ0PCyAAIAE6AAQMCwsjAEEgayICJAACQAJAIAAoAgBFBEAgACgCECIBRQ0BIAFBrYnCAEEBEIQBIQEMAgsgAiAAEP0BIAIoAgBFBEAgACgCECIDBEBBASEBIANBlInCAEGEicIAIAItAARBAXEiAxtBGUEQIAMbEIQBDQMLIAAgAv0AAgD9CwIADAELIAAoAhBFDQAgAP0AAgAhCiAAIAL9AAIA/QsCACACIAr9CwMQIAAQUyEBIAAgAv0AAxD9CwIADAELQQAhAQsgAkEgaiQAIAENCwwJCyAFKQMYIghQDQAgACAIEPABDQogACgCECIBRQ0AQQEhAiABQcyJwgBBARCEAQ0MCyADQdIARg0GIAAoAhAiAkUNBiACQc2JwgBBBBCEAQ0JDAYLIAAoAhAiAkUNACACQc2JwgBBBBCEAQ0ICyAAEFMNBwwFCyAAKAIQIgFFDQAgAUGEicIAQRAQhAENCAtBACECIABBADoABCAAQQA2AgAMBwsgBSkDGCIIUA0CIAAoAhAiAgRAIAJB3YnCAEEDEIQBDQULIAAgCBDwAQ0EDAILIAAgBDYCCCAAQQAQQQ0DDAELIAAQUw0CC0EAIQIgACgCAEUNAyAAIAAoAgxBAWs2AgwMAwtBACECIABBADYCAAwCC0EBIQIMAQtBACECCyAFQSBqJAAgAguUCAIFfwF9IAEoAgAiCUH///8DcSEGIAlBgICAgHhxIQoCQCAJQYCAgPwHcSIHQYCAgPwHRgRAIApBEHYgBkENdnIgBkEAR0EJdHJBgPgBciEKDAELIApBEHYhCiAHQYCAgLgETQRAIAdBgICAxANPBEAgCUEMdiAJQf/fAHFBAEdxIAdBDXYgBkENdmpBgIABaiAKcmohCgwCCyAHQYCAgJgDSQ0BIAZBgICABHIiCUEeIAdBF3YiBmt2IQcgCUEdIAZrIgZ2QQFxBH8gB0EDIAZ0QQFrIAlxQQBHagUgBwsgCnIhCgwBCyAKQYD4AXIhCgsgASgCBCIGQf///wNxIQggBkGAgICAeHEhCQJAIAZBgICA/AdxIgdBgICA/AdHBEAgCUEQdiEJIAdBgICAuARNBEAgB0GAgIDEA08EQCAGQQx2IAZB/98AcUEAR3EgB0ENdiAIQQ12akGAgAFqIAlyaiEJDAMLIAdBgICAmANJDQIgCEGAgIAEciIGQR4gB0EXdiIIa3YhByAGQR0gCGsiCHZBAXEEfyAHQQMgCHRBAWsgBnFBAEdqBSAHCyAJciEJDAILIAlBgPgBciEJDAELIAlBEHYgCEENdnIgCEEAR0EJdHJBgPgBciEJCyABKAIIIgZB////A3EhCCAGQYCAgIB4cSEHAkAgBkGAgID8B3EiAUGAgID8B0cEQCAHQRB2IQcgAUGAgIC4BE0EQCABQYCAgMQDTwRAIAZBDHYgBkH/3wBxQQBHcSABQQ12IAhBDXZqQYCAAWogB3JqIQcMAwsgAUGAgICYA0kNAiAIQYCAgARyIgZBHiABQRd2IghrdiEBIAZBHSAIayIIdkEBcQR/IAFBAyAIdEEBayAGcUEAR2oFIAELIAdyIQcMAgsgB0GA+AFyIQcMAQsgB0EQdiAIQQ12ciAIQQBHQQl0ckGA+AFyIQcLIAJDAACAPxD5AiECIAMqAgghCyACIAKSIAMqAgAgAyoCBBD5AiALEPkClLwiBkH///8DcSEIIAZBgICAgHhxIQMCQCAGQYCAgPwHcSIBQYCAgPwHRgRAIANBEHYgCEENdnIgCEEAR0EJdHJBgPgBciEDDAELIANBEHYhAyABQYCAgLgETQRAIAFBgICAxANPBEAgBkEMdiAGQf/fAHFBAEdxIAFBDXYgCEENdmpBgIABaiADcmohAwwCCyABQYCAgJgDSQ0BIAhBgICABHIiBkEeIAFBF3YiCGt2IQEgBkEdIAhrIgh2QQFxBH8gAUEDIAh0QQFrIAZxQQBHagUgAQsgA3IhAwwBCyADQYD4AXIhAwsgACAFNgIMIAAgBEH//wNxNgIIIAAgB0H//wNxIANBEHRyNgIEIAAgCkH//wNxIAlBEHRyNgIAC/4HAhN/AX4CQAJAAkACQCABKAIAQQFGBEAgASgCHCIFIAEoAjQiBEcEQCABKAIwIQsgBCEDIAUgASgCPCIIQQFrIhBqIgIgBE8NAiABKAI4IQ0gBSALaiERIAUgCGohBiABKAIYIgMgBWohDiAIIANrIRIgBSABKAIQIgxrQQFqIRMgASkDCCEVIAEoAiQiD0F/RiEJIA8hByAFIQMDQCADIAVHDQMCQAJAIBUgAiALajEAAIinQQFxRQRAIAEgBjYCHCAGIQMgCQ0CQQAhAgwBCyAMIAcgDCAHIAxLGyAJGyIKIAggCCAKSRshFCAKIQMCQAJAAkADQCADIgIgFEYEQEEAIAcgCRshCiAMIQIDQCACIApNBEAgASAGNgIcIA9Bf0cEQCABQQA2AiQLIAAgBjYCCCAAIAU2AgQgAEEANgIADwsgAkEBayICIAhPDQUgAiAFaiIDIARPDQMgAiANai0AACADIAtqLQAARg0ACyABIA42AhwgEiECIA4hAyAJRQ0FDAYLIAIgBWogBE8NAiACQQFqIQMgAiANai0AACACIBFqLQAARg0ACyACIBNqIQMgCQ0EQQAhAgwDCyADIARB0IDCABCdAgALIAQgBSAKaiIAIAAgBEkbIARB4IDCABCdAgALIAIgCEHAgMIAEJ0CAAsgASACNgIkIAIhBwsgAyAQaiICIARJDQALIAQhAwwDCyAAQQI2AgAPCwJAIAEtAA5FBEAgASABLQAMIgVBAXM6AAwgASgCNCECIAEoAjAhBCABKAIEIgNFDQECQCACIANNBEAgAiADRw0BDAMLIAMgBGosAABBv39KDQILIAQgAiADIAJB7IHCABCVAwALIABBAjYCAA8LAkACQCACIANHBEACfyADIARqIgQsAAAiAkEATgRAIAJB/wFxDAELIAQtAAFBP3EhBiACQR9xIQcgB0EGdCAGciACQV9NDQAaIAQtAAJBP3EgBkEGdHIhBiAGIAdBDHRyIAJBcEkNABogB0ESdEGAgPAAcSAELQADQT9xIAZBBnRycgshBEEBIQIgBUEBcUUNAQwCCyAFQQFxDQEgAEECNgIAIAFBAToADg8LAkAgBEGAAUkNAEECIQIgBEGAEEkNAEEDQQQgBEGAgARJGyECCyAAIAM2AgQgAEEBNgIAIAAgAiADaiIANgIIIAEgADYCBA8LIAAgAzYCCCAAIAM2AgQgAEEANgIADwsgA0UNAQsgAyECA0ACQCACIARPBEAgAiAERg0EDAELIAIgC2osAABBv39MDQAgAiEEDAMLIAJBAWoiAg0ACwtBACEECyAAIAQ2AgggACAFNgIEIABBATYCACABIAMgBCADIARLGzYCHAv6CAMFfwN7AX0gAC8BBiEEAn8gAC8BBCIFQf//AXFFBEAgBUEQdAwBCyAFQf8HcSEHIAVBgIACcSEGIAVBgPgBcSIFQYD4AUYEQCAGQRB0IQUgBUGAgID8B3IgB0UNARogBSAHQQ10ckGAgID+B3IMAQsgBkEQdCEGIAVBDXRBgICA/ABxIAdBDXRyQYCAgMADaiAGciAFDQAaIAcgB2dBEGsiB0H//wNxQQhqdEH///8DcSAGQYCAgNgDciAHQRd0a3ILIQcgAC8BCCEFAn8gBEH//wFxBEAgBEH/B3EhBiAEQYCAAnEhCCAEQYD4AXEiBEGA+AFHBEAgCEEQdCEIIARBDXRBgICA/ABxIAZBDXRyQYCAgMADaiAIciAEDQIaIAYgBmdBEGsiBEH//wNxQQhqdEH///8DcSAIQYCAgNgDciAEQRd0a3IMAgsgCEEQdCEEIAQgBkENdHJBgICA/gdyIAYNARogBEGAgID8B3IMAQsgBEEQdAshBAJ/IAVB//8BcQRAIAVB/wdxIQYgBUGAgAJxIQggBUGA+AFxIgVBgPgBRwRAIAhBEHQhCCAFQQ10QYCAgPwAcSAGQQ10ckGAgIDAA2ogCHIgBQ0CGiAGIAZnQRBrIgVB//8DcUEIanRB////A3EgCEGAgIDYA3IgBUEXdGtyDAILIAhBEHQhBSAFIAZBDXRyQYCAgP4HciAGDQEaIAVBgICA/AdyDAELIAVBEHQL/REgB/0cACAE/RwBIAH9AAQA/eUBIQkCfyAALwEKIgRB//8BcUUEQCAEQRB0DAELIARB/wdxIQAgBEGAgAJxIQcgBEGA+AFxIgRBgPgBRgRAIAdBEHQhBCAEQYCAgPwHciAARQ0BGiAEIABBDXRyQYCAgP4HcgwBCyAHQRB0IQcgBEENdEGAgID8AHEgAEENdHJBgICAwANqIAdyIAQNABogB0GAgIDYA3IgAGdBEGsiBEEXdGsgACAEQf//A3FBCGp0Qf///wNxcgshACABKgJQAn0gCSAB/QAEEP3mASIKIAn9DQgJCgsAAQIDAAECAwABAgMgCiAKIAn9DQQFBgcAAQIDAAECAwABAgP95AH95AEiCv0fAEMAAAAAX0UEQCAJIAH9AAQg/eYBIgsgCf0NCAkKCwABAgMAAQIDAAECAyALIAsgCf0NBAUGBwABAgMAAQIDAAECA/3kAf3kASAK/ecB/R8AIAKViyAJIAH9AAQw/eYBIgsgCf0NCAkKCwABAgMAAQIDAAECAyALIAsgCf0NBAUGBwABAgMAAQIDAAECA/3kAf3kASAK/ecB/R8AIAOVixD5AiECIAEqAlQhAyACQwAAgD9fRQRAIANDAACAvyAClSABKgJYIAOTlJIMAgtDAACAPyACQwAAgD8gA5OUkwwBCyABKgJYCyEDIAC+IAkgCf3mASIJIAn9DQgJCgsAAQIDAAECAwABAgMgCSAJIAn9DQQFBgcAAQIDAAECAwABAgP95AH95AH94wH9HwBDvTeGNRD5ApWUIAOUC7QKAgN8A38jAEEQayIFJAAgALshAQJAIAC8IgZB/////wdxIgRB25+k+gNPBEAgBEHSp+2DBE8EQCAEQdbjiIcETwRAAkACQAJAAkAgBEH////7B00EQCAFQgA3AwgCQCAEQdqfpO4ETQRAIAEgAUSDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCICRAAAAFD7Ifm/oqAgAkRjYhphtBBRvqKgIQEgAvwCIQQMAQsgBSAEIARBF3ZBlgFrIgRBF3Rrvrs5AwAgBSAFQQhqIAQQLyEEIAZBAE4EQCAFKwMIIQEMAQtBACAEayEEIAUrAwiaIQELIARBA3FBAWsOAwMEAQILIAAgAJMhAAwHCyABIAGiIgFEgV4M/f//37+iRAAAAAAAAPA/oCABIAGiIgJEQjoF4VNVpT+ioCABIAKiIAFEaVDu4EKT+T6iRCceD+iHwFa/oKKgtowhAAwGCyABIAEgAaIiAqIiAyACIAKioiACRKdGO4yHzcY+okR058ri+QAqv6CiIAEgAyACRLL7bokQEYE/okR3rMtUVVXFv6CioKC2IQAMBQsgASABoiIBRIFeDP3//9+/okQAAAAAAADwP6AgASABoiICREI6BeFTVaU/oqAgASACoiABRGlQ7uBCk/k+okQnHg/oh8BWv6CioLYhAAwECyABIAGiIgIgAZqiIgMgAiACoqIgAkSnRjuMh83GPqJEdOfK4vkAKr+goiADIAJEsvtuiRARgT+iRHesy1RVVcW/oKIgAaGgtiEADAMLIARB4Nu/hQRPBEBEGC1EVPshGcBEGC1EVPshGUAgBkEAThsgAaAiAiACIAKiIgGiIgMgASABoqIgAUSnRjuMh83GPqJEdOfK4vkAKr+goiACIAMgAUSy+26JEBGBP6JEd6zLVFVVxb+goqCgtiEADAMLIAZBAE4EQCABRNIhM3982RLAoCIBIAGiIgFEgV4M/f//37+iRAAAAAAAAPA/oCABIAGiIgJEQjoF4VNVpT+ioCABIAKiIAFEaVDu4EKT+T6iRCceD+iHwFa/oKKgtowhAAwDCyABRNIhM3982RJAoCIBIAGiIgFEgV4M/f//37+iRAAAAAAAAPA/oCABIAGiIgJEQjoF4VNVpT+ioCABIAKiIAFEaVDu4EKT+T6iRCceD+iHwFa/oKKgtiEADAILIARB5JfbgARPBEBEGC1EVPshCcBEGC1EVPshCUAgBkEAThsgAaAiAiACoiIBIAKaoiIDIAEgAaKiIAFEp0Y7jIfNxj6iRHTnyuL5ACq/oKIgAyABRLL7bokQEYE/okR3rMtUVVXFv6CiIAKhoLYhAAwCCyAGQQBOBEAgAUQYLURU+yH5v6AiASABoiIBRIFeDP3//9+/okQAAAAAAADwP6AgASABoiICREI6BeFTVaU/oqAgASACoiABRGlQ7uBCk/k+okQnHg/oh8BWv6CioLYhAAwCCyABRBgtRFT7Ifk/oCIBIAGiIgFEgV4M/f//37+iRAAAAAAAAPA/oCABIAGiIgJEQjoF4VNVpT+ioCABIAKiIAFEaVDu4EKT+T6iRCceD+iHwFa/oKKgtowhAAwBCyAEQYCAgMwDTwRAIAEgAaIiAiABoiIDIAIgAqKiIAJEp0Y7jIfNxj6iRHTnyuL5ACq/oKIgAyACRLL7bokQEYE/okR3rMtUVVXFv6CiIAGgoLYhAAwBCyAFIABDAACAA5QgAEMAAIB7kiAEQYCAgARJGzgCCCAFKgIIGgsgBUEQaiQAIAAL6AgBCX8jAEEgayIIJAAgBEF8cSIFIANqIQYCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAiADSSIHIAIgA2sgAyACayIJIAIgA0sbQQFGcUUEQCABQQNrIgVBACABIAVPGyIFIAYgBSAGSRshCiAHIAlBA0txDQEgAyAKSQ0CDA4LIAEgA0EBayICSwRAIAMgBksNAyABIAZJDQQgBQRAIAAgA2ogACACai0AACAF/AsACyAGQQFrIQUMDwsgAiABQdD4wQAQnQIACyADIApPDQwgAUEEayEHIAMhBgNAIAJBfEYNCCACQQRqIQUgAkF7Sw0JIAEgBUkNCiAGIAdLDQsgACAGaiAAIAJqKAAANgAAIAUhAiAKIAZBBGoiBksNAAsMDQsgACADaiELIAAgAmohDEEAIQUDQCADIAVqQQNqIAFPDQMgAiAFaiIGQQNqIAFPDQQgASAGTQ0FIAUgC2oiByAFIAxqIgktAAA6AAAgBkEBaiINIAFPDQYgB0EBaiAJQQFqLQAAOgAAIAEgBkECaiIGSwRAIAdBAmogCUECai0AADoAACAHQQNqIAlBA2otAAA6AAAgAyAFQQRqIgVqIgYgCk8NDAwBCwsgBiABQaj6wQAQnQIACyADIAZB4PjBABCtAwALIAYgAUHg+MEAEKwDAAtB8PjBAEEvQaD5wQAQxAIAC0Gw+cEAQcgAQfj5wQAQxAIACyAGIAFBiPrBABCdAgALIA0gAUGY+sEAEJ0CAAsjAEEgayIAJAAgAEEANgIYIABBATYCDCAAQYz+wAA2AgggAEIENwIQIABBCGpBjPDBABDaAgALIAIgBUHo/cEAEK0DAAsgBSABQej9wQAQrAMACyAIQQA2AhggCEEBNgIMIAhBhPDBADYCCCAIQgQ3AhAgCEEIakHo/cEAENoCAAsgAiAFaiEFDAELIAMhBiACIQULAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIARBA3FBAWsOAwABAg4LIAEgBUsNCiAFIAFBuPrBABCdAgALIAZBAWoiAiABTw0BIAVBAWoiAyABTw0CIAEgBU0NAyABIAZLDQogBiABQYD8wQAQnQIACyAGQQJqIgIgAU8NAyAFQQJqIgMgAU8NBCABIAVNDQUgASAGTQ0GIAAgBmogACAFai0AADoAACAFQQFqIgUgAU8NByAGQQFqIgYgAUkNCSAGIAFB2P3BABCdAgALQdj6wQBBL0GI+8EAEMQCAAtBmPvBAEHIAEHg+8EAEMQCAAsgBSABQfD7wQAQnQIAC0GQ/MEAQS9BwPzBABDEAgALQdD8wQBByABBmP3BABDEAgALIAUgAUGo/cEAEJ0CAAsgBiABQbj9wQAQnQIACyAFIAFByP3BABCdAgALIAEgBksEQCAFIQMgBiECDAILIAYgAUHI+sEAEJ0CAAsgACAGaiAAIAVqLQAAOgAACyAAIAJqIAAgA2otAAA6AAALIAhBIGokAAuMCgIDfAN/IwBBEGsiBSQAIAC7IQECfQJAAkAgALwiBkH/////B3EiBEHbn6T6A08EQCAEQdKn7YMETwRAIARB1uOIhwRPBEACQAJAAkACQCAEQf////sHTQRAIAVCADcDCAJAIARB2p+k7gRNBEAgASABRIPIyW0wX+Q/okQAAAAAAAA4Q6BEAAAAAAAAOMOgIgJEAAAAUPsh+b+ioCACRGNiGmG0EFG+oqAhASAC/AIhBAwBCyAFIAQgBEEXdkGWAWsiBEEXdGu+uzkDACAFIAVBCGogBBAvIQQgBkEATgRAIAUrAwghAQwBC0EAIARrIQQgBSsDCJohAQsgBEEDcUEBaw4DAwQBAgsgACAAkwwJCyABIAEgAaIiAqIiAyACIAKioiACRKdGO4yHzcY+okR058ri+QAqv6CiIAEgAyACRLL7bokQEYE/okR3rMtUVVXFv6CioKC2DAgLIAEgAaIiAUSBXgz9///fv6JEAAAAAAAA8D+gIAEgAaIiAkRCOgXhU1WlP6KgIAEgAqIgAURpUO7gQpP5PqJEJx4P6IfAVr+goqC2DAcLIAEgAaIiAiABmqIiAyACIAKioiACRKdGO4yHzcY+okR058ri+QAqv6CiIAMgAkSy+26JEBGBP6JEd6zLVFVVxb+goiABoaC2DAYLIAEgAaIiAUSBXgz9///fv6JEAAAAAAAA8D+gIAEgAaIiAkRCOgXhU1WlP6KgIAEgAqIgAURpUO7gQpP5PqJEJx4P6IfAVr+goqC2jAwFCyAEQd/bv4UESw0CIAZBAE4EQCABRNIhM3982RLAoCICIAIgAqIiAaIiAyABIAGioiABRKdGO4yHzcY+okR058ri+QAqv6CiIAIgAyABRLL7bokQEYE/okR3rMtUVVXFv6CioKC2DAULRNIhM3982RLAIAGhIgIgAiACoiIBoiIDIAEgAaKiIAFEp0Y7jIfNxj6iRHTnyuL5ACq/oKIgAiADIAFEsvtuiRARgT+iRHesy1RVVcW/oKKgoLYMBAsgBEHjl9uABEsNAiAGQQBOBEBEGC1EVPsh+T8gAaEiAiACIAKiIgGiIgMgASABoqIgAUSnRjuMh83GPqJEdOfK4vkAKr+goiACIAMgAUSy+26JEBGBP6JEd6zLVFVVxb+goqCgtgwECyABRBgtRFT7Ifk/oCICIAIgAqIiAaIiAyABIAGioiABRKdGO4yHzcY+okR058ri+QAqv6CiIAIgAyABRLL7bokQEYE/okR3rMtUVVXFv6CioKC2DAMLIARBgICAzANPBEAgASABoiIBRIFeDP3//9+/okQAAAAAAADwP6AgASABoiICREI6BeFTVaU/oqAgASACoiABRGlQ7uBCk/k+okQnHg/oh8BWv6CioLYMAwsgBSAAQwAAgHuSOAIIIAUqAggaQwAAgD8MAgtEGC1EVPshGcBEGC1EVPshGUAgBkEAThsgAaAiASABoiIBRIFeDP3//9+/okQAAAAAAADwP6AgASABoiICREI6BeFTVaU/oqAgASACoiABRGlQ7uBCk/k+okQnHg/oh8BWv6CioLYMAQtEGC1EVPshCcBEGC1EVPshCUAgBkEAThsgAaAiASABoiIBRIFeDP3//9+/okQAAAAAAADwP6AgASABoiICREI6BeFTVaU/oqAgASACoiABRGlQ7uBCk/k+okQnHg/oh8BWv6CioLaMCyAFQRBqJAALvQcBCn8jAEEgayIIJAACQAJAIAEoAhBFBEAgAUF/NgIQIAMgAyACQQNqQXxxIAJrIgprQQdxQQAgAyAKTxsiBGshCSADIARJDQECQAJAAkACfwJAIARFDQACfyAEQQFrIAIgA2oiBUEBayIGLQAAQQpGDQAaIAYgAiAJaiIGRg0BIARBAmsgBUECayIHLQAAQQpGDQAaIAYgB0YNASAEQQNrIAVBA2siBy0AAEEKRg0AGiAGIAdGDQEgBEEEayAFQQRrIgctAABBCkYNABogBiAHRg0BIARBBWsgBUEFayIHLQAAQQpGDQAaIAYgB0YNASAEQQZrIAVBBmsiBy0AAEEKRg0AGiAGIAdGDQEgBEEHayAFQQdrIgUtAABBCkYNABogBSAGRg0BIARBeHILIAlqQQFqDAELIAogAyADIApLGyEMQQAgBGshCiACQQRrIQ0gBEF/cyACaiEHA0ACQCAHIQUgCiEEIAkiBiAMTQ0AIARBCGshCiAFQQhrIQdBgIKECCACIAZBCGsiCWooAgAiC0GKlKjQAHNrIAtyQYCC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BSAGaiwAAEG/f0wNAQsgAiAGaiEEIAcNASAAQgE3AgggACADNgIEIAAgBDYCAA8LIAYgBCACIAVBxIjCABCVAwALIAIgBmpBAWshBiADIQECfwNAIAEiAkUEQEEAIQEgBCEFQQEMAgsgAkEBayEBIAIgBmotAABB3wBHDQALAkACQCABRQ0AAkAgASADTwRAIAEgA0cNASACDQJBACEGDAMLIAEgBGosAABBv39KDQELIAQgA0EAIAFB1IjCABCVAwALAkAgAiADTwRAIAMhBiACIANHDQEMAgsgAiAEaiwAAEG/f0wNACACIQYMAQsgBCADIAIgA0HkiMIAEJUDAAsgBCAGaiEFIAMgBmshAyAECyECIANFBEAMAQsgACADNgIMIAAgBTYCCCAAIAE2AgQgACACNgIADwsgAEEANgIAIABBADoABAuWBgEDfyMAQSBrIgMkACAAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEOKAIBAQEBAQEBAQMFAQEEAQEBAQEBAQEBAQEBAQEBAQEBAQEIAQEBAQcACyABQdwARg0FCyACQQFxRSABQf8FTXINByABELcBRQ0HIANBDmpBADoAACADQQA7AQwgAyABQRR2QfCAwgBqLQAAOgAPIAMgAUEEdkEPcUHwgMIAai0AADoAEyADIAFBCHZBD3FB8IDCAGotAAA6ABIgAyABQQx2QQ9xQfCAwgBqLQAAOgARIAMgAUEQdkEPcUHwgMIAai0AADoAECABQQFyZ0ECdiICIANBDGoiBWoiBEH7ADoAACAEQQFrQfUAOgAAIAUgAkECayICakHcADoAACADQRRqIgQgAUEPcUHwgMIAai0AADoAACAAIAMpAQw3AAAgA0H9ADoAFQwICyAAQgA3AQIgAEHc4AA7AQAMCgsgAEIANwECIABB3OgBOwEADAkLIABCADcBAiAAQdzkATsBAAwICyAAQgA3AQIgAEHc3AE7AQAMBwsgAEIANwECIABB3LgBOwEADAYLIAJBgAJxRQ0BIABCADcBAiAAQdzOADsBAAwFCyACQf///wdxQYCABE8NAwsgARD6AQ0BIANBGGpBADoAACADQQA7ARYgAyABQRR2QfCAwgBqLQAAOgAZIAMgAUEEdkEPcUHwgMIAai0AADoAHSADIAFBCHZBD3FB8IDCAGotAAA6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QYCAgNgDciADQRd0a3ILIQUgAS8BJCEBAn8gAkH//wFxBEAgAkH/B3EhAyACQYCAAnEhBCACQYD4AXEiAkGA+AFHBEAgBEEQdCIEIAJBDXRBgICA/ABxIANBDXRyQYCAgMADanIgAg0CGiADIANnQRBrIgJB//8DcUEIanRB////A3EgBEGAgIDYA3IgAkEXdGtyDAILIARBEHQiAiADQQ10ckGAgID+B3IgAw0BGiACQYCAgPwHcgwBCyACQRB0CyEDIAACfyABQf//AXEEQCABQf8HcSEAIAFBgIACcSECIAFBgPgBcSIBQYD4AUcEQCACQRB0IgIgAUENdEGAgID8AHEgAEENdHJBgICAwANqciABDQIaIAAgAGdBEGsiAEH//wNxQQhqdEH///8DcSACQYCAgNgDciAAQRd0a3IMAgsgAkEQdCIBIABBDXRyQYCAgP4HciAADQEaIAFBgICA/AdyDAELIAFBEHQLvhCcAf0TIAW+EJwB/SAAIAO+EJwB/SAB/QsEAAu2BAEEfyABLwEcIQQCfyABLwEaIgJB//8BcUUEQCACQRB0DAELIAJB/wdxIQUgAkGAgAJxIQMgAkGA+AFxIgJBgPgBRgRAIANBEHQhAiACQYCAgPwHciAFRQ0BGiACIAVBDXRyQYCAgP4HcgwBCyADQRB0IQMgAkENdEGAgID8AHEgBUENdHJBgICAwANqIANyIAINABogBSAFZ0EQayIFQf//A3FBCGp0Qf///wNxIANBgICA2ANyIAVBF3RrcgshBSABLwEeIQECfyAEQf//AXEEQCAEQf8HcSECIARBgIACcSEDIARBgPgBcSIEQYD4AUcEQCADQRB0IQMgBEENdEGAgID8AHEgAkENdHJBgICAwANqIANyIAQNAhogAiACZ0EQayIEQf//A3FBCGp0Qf///wNxIANBgICA2ANyIARBF3RrcgwCCyADQRB0IQQgBCACQQ10ckGAgID+B3IgAg0BGiAEQYCAgPwHcgwBCyAEQRB0CyEEIAACfyABQf//AXEEQCABQf8HcSECIAFBgIACcSEDIAFBgPgBcSIBQYD4AUcEQCADQRB0IQMgAUENdEGAgID8AHEgAkENdHJBgICAwANqIANyIAENAhogAiACZ0EQayIBQf//A3FBCGp0Qf///wNxIANBgICA2ANyIAFBF3RrcgwC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IAEoAhwhAQwBCyABKAIgIgIgASgCHCIBRg0BCyABIAdqIQggAiABayEDCyAAIAM2AgQgACAINgIAIAZBEGokAAuWAwEDfyMAQYABayIEJAACfwJAIAEoAggiAkGAgIAQcUUEQCACQYCAgCBxDQFBAyECIAAtAAAiACEDIABBCk8EQCAEIAAgAEHkAG4iA0HkAGxrQf8BcUEBdCICQbX6wABqLQAAOgACIAQgAkG0+sAAai0AADoAAUEBIQILQQAgACADG0UEQCAEIAJBAWsiAmogA0EBdEH+AXFBtfrAAGotAAA6AAALIAFBAUEBQQAgAiAEakEDIAJrEI4BDAILIAAtAAAhAkGBASEAA0AgACAEakECayACQQ9xIgNBMHIgA0HXAGogA0EKSRs6AAAgAkH/AXEiA0EEdiECIABBAWshACADQQ9LDQALIAFBAUGbisIAQQIgACAEakEBa0GBASAAaxCOAQwBCyAALQAAIQJBgQEhAANAIAAgBGpBAmsgAkEPcSIDQTByIANBN2ogA0EKSRs6AAAgAkH/AXEiA0EEdiECIABBAWshACADQQ9LDQALIAFBAUGbisIAQQIgACAEakEBa0GBASAAaxCOAQsgBEGAAWokAAu8AwIGfwF+IwBB0ABrIgIkACACQSBqIAAgACgCACgCBBECACACIAJByABqrUKAgICAwAGENwMoQQEhAyACQQE2AjQgAkHcq8IANgIwIAJCATcCPCACIAIpAyA3AkggAiACQShqNgI4AkAgASgCACIGIAEoAgQiByACQTBqEIwBDQAgAS0ACkGAAXFFBEBBACEDDAELIAJBGGogACAAKAIAKAIEEQIAIAJBEGogAigCGCACKAIcKAIYEQIAIAIoAhAiBEUEQEEAIQMMAQsgAkEIaiAEIAIoAhQiBSgCGBECACACKAIMIQAgAigCCCEBIAIgBTYCLCACIAQ2AiggAkEBNgI0IAJBoM/AADYCMCACQgE3AjwgAiACQShqrUKAgICAwAGEIgg3A0ggAiACQcgAajYCOCAGIAcgAkEwahCKAw0AA0AgAUUEQEEAIQMMAgsgAiABIAAoAhgRAgAgAigCBCACKAIAIAIgADYCLCACIAE2AiggAkEBNgI0IAJBoM/AADYCMCACQgE3AjwgAiAINwNIIAIgAkHIAGo2AjghASEAIAYgByACQTBq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A0F4cSIEQQRBCCADQQNxIgMbIAJqSQ0BIANBACAEIAJBJ2pLGw0CIAEQWwsgACgCFCEBIAAoAhgiAigCACIDBEAgASADEQMACyACKAIEIgIEQCABQQRrKAIAIgNBeHEiBEEEQQggA0EDcSIDGyACakkNASADQQAgBCACQSdqSxsNAiABEFsLAkAgAEF/Rg0AIAAgACgCBEEBayIBNgIEIAENACAAQQRrKAIAIgFBeHEiAkEgQSQgAUEDcSIBG0kNASABQQAgAkHEAE8bDQIgABBbCw8LQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIAC9cCAQV/QRFBACAAQa+wBE8bIgIgAkEIciIBIABBC3QiAiABQQJ0QYSUwQBqKAIAQQt0SRsiASABQQRyIgEgAUECdEGElMEAaigCAEELdCACSxsiASABQQJyIgEgAUECdEGElMEAaigCAEELdCACSxsiASABQQFqIgEgAUECdEGElMEAaigCAEELdCACSxsiASABQQFqIgEgAUECdEGElMEAaigCAEELdCACSxsiAUECdEGElMEAaigCAEELdCIEIAJGIAIgBEtqIAFqIgRBAnRBhJTBAGoiBSgCAEEVdiECQe8FIQECQCAEQSBNBEAgBSgCBEEVdiEBIARFDQELIAVBBGsoAgBB////AHEhAwsCQCABIAJBf3NqRQ0AIAAgA2shAyABQQFrIQFBACEAA0AgACACQe/ZwABqLQAAaiIAIANLDQEgASACQQFqIgJHDQALCyACQQFxC9cCAQV/QRJBACAAQbC4BE8bIgIgAkEJciIBIABBC3QiAiABQQJ0QZiSwQBqKAIAQQt0SRsiASABQQVqIgEgAUECdEGYksEAaigCAEELdCACSxsiASABQQJqIgEgAUECdEGYksEAaigCAEELdCACSxsiASABQQFqIgEgAUECdEGYksEAaigCAEELdCACSxsiASABQQFqIgEgAUECdEGYksEAaigCAEELdCACSxsiAUECdEGYksEAaigCAEELdCIEIAJGIAIgBEtqIAFqIgRBAnRBmJLBAGoiBSgCAEEVdiECQYkHIQECQCAEQSNNBEAgBSgCBEEVdiEBIARFDQELIAVBBGsoAgBB////AHEhAwsCQCABIAJBf3NqRQ0AIAAgA2shAyABQQFrIQFBACEAA0AgACAC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AiAGaiADIAQQ9gEhAgsgBCgCAEEEaigCACAAKAIAIAEoAgAQigEiAyAEKAIAQQRqKAIAIAAoAgAgAigCABCKAUYEfyACIAEgBCgCAEEEaigCACABKAIAIAIoAgAQigEgA3MbBSAACwu9AQEEfyMAQRBrIgIkACACQQhqIgMgAUEkaigCADYCACACIAEpAhw3AwACQAJAQQwQLiIEBEAgBCACKQMANwIAIARBCGogAygCADYCACABQQRqEHEgAUEEaygCACIDQXhxQSxBMCADQQNxIgUbSQ0BIAVBACADQdAATxsNAiABEFsgAEHMjsIANgIEIAAgBDYCACACQRBqJAAPCwALQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIAC6gBAQN/IwBBEGsiAyQAQQMhAiAALQAAIgAhBCAAQQpPBEAgAyAAIABB5ABuIgRB5ABsa0H/AXFBAXQiAkG1+sAAai0AADoADyADIAJBtPrAAGotAAA6AA5BASECC0EAIAAgBBtFBEAgAkEBayICIANBDWpqIARBAXRB/gFxQbX6wABqLQAAOgAACyABQQFBAUEAIANBDWogAmpBAyACaxCOASADQRBqJAALqgMBCH8jAEEQayIDJAAgACgCBCEFIAAoAgAhAEEBIQcgASgCAEG3icIAQQEgASgCBCgCDBEAACECIANBADoACSADIAI6AAggAyABNgIEAkACQCAFBEADQCADIAA2AgwgA0EMaiEIIwBBIGsiASQAQQEhBgJAIANBBGoiBC0ABA0AIAQtAAUhCQJAIAQoAgAiAi0ACkGAAXFFBEAgCUEBcUUNASACKAIAQbWJwgBBAiACKAIEKAIMEQAARQ0BDAILIAlBAXFFBEAgAigCAEHstMIAQQEgAigCBCgCDBEAAA0CCyABQQE6AA8gAUHk+MAANgIUIAEgAikCADcCACABIAIpAgg3AhggASABQQ9qNgIIIAEgATYCECAIIAFBEGoQxgINASABKAIQQYP5wABBAiABKAIUKAIMEQAAIQYMAQsgCCACEMYCIQYLIARBAToABSAEIAY6AAQgAUEgaiQAIABBAWohACAFQQFrIgUNAAsgAy0ACEEBcUUNAQwCCyACDQELIAMoAgQiACgCAEG4icIAQQEgACgCBCgCDBEAACEHCyADQRBqJAAgBwvhAQAgAEEgSQRAQQAPCyAAQf8ASQRAQQEPCyAAQYCABE8EQCAAQYCACE8EQCAAQeD//wBxQeDNCkcgAEH+//8AcUGe8ApHcSAAQfCDOElxIAD9Ef0MwEj9/1Ax/f8QFP3/AAj9//2uAf0M+f////H////w////Xfb///08/VNBf3NxIABBgIAMa0GedElxIABB0KYMa0F7SXEgAEGAgjhrQbDFVElxDwsgAEHkg8EAQSxBvITBAEHQAUGMhsEAQeYDELoBDwsgAEHyicEAQShBworBAEGiAkHkjMEAQakCELoBC80CAgZ/AX4gACgCACEEIwBBIGsiAiQAQQQgACgCACIFQQF0IgYgBkEETRsiBq1CLH4iCEIgiFBFBEBBACABEIMDAAsCQCAIpyIHQfz///8HTQR/IAIgBQR/IAIgBUEsbDYCHCACIAAoAgQ2AhRBBAVBAAs2AhggAkEIakEEIAcgAkEUahCIAiACKAIIQQFHDQEgAigCEBogAigCDAUgAwsgARCDAwALIAIoAgwhASAAIAY2AgAgACABNgIEIAJBIGokAAJAIAAoAggiAiAEIAAoAgwiA2tNDQAgBCACayIBIAMgAWsiA0sgACgCACIFIARrIANPcUUEQCAFIAFrIQQgAUEsbCIBBEAgACgCBCIDIARBLGxqIAMgAkEsbGogAfwKAAALIAAgBDYCCA8LIANBLGwiAUUNACAAKAIEIgAgBEEsbGogACAB/AoAAAsLowECAn8BfiMAQRBrIgMkAAJAAkACQCABKAIIIgQgASgCBEkEQCABKAIAIARqLQAAIAJB/wFxRg0BCyAAQgA3AwgMAQtBASECIAEgBEEBajYCCCADIAEQuQEgAy0AAEUEQCADKQMIIgVCf1IEQCAAIAVCAXw3AwgMAgsgAEEAOgABDAILIAAgAy0AAToAAQwBC0EAIQILIAAgAjoAACADQRBqJAALowECAn8BfiMAQRBrIgIkACABKAIIIQMgAiABELkBAkAgAi0AAEEBRgRAIAItAAEhASAAQQA2AgAgACABOgAEDAELIAIpAwgiBCADQQFrrVQEQCABKAIMQQFqIgNB9ANNBEAgACADNgIMIAAgBD4CCCAAIAEpAgA3AgAMAgsgAEEANgIAIABBAToABAwBCyAAQQA2AgAgAEEAOgAECyACQRBqJAALqAEBAn8gASgCDCECAkACQAJAAkACQAJAAkAgASgCBA4CAAECCyACDQFBASEDQQAhAUEBIQIMAwsgAkUNAQsgACABEK0BDwsgASgCACICKAIEIgFBAEgNASACKAIAIQMgAUUEQEEBIQJBACEBDAELIAEQLiICRQ0CCyABBEAgAiADIAH8CgAACyAAIAE2AgggACACNgIEIAAgATYCAA8LQdCRwgAQzQILAAuVAQMDfAF+AX8gALsgAbuiIgMgArsiBKAiBb0iBkL/////AYNCgICAgAFSIAZCgICAgICAgPj/AINCgICAgICAgPj/AFFyIAQgBSADoWEgBSAEoSADYXFyBHwgBQUgBkIBfSAGQgGEIAZCAFMiByADIAQgBaGgIAMgBaEgBKAgByADIARjcxtEAAAAAAAAAABjcxu/C7YLlQEBA38CfwJAAkAgASgCACIDRQRADAELA0ACQCABKAIIIgQgASgCBE8NACADIARqLQAAQcUARw0AIAEgBEEBajYCCAwCCwJAIAJFDQAgASgCECIDRQ0AIANBtYnCAEECEIQBDQMLIAEQUw0CIAJBAWohAiABKAIAIgMNAAsLQQAMAQtBAQshASAAIAI2AgQgACABNgIAC6ABAgN/AW8jAEEgayIDJAAgABDNAyEEIAMgAjYCBCADIAQ2AgAgAiAERgRAEJkDIgQQgQMiBSUBIAEgAhAfIQYQngEiASAGJgEgBEGEAU8EQCAEELUCCyAFQYQBTwRAIAUQtQILIAAgAUEAEKoDIAFBhAFPBEAgARC1AgsgA0EgaiQADwsgA0EANgIIIAMgA0EEaiADQQhqQdzvwQAQzwIAC5gBAQN/IAEoAiAhAiABKAIcIQMCQAJAQQgQLiIEBEAgBCACNgIEIAQgAzYCACABQQRqEHEgAUEEaygCACICQXhxIgNBKEEsIAJBA3EiAhtJDQEgAkEAIANBzABPGw0CIAEQWyAAQeCfwAA2AgQgACAENgIADwsAC0HYqMIAQS5BiKnCABDEAgALQZipwgBBLkHIqcIAEMQCAAuNAQEDfyMAQRBrIgEkACABQQA6AA8CQAJAQQEQLiICBEAgACABQQ9qrTcDACAAIAKtNwMIIAJBBGsoAgAiAEF4cSIDQQVBCSAAQQNxIgAbSQ0BIABBACADQSlPGw0CIAIQWyABQRBqJAAPCwALQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIAC50BAgN/AW8jAEEgayIDJAAgAyAAEM0DIgQ2AgAgAyACNgIEIAIgBEYEQBCZAyIEEIEDIgUlARAdIQYQngEiAiAGJgEgBUGEAU8EQCAFELUCCyACIAAgAUECdhCqAyACQYQBTwRAIAIQtQILIARBhAFPBEAgBBC1AgsgA0EgaiQADwsgA0EANgIIIAMgA0EEaiADQQhqQdzvwQAQzwIAC40BAQR/IwBBEGsiAiQAAn9BASABKAIAIgNBJyABKAIEIgUoAhAiAREBAA0AGiACIAAoAgBBgQIQdwJAIAItAA0iAEGBAU8EQCADIAIoAgAgAREBAEUNAUEBDAILIAMgAiACLQAMIgRqIAAgBGsgBSgCDBEAAEUNAEEBDAELIANBJyABEQEACyACQRBqJAALmAEBA38gASgCICECIAEoAhwhAwJAAkBBCBAuIgQEQCAEIAI2AgQgBCADNgIAIAFBBGoQcSABQQRrKAIAIgJBeHEiA0EoQSwgAkEDcSICG0kNASACQQAgA0HMAE8bDQIgARBbIABBkI7CADYCBCAAIAQ2AgAPCwALQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIAC4ABAQJ/IANBCE8EQCAAIAAgA0EDdiIDQQR0IgRqIAAgA0EcbCIFaiADEIcCIQAgASABIARqIAEgBWogAxCHAiEBIAIgAiAEaiACIAVqIAMQhwIhAgsgACACIAEgACgCACIAIAEoAgAiAUkiAyABIAIoAgAiAklzGyADIAAgAklzGwt9AQF/An8CQCADKAIEBEAgAygCCCIERQRAIAEgAkUNAxogAUEJSQ0CIAEgAhCyAQwDCyADKAIAIAQgASACEGIMAgsgASACRQ0BGiABQQlJDQAgASACELIBDAELIAIQLgshAyAAIAI2AgggACADIAEgAxs2AgQgACADRTYCAAuEAQEDfwJ/AkAgACgCACIBRQ0AA0ACQCAAKAIIIgMgACgCBE8NACABIANqLQAAQcUARw0AIAAgA0EBajYCCAwCCwJAIAJFDQAgACgCECIBRQ0AIAFBtYnCAEECEIQBRQ0AQQEPC0EBIABBARBDDQIaIAJBAWshAiAAKAIAIgENAAsLQQALC40BAQR/IAAQnwECQAJAIAAoAugFIgIEQCAAKALsBSIDQQRrKAIAIgFBeHEiBEEEQQggAUEDcSIBGyACakkNASABQQAgBCACQSdqSxsNAiADEFsLIAAoAtwFQYCAgIB4RwRAIABBgAFqEEsLDwtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgALhgEBA38gACgCACECIAAoAgQiACgCACIBBEAgAiABEQMACwJAAkAgACgCBCIABEAgAkEEaygCACIBQXhxIgNBBEEIIAFBA3EiARsgAGpJDQEgAUEAIAMgAEEnaksbDQIgAhBbCw8LQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIAC4sBAQR/IAAQeQJAAkAgACgCqAUiAgRAIAAoAqwFIgNBBGsoAgAiAUF4cSIEQQRBCCABQQNxIgEbIAJqSQ0BIAFBACAEIAJBJ2pLGw0CIAMQWwsgACgCnAVBgICAgHhHBEAgAEFAaxBLCw8LQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIAC5IBAQJ/IwBBEGsiAiQAIAAoAiQiAUEJTwRAIAAoAgQhAQsCQAJAAkACQCABQQFqDgICAQALIAFnIgFFDQFBfyABdiEBCyACQQhqIAAgAUEBahCYASACKAIIIgBBgYCAgHhHBEAgAA0CQeiLwgBBEUGAksIAEMQCAAsgAkEQaiQADwtB6IvCAEERQZCSwgAQqQILAAuMAQIDfwF+IAEpAhwhBQJAAkBBCBAuIgMEQCADIAU3AgAgAUEEahBxIAFBBGsoAgAiAkF4cSIEQShBLCACQQNxIgIbSQ0BIAJBACAEQcwATxsNAiABEFsgAEHYoMAANgIEIAAgAzYCAA8LAAtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgALdwEDfyMAQYABayIEJAAgACgCACEAQYEBIQIDQCACIARqQQJrIABBD3EiA0EwciADQdcAaiADQQpJGzoAACACQQFrIQIgAEEPSyAAQQR2IQANAAsgAUEBQZuKwgBBAiACIARqQQFrQYEBIAJrEI4BIARBgAFqJAALggEBAX8jAEEwayICJAAgAiAAKAIAKAIAIgA2AhggAiAAaDYCHCACQQM2AgQgAkGY9sAANgIAIAJCAjcCDCACIAJBHGqtQoCAgICwBYQ3AyggAiACQRhqrUKAgICAwAWENwMgIAIgAkEgajYCCCABKAIAIAEoAgQgAhCMASACQTBqJAALiAEBA38gAS0AHCECAkACQEEBEC4iAwRAIAMgAjoAACABQQRqEHEgAUEEaygCACICQXhxQSRBKCACQQNxIgQbSQ0BIARBACACQcgATxsNAiABEFsgAEGkn8AANgIEIAAgAzYCAA8LAAtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgALYgEEfiAAIAJC/////w+DIgMgAUL/////D4MiBH4iBSAEIAJCIIgiAn4iBCADIAFCIIgiBn58IgFCIIZ8IgM3AwAgACADIAVUrSACIAZ+IAEgBFStQiCGIAFCIIiEfHw3AwgLegEBfyMAQUBqIgUkACAFIAE2AgwgBSAANgIIIAUgAzYCFCAFIAI2AhAgBUECNgIcIAVBgLXCADYCGCAFQgI3AiQgBSAFQRBqrUKAgICAEIQ3AzggBSAFQQhqrUKAgICAIIQ3AzAgBSAFQTBqNgIgIAVBGGogBBDaAgALgAEBAn8gAEEMahB5AkACQAJAIABBf0YNACAAIAAoAgRBAWsiATYCBCABDQAgAEEEaygCACIBQXhxIgJB2ABB3AAgAUEDcSIBG0kNASABQQAgAkH8AE8bDQIgABBbCw8LQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIAC3UBA38gAEEEahBxAkACQCAAKAIcIgIEQCAAKAIgIgBBBGsoAgAiAUF4cSIDQQRBCCABQQNxIgEbIAJqSQ0BIAFBACADIAJBJ2pLGw0CIAAQWwsPC0HYqMIAQS5BiKnCABDEAgALQZipwgBBLkHIqcIAEMQCAAttAQJ/IAEoAggiBEUgAyABKAIAIgUgBGtNckUEQCABQQA2AgggAUEAOgAMQQAhBAsgAyAFSQRAIAMEQCABKAIEIARqIAIgA/wKAAALIABBBDoAACABIAMgBGo2AggPCyAAQgQ3AgAgAUEAOgAMC24BA38CQAJAIAAoAgAiAgRAIAAoAgQiAEEEaygCACIBQXhxIgNBBEEIIAFBA3EiARsgAmpJDQEgAUEAIAMgAkEnaksbDQIgABBbCw8LQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIAC2sBAn8jAEEgayIBJAACfyAALQBsQQJHBEAgACgCZCICBEAgAiAAKAJoKAIUEQQADAILQfSlwAAQqwMACyABQQA2AhggAUEBNgIMIAFB7KXAADYCCCABQgQ3AhAgAUEIahCfAgsgAUEgaiQAC24BAn8jAEEgayIBJAACfyAALQCsAUECRwRAIAAoAqQBIgIEQCACIAAoAqgBKAIUEQQADAILQfSlwAAQqwMACyABQQA2AhggAUEBNgIMIAFB7KXAADYCCCABQgQ3AhAgAUEIahCfAgsgAUEgaiQAC2kBAn8CQAJAIAAEQCAAQQhrIgIgAigCAEEBaiIDNgIAIANFDQEgACgCAA0CIABBfzYCACAAQQRqIAEQJCAAQQA2AgAgAiACKAIAQQFrIgA2AgAgAEUEQCACEJQCCw8LELMDCwALELUDAAt7AQF/IwBBEGsiAyQAQejEwgBB6MTCACgCACIEQQFqNgIAAkAgBEEASA0AAkBByMjCAC0AAEUEQEHEyMIAQcTIwgAoAgBBAWo2AgBB5MTCACgCAEEATg0BDAILIANBCGogACABEQIAAAtByMjCAEEAOgAAIAJFDQAACwALaQECfyMAQSBrIgIkACACQQhqEP0CQSgQLiIBRQRAAAsgAUGco8AANgIAIAEgAikCCDcCBCABIAApAgA3AhwgAUEMaiACQRBq/QACAP0LAgAgAUEkaiAAQQhqKAIANgIAIAJBIGokACABC2oCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQaz3wAA2AgggA0ICNwIUIANCgICAgOAAIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhDaAgALaQECfyMAQSBrIgIkACACQQhqEP0CQSgQLiIBRQRAAAsgAUGMkMIANgIAIAEgAikCCDcCBCABIAApAgA3AhwgAUEMaiACQRBq/QACAP0LAgAgAUEkaiAAQQhqKAIANgIAIAJBIGokACABC2cBAn8jAEEQayICJAAgACgCDCEBAn8CQAJAAkAgACgCBA4CAAECCyABDQFBAUEAEKoCDAILIAENACAAKAIAIgAoAgAgACgCBBCqAgwBCyACQQRqIgEgABCtASABEJwCCyACQRBqJAALZwECfyMAQRBrIgIkACAAKAIMIQECfwJAAkACQCAAKAIEDgIAAQILIAENAUEBQQAQrAIMAgsgAQ0AIAAoAgAiACgCACAAKAIEEKwCDAELIAJBBGoiASAAEK0BIAEQngILIAJBEGokAAtkAQF/IwBBEGsiACQAAn8gAigCAARAQeC0wgAhA0EJDAELIABBBGogAigCBCACKAIIEHpB4LTCACAAKAIIIAAoAgQiAhshA0EJIAAoAgwgAhsLIQIgAyACIAEQlAEgAEEQaiQAC10BAX8CfwJAIAMoAgQEQCADKAIIIgRFBEAgAg0CIAEMAwsgAygCACAEIAEgAhBiDAILIAINACABDAELIAIQLgshAyAAIAI2AgggACADIAEgAxs2AgQgACADRTYCAAtfAQJ/IABBBGoQcQJAIABBBGsoAgAiAUF4cSICQShBLCABQQNxIgEbTwRAIAFBACACQcwATxsNASAAEFsPC0HYqMIAQS5BiKnCABDEAgALQZipwgBBLkHIqcIAEMQCAAtfAQJ/IABBBGoQcQJAIABBBGsoAgAiA0F4cSIEQShBLCADQQNxIgMbTwRAIANBACAEQcwATxsNASAAEFsPC0HYqMIAQS5BiKnCABDEAgALQZipwgBBLkHIqcIAEMQCAAtdAQJ/AkAgAEEEaygCACICQXhxIgNBBEEIIAJBA3EiAhsgAWpPBEAgAkEAIAMgAUEnaksbDQEgABBbDwtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgALXQECfyAAQQRqEHECQCAAQQRrKAIAIgFBeHFBJEEoIAFBA3EiAhtPBEAgAkEAIAFByABPGw0BIAAQWw8LQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIAC10BAn8gAEEEahBxAkAgAEEEaygCACIDQXhxQSxBMCADQQNxIgQbTwRAIARBACADQdAATxsNASAAEFsPC0HYqMIAQS5BiKnCABDEAgALQZipwgBBLkHIqcIAEMQCAAtdAQJ/IABBBGoQcQJAIABBBGsoAgAiA0F4cUEkQSggA0EDcSIEG08EQCAEQQAgA0HIAE8bDQEgABBbDwtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgALWgEBfyMAQTBrIgMkACADIAE2AgwgAyAANgIIIANBATYCFCADQdyrwgA2AhAgA0IBNwIcIAMgA0EIaq1CgICAgCCENwMoIAMgA0EoajYCGCADQRBqIAIQ2gIAC10BAn8jAEEgayIDJAAgA0EIahD9AkEkEC4iAkUEQAALIAJBuKPAADYCACACIAMpAgg3AgQgAiABNgIgIAIgADYCHCACQQxqIANBEGr9AAIA/QsCACADQSBqJAAgAgtOAQJ/IwBBIGsiAiQAIAJBCGogACgCACIAIABBH3UiA3MgA2sgAkEWahC/ASABIABBf3NBH3ZBAUEAIAIoAgggAigCDBCOASACQSBqJAALXQECfyMAQSBrIgMkACADQQhqEP0CQSQQLiICRQRAAAsgAkHwj8IANgIAIAIgAykCCDcCBCACIAE2AiAgAiAANgIcIAJBDGogA0EQav0AAgD9CwIAIANBIGokACACC1QBAn8CQCAAQ////z4gAJiSIgC8IgJBF3ZB/wFxIgFBlQFLDQBBgICAgHhBgICAfCABQf8Aa3UgAUH/AEkbIgFBf3MgAnFFDQAgASACcb4hAAsgAAtXAQF/IAAoAugFIAAoAvAFIgNrIAJJBEAgAEHoBWogAyACQQFBARDZASAAKALwBSEDCyACBEAgACgC7AUgA2ogASAC/AoAAAsgACACIANqNgLwBSAAEDcLVwEBfyAAKAKoBSAAKAKwBSIDayACSQRAIABBqAVqIAMgAkEBQQEQ2QEgACgCsAUhAwsgAgRAIAAoAqwFIANqIAEgAvwKAAALIAAgAiADajYCsAUgABA4C1cBAX8gACgCgAEgACgCiAEiA2sgAkkEQCAAQYABaiADIAJBAUEBENkBIAAoAogBIQMLIAIEQCAAKAKEASADaiABIAL8CgAACyAAIAIgA2o2AogBIAAQSQtRAQF/IAAoAkAgACgCSCIDayACSQRAIABBQGsgAyACQQFBARDZASAAKAJIIQMLIAIEQCAAKAJEIANqIAEgAvwKAAALIAAgAiADajYCSCAAECcLTAEDfwJAAkAgAARAIABBCGsiASABKAIAIgJBAWoiAzYCACADRQ0BIAAoAgBBf0YNAiAAKAIYIAEgAjYCAEEARw8LELMDCwALELUDAAtWAQJ/IwBBIGsiAiQAIAJBCGoQ/QJBIBAuIgFFBEAACyABQeSiwAA2AgAgASACKQIINwIEIAEgADoAHCABQQxqIAJBEGr9AAIA/QsCACACQSBqJAAgAQtWAQJ/IwBBIGsiAiQAIAJBCGoQ/QJBJBAuIgFFBEAACyABQYCjwAA2AgAgASACKQIINwIEIAEgADcCHCABQQxqIAJBEGr9AAIA/QsCACACQSBqJAAgAQtfAQF/AkAgAEGEAU8EQCAA0G8mARDFASAAQYTCwgAoAgAiAUkNASAAIAFrIgBB/MHCACgCAE8NAUH4wcIAKAIAIABBAnRqQYDCwgAoAgA2AgBBgMLCACAANgIACw8LAAtJAQN/AkACQCAABEAgAEEIayIBIAEoAgAiAkEBaiIDNgIAIANFDQEgACgCAEF/Rg0CIAAoAgwgASACNgIADwsQswMLAAsQtQMAC0wBAX8gACgCACAAKAIIIgNrIAJJBEAgACADIAJBAUEBENkBIAAoAgghAwsgAgRAIAAoAgQgA2ogASAC/AoAAAsgACACIANqNgIIQQALTQEBfyMAQTBrIgEkACABQQE2AgwgAUHcq8IANgIIIAFCATcCFCABIAFBL2qtQoCAgIDQAYQ3AyAgASABQSBqNgIQIAFBCGogABDaAgALQAACQCABaUEBRyAAQYCAgIB4IAFrS3INACAABEACfyABQQlPBEAgASAAELIBDAELIAAQLgsiAUUNAQsgAQ8LAAtDAQN/AkAgAkUNAANAIAAtAAAiBCABLQAAIgVGBEAgAEEBaiEAIAFBAWohASACQQFrIgINAQwCCwsgBCAFayEDCyADC0wBAX8CfwJAIAIoAgRFDQAgAigCCCIDRQ0AIAIoAgAgA0EBIAEQYgwBCyABEC4LIQIgACABNgIIIAAgAkEBIAIbNgIEIAAgAkU2AgALUAEBfwJAIAFB4QBrIgFB/wFxQRlLBEBBACEBDAELIAFBAnRB/AdxIgJBpLrCAGooAgAhASACQby5wgBqKAIAIQILIAAgAjYCBCAAIAE2AgALUAEBfyMAQRBrIgIkACACQQhqIAEgASgCACgCBBECACACIAIoAgggAigCDCgCGBECACACKAIEIQEgACACKAIANgIAIAAgATYCBCACQRBqJAALSAEBfyAAKAIAIAAoAggiA2sgAkkEQCAAIAMgAhDtASAAKAIIIQMLIAIEQCAAKAIEIANqIAEgAvwKAAALIAAgAiADajYCCEEAC0gBAX8gACgCACAAKAIIIgNrIAJJBEAgACADIAIQ7gEgACgCCCEDCyACBEAgACgCBCADaiABIAL8CgAACyAAIAIgA2o2AghBAAtPAQJ/IAAoAgQhAiAAKAIAIQMCQCAAKAIIIgAtAABFDQAgA0H8+MAAQQQgAigCDBEAAEUNAEEBDwsgACABQQpGOgAAIAMgASACKAIQEQEAC0oBAn8gACAAKAIEIgMgAms2AgQgACAAKAIAIAIgA0tyIgQ2AgBBASEDIAQEfyADBSAAKAIIIgAoAgAgASACIAAoAgQoAgwRAAALC5o8BAZ+En8CewN9IwBBEGsiGiQAIAAhFiAEIRwgBiEeIAghHyAJISBBACEIIwBB4ABrIhUkAAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQCAHIgkgBUEEdEYEQCAFICBGBEAgBSALRgRAIAUgDUcNAyACQwAAAD+UQzX6jjyUEGMhAiADQwAAAD+UQzX6jjyUEGMhA0GowsIAKAIARQRAEDALQbDCwgAoAgBFBEBBsMLCAEF/NgIAQfTCwgBBADYCAAJAAkAgBa1C8AB+Ig5CIIinDQAgDqciAEHx////B08NAAJAIABFBEBBECEGDAELIAUhIUEQIAAQsgEiBkUNAgsCQAJAAkAgBQRAQcTCwgAoAgBFDRVByMLCACkDACIOQjiGIA5CgP4Dg0IohoQgDkKAgPwHg0IYhiAOQoCAgPgPg0IIhoSEIA5CCIhCgICA+A+DIA5CGIhCgID8B4OEIA5CKIhCgP4DgyAOQjiIhISEIRFBuMLCACgCACIYQShrIRcgDkJ/hSESQbzCwgAoAgAhB0HQwsIAKQMAIRADQCAHIBAgHCAIQQJ0IhRqKAIAIhmthSIPQjiGIA9CgP4Dg0IohoQgD0KAgPwHg0IYhiAPQoCAgPgPg0IIhoSEIBBCCIhCgICA+A+DIBBCGIhCgID8B4OEIBBCKIhCgP4DgyAQQjiIhISEQtKBqpur+oLXp39+Ig5COIYgDkKA/gODQiiGhCAOQoCA/AeDQhiGIA5CgICA+A+DQgiGhIQgDkIIiEKAgID4D4MgDkIYiEKAgPwHg4QgDkIoiEKA/gODIA5COIiEhIQgD0LYotHvwqnlvy1+hSIOQjiGIA5CgP4Dg0IohoQgDkKAgPwHg0IYhiAOQoCAgPgPg0IIhoSEIA5CCIhCgICA+A+DIA5CGIhCgID8B4OEIA5CKIhCgP4DgyAOQjiIhISEIBJ+Ig9COIYgD0KA/gODQiiGhCAPQoCA/AeDQhiGIA9CgICA+A+DQgiGhIQgD0IIiEKAgID4D4MgD0IYiEKAgPwHg4QgD0IoiEKA/gODIA9COIiEhIQgDiARfoUgDokiDqdxIQQgDkIZiEL/AINCgYKEiJCgwIABfiETQQAhAANAAkAgBCAYaikAACIPIBOFIg5Cf4UgDkKBgoSIkKDAgAF9g0KAgYKEiJCgwIB/gyIOUEUEQANAIBkgFyAOeqdBA3YgBGogB3FBWGwiHWooAgBGDQIgDkIBfSAOgyIOUEUNAAsLIA8gD0IBhoNCgIGChIiQoMCAf4NQRQ0YIAQgAEEIaiIAaiAHcSEEDAELCyAIQQR0IgBBA3IiBCAJSw0EIABBB3IiBCAJSw0DIABBC3IiBCAJSw0CIAkgAEEPciIESQRAIAQgCUH0x8AAEKwDAAsgHiAAQQJ0aiIEKgIIISggBP1dAgAhJyAEQRhqKgIAISkgBEEQav1dAgAhJiAYIB1qIgBBIGspAgAhDiAAQQhrKQIAIQ8gBiAIQfAAbGoiAEEANgJkIABCgICAgMAANwJcIAAgDCAUaioCADgCWCAAIAogFGoqAgA4AlQgACAUIB9qKgIAOAJQIAAgDzcDSCAAIA43A0AgACAEQTBq/V0CACAEQThqKgIAIir9IAIgKv0gA/0LBAAgACAmICn9IAIgKf0gAyImICYgJv3mASImICb9DQgJCgsAAQIDAAECAwABAgMgJiAmICb9DQQFBgcAAQIDAAECAwABAgP95AH95AEgJv0NAAECAwABAgMAAQIDAAECA/3jAf3nAf0LBDAgACAnICj9IAIgKP0gAyImICYgJv3mASImICb9DQgJCgsAAQIDAAECAwABAgMgJiAmICb9DQQFBgcAAQIDAAECAwABAgP95AH95AEgJv0NAAECAwABAgMAAQIDAAECA/3jAf3nAf0LBCAgACAEQSBq/V0CACAEQShqKgIAIij9IAIiJiAmICj9IAMiJiAm/eYBIiYgJv0NCAkKCwABAgMAAQIDAAECAyAmICYgJv0NBAUGBwABAgMAAQIDAAECA/3kAf3kASAm/Q0AAQIDAAECAwABAgMAAQID/eMB/ecBICb9DQABAgMEBQYHCAkKCwgJCgv94QH9CwQQIAhBAWoiCCAFRw0ACwsgFUKAgICAwAA3AgRBACEIIBVBADYCDEGkxMIAKAIAIgRFBEAQ1QEhBAsgBCgCACAEKAIEKAIMEQQAIQAgFUHYksIA/QADAP0LAxAgFSAArULf5ZfC7oqNqkaFIg9COIYgD0KA/gODQiiGhCAPQoCA/AeDQhiGIA9CgICA+A+DQgiGhIRCxqnRsQWEQtKBqpur+oLXp39+Ig5CgJQCg0IohiAOQoCAsAKDQhiGIA5CgICA6AaDQgiGhIQgDkIIiEKAgID4D4MgDkIYiEKAgPwHg4QgDkIoiEKA/gODIA5COIiEhIRCgICAgICAgIDsAIQgD0LYotHvwqnlvy1+hSIQQvGxzPG5irjsfoUiDkLYotHvwqnlvy1+IA5COIYgDkKA/gODQiiGhCAOQoCA/AeDQhiGIA5CgICA+A+DQgiGhIQgDkIIiEKAgID4D4MgDkIYiEKAgPwHg4QgDkIoiEKA/gODIA5COIiEhIRC0oGqm6v6gtenf34iDkI4hiAOQoD+A4NCKIaEIA5CgID8B4NCGIYgDkKAgID4D4NCCIaEhCAOQgiIQoCAgPgPgyAOQhiIQoCA/AeDhCAOQiiIQoD+A4MgDkI4iISEhIVCkfqOpPHPk/fFAIUiDkI4hiAOQoD+A4NCKIaEIA5CgID8B4NCGIYgDkKAgID4D4NCCIaEhCAOQgiIQoCAgPgPgyAOQhiIQoCA/AeDhCAOQiiIQoD+A4MgDkI4iISEhELSgaqbq/qC16d/fiIPQjiGIA9CgP4Dg0IohoQgD0KAgPwHg0IYhiAPQoCAgPgPg0IIhoSEIA9CCIhCgICA+A+DIA9CGIhCgID8B4OEIA9CKIhCgP4DgyAPQjiIhISEIA5C2KLR78Kp5b8tfoUiDkI4hiAOQoD+A4NCKIaEIA5CgID8B4NCGIYgDkKAgID4D4NCCIaEhCAOQgiIQoCAgPgPgyAOQhiIQoCA/AeDhCAOQiiIQoD+A4MgDkI4iISEhEKOip+43Pep+HF+Ig9COIYgD0KA/gODQiiGhCAPQoCA/AeDQhiGIA9CgICA+A+DQgiGhIQgD0IIiEKAgID4D4MgD0IYiEKAgPwHg4QgD0IoiEKA/gODIA9COIiEhIQgDkKOnuCShIe+nXF+hSAOiTcDOCAVIBBCos6WmuCPovoAhSIOQtii0e/CqeW/LX4gDkI4hiAOQoD+A4NCKIaEIA5CgID8B4NCGIYgDkKAgID4D4NCCIaEhCAOQgiIQoCAgPgPgyAOQhiIQoCA/AeDhCAOQiiIQoD+A4MgEEI4iISEhELSgaqbq/qC16d/fiIOQjiGIA5CgP4Dg0IohoQgDkKAgPwHg0IYhiAOQoCAgPgPg0IIhoSEIA5CCIhCgICA+A+DIA5CGIhCgID8B4OEIA5CKIhCgP4DgyAOQjiIhISEhULzu7XxgP3PsdEAhSIOQjiGIA5CgP4Dg0IohoQgDkKAgPwHg0IYhiAOQoCAgPgPg0IIhoSEIA5CCIhCgICA+A+DIA5CGIhCgID8B4OEIA5CKIhCgP4DgyAOQjiIhISEQtKBqpur+oLXp39+Ig9COIYgD0KA/gODQiiGhCAPQoCA/AeDQhiGIA9CgICA+A+DQgiGhIQgD0IIiEKAgID4D4MgD0IYiEKAgPwHg4QgD0IoiEKA/gODIA9COIiEhIQgDkLYotHvwqnlvy1+hSIOQjiGIA5CgP4Dg0IohoQgDkKAgPwHg0IYhiAOQoCAgPgPg0IIhoSEIA5CCIhCgICA+A+DIA5CGIhCgID8B4OEIA5CKIhCgP4DgyAOQjiIhISEQo6Kn7jc96n4cX4iD0I4hiAPQoD+A4NCKIaEIA9CgID8B4NCGIYgD0KAgID4D4NCCIaEhCAPQgiIQoCAgPgPgyAPQhiIQoCA/AeDhCAPQiiIQoD+A4MgD0I4iISEhCAOQo6e4JKEh76dcX6FIA6JNwMwIBUgEELzu7XxgP3PsdEAhSIOQtii0e/CqeW/LX4gDkI4hiAOQoD+A4NCKIaEIA5CgID8B4NCGIYgDkKAgID4D4NCCIaEhCAOQgiIQoCAgPgPgyAOQhiIQoCA/AeDhCAOQiiIQoD+A4MgDkI4iISEhELSgaqbq/qC16d/fiIOQjiGIA5CgP4Dg0IohoQgDkKAgPwHg0IYhiAOQoCAgPgPg0IIhoSEIA5CCIhCgICA+A+DIA5CGIhCgID8B4OEIA5CKIhCgP4DgyAOQjiIhISEhULxsczxuYq47H6FIg5COIYgDkKA/gODQiiGhCAOQoCA/AeDQhiGIA5CgICA+A+DQgiGhIQgDkIIiEKAgID4D4MgDkIYiEKAgPwHg4QgDkIoiEKA/gODIA5COIiEhIRC0oGqm6v6gtenf34iD0I4hiAPQoD+A4NCKIaEIA9CgID8B4NCGIYgD0KAgID4D4NCCIaEhCAPQgiIQoCAgPgPgyAPQhiIQoCA/AeDhCAPQiiIQoD+A4MgD0I4iISEhCAOQtii0e/CqeW/LX6FIg5COIYgDkKA/gODQiiGhCAOQoCA/AeDQhiGIA5CgICA+A+DQgiGhIQgDkIIiEKAgID4D4MgDkIYiEKAgPwHg4QgDkIoiEKA/gODIA5COIiEhIRCjoqfuNz3qfhxfiIPQjiGIA9CgP4Dg0IohoQgD0KAgPwHg0IYhiAPQoCAgPgPg0IIhoSEIA9CCIhCgICA+A+DIA9CGIhCgID8B4OEIA9CKIhCgP4DgyAPQjiIhISEIA5Cjp7gkoSHvp1xfoUgDok3AyggFSAQQpH6jqTxz5P3xQCFIg5C2KLR78Kp5b8tfiAOQjiGIA5CgP4Dg0IohoQgDkKAgPwHg0IYhiAOQoCAgPgPg0IIhoSEIA5CCIhCgICA+A+DIA5CGIhCgID8B4OEIA5CKIhCgP4DgyAOQjiIhISEQtKBqpur+oLXp39+Ig5COIYgDkKA/gODQiiGhCAOQoCA/AeDQhiGIA5CgICA+A+DQgiGhIQgDkIIiEKAgID4D4MgDkIYiEKAgPwHg4QgDkIoiEKA/gODIA5COIiEhISFIg9Cos6WmuCPovoAhSIOQjiGIA5CgP4Dg0IohoQgDkKAgPwHg0IYhiAOQoCAgPgPg0IIhoSEIA5CCIhCgICA+A+DIA5CGIhCgID8B4OEIA5CKIhCgP4DgyAPQjiIhISEQtKBqpur+oLXp39+Ig9COIYgD0KA/gODQiiGhCAPQoCA/AeDQhiGIA9CgICA+A+DQgiGhIQgD0IIiEKAgID4D4MgD0IYiEKAgPwHg4QgD0IoiEKA/gODIA9COIiEhIQgDkLYotHvwqnlvy1+hSIOQjiGIA5CgP4Dg0IohoQgDkKAgPwHg0IYhiAOQoCAgPgPg0IIhoSEIA5CCIhCgICA+A+DIA5CGIhCgID8B4OEIA5CKIhCgP4DgyAOQjiIhISEQo6Kn7jc96n4cX4iD0I4hiAPQoD+A4NCKIaEIA9CgID8B4NCGIYgD0KAgID4D4NCCIaEhCAPQgiIQoCAgPgPgyAPQhiIQoCA/AeDhCAPQiiIQoD+A4MgD0I4iISEhCAOQo6e4JKEh76dcX6FIA6JNwMgIBUgBTYCRCAVIBw2AkAgBiAFQfAAbGohHSAVIBVBBGo2AkwgFSAVQRBqNgJIIAUEQCAGQfAAaiEHIAVBAWtB/////wBxQQFqIQggBiEEQQAhAANAIAQoAkRFDQwgBCgCQCAEIAIgAxBWISggFUEANgJYIBUgADYCVCAVICg4AlAgFUHQAGoQoQEgFUFAayAAQQAQSkHwAEEAIAciBCAdRxsgBGohByAIIABBAWoiAEcNAAsLQfTCwgAoAgAiAARAA0ACQCAFQfDCwgAoAgAiGSgCBCIYSwRAIBkqAgAgAV9FDQEMDwsgGCAFQbTFwAAQnQIACwJAAkAgGSgCCCIXIAYgGEHwAGxqIhQoAkQiBEkEQCAUKAJAIBdBBHRqIhsvAQwiB0UEQCAVQdAAahBgIBQoAmQiACAUKAJcRgRAIBRB3ABqQdTFwAAQ8gELIBQoAmAgAEECdGogFzYCACAUIABBAWo2AmQMAwsgByAIakEBayIEIBZLDRAgGygCACEAIBVB0ABqEGAgFUFAayIZIBggABBKIBkgGCAAIAdqQQFrIhkQSiAUQcwAaiIjKAIAIRsgFEHIAGoiJCgCACEiIABBgIAETwRAIABBEHYiJSAbTw0CICIgJUECdGooAgBFDQILIBlBgIAETwRAIBlBEHYiGSAbTw0CICIgGUECdGooAgBFDQILIBRB3ABqIRkDQAJAAkAgAEEQdiIIICMoAgAiF0kEQCAAQf//A3EgJCgCACAIQQJ0aigCAEEQdHIiCCAUKAJEIhdPDQEgFCgCQCAIQQR0aiAUIAIgAxBWIiggAV9FBEAgFSAINgJYIBUgGDYCVCAVICg4AlAgFUHQAGoQoQEMAwsgFCgCZCIXIBQoAlxGBEAgGUGUxsAAEPIBCyAUKAJgIBdBAnRqIAg2AgAgFCAXQQFqNgJkDAILIAggF0H0xcAAEJ0CAAsgCCAXQYTGwAAQnQIACyAAQQFqIQAgB0EBayIHDQALIAQhCAwCCyAXIARBxMXAABCdAgALIBQoAmQiACAUKAJcRgRAIBRB3ABqQeTFwAAQ8gELIBQoAmAgAEECdGogFzYCACAUIABBAWo2AmQLQfTCwgAoAgAiAA0ACwtB9MLCAEEANgIAEJoDIRggBUUNEAwMCyAEIAlB5MfAABCsAwALIAQgCUHUx8AAEKwDAAsgBCAJQcTHwAAQrAMAC0GAlsIAEM0CCwALQcydwAAQuAIAC0HexMAAQR8QgAMhB0EBDAoLQf3EwABBGRCAAyEHQQEMCQtBlsXAAEEeEIADIQdBAQwIC0HAxMAAQR4QgAMhB0EBDAcLQQBBAEGkx8AAEJ0CAAtB9MLCAEEANgIAIABBDGwhACAZQQhqIQQDQCAEQQRrKAIAIgcgBU8NAiAEKAIAIRYgBiAHQfAAbGoiFEHcAGohCCAUKAJkIhggFCgCXEYEQCAIQZTHwAAQ8gELIAgoAgQgGEECdGogFjYCACAIIBhBAWo2AgggFUFAayAHIBYQSiAEQQxqIQQgAEEMayIADQALEJoDIRgLIAYhBANAAkAgBCgCZCIUQQJJDQAgBCgCYCEHIBRBFU8EQAJAAkACQCAHKAIEIgggBygCAEkiF0UEQCAHQQhqIRZBAiEAA0AgCCAWKAIAIghLDQIgFkEEaiEWIBQgAEEBaiIARw0ACwwCCyAHQQhqIRZBAiEAA0AgCCAWKAIAIghNDQEgFkEEaiEWIBQgAEEBaiIARw0ACwwBCyAAIBRHDQELIBdFDQIgFEECdCAHakEQayEIIBRBAXYiF0H8////B3EiGSEWIAchAANAIAAgCP0AAgAgAP0AAgAiJv0NDA0ODwgJCgsEBQYHAAECA/0LAgAgCCAmICb9DQwNDg8ICQoLBAUGBwABAgP9CwIAIABBEGohACAIQRBrIQggFkEEayIWDQALIBcgGUYNAiAUQQJ0IBRBAXRBcHEiAGsgB2pBBGshCCAXIBlrIRYgACAHaiEAA0AgACgCACEHIAAgCCgCADYCACAIIAc2AgAgCEEEayEIIABBBGohACAWQQFrIhYNAAsMAgsgByAUQQAgFEEBcmdBAXRBPnMQMQwBCyAHQQRqIRcgByAUQQJ0aiEZQQAhFgNAIBcoAgAiFCAXQQRrKAIAIghJBEAgFiEAAn8DQCAAIAdqQQRqIAg2AgAgByAARQ0BGiAUIABBBGsiACAHaiIbKAIAIghJDQALIBtBBGoLIBQ2AgALIBZBBGohFiAXQQRqIhcgGUcNAAsLIAQoAmQiAEH//wBxQQBHQQ50IABqQYCA//8DcRCTAyIHQQAgBCgCZBD6AiIAIAQoAmAgBCgCZBCBAiAAQYQBTwRAIAAQtQILEJgDIgBB9bnAAEEJEIADIgggBCgCZLgQkgMiFhCXA0HoyMIALQAADQJB7MjCAEEANgIAQejIwgBBADoAACAWQYQBTwRAIBYQtQILIAhBhAFPBEAgCBC1AgsgAEHcxsAAQQcQgAMiCCAHEJcDQejIwgAtAAANA0HsyMIAQQA2AgBB6MjCAEEAOgAAIAdBhAFPBEAgBxC1AgsgCEGEAU8EQCAIELUCCyAYIAAQsAMgAEGEAU8EQCAAELUCCyAEQfAAaiIEIB1HDQALDAMLIAcgBUGEx8AAEJ0CAAtB6MjCAEEAOgAAQezIwgAoAgAhAEHsyMIAQQA2AgAgFSAANgJQQaiNwgBBKyAVQdAAakGUusAAQfTGwAAQkwIAC0HoyMIAQQA6AABB7MjCACgCACEAQezIwgBBADYCACAVIAA2AlBBqI3CAEErIBVB0ABqQZS6wABB5MbAABCTAgALEJoDIQQgFSgCDCIHBEAgFSgCCCEAIAdBA3QhBwNAIABBBGooAgAhFCAAKAIAIRYQmgMiCCAWuBCSAyIWELADIBZBhAFPBEAgFhC1AgsgCCAUuBCSAyIWELADIBZBhAFPBEAgFhC1AgsgBCAIELADIAhBhAFPBEAgCBC1AgsgAEEIaiEAIAdBCGsiBw0ACwsQmAMiB0GkxsAAQQ8QgAMiACAYEJcDQejIwgAtAAANAUHsyMIAQQA2AgBB6MjCAEEAOgAAIBhBhAFPBEAgGBC1AgsgAEGEAU8EQCAAELUCCyAHQbPGwABBBhCAAyIAIAQQlwNB6MjCAC0AAA0CQezIwgBBADYCAEHoyMIAQQA6AAAgBEGEAU8EQCAEELUCCyAAQYQBTwRAIAAQtQILAkAgFSgCFCIWRQ0AIBUoAhwiCARAIBUoAhAiAEEIaiEEIAApAwBCf4VCgIGChIiQoMCAf4MhDgNAIA5QBEADQCAAQYABayEAIAQpAwAgBEEIaiEEQoCBgoSIkKDAgH+DIg5CgIGChIiQoMCAf1ENAAsgDkKAgYKEiJCgwIB/hSEOCyAAIA56p0EBdEHwAXFrIhhBDGsoAgAiFARAIBhBCGsoAgAiGEEEaygCACIXQXhxIhlBBEEIIBdBA3EiFxsgFGpJDQggF0EAIBkgFEEnaksbDQkgGBBbCyAOQgF9IA6DIQ4gCEEBayIIDQALCyAWQRFsQRlqIgBFDQAgFSgCECAWQQR0a0EQayAAEKUCCyAVKAIEIgAEQCAVKAIIIABBA3QQpQILIAUEQCAGQeAAaiEEIAUhAANAIARBBGsoAgAiCARAIAQoAgAiFkEEaygCACIUQXhxIhggCEECdCIIQQRBCCAUQQNxIhQbakkNByAUQQAgGCAIQSdqSxsNCCAWEFsLIARB8ABqIQQgAEEBayIADQALCyAhBEAgBiAhQfAAbBClAgtBsMLCAEGwwsIAKAIAQQFqNgIAQQALIQAgDQRAIAxBBGsoAgAiBEF4cSIGIA1BAnQiCEEEQQggBEEDcSIEG2pJDQQgBEEAIAYgCEEnaksbDQUgDBBbCyALBEAgCkEEaygCACIEQXhxIgYgC0ECdCIIQQRBCCAEQQNxIgQbakkNBCAEQQAgBiAIQSdqSxsNBSAKEFsLICAEQCAfQQRrKAIAIgRBeHEiBiAgQQJ0IghBBEEIIARBA3EiBBtqSQ0EIARBACAGIAhBJ2pLGw0FIB8QWwsgCQRAIB5BBGsoAgAiBEF4cSIGIAlBAnQiCEEEQQggBEEDcSIEG2pJDQQgBEEAIAYgCEEnaksbDQUgHhBbCyAFBEAgHEEEaygCACIEQXhxIgYgBUECdCIFQQRBCCAEQQNxIgQbakkNBCAEQQAgBiAFQSdqSxsNBSAcEFsLIBogADYCCCAaIAdBACAAGzYCBCAaQQAgByAAGzYCACAVQeAAaiQADAULQejIwgBBADoAAEHsyMIAKAIAIQBB7MjCAEEANgIAIBUgADYCUEGojcIAQSsgFUHQAGpBlLrAAEHMxsAAEJMCAAtB6MjCAEEAOgAAQezIwgAoAgAhAEHsyMIAQQA2AgAgFSAANgJQQaiNwgBBKyAVQdAAakGUusAAQbzGwAAQkwIAC0G0x8AAEKsDAAtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgALIBooAgAgGigCBCAaKAIIIBpBEGokAAtIAgJ/AX0gASgCCCIDQYCAgAFxIQIgACoCACEEIANBgICAgAFxRQRAIAEgBCACQQBHQQAQggEPCyABIAQgAkEARyABLwEOECsLQgEBfyMAQSBrIgMkACADQQA2AhAgA0EBNgIEIANCBDcCCCADIAE2AhwgAyAANgIYIAMgA0EYajYCACADIAIQ2gIACzsBAX8jAEEgayICJAAgAkEIaiAAKAIAIAJBFmoQvwEgAUEBQQFBACACKAIIIAIoAgwQjgEgAkEgaiQAC5oCAQN/IAAoAgAhACABKAIIIgJBgICAEHFFBEAgAkGAgIAgcUUEQCAAIAEQ+AEPCyAALQAAIQAjAEGAAWsiBCQAQYEBIQMDQCADIARqQQJrIABBD3EiAkEwciACQTdqIAJBCkkbOgAAIAAiAkEEdiEAIANBAWshAyACQQ9LDQALIAFBAUGbisIAQQIgAyAEakEBa0GBASADaxCOASAEQYABaiQADwsgAC0AACEAIwBBgAFrIgQkAEGBASEDA0AgAyAEakECayAAQQ9xIgJBMHIgAkHXAGogAkEKSRs6AAAgACICQQR2IQAgA0EBayEDIAJBD0sNAAsgAUEBQZuKwgBBAiADIARqQQFrQYEBIANrEI4BIARBgAFqJAALOAEBfyMAQRBrIgIkACACQQhqIAAgACgCACgCBBECACACKAIIIAEgAigCDCgCEBEBACACQRBqJAAL4SkCA34WfyMAQRBrIhYkACMBQQFrIhckASAXIAgmASAAIRsgASEZIwBB0ABrIg0kAEGkxMIAKAIAIg9FBEAQ1QEhDwsgDygCACAPKAIEKAIMEQQAIQAgDUHYksIA/QADAP0LAxAgDSAArULf5ZfC7oqNqkaFIgpCOIYgCkKA/gODQiiGhCAKQoCA/AeDQhiGIApCgICA+A+DQgiGhIRCxqnRsQWEQtKBqpur+oLXp39+IglCgJQCg0IohiAJQoCAsAKDQhiGIAlCgICA6AaDQgiGhIQgCUIIiEKAgID4D4MgCUIYiEKAgPwHg4QgCUIoiEKA/gODIAlCOIiEhIRCgICAgICAgIDsAIQgCkLYotHvwqnlvy1+hSILQvGxzPG5irjsfoUiCULYotHvwqnlvy1+IAlCOIYgCUKA/gODQiiGhCAJQoCA/AeDQhiGIAlCgICA+A+DQgiGhIQgCUIIiEKAgID4D4MgCUIYiEKAgPwHg4QgCUIoiEKA/gODIAlCOIiEhIRC0oGqm6v6gtenf34iCUI4hiAJQoD+A4NCKIaEIAlCgID8B4NCGIYgCUKAgID4D4NCCIaEhCAJQgiIQoCAgPgPgyAJQhiIQoCA/AeDhCAJQiiIQoD+A4MgCUI4iISEhIVCkfqOpPHPk/fFAIUiCUI4hiAJQoD+A4NCKIaEIAlCgID8B4NCGIYgCUKAgID4D4NCCIaEhCAJQgiIQoCAgPgPgyAJQhiIQoCA/AeDhCAJQiiIQoD+A4MgCUI4iISEhELSgaqbq/qC16d/fiIKQjiGIApCgP4Dg0IohoQgCkKAgPwHg0IYhiAKQoCAgPgPg0IIhoSEIApCCIhCgICA+A+DIApCGIhCgID8B4OEIApCKIhCgP4DgyAKQjiIhISEIAlC2KLR78Kp5b8tfoUiCUI4hiAJQoD+A4NCKIaEIAlCgID8B4NCGIYgCUKAgID4D4NCCIaEhCAJQgiIQoCAgPgPgyAJQhiIQoCA/AeDhCAJQiiIQoD+A4MgCUI4iISEhEKOip+43Pep+HF+IgpCOIYgCkKA/gODQiiGhCAKQoCA/AeDQhiGIApCgICA+A+DQgiGhIQgCkIIiEKAgID4D4MgCkIYiEKAgPwHg4QgCkIoiEKA/gODIApCOIiEhIQgCUKOnuCShIe+nXF+hSAJiTcDOCANIAtCos6WmuCPovoAhSIJQtii0e/CqeW/LX4gCUI4hiAJQoD+A4NCKIaEIAlCgID8B4NCGIYgCUKAgID4D4NCCIaEhCAJQgiIQoCAgPgPgyAJQhiIQoCA/AeDhCAJQiiIQoD+A4MgC0I4iISEhELSgaqbq/qC16d/fiIJQjiGIAlCgP4Dg0IohoQgCUKAgPwHg0IYhiAJQoCAgPgPg0IIhoSEIAlCCIhCgICA+A+DIAlCGIhCgID8B4OEIAlCKIhCgP4DgyAJQjiIhISEhULzu7XxgP3PsdEAhSIJQjiGIAlCgP4Dg0IohoQgCUKAgPwHg0IYhiAJQoCAgPgPg0IIhoSEIAlCCIhCgICA+A+DIAlCGIhCgID8B4OEIAlCKIhCgP4DgyAJQjiIhISEQtKBqpur+oLXp39+IgpCOIYgCkKA/gODQiiGhCAKQoCA/AeDQhiGIApCgICA+A+DQgiGhIQgCkIIiEKAgID4D4MgCkIYiEKAgPwHg4QgCkIoiEKA/gODIApCOIiEhIQgCULYotHvwqnlvy1+hSIJQjiGIAlCgP4Dg0IohoQgCUKAgPwHg0IYhiAJQoCAgPgPg0IIhoSEIAlCCIhCgICA+A+DIAlCGIhCgID8B4OEIAlCKIhCgP4DgyAJQjiIhISEQo6Kn7jc96n4cX4iCkI4hiAKQoD+A4NCKIaEIApCgID8B4NCGIYgCkKAgID4D4NCCIaEhCAKQgiIQoCAgPgPgyAKQhiIQoCA/AeDhCAKQiiIQoD+A4MgCkI4iISEhCAJQo6e4JKEh76dcX6FIAmJNwMwIA0gC0Lzu7XxgP3PsdEAhSIJQtii0e/CqeW/LX4gCUI4hiAJQoD+A4NCKIaEIAlCgID8B4NCGIYgCUKAgID4D4NCCIaEhCAJQgiIQoCAgPgPgyAJQhiIQoCA/AeDhCAJQiiIQoD+A4MgCUI4iISEhELSgaqbq/qC16d/fiIJQjiGIAlCgP4Dg0IohoQgCUKAgPwHg0IYhiAJQoCAgPgPg0IIhoSEIAlCCIhCgICA+A+DIAlCGIhCgID8B4OEIAlCKIhCgP4DgyAJQjiIhISEhULxsczxuYq47H6FIglCOIYgCUKA/gODQiiGhCAJQoCA/AeDQhiGIAlCgICA+A+DQgiGhIQgCUIIiEKAgID4D4MgCUIYiEKAgPwHg4QgCUIoiEKA/gODIAlCOIiEhIRC0oGqm6v6gtenf34iCkI4hiAKQoD+A4NCKIaEIApCgID8B4NCGIYgCkKAgID4D4NCCIaEhCAKQgiIQoCAgPgPgyAKQhiIQoCA/AeDhCAKQiiIQoD+A4MgCkI4iISEhCAJQtii0e/CqeW/LX6FIglCOIYgCUKA/gODQiiGhCAJQoCA/AeDQhiGIAlCgICA+A+DQgiGhIQgCUIIiEKAgID4D4MgCUIYiEKAgPwHg4QgCUIoiEKA/gODIAlCOIiEhIRCjoqfuNz3qfhxfiIKQjiGIApCgP4Dg0IohoQgCkKAgPwHg0IYhiAKQoCAgPgPg0IIhoSEIApCCIhCgICA+A+DIApCGIhCgID8B4OEIApCKIhCgP4DgyAKQjiIhISEIAlCjp7gkoSHvp1xfoUgCYk3AyggDSALQpH6jqTxz5P3xQCFIglC2KLR78Kp5b8tfiAJQjiGIAlCgP4Dg0IohoQgCUKAgPwHg0IYhiAJQoCAgPgPg0IIhoSEIAlCCIhCgICA+A+DIAlCGIhCgID8B4OEIAlCKIhCgP4DgyAJQjiIhISEQtKBqpur+oLXp39+IglCOIYgCUKA/gODQiiGhCAJQoCA/AeDQhiGIAlCgICA+A+DQgiGhIQgCUIIiEKAgID4D4MgCUIYiEKAgPwHg4QgCUIoiEKA/gODIAlCOIiEhISFIgpCos6WmuCPovoAhSIJQjiGIAlCgP4Dg0IohoQgCUKAgPwHg0IYhiAJQoCAgPgPg0IIhoSEIAlCCIhCgICA+A+DIAlCGIhCgID8B4OEIAlCKIhCgP4DgyAKQjiIhISEQtKBqpur+oLXp39+IgpCOIYgCkKA/gODQiiGhCAKQoCA/AeDQhiGIApCgICA+A+DQgiGhIQgCkIIiEKAgID4D4MgCkIYiEKAgPwHg4QgCkIoiEKA/gODIApCOIiEhIQgCULYotHvwqnlvy1+hSIJQjiGIAlCgP4Dg0IohoQgCUKAgPwHg0IYhiAJQoCAgPgPg0IIhoSEIAlCCIhCgICA+A+DIAlCGIhCgID8B4OEIAlCKIhCgP4DgyAJQjiIhISEQo6Kn7jc96n4cX4iCkI4hiAKQoD+A4NCKIaEIApCgID8B4NCGIYgCkKAgID4D4NCCIaEhCAKQgiIQoCAgPgPgyAKQhiIQoCA/AeDhCAKQiiIQoD+A4MgCkI4iISEhCAJQo6e4JKEh76dcX6FIAmJNwMgQajCwgAoAgBFBEAQMAsCQEGwwsIAKAIARQRAQbDCwgBBfzYCACAXJQEQDiEfIAcgBSADIBkgAyAZSRsiACAAIAVLGyIAIAAgB0sbIiBFDQECQANAIBggH0YNAyAXJQEgGBAPIQgQngEiEiAIJgEgBiAYQQJ0IgBqKAIAIRwgACAEaigCACAAIAJqKAIAIR4gDUFAayAAIBtqKAIAIhoQdAJAIA0oAkwiDARAIAwoAgAiACAMKAIEIg8gDSgCQCIQcSIOaikAAEKAgYKEiJCgwIB/gyIJUARAQQghAQNAIAEgDmohDiABQQhqIQEgACAOIA9xIg5qKQAAQoCBgoSIkKDAgH+DIglQDQALCyAAIAl6p0EDdiAOaiAPcSIOaiwAACIBQQBOBEAgACAAKQMAQoCBgoSIkKDAgH+DeqdBA3YiDmotAAAhAQsgDSgCSCETIAAgDmogEEEZdiIQOgAAIAAgDkEIayAPcWpBCGogEDoAACAMIAwoAgggAUEBcWs2AgggDCAMKAIMQQFqNgIMIAAgDkFYbGoiEEEEa0EANgIAIBBBDGtCgICAgMAANwIAIBBBFGtCBDcCACAQQRxrQgA3AgAgEEEka0KAgICAwAA3AgAgEEEoayATNgIADAELIA0oAkAhEAtBEHYhDyAcQRB2IBxB//8DcUEAR2oiESAeQRB2IgFqIhMgEEEQayIdKAIAIgxLBEAgEyAMIgBrIg4gEEEYayIVKAIAIABrSwRAIBUgACAOQQRBBBDZASAdKAIAIQALIBBBFGsoAgAiFCAAQQJ0aiEVIA5BAk8EfyATIAxBf3NqQQJ0IgwEQCAVQQAgDPwLAAsgACAOaiIMQQFrIQAgFCAMQQJ0akEEawUgFQtBADYCACAdIABBAWo2AgALIA8gEWoiFSAQQQRrIhMoAgAiDEsEQCAVIAwiAGsiDiAQQQxrIhQoAgAgAGtLBEAgFCAAIA5BBEEEENkBIBMoAgAhAAsgEEEIaygCACIhIABBAnRqIRQgDkECTwR/IBUgDEF/c2pBAnQiDARAIBRBACAM/AsACyAAIA5qIgxBAWshACAhIAxBAnRqQQRrBSAUC0EANgIAIBMgAEEBajYCAAsgEiEMAkAgEQRAIAFBAnQhDiAPQQJ0IQAgEEEIayESIBBBFGshFQNAIAEgHSgCACIUTw0CIBUoAgAgDmogDzYCACAPIBMoAgAiFE8NBCASKAIAIABqIAE2AgAgDkEEaiEOIAFBAWohASAAQQRqIQAgD0EBaiEPIBFBAWsiEQ0ACwsCQAJAIA0oAhxFDQAgDSgCFCIAIA0pAygiCSAarYUiCkI4hiAKQoD+A4NCKIaEIApCgID8B4NCGIYgCkKAgID4D4NCCIaEhCAJQgiIQoCAgPgPgyAJQhiIQoCA/AeDhCAJQiiIQoD+A4MgCUI4iISEhELSgaqbq/qC16d/fiIJQjiGIAlCgP4Dg0IohoQgCUKAgPwHg0IYhiAJQoCAgPgPg0IIhoSEIAlCCIhCgICA+A+DIAlCGIhCgID8B4OEIAlCKIhCgP4DgyAJQjiIhISEIApC2KLR78Kp5b8tfoUiCUI4hiAJQoD+A4NCKIaEIAlCgID8B4NCGIYgCUKAgID4D4NCCIaEhCAJQgiIQoCAgPgPgyAJQhiIQoCA/AeDhCAJQiiIQoD+A4MgCUI4iISEhCANKQMgIgpCf4V+IgtCOIYgC0KA/gODQiiGhCALQoCA/AeDQhiGIAtCgICA+A+DQgiGhIQgC0IIiEKAgID4D4MgC0IYiEKAgPwHg4QgC0IoiEKA/gODIAtCOIiEhIQgCSAKQjiGIApCgP4Dg0IohoQgCkKAgPwHg0IYhiAKQoCAgPgPg0IIhoSEIApCCIhCgICA+A+DIApCGIhCgID8B4OEIApCKIhCgP4DgyAKQjiIhISEfoUgCYkiCadxIQ8gCUIZiEL/AINCgYKEiJCgwIABfiELIA0oAhAiAUEIayESQQAhEQNAIAEgD2opAAAiCiALhSIJQn+FIAlCgYKEiJCgwIABfYNCgIGChIiQoMCAf4MiCVBFBEADQCAaIBIgCXqnQQN2IA9qIABxQQN0aygCAEYNBCAJQgF9IAmDIglQRQ0ACwsgCiAKQgGGg0KAgYKEiJCgwIB/g1BFDQEgDyARQQhqIhFqIABxIQ8MAAsACyATKAIAEJMDIgAgEEEIaygCACATKAIAEIECIA1BCGogDUEQaiAaIAAQXiANKAIIRQ0AIA0oAgwiAEGEAUkNACAAELUCCyAaIB4gHCAMEFAgDEGEAU8EQCAMELUCCyAYQQFqIhggIEcNAQwECwsgASAUQfDDwAAQnQIACyAPIBRBgMTAABCdAgALQcydwAAQuAIACxCYAyEQIA0oAhwhESANQRhqQeCSwgApAwA3AwAgDSgCFCEMIA0oAhAhACANQdiSwgApAwA3AxAgEQRAIABBCGohDyAAKQMAQn+FQoCBgoSIkKDAgH+DIQkgACEBA0AgCVAEQANAIAFBQGohASAPKQMAIA9BCGohD0KAgYKEiJCgwIB/gyIJQoCBgoSIkKDAgH9RDQALIAlCgIGChIiQoMCAf4UhCQsgASAJeqdB+ABxayIOQQRrKAIAIRIgECAOQQhrKAIAuBCSAyIOIBIQlwNB6MjCAC0AAARAQejIwgBBADoAAEHsyMIAKAIAIQBB7MjCAEEANgIAIA0gADYCQEGojcIAQSsgDUFAa0GUusAAQeDDwAAQkwIAC0HsyMIAQQA2AgBB6MjCAEEAOgAAIBJBhAFPBEAgEhC1AgsgDkGEAU8EQCAOELUCCyAJQgF9IAmDIQkgEUEBayIRDQALCwJAAkACQAJAIAwEQCAMQQlqIgEEQCAAQf8BIAH8CwALQbDCwgBBsMLCACgCAEEBajYCACAMQQlsIgFBEWoiEkUNASAAIAxBA3RrIgBBDGsoAgAiDEF4cSIPQQRBCCAMQQNxIgwbIBJqSQ0CIAxBACAPIAFBOGpLGw0DIABBCGsQWwwBC0GwwsIAQbDCwgAoAgBBAWo2AgALIAcEQCAGQQRrKAIAIgBBeHEiASAHQQJ0IgdBBEEIIABBA3EiABtqSQ0BIABBACABIAdBJ2pLGw0CIAYQWwsgBQRAIARBBGsoAgAiAEF4cSIBIAVBAnQiBUEEQQggAEEDcSIAG2pJDQEgAEEAIAEgBUEnaksbDQIgBBBbCyADBEAgAkEEaygCACIAQXhxIgEgA0ECdCIDQQRBCCAAQQNxIgAbakkNASAAQQAgASADQSdqSxsNAiACEFsLIBkEQCAbQQRrKAIAIgBBeHEiASAZQQJ0IgJBBEEIIABBA3EiABtqSQ0BIABBACABIAJBJ2pLGw0CIBsQWwsgFkIANwIEIBYgEDYCACANQdAAaiQADAILQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIACyAX0G9BAfwRASAXQQFqJAEgFigCACAWKAIEIBYoAgggFkEQaiQACzgAAkAgAkGAgMQARg0AIAAgAiABKAIQEQEARQ0AQQEPCyADRQRAQQAPCyAAIAMgBCABKAIMEQAAC8MmAgN+EH8jAEEQayIWJAAjAEHQAGsiDCQAQajCwgAoAgBFBEAQMAsCQEGwwsIAKAIARQRAQbDCwgBBfzYCAEGkxMIAKAIAIg1FBEAQ1QEhDQsgDSgCACANKAIEKAIMEQQAIQsgDEHYksIA/QADAP0LAxAgDCALrULf5ZfC7oqNqkaFIglCOIYgCUKA/gODQiiGhCAJQoCA/AeDQhiGIAlCgICA+A+DQgiGhIRCxqnRsQWEQtKBqpur+oLXp39+IghCgJQCg0IohiAIQoCAsAKDQhiGIAhCgICA6AaDQgiGhIQgCEIIiEKAgID4D4MgCEIYiEKAgPwHg4QgCEIoiEKA/gODIAhCOIiEhIRCgICAgICAgIDsAIQgCULYotHvwqnlvy1+hSIJQvGxzPG5irjsfoUiCELYotHvwqnlvy1+IAhCOIYgCEKA/gODQiiGhCAIQoCA/AeDQhiGIAhCgICA+A+DQgiGhIQgCEIIiEKAgID4D4MgCEIYiEKAgPwHg4QgCEIoiEKA/gODIAhCOIiEhIRC0oGqm6v6gtenf34iCEI4hiAIQoD+A4NCKIaEIAhCgID8B4NCGIYgCEKAgID4D4NCCIaEhCAIQgiIQoCAgPgPgyAIQhiIQoCA/AeDhCAIQiiIQoD+A4MgCEI4iISEhIVCkfqOpPHPk/fFAIUiCkI4hiAKQoD+A4NCKIaEIApCgID8B4NCGIYgCkKAgID4D4NCCIaEhCAKQgiIQoCAgPgPgyAKQhiIQoCA/AeDhCAKQiiIQoD+A4MgCkI4iISEhELSgaqbq/qC16d/fiIIQjiGIAhCgP4Dg0IohoQgCEKAgPwHg0IYhiAIQoCAgPgPg0IIhoSEIAhCCIhCgICA+A+DIAhCGIhCgID8B4OEIAhCKIhCgP4DgyAIQjiIhISEIApC2KLR78Kp5b8tfoUiCkI4hiAKQoD+A4NCKIaEIApCgID8B4NCGIYgCkKAgID4D4NCCIaEhCAKQgiIQoCAgPgPgyAKQhiIQoCA/AeDhCAKQiiIQoD+A4MgCkI4iISEhEKOip+43Pep+HF+IghCOIYgCEKA/gODQiiGhCAIQoCA/AeDQhiGIAhCgICA+A+DQgiGhIQgCEIIiEKAgID4D4MgCEIYiEKAgPwHg4QgCEIoiEKA/gODIAhCOIiEhIQgCkKOnuCShIe+nXF+hSAKiTcDOCAMIAlCos6WmuCPovoAhSIIQtii0e/CqeW/LX4gCEI4hiAIQoD+A4NCKIaEIAhCgID8B4NCGIYgCEKAgID4D4NCCIaEhCAIQgiIQoCAgPgPgyAIQhiIQoCA/AeDhCAIQiiIQoD+A4MgCUI4iISEhELSgaqbq/qC16d/fiIIQjiGIAhCgP4Dg0IohoQgCEKAgPwHg0IYhiAIQoCAgPgPg0IIhoSEIAhCCIhCgICA+A+DIAhCGIhCgID8B4OEIAhCKIhCgP4DgyAIQjiIhISEhULzu7XxgP3PsdEAhSIKQjiGIApCgP4Dg0IohoQgCkKAgPwHg0IYhiAKQoCAgPgPg0IIhoSEIApCCIhCgICA+A+DIApCGIhCgID8B4OEIApCKIhCgP4DgyAKQjiIhISEQtKBqpur+oLXp39+IghCOIYgCEKA/gODQiiGhCAIQoCA/AeDQhiGIAhCgICA+A+DQgiGhIQgCEIIiEKAgID4D4MgCEIYiEKAgPwHg4QgCEIoiEKA/gODIAhCOIiEhIQgCkLYotHvwqnlvy1+hSIKQjiGIApCgP4Dg0IohoQgCkKAgPwHg0IYhiAKQoCAgPgPg0IIhoSEIApCCIhCgICA+A+DIApCGIhCgID8B4OEIApCKIhCgP4DgyAKQjiIhISEQo6Kn7jc96n4cX4iCEI4hiAIQoD+A4NCKIaEIAhCgID8B4NCGIYgCEKAgID4D4NCCIaEhCAIQgiIQoCAgPgPgyAIQhiIQoCA/AeDhCAIQiiIQoD+A4MgCEI4iISEhCAKQo6e4JKEh76dcX6FIAqJNwMwIAwgCULzu7XxgP3PsdEAhSIIQtii0e/CqeW/LX4gCEI4hiAIQoD+A4NCKIaEIAhCgID8B4NCGIYgCEKAgID4D4NCCIaEhCAIQgiIQoCAgPgPgyAIQhiIQoCA/AeDhCAIQiiIQoD+A4MgCEI4iISEhELSgaqbq/qC16d/fiIIQjiGIAhCgP4Dg0IohoQgCEKAgPwHg0IYhiAIQoCAgPgPg0IIhoSEIAhCCIhCgICA+A+DIAhCGIhCgID8B4OEIAhCKIhCgP4DgyAIQjiIhISEhULxsczxuYq47H6FIgpCOIYgCkKA/gODQiiGhCAKQoCA/AeDQhiGIApCgICA+A+DQgiGhIQgCkIIiEKAgID4D4MgCkIYiEKAgPwHg4QgCkIoiEKA/gODIApCOIiEhIRC0oGqm6v6gtenf34iCEI4hiAIQoD+A4NCKIaEIAhCgID8B4NCGIYgCEKAgID4D4NCCIaEhCAIQgiIQoCAgPgPgyAIQhiIQoCA/AeDhCAIQiiIQoD+A4MgCEI4iISEhCAKQtii0e/CqeW/LX6FIgpCOIYgCkKA/gODQiiGhCAKQoCA/AeDQhiGIApCgICA+A+DQgiGhIQgCkIIiEKAgID4D4MgCkIYiEKAgPwHg4QgCkIoiEKA/gODIApCOIiEhIRCjoqfuNz3qfhxfiIIQjiGIAhCgP4Dg0IohoQgCEKAgPwHg0IYhiAIQoCAgPgPg0IIhoSEIAhCCIhCgICA+A+DIAhCGIhCgID8B4OEIAhCKIhCgP4DgyAIQjiIhISEIApCjp7gkoSHvp1xfoUgCok3AyggDCAJQpH6jqTxz5P3xQCFIglC2KLR78Kp5b8tfiAJQjiGIAlCgP4Dg0IohoQgCUKAgPwHg0IYhiAJQoCAgPgPg0IIhoSEIAlCCIhCgICA+A+DIAlCGIhCgID8B4OEIAlCKIhCgP4DgyAJQjiIhISEQtKBqpur+oLXp39+IglCOIYgCUKA/gODQiiGhCAJQoCA/AeDQhiGIAlCgICA+A+DQgiGhIQgCUIIiEKAgID4D4MgCUIYiEKAgPwHg4QgCUIoiEKA/gODIAlCOIiEhISFIglCos6WmuCPovoAhSIIQjiGIAhCgP4Dg0IohoQgCEKAgPwHg0IYhiAIQoCAgPgPg0IIhoSEIAhCCIhCgICA+A+DIAhCGIhCgID8B4OEIAhCKIhCgP4DgyAJQjiIhISEQtKBqpur+oLXp39+IglCOIYgCUKA/gODQiiGhCAJQoCA/AeDQhiGIAlCgICA+A+DQgiGhIQgCUIIiEKAgID4D4MgCUIYiEKAgPwHg4QgCUIoiEKA/gODIAlCOIiEhIQgCELYotHvwqnlvy1+hSIIQjiGIAhCgP4Dg0IohoQgCEKAgPwHg0IYhiAIQoCAgPgPg0IIhoSEIAhCCIhCgICA+A+DIAhCGIhCgID8B4OEIAhCKIhCgP4DgyAIQjiIhISEQo6Kn7jc96n4cX4iCUI4hiAJQoD+A4NCKIaEIAlCgID8B4NCGIYgCUKAgID4D4NCCIaEhCAJQgiIQoCAgPgPgyAJQhiIQoCA/AeDhCAJQiiIQoD+A4MgCUI4iISEhCAIQo6e4JKEh76dcX6FIAiJNwMgIAcgBSADIAEgASADSxsiCyAFIAtJGyILIAcgC0kbIhdFDQECQANAIAYgGUECdCILaigCACEUIAQgC2ooAgAhGCACIAtqKAIAIRMgDEFAayAAIAtqKAIAIhoQdAJAIAwoAkwiEARAIBAoAgAiDSAQKAIEIhUgDCgCQCIRcSISaikAAEKAgYKEiJCgwIB/gyIJUARAQQghDwNAIA8gEmohCyAPQQhqIQ8gDSALIBVxIhJqKQAAQoCBgoSIkKDAgH+DIglQDQALCyANIAl6p0EDdiASaiAVcSISaiwAACIPQQBOBEAgDSANKQMAQoCBgoSIkKDAgH+DeqdBA3YiEmotAAAhDwsgDCgCSCEOIA0gEmogEUEZdiILOgAAIA0gEkEIayAVcWpBCGogCzoAACAQIBAoAgggD0EBcWs2AgggECAQKAIMQQFqNgIMIA0gEkFYbGoiD0EEa0EANgIAIA9BDGtCgICAgMAANwIAIA9BFGtCBDcCACAPQRxrQgA3AgAgD0Eka0KAgICAwAA3AgAgD0EoayAONgIADAELIAwoAkAhDwsCQCAUQRB2Ig4gFEH//wNxQQBHIgtyBEAgCyAOaiEQIBNBEHYiDUECdCEVIBhBEHYiDkECdCESIA9BCGshFCAPQQRrIRggD0EUayETIA9BEGshEQNAIA0gESgCACILTw0CIBMoAgAgFWpBADYCACAOIBgoAgAiC08NBCAUKAIAIBJqQQA2AgAgFUEEaiEVIA1BAWohDSASQQRqIRIgDkEBaiEOIBBBAWsiEA0ACwsCQAJAIAwoAhxFDQAgDCgCFCIRIAwpAygiCCAarYUiCUI4hiAJQoD+A4NCKIaEIAlCgID8B4NCGIYgCUKAgID4D4NCCIaEhCAIQgiIQoCAgPgPgyAIQhiIQoCA/AeDhCAIQiiIQoD+A4MgCEI4iISEhELSgaqbq/qC16d/fiIIQjiGIAhCgP4Dg0IohoQgCEKAgPwHg0IYhiAIQoCAgPgPg0IIhoSEIAhCCIhCgICA+A+DIAhCGIhCgID8B4OEIAhCKIhCgP4DgyAIQjiIhISEIAlC2KLR78Kp5b8tfoUiCkI4hiAKQoD+A4NCKIaEIApCgID8B4NCGIYgCkKAgID4D4NCCIaEhCAKQgiIQoCAgPgPgyAKQhiIQoCA/AeDhCAKQiiIQoD+A4MgCkI4iISEhCAMKQMgIghCf4V+IglCOIYgCUKA/gODQiiGhCAJQoCA/AeDQhiGIAlCgICA+A+DQgiGhIQgCUIIiEKAgID4D4MgCUIYiEKAgPwHg4QgCUIoiEKA/gODIAlCOIiEhIQgCiAIQjiGIAhCgP4Dg0IohoQgCEKAgPwHg0IYhiAIQoCAgPgPg0IIhoSEIAhCCIhCgICA+A+DIAhCGIhCgID8B4OEIAhCKIhCgP4DgyAIQjiIhISEfoUgCokiCadxIQ0gCUIZiEL/AINCgYKEiJCgwIABfiEIIAwoAhAiDkEIayELQQAhEANAIA0gDmopAAAiCiAIhSIJQn+FIAlCgYKEiJCgwIABfYNCgIGChIiQoMCAf4MiCVBFBEADQCAaIAsgCXqnQQN2IA1qIBFxQQN0aygCAEYNBCAJQgF9IAmDIglQRQ0ACwsgCiAKQgGGg0KAgYKEiJCgwIB/g1BFDQEgDSAQQQhqIhBqIBFxIQ0MAAsACyAPQQRrIg4oAgAQkwMiCyAPQQhrKAIAIA4oAgAQgQIgDEEIaiAMQRBqIBogCxBeIAwoAghFDQAgDCgCDCILQYQBSQ0AIAsQtQILIBlBAWoiGSAXRw0BDAQLCyANIAtBoMTAABCdAgALIA4gC0GwxMAAEJ0CAAtBzJ3AABC4AgALEJgDIRQgDCgCHCEQIAxBGGpB4JLCACkDADcDACAMKAIUIRcgDCgCECELIAxB2JLCACkDADcDECAQBEAgC0EIaiENIAspAwBCf4VCgIGChIiQoMCAf4MhCSALIQ4DQCAJUARAA0AgDkFAaiEOIA0pAwAgDUEIaiENQoCBgoSIkKDAgH+DIglCgIGChIiQoMCAf1ENAAsgCUKAgYKEiJCgwIB/hSEJCyAOIAl6p0H4AHFrIhFBBGsoAgAhEyAUIBFBCGsoAgC4EJIDIhEgExCXA0HoyMIALQAABEBB6MjCAEEAOgAAQezIwgAoAgAhAEHsyMIAQQA2AgAgDCAANgJAQaiNwgBBKyAMQUBrQZS6wABBkMTAABCTAgALQezIwgBBADYCAEHoyMIAQQA6AAAgE0GEAU8EQCATELUCCyARQYQBTwRAIBEQtQILIAlCAX0gCYMhCSAQQQFrIhANAAsLAkACQAJAAkAgF0UNACAXQQlqIg4EQCALQf8BIA78CwALIBdBCWwiGEERaiITRQ0AIAsgF0EDdGsiEUEMaygCACILQXhxIg4gE0EEQQggC0EDcSILG2pJDQEgC0EAIA4gGEE4aksbDQIgEUEIaxBbC0GwwsIAQbDCwgAoAgBBAWo2AgAgBwRAIAZBBGsoAgAiEUF4cSIOIAdBAnQiC0EEQQggEUEDcSIHG2pJDQEgB0EAIA4gC0EnaksbDQIgBhBbCyAFBEAgBEEEaygCACILQXhxIgcgBUECdCIGQQRBCCALQQNxIgUbakkNASAFQQAgByAGQSdqSxsNAiAEEFsLIAMEQCACQQRrKAIAIgZBeHEiBSADQQJ0IgRBBEEIIAZBA3EiAxtqSQ0BIANBACAFIARBJ2pLGw0CIAIQWwsgAQRAIABBBGsoAgAiBEF4cSIDIAFBAnQiAkEEQQggBEEDcSIBG2pJDQEgAUEAIAMgAkEnaksbDQIgABBbCyAWQgA3AgQgFiAUNgIAIAxB0ABqJAAMAgtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgALIBYoAgAgFigCBCAWKAIIIBZBEGokAAvdAQEEfyMAQRBrIgIkACACIAA2AgwjAEEQayIAJAAgASgCAEHAgcIAQQ0gASgCBCgCDBEAACEDIABBADoADSAAIAM6AAwgACABNgIIIABBCGpBzYHCAEEEIAJBDGpBJRDUASEDIAAtAA0iBCAALQAMIgVyIQECQCAFQQFxIARBAUdyDQAgAygCACIBLQAKQYABcUUEQCABKAIAQZmKwgBBAiABKAIEKAIMEQAAIQEMAQsgASgCAEGihsIAQQEgASgCBCgCDBEAACEBCyAAQRBqJAAgAUEBcSACQRBqJAALOgEBfyMAQSBrIgAkACAAQQA2AhggAEEBNgIMIABByP3AADYCCCAAQgQ3AhAgAEEIakHQ/cAAENoCAAs3AQF/IwBBIGsiASQAIAFBADYCGCABQQE2AgwgAUGczMAANgIIIAFCBDcCECABQQhqIAAQ2gIACzcBAX8jAEEgayIBJAAgAUEANgIYIAFBATYCDCABQYyQwQA2AgggAUIENwIQIAFBCGogABDaAgALNwEBfyMAQRBrIgQkACAEIAE2AgwgBCAANgIIIARBCGpBvPfAACAEQQxqQbz3wAAgAiADEMcBAAs+AQF/QQEhAgJAIAAoAgAgARDKAQ0AIAEoAgBBsPbAAEECIAEoAgQoAgwRAAANACAAKAIEIAEQygEhAgsgAgs9AQF/IwBBEGsiAiQAIAJByp3AADYCDCACIAA2AgggAkEIakGsqMIAIAJBDGpBrKjCACABQfizwgAQxwEACzcAIAEoAgAgAC0AAEEEakH/AXFBAnQiAEHoy8AAaigCACAAQczLwABqKAIAIAEoAgQoAgwRAAALLQACQCADaUEBRyABQYCAgIB4IANrS3JFBEAgACABIAMgAhBiIgANAQsACyAAC+wUAw1/C3sIfRCeASIXIAkmAQJ/IAghEiMAQTBrIg0kACANQoCAgIDAADcCBCANQQA2AgxB+MPCAC0AAEUEQAJAAkACQEGAgMAAEC4iCARAIAhBBGstAABBA3EEQCAIQQBBgIDAAPwLAAtBiMTCAEEBOgAAQfjDwgAtAABB+MPCAEEBOgAAQYDEwgAtAAAhE0GAxMIAQQE6AABBhMTCACgCACEOQYTEwgAgCDYCAEH8w8IAQQA2AgBFIBNBAXFFckUEQCAOQQRrKAIAIghBeHFBhIDAAEGIgMAAIAhBA3EiEBtJDQIgEEEAIAhBqIDAAE8bDQMgDhBbCwwDCwALQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIACwsCQAJAAkACQAJAAn8CQAJAQfzDwgAoAgBFBEBB/MPCAEF/NgIAIBJFBEBBBCEKQQAhCEEADAQLQYCAEEEAQYjEwgAtAAAbIRhBhMTCACgCACEOIAwgC5NDAAB+Q5UhKCAKDQEgAyADlCAEIASUkiAFIAWUkiEqQQQhE0EAIQgDQCAXIAhBAnQgCEGAgAQgEiAIayIKIApBgIAETxsiCmoiEEECdBD6AiEUIApBAnQiCCAYSw0JIBQgDiAIEIQCIA4hCgNAIAhBBCAIQQRJIhEbIRUCQCAKLQADs0MAAH9DlUPNzMw9XQ0AIA1BGGogCiAVEIMBAn0CQCARRQRAIA0qAiAhJSANKgIcISYgDSoCGCEnQwAAAAAhDEMAAAAAISkgCigCDCIRQf8BcQRAIAsgKCARQQFrQf8BcbOUkhCcASEpCyARQQh2IhlB/wFxBEAgCyAoIBlBAWtB/wFxs5SSEJwBIQwLIAIgJZMhJSABICaTISYgACAnkyEnIBFBEHYiEUH/AXENAUMAAAAADAILQQMgFUHcucAAEJ0CAAsgCyAoIBFBAWtB/wFxs5SSEJwBCyEsIAMgJ5QgBCAmlJIgBSAllJIiKyArlCAqICcgJ5QgJiAmlJIgJSAllJIgKSAMkiAskkMAAEBAlSIMIAyUk5STIgxDAAAAAF0NACArjCAMkZMgKpUiDCAGYEUgByAMYEVyDQAgDSgCBCAPRgRAIA1BBGpBnLnAABDyASANKAIIIRMLIBMgD0ECdGogDDgCACANIA9BAWoiDzYCDAsgCiAVQQJ0aiEKIAggFWsiCA0ACyAUQYQBTwRAIBQQtQILIBAiCCASSQ0ACwwCC0HMncAAELgCAAsgA/0TIAX9IAEhHyAF/RMgBP0gASEgIAD9EyAC/SABISEgDUEgaiEZQQQhE0EAIQgDQCAXIAhBAnQgCEGAgAQgEiAIayIKIApBgIAETxsiCmoiEEECdBD6AiERIApBAnQiCCAYSw0HIBEgDiAIEIQCIA4hCgNAIAhBBCAIQQRJIhQbIRUCQCAKLQADs0MAAH9DlUPNzMw9XQ0AIA1BGGogCiAVEIMBIBQNBSANKgIcIQAgGSAN/VwCGP1WAgABIRpDAAAAACECQwAAAAAhDCAKKAIMIhRB/wFxBEAgCyAoIBRBAWtB/wFxs5SSEJwBIQwLIBRBCHYiFkH/AXEEQCALICggFkEBa0H/AXGzlJIQnAEhAgsgASAAkyEmICEgGv3lASEbIBRBEHYiFkH/AXEEfSALICggFkEBa0H/AXGzlJIQnAEFQwAAAAALIQUgHyAKKAIIIhb9ESAU/RwBQRj9rQEiGv0bAMCy/RMgGv0bAcCy/SAB/QwAAP5CAAD+QgAA/kIAAP5C/ecBIhogGv0NBAUGBwABAgMAAQIDAAECAyIdICAgGiAWQRB2wLJDAAD+QpUiAP0gACIi/eYBIB8gHf3mAf3lASIe/eYBIBogAP0gASIjIAMgGv0fACIllCAEIACUkyIn/RMgHv0NAAECAxAREhMAAQIDAAECA/3mAf3lASAeIBr9DQQFBgcAAQIDAAECAwABAgMgJ/0gAUMAAIA/IAAgAJSTICUgJZSTIBogGv3mAf0fAZNDAAAAABD5ApEiKv0TIiT95gH95AEiHCAc/eQB/eQBIRwgGyAdIBsgGv0NBAUGBwABAgMAAQIDAAECAyAm/SABICL95gEgGyAd/eYB/eUBIh395gEgIyAbIBr95gH9HwAgJiAAlJMiKf0TIB39DQABAgMQERITAAECAwABAgP95gH95QEgHSAa/Q0EBQYHAAECAwABAgMAAQIDICn9IAEgJP3mAf3kASIbIBv95AH95AEhGyAEIAAgJ5QgGiAe/eYB/R8BkyAe/R8AICqUkiIlICWSkiElICYgACAplCAaIB395gH9HwGTIB39HwAgKpSSIgAgAJKSISYCQCAFIAwgAhD5AiAFEPkCQwrXIzyUIgBdRQRAIAAgAl5FBEAgACAMXkUEQP0MAACAPwAAgD8AAIA/AACAPyAM/RMgBf0gAf3nASIeIBv95gEiGiAeIBz95gEiHP3mASIb/R8BIBv9HwBDAACAPyAClSICICaUIgAgAiAllCIClJKSIgUgBZQgHCAc/eYBIhz9HwEgHP0fACACIAKUkpIiAiAaIBr95gEiGv0fASAa/R8AIAAgAJSSkkMAAIC/kpSTIgBDAAAAAF0NBCAFjCAAkZMgApUhAAwDCyAc/R8AIgCLQ703hjVdDQMgJiAlIBv9HwCMIACVIgCUkiAClSICIAKUIBv9HwEgHP0fASAAlJIgBZUiAiAClJJDAACAP15FDQIMAwsgJYtDvTeGNV0NAiAbIBwgJowgJZUiAP0T/eYB/eQBIAz9EyAF/SAB/ecBIhogGv3mASIa/R8AIBr9HwGSQwAAgD9eRQ0BDAILIBz9HwEiAItDvTeGNV0NASAb/R8AIBz9HwAgG/0fAYwgAJUiAJSSIAyVIgUgBZQgJiAlIACUkiAClSICIAKUkkMAAIA/Xg0BCyAAIAZgRSAAIAdfRXINACANKAIEIA9GBEAgDUEEakGsucAAEPIBIA0oAgghEwsgEyAPQQJ0aiAAOAIAIA0gD0EBaiIPNgIMCyAKIBVBAnRqIQogCCAVayIIDQALIBFBgwFLBEAgERC1AgsgECIIIBJJDQALC0H8w8IAKAIAQQFqIQggDSgCCCEKIA0oAgQLIRJB/MPCACAINgIAIA8QFyEJEJ4BIgggCSYBIAglARAYIQ4gDSAPNgIUIA0gDjYCECAOIA9HDQEQmQMiEBCBAyITJQEgCiAPEBkhCRCeASIOIAkmASAQQYQBTwRAIBAQtQILIBNBhAFPBEAgExC1AgsgCCUBIA4lAUEAEBogDkGEAU8EQCAOELUCCyASBEAgCkEEaygCACIOQXhxIhAgEkECdCISQQRBCCAOQQNxIg4bakkNAyAOQQAgECASQSdqSxsNBCAKEFsLIBdBhAFPBEAgFxC1AgsgDUEwaiQAIAgMBQtBAyAVQdy5wAAQnQIACyANQQA2AhggDUEQaiANQRRqIA1BGGpB3O/BABDPAgALQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIACyAIIBhB9MjAABCsAwALIgglASAIELUCCzcBAX9BASEAIAEoAgAiAkGy9sAAQQMgASgCBCgCDCIBEQAABH8gAAUgAkGF+cAAQQcgAREAAAsL0woCCH8CfiMAQRBrIggkACACIQcjAEGgA2siBCQAQYCAgIB4IQICQCAARQRAQYCAgIB4IQEMAQsgAK0gAa1CIIaEIQwLIAcEQCAHrSADrUIghoQhDSADIQILIA2nIQdBAiEDAkACQAJAAkACQCAIAn8CQCABQYCAgIB4Rg0AIAQgDKciADYChAMgBCAMQiCIIgw+AogDAkACQCAMQgNSDQAgAEH0pcIAQQMQugJFBEBBACEDDAILIABB96XCAEEDELoCDQBBASEDDAELIARBATYCjAIgBEGQpsIANgKIAiAEQgE3ApQCIAQgBEGEA2qtQoCAgIDQAIQ3A5gDIAQgBEGYA2o2ApACIARBjANqIgMgBEGIAmoiBhD+ASADEJ4CIQUgBEEANgKUAyAEQoCAgIAQNwKMAyAEQdydwAA2AowCIARCoICAgA43ApACIAQgAzYCiAICQCAFIAYQrAFFBEAgBCgCjAMhBiAEKAKQAyIJIAQoApQDEIADIQMgBgRAIAlBBGsoAgAiCkF4cSILQQRBCCAKQQNxIgobIAZqSQ0IIApBACALIAZBJ2pLGw0JIAkQWwsgBSAFKAIAKAIAEQMAIAEEQCAAQQRrKAIAIgVBeHEiBkEEQQggBUEDcSIFGyABakkNCCAFQQAgBiABQSdqSxsNCSAAEFsLIAJBgICAgHhyQYCAgIB4RwRAIAdBBGsoAgAiAEF4cSIBQQRBCCAAQQNxIgAbIAJqSQ0IIABBACABIAJBJ2pLGw0CIAcQWwtBAQwEC0G8zcAAQTcgBEGYA2pB9J3AAEH0zcAAEJMCAAsMBgsgAUUNACAAQQRrKAIAIgVBeHEiBkEEQQggBUEDcSIFGyABakkNBCAFQQAgBiABQSdqSxsNAiAAEFsLIARBABCTAzYCiAEgBEEANgKEASAEQgA3AnwgBEEAOgB4IARCgICA/IuAgMA/NwJwIAT9DAAAgL8AAIA/AACAvwAAgD/9CwJgIAT9DAAAAAAAAIA/AABAwQAAEEH9CwJQIARBgICAgHg2AkQgBEEANgIkIARBADYCHCAEQQA2AhQgBEEANgIMIARCgICAgICAgICAfzcCNCAEQoCAgIDAADcCLAJ/IANBAkcEQCAEIANBAXEgBEEMahDIASAEKAIEIQYgBCgCACEJQQIMAQsgBEGIAmogBEEQakH8APwKAABBAAshCkGAgICAeCEFIAJBgICAgHhHBEAgDUIgiKchBUEBIQEgDUKAgICAEFoEQCAFEC4iAUUNBAsgBQRAIAEgByAF/AoAAAsgAa0gDUKAgICAcIOEIQwLIARBjAFqIgEgBEGIAmpB/AD8CgAAQbABEC4iAEUNAiAAIAo2AgAgAEEEaiABQfwA/AoAACAAIAM6AKwBIAAgBjYCqAEgACAJNgKkASAAQYCAgIB4NgKYASAAIAw3ApABIAAgBTYCjAEgAEEANgKIASAAQoCAgIAQNwKAASACQYCAgIB4ckGAgICAeEcEQCAHQQRrKAIAIgFBeHEiA0EEQQggAUEDcSIBGyACakkNBCABQQAgAyACQSdqSxsNBSAHEFsLQRwQLiIBRQ0CIAFBnMnAADYCGCABQQE2AhQgAUGEycAANgIQIAEgADYCDCABQQA2AgggAUKBgICAEDcCACABQQhqIQNBAAsiADYCCCAIIANBACAAGzYCBCAIQQAgAyAAGzYCACAEQaADaiQADAQLQZipwgBBLkHIqcIAEMQCCwALQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIACyAIKAIAIAgoAgQgCCgCCCAIQRBqJAAL7QsCCH8CfiMAQRBrIggkACACIQcjAEHgAWsiBCQAQYCAgIB4IQICQCAARQRAQYCAgIB4IQEMAQsgAK0gAa1CIIaEIQwLIAcEQCAHrSADrUIghoQhDSADIQILQYCAgIB4IQMgDachBwJAAkACQAJAAkAgCAJ/An8CQAJAIAFBgICAgHhHBEAgBCAMpyIANgLEASAEIAxCIIgiDD4CyAECQCAMQgNSDQAgAEH0pcIAQQMQugJFBEAMBAsgAEH3pcIAQQMQugINAEEBIQYMAwsgBEEBNgKMASAEQZCmwgA2AogBIARCATcClAEgBCAEQcQBaq1CgICAgNAAhDcD2AEgBCAEQdgBajYCkAEgBEHMAWoiAyAEQYgBaiIFEP4BIAMQngIhBiAEQQA2AtQBIARCgICAgBA3AswBIARB3J3AADYCjAEgBEKggICADjcCkAEgBCADNgKIASAGIAUQrAENASAEKALMASEFIAQoAtABIgkgBCgC1AEQgAMhAyAFBEAgCUEEaygCACIKQXhxIgtBBEEIIApBA3EiChsgBWpJDQggCkEAIAsgBUEnaksbDQkgCRBbCyAGIAYoAgAoAgARAwAgAQRAIABBBGsoAgAiBkF4cSIFQQRBCCAGQQNxIgYbIAFqSQ0IIAZBACAFIAFBJ2pLGw0JIAAQWwsgAkGAgICAeHJBgICAgHhHBEAgB0EEaygCACIAQXhxIgFBBEEIIABBA3EiABsgAmpJDQggAEEAIAEgAkEnaksbDQkgBxBbC0EBDAQLIARBHGoiAEIANwIAIARBLGoiAUKAgICAIDcCACAEQTxqQgI3AgAgBEKAgICAgAI3AhQgBEIQNwIMIARBADYCRCAEQgI3AiQgBEIANwI0IARBwAFqQQA2AgAgBEG4AWpCAjcDACAEQagBaiAB/QACAP0LAwAgBEGYAWogAP0AAgD9CwMAIAQgBP0AAgz9CwOIAUECIQZBAAwCC0G8zcAAQTcgBEHYAWpB9J3AAEH0zcAAEJMCAAsgAQRAIABBBGsoAgAiA0F4cSIFQQRBCCADQQNxIgMbIAFqSQ0FIANBACAFIAFBJ2pLGw0DIAAQWwsgBEKAgICAIDcCOCAEQgI3AjAgBEIANwIoIARCgICAgCA3AiAgBEIQNwIYIARCADcCECAEQoCAgICAAjcCCCAEQgA3AkAgBCAGIARBCGoQsQEgBCgCBCEJIAQoAgAhBUGAgICAeCEDQYCAgIB4CyEKIAJBgICAgHhHBEAgDUIgiKchA0EBIQEgDUKAgICAEFoEQCADEC4iAUUNBAsgAwRAIAEgByAD/AoAAAsgAa0gDUKAgICAcIOEIQwLIARBgAFqIgEgBEHAAWooAgA2AgAgBEH4AGogBEG4AWopAwA3AwAgBEHoAGogBEGoAWr9AAMA/QsDACAEQdgAaiAEQZgBav0AAwD9CwMAIAQgBP0AA4gB/QsDSEHwABAuIgBFDQIgACAKNgIYIAAgDDcCECAAIAM2AgwgAEEANgIIIABCgICAgBA3AgAgACAEKQNINwIcIAAgBjoAbCAAIAk2AmggACAFNgJkIABBgICAgHg2AlggAEEkaiAEQdAAav0AAwD9CwIAIABBNGogBEHgAGr9AAMA/QsCACAAQcQAaiAEQfAAav0AAwD9CwIAIABB1ABqIAEoAgA2AgAgAkGAgICAeHJBgICAgHhHBEAgB0EEaygCACIBQXhxIgNBBEEIIAFBA3EiARsgAmpJDQQgAUEAIAMgAkEnaksbDQUgBxBbC0EcEC4iAUUNAiABQYzKwAA2AhggAUEBNgIUIAFB9MnAADYCECABIAA2AgwgAUEANgIIIAFCgYCAgBA3AgAgAUEIaiEDQQALIgA2AgggCCADQQAgABs2AgQgCEEAIAMgABs2AgAgBEHgAWokAAwEC0GYqcIAQS5ByKnCABDEAgsAC0HYqMIAQS5BiKnCABDEAgALQZipwgBBLkHIqcIAEMQCAAsgCCgCACAIKAIEIAgoAgggCEEQaiQAC7kDAQR/IwBBEGsiBSQAEJ4BIgcgASYBIwBBoAFrIgQkAAJAIAJFBEAgBEHYAGogACAHQQBBABAlIAQoAlwhACAEKAJYIgJBgICAgHhGBEBBASEGDAILIARByABqIARBkAFq/QACAP0LAgAgBEE4aiAEQYABav0AAgD9CwIAIARBKGogBEHwAGr9AAIA/QsCACAEIAT9AAJg/QsCGCAEIAA2AhQgBCACNgIQIARBEGoiAiADECQgBCACENMBIAQoAgQhACAEKAIAIQYgAhB5DAELQQEhBiAEQdgAaiAAIAdBASACECUgBCgCXCEAIAQoAlgiAkGAgICAeEYNACAEQcgAaiAEQZABav0AAgD9CwIAIARBOGogBEGAAWr9AAIA/QsCACAEQShqIARB8ABq/QACAP0LAgAgBCAE/QACYP0LAhggBCAANgIUIAQgAjYCECAEQRBqIgIgAxAkIARBCGogAhDTASAEKAIMIQAgBCgCCCEGIAIQeQsgBSAGQQFxIgI2AgggBSAAQQAgAhs2AgQgBUEAIAAgAhs2AgAgBEGgAWokACAFKAIAIAUoAgQgBSgCCCAFQRBqJAAL5AEBA38jAEEQayIDJAAQngEiBSABJgEjAEHQAGsiBCQAAkAgAkUEQCAEQQhqIAAgBUEAQQAQJQwBCyAEQQhqIAAgBUEBIAIQJQsCQAJAAn8gBCgCCEGAgICAeEYEQEEBIQIgBCgCDAwBC0HUABAuIgBFDQFBACECIABBADYCCCAAQoGAgIAQNwIAIABBDGogBEEIakHIAPwKAAAgAEEIagshACADIAI2AgggAyAAQQAgAhs2AgQgA0EAIAAgAhs2AgAgBEHQAGokAAwBCwALIAMoAgAgAygCBCADKAIIIANBEGokAAvsAQICfwF+IwBBEGsiAiQAIAJBATsBDCACIAE2AgggAiAANgIEIwBBEGsiASQAIAJBBGoiACkCACEEIAEgADYCDCABIAQ3AgQjAEEQayIAJAAgAUEEaiIBKAIAIgIoAgwhAwJAAkACQAJAIAIoAgQOAgABAgsgAw0BQQEhAkEAIQMMAgsgAw0AIAIoAgAiAigCBCEDIAIoAgAhAgwBCyAAQYCAgIB4NgIAIAAgATYCDCAAQTQgASgCCCIALQAIIAAtAAkQmwIACyAAIAM2AgQgACACNgIAIABBNSABKAIIIgAtAAggAC0ACRCbAgALMwAgASgCACAAKAIALQAAQQJ0IgBBqLnCAGooAgAgAEGUucIAaigCACABKAIEKAIMEQAACyYBAX8jAEEQayICJAAgASgCBBogAEHAqMIAIAEQjAEgAkEQaiQAC+gRAwR+EX8BeyMAQRBrIg4kABCeASISIAEmASAAIQsjAEEQayIPJABBqMLCACgCAEUEQBAwCwJAAkACQEGwwsIAKAIARQRAQbDCwgBBfzYCAAJAAkAgC0H/////AEsNACALQQR0IgBB/f///wdPDQBB6MLCACgCACEQQQQhDAJAIABFBEBBBCEUDAELIAshDSAAEC4iFEUNAgtBBCEKAkAgC0EQdiALQf//A3FBAEdqIgdFDQAgB0ECdCIKEC4iDEUNAgJAIAdBBE8EQP0MAAAAAAEAAAACAAAAAwAAACEXIAdB/D9xIgYhCCAMIQADQCAAIBf9CwIAIABBEGohACAX/QwEAAAABAAAAAQAAAAEAAAA/a4BIRcgCEEEayIIDQALIAYgB0YNAQsgDCAGQQJ0aiEAA0AgACAGNgIAIABBBGohACAHIAZBAWoiBkcNAAsLIAoQLiIKRQ0CQQAhBiAHQQRPBED9DAAAAAABAAAAAgAAAAMAAAAhFyAHQfw/cSIGIQggCiEAA0AgACAX/QsCACAAQRBqIQAgF/0MBAAAAAQAAAAEAAAABAAAAP2uASEXIAhBBGsiCA0ACyAGIAdGDQELIAogBkECdGohAANAIAAgBjYCACAAQQRqIQAgByAGQQFqIgZHDQALCyAHEJMDIhUgCiAHEIECQdDCwgApAwAiAiAQrYUiA0I4hiADQoD+A4NCKIaEIANCgID8B4NCGIYgA0KAgID4D4NCCIaEhCACQgiIQoCAgPgPgyACQhiIQoCA/AeDhCACQiiIQoD+A4MgAkI4iISEhELSgaqbq/qC16d/fiICQjiGIAJCgP4Dg0IohoQgAkKAgPwHg0IYhiACQoCAgPgPg0IIhoSEIAJCCIhCgICA+A+DIAJCGIhCgID8B4OEIAJCKIhCgP4DgyACQjiIhISEIANC2KLR78Kp5b8tfoUiAkI4hiACQoD+A4NCKIaEIAJCgID8B4NCGIYgAkKAgID4D4NCCIaEhCACQgiIQoCAgPgPgyACQhiIQoCA/AeDhCACQiiIQoD+A4MgAkI4iISEhEHIwsIAKQMAIgNCf4V+IgRCOIYgBEKA/gODQiiGhCAEQoCA/AeDQhiGIARCgICA+A+DQgiGhIQgBEIIiEKAgID4D4MgBEIYiEKAgPwHg4QgBEIoiEKA/gODIARCOIiEhIQgAiADQjiGIANCgP4Dg0IohoQgA0KAgPwHg0IYhiADQoCAgPgPg0IIhoSEIANCCIhCgICA+A+DIANCGIhCgID8B4OEIANCKIhCgP4DgyADQjiIhISEfoUgAokhAkHAwsIAKAIARQRAEDkLQbzCwgAoAgAiESACp3EhBiACQhmIIgRC/wCDQoGChIiQoMCAAX4hBUG4wsIAKAIAIQgDQAJAAkACQAJAAkACQCAGIAhqKQAAIgMgBYUiAkJ/hSACQoGChIiQoMCAAX2DQoCBgoSIkKDAgH+DIgJQRQRAA0AgECAIIAJ6p0EDdiAGaiARcUFYbGoiAEEoaygCAEYNAiACQgF9IAKDIgJQRQ0ACwsgA0KAgYKEiJCgwIB/gyECIBNFBEAgAlANAyACeqdBA3YgBmogEXEhCQsgAiADQgGGg1AEQEEBIRMMBgsgCCAJaiwAACIGQQBOBEAgCCAIKQMAQoCBgoSIkKDAgH+DeqdBA3YiCWotAAAhBgsgCCAJaiAEp0H/AHEiADoAACAIIAlBCGsgEXFqQQhqIAA6AABBwMLCAEHAwsIAKAIAIAZBAXFrNgIAQcTCwgBBxMLCACgCAEEBajYCACAIIAlBWGxqIgBBKGsgEDYCACAAQSRrIA02AgAgAEEgayAUNgIAIABBHGtBADYCACAAQRhrIAc2AgAgAEEUayAMNgIAIABBEGsgBzYCACAAQQxrIAc2AgAgAEEIayAKNgIAIABBBGsgBzYCAAwBCyAAQQRrIAc2AgAgAEEQayAHNgIAIABBHGtBADYCACAAQQhrIggoAgAhBiAIIAo2AgAgAEEMayIIKAIAIQogCCAHNgIAIABBFGsiCSgCACEIIAkgDDYCACAAQRhrIgkoAgAhDCAJIAc2AgAgAEEgayIJKAIAIQcgCSAUNgIAIABBJGsiCSgCACEAIAkgDTYCACAAQYCAgIB4Rg0AIAAEQCAHQQRrKAIAIg1BeHEiCSAAQQR0IgBBBEEIIA1BA3EiDRtySQ0KIA1BACAJIABBJ2pLGw0LIAcQWwsgDARAIAhBBGsoAgAiAEF4cSINIAxBAnQiDEEEQQggAEEDcSIAG2pJDQogAEEAIA0gDEEnaksbDQsgCBBbCyAKRQ0AIAZBBGsoAgAiAEF4cSIMIApBAnQiCkEEQQggAEEDcSIAG2pJDQkgAEEAIAwgCkEnaksbDQogBhBbC0HowsIAQejCwgAoAgBBAWo2AgAgEEEAIAsgEhBQEJgDIgBBsMPAAEEFEIADIgsgELgQkgMiChCXA0HoyMIALQAADQFB7MjCAEEANgIAQejIwgBBADoAACAKQYQBTwRAIAoQtQILIAtBhAFPBEAgCxC1AgsgAEG1w8AAQQsQgAMiCyAVEJcDQejIwgAtAAANAkHsyMIAQQA2AgBB6MjCAEEAOgAAIBVBhAFPBEAgFRC1AgsgC0GEAU8EQCALELUCC0GwwsIAQbDCwgAoAgBBAWo2AgAgEkGEAU8EQCASELUCCyAOQgA3AgQgDiAANgIAIA9BEGokAAwKC0EAIRMMAgtB6MjCAEEAOgAAQezIwgAoAgAhAEHsyMIAQQA2AgAgDyAANgIIQaiNwgBBKyAPQQhqQZS6wABB0MPAABCTAgALQejIwgBBADoAAEHsyMIAKAIAIQBB7MjCAEEANgIAIA8gADYCDEGojcIAQSsgD0EMakGUusAAQcDDwAAQkwIACyAGIBZBCGoiFmogEXEhBgwACwALQaDDwAAQzQILAAtBzJ3AABC4AgALQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIACyAOKAIAIA4oAgQgDigCCCAOQRBqJAALMAAgASgCACAALQAAQQJ0IgBB/MrAAGooAgAgAEHUysAAaigCACABKAIEKAIMEQAACzAAIAEoAgAgACwAAEECdCIAQdy7wgBqKAIAIABBwLvCAGooAgAgASgCBCgCDBEAAAvpBQELfyMAQRBrIgckACMAQTBrIgEkAAJAAkACQAJAAkAgAARAIABBCGsiBSgCAEEBRw0BIAAoAhAhAyAAKAIMIQggACgCCCEEIAAoAgQhAiAFQQA2AgACQCAFQX9GDQAgAEEEayIGIAYoAgBBAWsiBjYCACAGDQAgAEEMaygCACIAQXhxIgZBIEEkIABBA3EiABtJDQQgAEEAIAZBxABPGw0FIAUQWwsCQCACIAQoAhQRBAAiAARAIAFBADYCGCABQoCAgIAQNwIQIAFB3J3AADYCICABQqCAgIAONwIkIAEgAUEQajYCHCAAIAFBHGoQrAENBCABKAIQIQUgASgCFCIKIAEoAhgQgAMhBiAFBEAgCkEEaygCACIJQXhxIgtBBEEIIAlBA3EiCRsgBWpJDQYgCUEAIAsgBUEnaksbDQcgChBbCyAAIAAoAgAoAgARAwAgBCgCACIABEAgAiAAEQMACyAEKAIEIgAEQCACQQRrKAIAIgRBeHEiBUEEQQggBEEDcSIEGyAAakkNBiAEQQAgBSAAQSdqSxsNByACEFsLIAMoAgAiAARAIAggABEDAAsgAygCBCIABEAgCEEEaygCACICQXhxIgNBBEEIIAJBA3EiAhsgAGpJDQYgAkEAIAMgAEEnaksbDQcgCBBbC0EBIQAMAQsgAUEIaiAIIAIgBCADKAIMEQcAIAEoAgwhBiABKAIIIQAgAygCBCICRQ0AIAhBBGsoAgAiA0F4cSIEQQRBCCADQQNxIgMbIAJqSQ0EIANBACAEIAJBJ2pLGw0FIAgQWwsgByAAQQFxIgA2AgggByAGQQAgABs2AgQgB0EAIAYgABs2AgAgAUEwaiQADAULELMDAAtB4MLAAEE/ELQDAAtBvM3AAEE3IAFBL2pB9J3AAEH0zcAAEJMCAAtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgALIAcoAgAgBygCBCAHKAIIIAdBEGokAAvhAwEKfyMAQRBrIgMkACMAQZACayIBJAACQAJAAkACQAJAAkAgAARAIABBCGsiBCAEKAIAQQFqIgI2AgAgAkUNASAAKAIAIgJBf0YNAiAAIAJBAWo2AgAgASAAQQRqQQAQIwJ/IAEoAgAiCUECRgRAIAEoAgQhAiABQQA2AogCIAFCgICAgBA3AoACIAFB3J3AADYChAEgAUKggICADjcCiAEgASABQYACajYCgAEgAiABQYABahCsAQ0FIAEoAoACIQUgASgChAIiCCABKAKIAhCAAyEHIAUEQCAIQQRrKAIAIgZBeHEiCkEEQQggBkEDcSIGGyAFakkNByAGQQAgCiAFQSdqSxsNCCAIEFsLIAIgAigCACgCABEDAEEADAELIAFBgAFqIgIgAUGAAfwKAAAgAhBICyECIAAgACgCAEEBazYCACAEIAQoAgBBAWsiADYCACAARQRAIAQQlAILIAMgBzYCBCADIAI2AgAgAyAJQQJGNgIIIAFBkAJqJAAMBgsQswMLAAsQtQMAC0G8zcAAQTcgAUGPAmpB9J3AAEH0zcAAEJMCAAtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgALIAMoAgAgAygCBCADKAIIIANBEGokAAvgAQEFfyMAQRBrIgEkACMAQRBrIgMkAAJAAkACQCAABEAgAEEIayIEIAQoAgBBAWoiAjYCACACRQ0BIAAoAgAiAkF/Rg0CIAAgAkEBajYCACADQQhqIABBBGoQ0wEgAygCDCECIAMoAgghBSAAIAAoAgBBAWs2AgAgBCAEKAIAQQFrIgA2AgAgAEUEQCAEEJQCCyABIAVBAXEiADYCCCABIAJBACAAGzYCBCABQQAgAiAAGzYCACADQRBqJAAMAwsQswMLAAsQtQMACyABKAIAIAEoAgQgASgCCCABQRBqJAALIgACQCAABEAgACgCAEF/Rg0BIAAoAkQPCxCzAwALELUDAAsiAAJAIAAEQCAAKAIAQX9GDQEgACgCSA8LELMDAAsQtQMAC+gIARB/IwBBEGsiCiQAEJ4BIgYgASYBIwBBMGsiAiQAAkACQAJAAkACQAJAAkACQCAAIgsEQCAAQQhrIgwgDCgCAEEBaiIANgIAIABFDQEgCygCAA0CIAtBfzYCACALQQhqKAIAIQ8gCygCBCEQQZDCwgAoAgBFBEACQEGcwsIAKAIAIQdBmMLCACgCACEAQZjCwgBCgICAgBA3AgBBkMLCACgCACEEQZDCwgBCATcCAEGgwsIAQQA2AgACQAJAIARFIABFckUEQCAHQQRrKAIAIgRBeHEiBUEEQQggBEEDcSIEGyAAakkNASAEQQAgBSAAQSdqSxsNAiAHEFsLDAILQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIACwtBlMLCACgCAA0DQZTCwgBBfzYCAAJAQYCAwAAgBhDLAyIAIABBgIDAAE8bIgRBoMLCACgCACIATQRAQZzCwgAoAgAhBQwBCyAEIABrIgNBmMLCACgCACAAa0sEQEGYwsIAIAAgA0EBQQEQ2QFBoMLCACgCACEAC0GcwsIAKAIAIgUgAGohByADQQJPBH8gA0EBayIDBEAgB0EAIAP8CwALIAUgACADaiIAagUgBwtBADoAACAAQQFqIQQLQQAhAEGgwsIAIAQ2AgACQAJAAkADQCAAIgcgBhDLAyIRTw0BIAAgBCAGEMsDIABrIgMgAyAESxsiCWohACAGJQEgByAAEAkhARCeASIDIAEmASADEMsDIQggAiAJNgIIIAIgCDYCFCAIIAlHDQgQmQMiDRCBAyIOJQEQDCEBEJ4BIgggASYBIA5BhAFPBEAgDhC1AgsgCCUBIAMlASAFEA0gCEGEAU8EQCAIELUCCyANQYQBTwRAIA0QtQILIANBhAFPBEAgAxC1AgsgECAFIAkgDygCEBEAACIJRQ0ACyACQQA2AhAgAkKAgICAEDcCCCACQdydwAA2AhwgAkKggICADjcCICACIAJBCGo2AhggCSACQRhqEKwBDQggAigCCCEAIAIoAgwiBCACKAIQEIADIQMgAARAIARBBGsoAgAiBUF4cSIIQQRBCCAFQQNxIgUbIABqSQ0KIAVBACAIIABBJ2pLGw0LIAQQWwsgCSAJKAIAKAIAEQMAQQEhAEGUwsIAQZTCwgAoAgBBAWo2AgAgBkGDAUsNAQwCC0EAIQBBlMLCAEGUwsIAKAIAQQFqNgIAIAZBhAFJDQELIAcgEUkhACAGELUCCyALQQA2AgAgDCAMKAIAQQFrIgY2AgAgBkUEQCAMELYBCyAKIAA2AgQgCiADQQAgABs2AgAgAkEwaiQADAgLELMDCwALELUDAAtBzJ3AABC4AgALIAJBADYCGCACQRRqIAJBCGogAkEYakHc78EAEM8CAAtBvM3AAEE3IAJBFGpB9J3AAEH0zcAAEJMCAAtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgALIAooAgAgCigCBCAKQRBqJAALKgAgACABLQAAQQJ0IgFBpMvAAGooAgA2AgQgACABQbjLwABqKAIANgIACyEAAkAgAARAIAAoAgBFDQEQtQMACxCzAwALIAAgATYCRAshAAJAIAAEQCAAKAIARQ0BELUDAAsQswMACyAAIAE2AkgLJQAgAEUEQEGo78EAQTIQtAMACyAAIAIgAyAEIAUgASgCEBEPAAslACABIAAtAABBAnQiAEGAucIAaigCACAAQey4wgBqKAIAEIQBCyMAIABFBEBBqO/BAEEyELQDAAsgACACIAMgBCABKAIQERIACyMAIABFBEBBqO/BAEEyELQDAAsgACACIAMgBCABKAIQEQcACyMAIABFBEBBqO/BAEEyELQDAAsgACACIAMgBCABKAIQET4ACyMAIABFBEBBqO/BAEEyELQDAAsgACACIAMgBCABKAIQEUAACyMAIABFBEBBqO/BAEEyELQDAAsgACACIAMgBCABKAIQEUIACycAIAAoAgAtAABFBEAgAUGMisIAQQUQhAEPCyABQZGKwgBBBBCEAQsnACAAQRxqQQAgAkKtoMydv86x+lJRG0EAIAFCucS3xZeH/65OURsLKAAgAEEcakEAIAJC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ZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2NvcmUvc3JjL3NsaWNlL2luZGV4LnJzAGxpYnJhcnkvY29yZS9zcmMvbnVtL2ZsdDJkZWMvc3RyYXRlZ3kvZ3Jpc3UucnMAc3BhcmstaW50ZXJuYWwtcnMvc3JjL3JheWNhc3QucnMAbGlicmFyeS9jb3JlL3NyYy9zbGljZS9zb3J0L3NoYXJlZC9zbWFsbHNvcnQucnMAL1VzZXJzL2FzdW5kcXVpLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9zb3J0L3N0YWJsZS9xdWlja3NvcnQucnMAc3BhcmstaW50ZXJuYWwtcnMvc3JjL3NvcnQucnMAbGlicmFyeS9hbGxvYy9zcmMvZm10LnJzAC9Vc2Vycy9hc3VuZHF1aS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2FueWhvdy0xLjAuOTgvc3JjL2ZtdC5ycwBsaWJyYXJ5L2NvcmUvc3JjL251bS9kaXlfZmxvYXQucnMAc3BhcmstbGliL3NyYy9nc3BsYXQucnMAc3BhcmstaW50ZXJuYWwtcnMvc3JjL3BhY2tlZF9zcGxhdHMucnMAbGlicmFyeS9jb3JlL3NyYy9mbXQvYnVpbGRlcnMucnMAbGlicmFyeS9zdGQvc3JjL3N5cy9zeW5jL211dGV4L25vX3RocmVhZHMucnMAL1VzZXJzL2FzdW5kcXVpLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9zdGQvc3JjL3N5cy9zeW5jL29uY2Uvbm9fdGhyZWFkcy5ycwBsaWJyYXJ5L2FsbG9jL3NyYy9zdHIucnMAL1VzZXJzL2FzdW5kcXVpLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9jb3JlL3NyYy9pdGVyL3RyYWl0cy9pdGVyYXRvci5ycwAvVXNlcnMvYXN1bmRxdWkvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9hbnlob3ctMS4wLjk4L3NyYy9lcnJvci5ycwBsaWJyYXJ5L2NvcmUvc3JjL3NsaWNlL21lbWNoci5ycwAvVXNlcnMvYXN1bmRxdWkvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9taW5pel9veGlkZS0wLjguOS9zcmMvaW5mbGF0ZS9vdXRwdXRfYnVmZmVyLnJzAC9Vc2Vycy9hc3VuZHF1aS9zcGFyazMvcnVzdC9zcGFyay1saWIvc3JjL2RlY29kZXIucnMAbGlicmFyeS9zdGQvc3JjL2lvL3N0ZGlvLnJzAC9Vc2Vycy9hc3VuZHF1aS8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvY29yZS9zcmMvc3RyL3BhdHRlcm4ucnMAL3J1c3RjLzI5NDgzODgzZWVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9jb3JlL3NyYy9zdHIvcGF0dGVybi5ycwAvcnVzdGMvMjk0ODM4ODNlZWQ2OWQ1ZmI0ZGIwMTk2NGNkZjJhZjRkODZlOWNiMi9saWJyYXJ5L2NvcmUvc3JjL29wcy9mdW5jdGlvbi5ycwBsaWJyYXJ5L2NvcmUvc3JjL251bS9mbHQyZGVjL3N0cmF0ZWd5L2RyYWdvbi5ycwBsaWJyYXJ5L2NvcmUvc3JjL251bS9iaWdudW0ucnMAbGlicmFyeS9zdGQvc3JjL2lvL2J1ZmZlcmVkL2xpbmV3cml0ZXJzaGltLnJzAC9Vc2Vycy9hc3VuZHF1aS8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvc3RkL3NyYy90aHJlYWQvbG9jYWwucnMAbGlicmFyeS9zdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzAGxpYnJhcnkvc3RkL3NyYy9zeW5jL3JlZW50cmFudF9sb2NrLnJzAC9Vc2Vycy9hc3VuZHF1aS8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAvVXNlcnMvYXN1bmRxdWkvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9taW5pel9veGlkZS0wLjguOS9zcmMvaW5mbGF0ZS9jb3JlLnJzAGxpYnJhcnkvY29yZS9zcmMvdW5pY29kZS9wcmludGFibGUucnMAc3BhcmstaW50ZXJuYWwtcnMvc3JjL2xvZF90cmVlLnJzAHNwYXJrLWxpYi9zcmMvc3BsYXRfZW5jb2RlLnJzAGxpYnJhcnkvc3RkL3NyYy9zeW5jL3BvaXNvbi9vbmNlLnJzAC9Vc2Vycy9hc3VuZHF1aS8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJzAGxpYnJhcnkvc3RkL3NyYy9iYWNrdHJhY2UucnMAL3J1c3QvZGVwcy9oYXNoYnJvd24tMC4xNS40L3NyYy9yYXcvbW9kLnJzAGxpYnJhcnkvY29yZS9zcmMvZm10L21vZC5ycwBsaWJyYXJ5L2NvcmUvc3JjL3N0ci9tb2QucnMAL1VzZXJzL2FzdW5kcXVpLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvYmluYXJ5X2hlYXAvbW9kLnJzAGxpYnJhcnkvc3RkL3NyYy9pby9tb2QucnMAbGlicmFyeS9zdGQvc3JjLy4uLy4uL2JhY2t0cmFjZS9zcmMvc3ltYm9saXplL21vZC5ycwBsaWJyYXJ5L3N0ZC9zcmMvdGhyZWFkL21vZC5ycwAvVXNlcnMvYXN1bmRxdWkvLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjL21vZC5ycwAvVXNlcnMvYXN1bmRxdWkvLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy92ZWMvbW9kLnJzAGxpYnJhcnkvY29yZS9zcmMvbnVtL2ZsdDJkZWMvbW9kLnJzAHNwYXJrLWxpYi9zcmMvcXVpY2tfbG9kLnJzAC9ydXN0L2RlcHMvZGxtYWxsb2MtMC4yLjkvc3JjL2RsbWFsbG9jLnJzAHNwYXJrLWludGVybmFsLXJzL3NyYy9saWIucnMAL1VzZXJzL2FzdW5kcXVpLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvanMtc3lzLTAuMy43Ny9zcmMvbGliLnJzAC9ydXN0L2RlcHMvcnVzdGMtZGVtYW5nbGUtMC4xLjI1L3NyYy9saWIucnMAL1VzZXJzL2FzdW5kcXVpLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvc2VyZGUtd2FzbS1iaW5kZ2VuLTAuNi41L3NyYy9saWIucnMAL1VzZXJzL2FzdW5kcXVpLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvb25jZV9jZWxsLTEuMjEuMy9zcmMvbGliLnJzAC9Vc2Vycy9hc3VuZHF1aS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3NtYWxsdmVjLTEuMTUuMS9zcmMvbGliLnJzAGxpYnJhcnkvY29yZS9zcmMvdW5pY29kZS91bmljb2RlX2RhdGEucnMAc3BhcmstbGliL3NyYy9zeW1tYXQzLnJzAC9ydXN0L2RlcHMvcnVzdGMtZGVtYW5nbGUtMC4xLjI1L3NyYy92MC5y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AgYBAWUBAQECBAEFAAkBAgACAQEEAZAEAgIEASAKKAYCBAgBCQYCAy4NAQIABwEGAQFSFgIHAQIBAnoGAwEBAgEHAQFIAgMBAQEAAgsCNAUFAQEBFwEAEQYPAAwDAwAFOwcJBAADKAIAAT8RQAIBAgAEAQcBAgACAQQALgIXAAMJEAIHHgSUAwA3BDIIAQ4BFgUBDwAHARECBwECAQUFPiEBoA4AAT0EAAX+AgAHbQgABQABHmCA8ABBGgYaLwEKAQQBBRcBHwHDAQQE0AEkBwIeBWABKgQCAgIEAQEGAQEDAQEBFAFTAYsIpgEmCSkAJgEBBQECKwEEAFYCBgALBSsCA0DAQAACBgImAgYCCAEBAQEBAQEfAjUBBwEBAwMBBwMEAgYEDQUDAQd0AQ0BEA1lAQQBAgoBAQMFBgEBAQEBAQQBBgQBAgQFBQQBESADAgA0AOUGBAMCDCYBAQUBAC4SHoRmAwQBPgICAQEBCBUFAQMAKwEOBlAABwwFABoGGgBQYCQEJHQLAQ8BBwECAQsBDwEHAQIAAQIDASoBCQAzDTNdFgoWAEAAQABVAUcBAgIBAgICBAEMAQEBBwFBAQQCCAEHARwBBAEFAQEDBwEAAhkBGQEfARkBHwEZAR8BGQEfARkBCAAKARQGBgA+AEQAGgYaBhoAAHAABwAtAQEBAgECAQFICzAVEAFlBwIGAgIBBCMBHhtbCzoJCQEYBAEJAQMBBSsDOwkqGAEgNwEBAQQIBAEDBwoCHQE6AQEBAgQIAQkBCgIaAQICOQEEAgQCAgMDAR4CAwELAjkBBAUBAgQBFAIWBgEBOgEBAgEECAEHAwoCHgE7AQEBDAEJASgBAwE3AQEDBQMBBAcCCwIdAToBAgIBAQMDAQQHAgsCHAI5AgEBAgQIAQkBCgIdAUgBBAECAwEBCAFRAQIHDAhiAQIJCwdJAhsBAQEBATcOAQUBAgULASQJAWYEAQYBAgICGQIEAxAEDQECAgYBDwEAAwAEHAMdAh4CQAIBBwgBAgsJAS0DAQF1AiIBdgMEAgkBBgPbAgIBOgEBBwEBAQECCAYKAgEwHzEEMAoEAyYJDAIgBAIGOAEBAgMBAQU4CAICmAMBDQEHBAEGAQMCxkAAAcMhAAONAWAgAAZpAgAEAQogAlACAAEDAQQBGQIFAZcCGhINASYIGQsBASwDMAECBAIC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AQAAAgEAAAMBAAAEAQAABQEAAAYBAAAHAQAACAEAAAkBAAAKAQAACwEAAAwBAAANAQAADgEAAA8BAAAQAQAAEQEAABIBAAATAQAAFAEAABUBAAAWAQAAFwEAABgBAAAZAQAAGgEAABsBAAAcAQAAHQEAAB4BAAAfAQAAIAEAACEBAAAiAQAAIwEAACQBAAAlAQAAJgEAACcBAAAoAQAAKQEAACoBAAArAQAALAEAAC0BAAAuAQAALwEAADABAAAAAEAAMgEAADMBAAA0AQAANQEAADYBAAA3AQAAOQEAADoBAAA7AQAAPAEAAD0BAAA+AQAAPwEAAEABAABBAQAAQgEAAEMBAABEAQAARQEAAEYBAABHAQAASAEAAEoBAABLAQAATAEAAE0BAABOAQAATwEAAFABAABRAQAAUgEAAFMBAABUAQAAVQEAAFYBAABXAQAAWAEAAFkBAABaAQAAWwEAAFwBAABdAQAAXgEAAF8BAABgAQAAYQEAAGIBAABjAQAAZAEAAGUBAABmAQAAZwEAAGgBAABpAQAAagEAAGsBAABsAQAAbQEAAG4BAABvAQAAcAEAAHEBAAByAQAAcwEAAHQBAAB1AQAAdgEAAHcBAAB4AQAA/wAAAHkBAAB6AQAAewEAAHwBAAB9AQAAfgEAAIEBAABTAgAAggEAAIMBAACEAQAAhQEAAIYBAABUAgAAhwEAAIgBAACJAQAAVgIAAIoBAABXAgAAiwEAAIwBAACOAQAA3QEAAI8BAABZAgAAkAEAAFsCAACRAQAAkgEAAJMBAABgAgAAlAEAAGMCAACWAQAAaQIAAJcBAABoAgAAmAEAAJkBAACcAQAAbwIAAJ0BAAByAgAAnwEAAHUCAACgAQAAoQEAAKIBAACjAQAApAEAAKUBAACmAQAAgAIAAKcBAACoAQAAqQEAAIMCAACsAQAArQEAAK4BAACIAgAArwEAALABAACxAQAAigIAALIBAACLAgAAswEAALQBAAC1AQAAtgEAALcBAACSAgAAuAEAALkBAAC8AQAAvQEAAMQBAADGAQAAxQEAAMYBAADHAQAAyQEAAMgBAADJAQAAygEAAMwBAADLAQAAzAEAAM0BAADOAQAAzwEAANABAADRAQAA0gEAANMBAADUAQAA1QEAANYBAADXAQAA2AEAANkBAADaAQAA2wEAANwBAADeAQAA3wEAAOABAADhAQAA4gEAAOMBAADkAQAA5QEAAOYBAADnAQAA6AEAAOkBAADqAQAA6wEAAOwBAADtAQAA7gEAAO8BAADxAQAA8wEAAPIBAADzAQAA9AEAAPUBAAD2AQAAlQEAAPcBAAC/AQAA+AEAAPkBAAD6AQAA+wEAAPwBAAD9AQAA/gEAAP8BAAAAAgAAAQIAAAICAAADAgAABAIAAAUCAAAGAgAABwIAAAgCAAAJAgAACgIAAAsCAAAMAgAADQIAAA4CAAAPAgAAEAIAABECAAASAgAAEwIAABQCAAAVAgAAFgIAABcCAAAYAgAAGQIAABoCAAAbAgAAHAIAAB0CAAAeAgAAHwIAACACAACeAQAAIgIAACMCAAAkAgAAJQIAACYCAAAnAgAAKAIAACkCAAAqAgAAKwIAACwCAAAtAgAALgIAAC8CAAAwAgAAMQIAADICAAAzAgAAOgIAAGUsAAA7AgAAPAIAAD0CAACaAQAAPgIAAGYsAABBAgAAQgIAAEMCAACAAQAARAIAAIkCAABFAgAAjAIAAEYCAABHAgAASAIAAEkCAABKAgAASwIAAEwCAABNAgAATgIAAE8CAABwAwAAcQMAAHIDAABzAwAAdgMAAHcDAAB/AwAA8wMAAIYDAACsAwAAiAMAAK0DAACJAwAArgMAAIoDAACvAwAAjAMAAMwDAACOAwAAzQMAAI8DAADOAwAAkQMAALEDAACSAwAAsgMAAJMDAACzAwAAlAMAALQDAACVAwAAtQMAAJYDAAC2AwAAlwMAALcDAACYAwAAuAMAAJkDAAC5AwAAmgMAALoDAACbAwAAuwMAAJwDAAC8AwAAnQMAAL0DAACeAwAAvgMAAJ8DAAC/AwAAoAMAAMADAAChAwAAwQMAAKMDAADDAwAApAMAAMQDAAClAwAAxQMAAKYDAADGAwAApwMAAMcDAACoAwAAyAMAAKkDAADJAwAAqgMAAMoDAACrAwAAywMAAM8DAADXAwAA2AMAANkDAADaAwAA2wMAANwDAADdAwAA3gMAAN8DAADgAwAA4QMAAOIDAADjAwAA5AMAAOUDAADmAwAA5wMAAOgDAADpAwAA6gMAAOsDAADsAwAA7QMAAO4DAADvAwAA9AMAALgDAAD3AwAA+AMAAPkDAADyAwAA+gMAAPsDAAD9AwAAewMAAP4DAAB8AwAA/wMAAH0DAAAABAAAUAQAAAEEAABRBAAAAgQAAFIEAAADBAAAUwQAAAQEAABUBAAABQQAAFUEAAAGBAAAVgQAAAcEAABXBAAACAQAAFgEAAAJBAAAWQQAAAoEAABaBAAACwQAAFsEAAAMBAAAXAQAAA0EAABdBAAADgQAAF4EAAAPBAAAXwQAABAEAAAwBAAAEQQAADEEAAASBAAAMgQAABMEAAAzBAAAFAQAADQEAAAVBAAANQQAABYEAAA2BAAAFwQAADcEAAAYBAAAOAQAABkEAAA5BAAAGgQAADoEAAAbBAAAOwQAABwEAAA8BAAAHQQAAD0EAAAeBAAAPgQAAB8EAAA/BAAAIAQAAEAEAAAhBAAAQQQAACIEAABCBAAAIwQAAEMEAAAkBAAARAQAACUEAABFBAAAJgQAAEYEAAAnBAAARwQAACgEAABIBAAAKQQAAEkEAAAqBAAASgQAACsEAABLBAAALAQAAEwEAAAtBAAATQQAAC4EAABOBAAALwQAAE8EAABgBAAAYQQAAGIEAABjBAAAZAQAAGUEAABmBAAAZwQAAGgEAABpBAAAagQAAGsEAABsBAAAbQQAAG4EAABvBAAAcAQAAHEEAAByBAAAcwQAAHQEAAB1BAAAdgQAAHcEAAB4BAAAeQQAAHoEAAB7BAAAfAQAAH0EAAB+BAAAfwQAAIAEAACBBAAAigQAAIsEAACMBAAAjQQAAI4EAACPBAAAkAQAAJEEAACSBAAAkwQAAJQEAACVBAAAlgQAAJcEAACYBAAAmQQAAJoEAACbBAAAnAQAAJ0EAACeBAAAnwQAAKAEAAChBAAAogQAAKMEAACkBAAApQQAAKYEAACnBAAAqAQAAKkEAACqBAAAqwQAAKwEAACtBAAArgQAAK8EAACwBAAAsQQAALIEAACzBAAAtAQAALUEAAC2BAAAtwQAALgEAAC5BAAAugQAALsEAAC8BAAAvQQAAL4EAAC/BAAAwAQAAM8EAADBBAAAwgQAAMMEAADEBAAAxQQAAMYEAADHBAAAyAQAAMkEAADKBAAAywQAAMwEAADNBAAAzgQAANAEAADRBAAA0gQAANMEAADUBAAA1QQAANYEAADXBAAA2AQAANkEAADaBAAA2wQAANwEAADdBAAA3gQAAN8EAADgBAAA4QQAAOIEAADjBAAA5AQAAOUEAADmBAAA5wQAAOgEAADpBAAA6gQAAOsEAADsBAAA7QQAAO4EAADvBAAA8AQAAPEEAADyBAAA8wQAAPQEAAD1BAAA9gQAAPcEAAD4BAAA+QQAAPoEAAD7BAAA/AQAAP0EAAD+BAAA/wQAAAAFAAABBQAAAgUAAAMFAAAEBQAABQUAAAYFAAAHBQAACAUAAAkFAAAKBQAACwUAAAwFAAANBQAADgUAAA8FAAAQBQAAEQUAABIFAAATBQAAFAUAABUFAAAWBQAAFwUAABgFAAAZBQAAGgUAABsFAAAcBQAAHQUAAB4FAAAfBQAAIAUAACEFAAAiBQAAIwUAACQFAAAlBQAAJgUAACcFAAAoBQAAKQUAACoFAAArBQAALAUAAC0FAAAuBQAALwUAADEFAABhBQAAMgUAAGIFAAAzBQAAYwUAADQFAABkBQAANQUAAGUFAAA2BQAAZgUAADcFAABnBQAAOAUAAGgFAAA5BQAAaQUAADoFAABqBQAAOwUAAGsFAAA8BQAAbAUAAD0FAABtBQAAPgUAAG4FAAA/BQAAbwUAAEAFAABwBQAAQQUAAHEFAABCBQAAcgUAAEMFAABzBQAARAUAAHQFAABFBQAAdQUAAEYFAAB2BQAARwUAAHcFAABIBQAAeAUAAEkFAAB5BQAASgUAAHoFAABLBQAAewUAAEwFAAB8BQAATQUAAH0FAABOBQAAfgUAAE8FAAB/BQAAUAUAAIAFAABRBQAAgQUAAFIFAACCBQAAUwUAAIMFAABUBQAAhAUAAFUFAACFBQAAVgUAAIYFAACgEAAAAC0AAKEQAAABLQAAohAAAAItAACjEAAAAy0AAKQQAAAELQAApRAAAAUtAACmEAAABi0AAKcQAAAHLQAAqBAAAAgtAACpEAAACS0AAKoQAAAKLQAAqxAAAAstAACsEAAADC0AAK0QAAANLQAArhAAAA4tAACvEAAADy0AALAQAAAQLQAAsRAAABEtAACyEAAAEi0AALMQAAATLQAAtBAAABQtAAC1EAAAFS0AALYQAAAWLQAAtxAAABctAAC4EAAAGC0AALkQAAAZLQAAuhAAABotAAC7EAAAGy0AALwQAAAcLQAAvRAAAB0tAAC+EAAAHi0AAL8QAAAfLQAAwBAAACAtAADBEAAAIS0AAMIQAAAiLQAAwxAAACMtAADEEAAAJC0AAMUQAAAlLQAAxxAAACctAADNEAAALS0AAKATAABwqwAAoRMAAHGrAACiEwAAcqsAAKMTAABzqwAApBMAAHSrAAClEwAAdasAAKYTAAB2qwAApxMAAHerAACoEwAAeKsAAKkTAAB5qwAAqhMAAHqrAACrEwAAe6sAAKwTAAB8qwAArRMAAH2rAACuEwAAfqsAAK8TAAB/qwAAsBMAAICrAACxEwAAgasAALITAACCqwAAsxMAAIOrAAC0EwAAhKsAALUTAACFqwAAthMAAIarAAC3EwAAh6sAALgTAACIqwAAuRMAAImrAAC6EwAAiqsAALsTAACLqwAAvBMAAIyrAAC9EwAAjasAAL4TAACOqwAAvxMAAI+rAADAEwAAkKsAAMETAACRqwAAwhMAAJKrAADDEwAAk6sAAMQTAACUqwAAxRMAAJWrAADGEwAAlqsAAMcTAACXqwAAyBMAAJirAADJEwAAmasAAMoTAACaqwAAyxMAAJurAADMEwAAnKsAAM0TAACdqwAAzhMAAJ6rAADPEwAAn6sAANATAACgqwAA0RMAAKGrAADSEwAAoqsAANMTAACjqwAA1BMAAKSrAADVEwAApasAANYTAACmqwAA1xMAAKerAADYEwAAqKsAANkTAACpqwAA2hMAAKqrAADbEwAAq6sAANwTAACsqwAA3RMAAK2rAADeEwAArqsAAN8TAACvqwAA4BMAALCrAADhEwAAsasAAOITAACyqwAA4xMAALOrAADkEwAAtKsAAOUTAAC1qwAA5hMAALarAADnEwAAt6sAAOgTAAC4qwAA6RMAALmrAADqEwAAuqsAAOsTAAC7qwAA7BMAALyrAADtEwAAvasAAO4TAAC+qwAA7xMAAL+rAADwEwAA+BMAAPETAAD5EwAA8hMAAPoTAADzEwAA+xMAAPQTAAD8EwAA9RMAAP0TAACJHAAAihwAAJAcAADQEAAAkRwAANEQAACSHAAA0hAAAJMcAADTEAAAlBwAANQQAACVHAAA1RAAAJYcAADWEAAAlxwAANcQAACYHAAA2BAAAJkcAADZEAAAmhwAANoQAACbHAAA2xAAAJwcAADcEAAAnRwAAN0QAACeHAAA3hAAAJ8cAADfEAAAoBwAAOAQAAChHAAA4RAAAKIcAADiEAAAoxwAAOMQAACkHAAA5BAAAKUcAADlEAAAphwAAOYQAACnHAAA5xAAAKgcAADoEAAAqRwAAOkQAACqHAAA6hAAAKscAADrEAAArBwAAOwQAACtHAAA7RAAAK4cAADuEAAArxwAAO8QAACwHAAA8BAAALEcAADxEAAAshwAAPIQAACzHAAA8xAAALQcAAD0EAAAtRwAAPUQAAC2HAAA9hAAALccAAD3EAAAuBwAAPgQAAC5HAAA+RAAALocAAD6EAAAvRwAAP0QAAC+HAAA/hAAAL8cAAD/EAAAAB4AAAEeAAACHgAAAx4AAAQeAAAFHgAABh4AAAceAAAIHgAACR4AAAoeAAALHgAADB4AAA0eAAAOHgAADx4AABAeAAARHgAAEh4AABMeAAAUHgAAFR4AABYeAAAXHgAAGB4AABkeAAAaHgAAGx4AABweAAAdHgAAHh4AAB8eAAAgHgAAIR4AACIeAAAjHgAAJB4AACUeAAAmHgAAJx4AACgeAAApHgAAKh4AACseAAAsHgAALR4AAC4eAAAvHgAAMB4AADEeAAAyHgAAMx4AADQeAAA1HgAANh4AADceAAA4HgAAOR4AADoeAAA7HgAAPB4AAD0eAAA+HgAAPx4AAEAeAABBHgAAQh4AAEMeAABEHgAARR4AAEYeAABHHgAASB4AAEkeAABKHgAASx4AAEweAABNHgAATh4AAE8eAABQHgAAUR4AAFIeAABTHgAAVB4AAFUeAABWHgAAVx4AAFgeAABZHgAAWh4AAFseAABcHgAAXR4AAF4eAABfHgAAYB4AAGEeAABiHgAAYx4AAGQeAABlHgAAZh4AAGceAABoHgAAaR4AAGoeAABrHgAAbB4AAG0eAABuHgAAbx4AAHAeAABxHgAAch4AAHMeAAB0HgAAdR4AAHYeAAB3HgAAeB4AAHkeAAB6HgAAex4AAHweAAB9HgAAfh4AAH8eAACAHgAAgR4AAIIeAACDHgAAhB4AAIUeAACGHgAAhx4AAIgeAACJHgAAih4AAIseAACMHgAAjR4AAI4eAACPHgAAkB4AAJEeAACSHgAAkx4AAJQeAACVHgAAnh4AAN8AAACgHgAAoR4AAKIeAACjHgAApB4AAKUeAACmHgAApx4AAKgeAACpHgAAqh4AAKseAACsHgAArR4AAK4eAACvHgAAsB4AALEeAACyHgAAsx4AALQeAAC1HgAAth4AALceAAC4HgAAuR4AALoeAAC7HgAAvB4AAL0eAAC+HgAAvx4AAMAeAADBHgAAwh4AAMMeAADEHgAAxR4AAMYeAADHHgAAyB4AAMkeAADKHgAAyx4AAMweAADNHgAAzh4AAM8eAADQHgAA0R4AANIeAADTHgAA1B4AANUeAADWHgAA1x4AANgeAADZHgAA2h4AANseAADcHgAA3R4AAN4eAADfHgAA4B4AAOEeAADiHgAA4x4AAOQeAADlHgAA5h4AAOceAADoHgAA6R4AAOoeAADrHgAA7B4AAO0eAADuHgAA7x4AAPAeAADxHgAA8h4AAPMeAAD0HgAA9R4AAPYeAAD3HgAA+B4AAPkeAAD6HgAA+x4AAPweAAD9HgAA/h4AAP8eAAAIHwAAAB8AAAkfAAABHwAACh8AAAIfAAALHwAAAx8AAAwfAAAEHwAADR8AAAUfAAAOHwAABh8AAA8fAAAHHwAAGB8AABAfAAAZHwAAER8AABofAAASHwAAGx8AABMfAAAcHwAAFB8AAB0fAAAVHwAAKB8AACAfAAApHwAAIR8AACofAAAiHwAAKx8AACMfAAAsHwAAJB8AAC0fAAAlHwAALh8AACYfAAAvHwAAJx8AADgfAAAwHwAAOR8AADEfAAA6HwAAMh8AADsfAAAzHwAAPB8AADQfAAA9HwAANR8AAD4fAAA2HwAAPx8AADcfAABIHwAAQB8AAEkfAABBHwAASh8AAEIfAABLHwAAQx8AAEwfAABEHwAATR8AAEUfAABZHwAAUR8AAFsfAABTHwAAXR8AAFUfAABfHwAAVx8AAGgfAABgHwAAaR8AAGEfAABqHwAAYh8AAGsfAABjHwAAbB8AAGQfAABtHwAAZR8AAG4fAABmHwAAbx8AAGcfAACIHwAAgB8AAIkfAACBHwAAih8AAIIfAACLHwAAgx8AAIwfAACEHwAAjR8AAIUfAACOHwAAhh8AAI8fAACHHwAAmB8AAJAfAACZHwAAkR8AAJofAACSHwAAmx8AAJMfAACcHwAAlB8AAJ0fAACVHwAAnh8AAJYfAACfHwAAlx8AAKgfAACgHwAAqR8AAKEfAACqHwAAoh8AAKsfAACjHwAArB8AAKQfAACtHwAApR8AAK4fAACmHwAArx8AAKcfAAC4HwAAsB8AALkfAACxHwAAuh8AAHAfAAC7HwAAcR8AALwfAACzHwAAyB8AAHIfAADJHwAAcx8AAMofAAB0HwAAyx8AAHUfAADMHwAAwx8AANgfAADQHwAA2R8AANEfAADaHwAAdh8AANsfAAB3HwAA6B8AAOAfAADpHwAA4R8AAOofAAB6HwAA6x8AAHsfAADsHwAA5R8AAPgfAAB4HwAA+R8AAHkfAAD6HwAAfB8AAPsfAAB9HwAA/B8AAPMfAAAmIQAAyQMAACohAABrAAAAKyEAAOUAAAAyIQAATiEAAGAhAABwIQAAYSEAAHEhAABiIQAAciEAAGMhAABzIQAAZCEAAHQhAABlIQAAdSEAAGYhAAB2IQAAZyEAAHchAABoIQAAeCEAAGkhAAB5IQAAaiEAAHohAABrIQAAeyEAAGwhAAB8IQAAbSEAAH0hAABuIQAAfiEAAG8hAAB/IQAAgyEAAIQhAAC2JAAA0CQAALckAADRJAAAuCQAANIkAAC5JAAA0yQAALokAADUJAAAuyQAANUkAAC8JAAA1iQAAL0kAADXJAAAviQAANgkAAC/JAAA2SQAAMAkAADaJAAAwSQAANskAADCJAAA3CQAAMMkAADdJAAAxCQAAN4kAADFJAAA3yQAAMYkAADgJAAAxyQAAOEkAADIJAAA4iQAAMkkAADjJAAAyiQAAOQkAADLJAAA5SQAAMwkAADmJAAAzSQAAOckAADOJAAA6CQAAM8kAADpJAAAACwAADAsAAABLAAAMSwAAAIsAAAyLAAAAywAADMsAAAELAAANCwAAAUsAAA1LAAABiwAADYsAAAHLAAANywAAAgsAAA4LAAACSwAADksAAAKLAAAOiwAAAssAAA7LAAADCwAADwsAAANLAAAPSwAAA4sAAA+LAAADywAAD8sAAAQLAAAQCwAABEsAABBLAAAEiwAAEIsAAATLAAAQywAABQsAABELAAAFSwAAEUsAAAWLAAARiwAABcsAABHLAAAGCwAAEgsAAAZLAAASSwAABosAABKLAAAGywAAEssAAAcLAAATCwAAB0sAABNLAAAHiwAAE4sAAAfLAAATywAACAsAABQLAAAISwAAFEsAAAiLAAAUiwAACMsAABTLAAAJCwAAFQsAAAlLAAAVSwAACYsAABWLAAAJywAAFcsAAAoLAAAWCwAACksAABZLAAAKiwAAFosAAArLAAAWywAACwsAABcLAAALSwAAF0sAAAuLAAAXiwAAC8sAABfLAAAYCwAAGEsAABiLAAAawIAAGMsAAB9HQAAZCwAAH0CAABnLAAAaCwAAGksAABqLAAAaywAAGwsAABtLAAAUQIAAG4sAABxAgAAbywAAFACAABwLAAAUgIAAHIsAABzLAAAdSwAAHYsAAB+LAAAPwIAAH8sAABAAgAAgCwAAIEsAACCLAAAgywAAIQsAACFLAAAhiwAAIcsAACILAAAiSwAAIosAACLLAAAjCwAAI0sAACOLAAAjywAAJAsAACRLAAAkiwAAJMsAACULAAAlSwAAJYsAACXLAAAmCwAAJksAACaLAAAmywAAJwsAACdLAAAniwAAJ8sAACgLAAAoSwAAKIsAACjLAAApCwAAKUsAACmLAAApywAAKgsAACpLAAAqiwAAKssAACsLAAArSwAAK4sAACvLAAAsCwAALEsAACyLAAAsywAALQsAAC1LAAAtiwAALcsAAC4LAAAuSwAALosAAC7LAAAvCwAAL0sAAC+LAAAvywAAMAsAADBLAAAwiwAAMMsAADELAAAxSwAAMYsAADHLAAAyCwAAMksAADKLAAAyywAAMwsAADNLAAAziwAAM8sAADQLAAA0SwAANIsAADTLAAA1CwAANUsAADWLAAA1ywAANgsAADZLAAA2iwAANssAADcLAAA3SwAAN4sAADfLAAA4CwAAOEsAADiLAAA4ywAAOssAADsLAAA7SwAAO4sAADyLAAA8ywAAECmAABBpgAAQqYAAEOmAABEpgAARaYAAEamAABHpgAASKYAAEmmAABKpgAAS6YAAEymAABNpgAATqYAAE+mAABQpgAAUaYAAFKmAABTpgAAVKYAAFWmAABWpgAAV6YAAFimAABZpgAAWqYAAFumAABcpgAAXaYAAF6mAABfpgAAYKYAAGGmAABipgAAY6YAAGSmAABlpgAAZqYAAGemAABopgAAaaYAAGqmAABrpgAAbKYAAG2mAACApgAAgaYAAIKmAACDpgAAhKYAAIWmAACGpgAAh6YAAIimAACJpgAAiqYAAIumAACMpgAAjaYAAI6mAACPpgAAkKYAAJGmAACSpgAAk6YAAJSmAACVpgAAlqYAAJemAACYpgAAmaYAAJqmAACbpgAAIqcAACOnAAAkpwAAJacAACanAAAnpwAAKKcAACmnAAAqpwAAK6cAACynAAAtpwAALqcAAC+nAAAypwAAM6cAADSnAAA1pwAANqcAADenAAA4pwAAOacAADqnAAA7pwAAPKcAAD2nAAA+pwAAP6cAAECnAABBpwAAQqcAAEOnAABEpwAARacAAEanAABHpwAASKcAAEmnAABKpwAAS6cAAEynAABNpwAATqcAAE+nAABQpwAAUacAAFKnAABTpwAAVKcAAFWnAABWpwAAV6cAAFinAABZpwAAWqcAAFunAABcpwAAXacAAF6nAABfpwAAYKcAAGGnAABipwAAY6cAAGSnAABlpwAAZqcAAGenAABopwAAaacAAGqnAABrpwAAbKcAAG2nAABupwAAb6cAAHmnAAB6pwAAe6cAAHynAAB9pwAAeR0AAH6nAAB/pwAAgKcAAIGnAACCpwAAg6cAAISnAACFpwAAhqcAAIenAACLpwAAjKcAAI2nAABlAgAAkKcAAJGnAACSpwAAk6cAAJanAACXpwAAmKcAAJmnAACapwAAm6cAAJynAACdpwAAnqcAAJ+nAACgpwAAoacAAKKnAACjpwAApKcAAKWnAACmpwAAp6cAAKinAACppwAAqqcAAGYCAACrpwAAXAIAAKynAABhAgAAracAAGwCAACupwAAagIAALCnAACeAgAAsacAAIcCAACypwAAnQIAALOnAABTqwAAtKcAALWnAAC2pwAAt6cAALinAAC5pwAAuqcAALunAAC8pwAAvacAAL6nAAC/pwAAwKcAAMGnAADCpwAAw6cAAMSnAACUpwAAxacAAIICAADGpwAAjh0AAMenAADIpwAAyacAAMqnAADLpwAAZAIAAMynAADNpwAA0KcAANGnAADWpwAA16cAANinAADZpwAA2qcAANunAADcpwAAmwEAAPWnAAD2pwAAIf8AAEH/AAAi/wAAQv8AACP/AABD/wAAJP8AAET/AAAl/wAARf8AACb/AABG/wAAJ/8AAEf/AAAo/wAASP8AACn/AABJ/wAAKv8AAEr/AAAr/wAAS/8AACz/AABM/wAALf8AAE3/AAAu/wAATv8AAC//AABP/wAAMP8AAFD/AAAx/wAAUf8AADL/AABS/wAAM/8AAFP/AAA0/wAAVP8AADX/AABV/wAANv8AAFb/AAA3/wAAV/8AADj/AABY/wAAOf8AAFn/AAA6/wAAWv8AAAAEAQAoBAEAAQQBACkEAQACBAEAKgQBAAMEAQArBAEABAQBACwEAQAFBAEALQQBAAYEAQAuBAEABwQBAC8EAQAIBAEAMAQBAAkEAQAxBAEACgQBADIEAQALBAEAMwQBAAwEAQA0BAEADQQBADUEAQAOBAEANgQBAA8EAQA3BAEAEAQBADgEAQARBAEAOQQBABIEAQA6BAEAEwQBADsEAQAUBAEAPAQBABUEAQA9BAEAFgQBAD4EAQAXBAEAPwQBABgEAQBABAEAGQQBAEEEAQAaBAEAQgQBABsEAQBDBAEAHAQBAEQEAQAdBAEARQQBAB4EAQBGBAEAHwQBAEcEAQAgBAEASAQBACEEAQBJBAEAIgQBAEoEAQAjBAEASwQBACQEAQBMBAEAJQQBAE0EAQAmBAEATgQBACcEAQBPBAEAsAQBANgEAQCxBAEA2QQBALIEAQDaBAEAswQBANsEAQC0BAEA3AQBALUEAQDdBAEAtgQBAN4EAQC3BAEA3wQBALgEAQDgBAEAuQQBAOEEAQC6BAEA4gQBALsEAQDjBAEAvAQBAOQEAQC9BAEA5QQBAL4EAQDmBAEAvwQBAOcEAQDABAEA6AQBAMEEAQDpBAEAwgQBAOoEAQDDBAEA6wQBAMQEAQDsBAEAxQQBAO0EAQDGBAEA7gQBAMcEAQDvBAEAyAQBAPAEAQDJBAEA8QQBAMoEAQDyBAEAywQBAPMEAQDMBAEA9AQBAM0EAQD1BAEAzgQBAPYEAQDPBAEA9wQBANAEAQD4BAEA0QQBAPkEAQDSBAEA+gQBANMEAQD7BAEAcAUBAJcFAQBxBQEAmAUBAHIFAQCZBQEAcwUBAJoFAQB0BQEAmwUBAHUFAQCcBQEAdgUBAJ0FAQB3BQEAngUBAHgFAQCfBQEAeQUBAKAFAQB6BQEAoQUBAHwFAQCjBQEAfQUBAKQFAQB+BQEApQUBAH8FAQCmBQEAgAUBAKcFAQCBBQEAqAUBAIIFAQCpBQEAgwUBAKoFAQCEBQEAqwUBAIUFAQCsBQEAhgUBAK0FAQCHBQEArgUBAIgFAQCvBQEAiQUBALAFAQCKBQEAsQUBAIwFAQCzBQEAjQUBALQFAQCOBQEAtQUBAI8FAQC2BQEAkAUBALcFAQCRBQEAuAUBAJIFAQC5BQEAlAUBALsFAQCVBQEAvAUBAIAMAQDADAEAgQwBAMEMAQCCDAEAwgwBAIMMAQDDDAEAhAwBAMQMAQCFDAEAxQwBAIYMAQDGDAEAhwwBAMcMAQCIDAEAyAwBAIkMAQDJDAEAigwBAMoMAQCLDAEAywwBAIwMAQDMDAEAjQwBAM0MAQCODAEAzgwBAI8MAQDPDAEAkAwBANAMAQCRDAEA0QwBAJIMAQDSDAEAkwwBANMMAQCUDAEA1AwBAJUMAQDVDAEAlgwBANYMAQCXDAEA1wwBAJgMAQDYDAEAmQwBANkMAQCaDAEA2gwBAJsMAQDbDAEAnAwBANwMAQCdDAEA3QwBAJ4MAQDeDAEAnwwBAN8MAQCgDAEA4AwBAKEMAQDhDAEAogwBAOIMAQCjDAEA4wwBAKQMAQDkDAEApQwBAOUMAQCmDAEA5gwBAKcMAQDnDAEAqAwBAOgMAQCpDAEA6QwBAKoMAQDqDAEAqwwBAOsMAQCsDAEA7AwBAK0MAQDtDAEArgwBAO4MAQCvDAEA7wwBALAMAQDwDAEAsQwBAPEMAQCyDAEA8gwBAFANAQBwDQEAUQ0BAHENAQBSDQEAcg0BAFMNAQBzDQEAVA0BAHQNAQBVDQEAdQ0BAFYNAQB2DQEAVw0BAHcNAQBYDQEAeA0BAFkNAQB5DQEAWg0BAHoNAQBbDQEAew0BAFwNAQB8DQEAXQ0BAH0NAQBeDQEAfg0BAF8NAQB/DQEAYA0BAIANAQBhDQEAgQ0BAGINAQCCDQEAYw0BAIMNAQBkDQEAhA0BAGUNAQCFDQEAoBgBAMAYAQChGAEAwRgBAKIYAQDCGAEAoxgBAMMYAQCkGAEAxBgBAKUYAQDFGAEAphgBAMYYAQCnGAEAxxgBAKgYAQDIGAEAqRgBAMkYAQCqGAEAyhgBAKsYAQDLGAEArBgBAMwYAQCtGAEAzRgBAK4YAQDOGAEArxgBAM8YAQCwGAEA0BgBALEYAQDRGAEAshgBANIYAQCzGAEA0xgBALQYAQDUGAEAtRgBANUYAQC2GAEA1hgBALcYAQDXGAEAuBgBANgYAQC5GAEA2RgBALoYAQDaGAEAuxgBANsYAQC8GAEA3BgBAL0YAQDdGAEAvhgBAN4YAQC/GAEA3xgBAEBuAQBgbgEAQW4BAGFuAQBCbgEAYm4BAENuAQBjbgEARG4BAGRuAQBFbgEAZW4BAEZuAQBmbgEAR24BAGduAQBIbgEAaG4BAEluAQBpbgEASm4BAGpuAQBLbgEAa24BAExuAQBsbgEATW4BAG1uAQBObgEAbm4BAE9uAQBvbgEAUG4BAHBuAQBRbgEAcW4BAFJuAQBybgEAU24BAHNuAQBUbgEAdG4BAFVuAQB1bgEAVm4BAHZuAQBXbgEAd24BAFhuAQB4bgEAWW4BAHluAQBabgEAem4BAFtuAQB7bgEAXG4BAHxuAQBdbgEAfW4BAF5uAQB+bgEAX24BAH9uAQAA6QEAIukBAAHpAQAj6QEAAukBACTpAQAD6QEAJekBAATpAQAm6QEABekBACfpAQAG6QEAKOkBAAfpAQAp6QEACOkBACrpAQAJ6QEAK+kBAArpAQAs6QEAC+kBAC3pAQAM6QEALukBAA3pAQAv6QEADukBADDpAQAP6QEAMekBABDpAQAy6QEAEekBADPpAQAS6QEANOkBABPpAQA16QEAFOkBADbpAQAV6QEAN+kBABbpAQA46QEAF+kBADnpAQAY6QEAOukBABnpAQA76QEAGukBADzpAQAb6QEAPekBABzpAQA+6QEAHekBAD/pAQAe6QEAQOkBAB/pAQBB6QEAIOkBAELpAQAh6QEAQ+kBAFZlYzNBSGFzaCB0YWJsZSBjYXBhY2l0eSBvdmVyZmxvdwAAAHF3EAAcAAAA6QkQACsAAAAlAAAAKAAAAGNsb3N1cmUgaW52b2tlZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkAACqDBAAXgAAAPsYAAABAAAAZGVzdCBpcyBvdXQgb2YgYm91bmRzAAAA7HcQABUAAACRABAAdAAAAFIDAAAyAAAAEBESAAgHCQYKBQsEDAMNAg4BDwBoCBAAawAAABECAAAoAAAAaAgQAGsAAACGAgAAHQAAAAAAAIAAQADAACAAoABgAOAAEACQAFAA0AAwALAAcADwAAgAiABIAMgAKACoAGgA6AAYAJgAWADYADgAuAB4APgABACEAEQAxAAkAKQAZADkABQAlABUANQANAC0AHQA9AAMAIwATADMACwArABsAOwAHACcAFwA3AA8ALwAfAD8AAIAggBCAMIAIgCiAGIA4gASAJIAUgDSADIAsgByAPIACgCKAEoAygAqAKoAagDqABoAmgBaANoAOgC6AHoA+gAGAIYARgDGACYApgBmAOYAFgCWAFYA1gA2ALYAdgD2AA4AjgBOAM4ALgCuAG4A7gAeAJ4AXgDeAD4AvgB+AP4AAQCBAEEAwQAhAKEAYQDhABEAkQBRANEAMQCxAHEA8QAJAIkASQDJACkAqQBpAOkAGQCZAFkA2QA5ALkAeQD5AAUAhQBFAMUAJQClAGUA5QAVAJUAVQDVADUAtQB1APUADQCNAE0AzQAtAK0AbQDtAB0AnQBdAN0APQC9AH0A/QADAIMAQwDDACMAowBjAOMAEwCTAFMA0wAzALMAcwDzAAsAiwBLAMsAKwCrAGsA6wAbAJsAWwDbADsAuwB7APsABwCHAEcAxwAnAKcAZwDnABcAlwBXANcANwC3AHcA9wAPAI8ATwDPAC8ArwBvAO8AHwCfAF8A3wA/AL8AfwD/gACAgIBAgMCAIICggGCA4IAQgJCAUIDQgDCAsIBwgPCACICIgEiAyIAogKiAaIDogBiAmIBYgNiAOIC4gHiA+IAEgISARIDEgCSApIBkgOSAFICUgFSA1IA0gLSAdID0gAyAjIBMgMyALICsgGyA7IAcgJyAXIDcgDyAvIB8gPyAAoCCgEKAwoAigKKAYoDigBKAkoBSgNKAMoCygHKA8oAKgIqASoDKgCqAqoBqgOqAGoCagFqA2oA6gLqAeoD6gAaAhoBGgMaAJoCmgGaA5oAWgJaAVoDWgDaAtoB2gPaADoCOgE6AzoAugK6AboDugB6AnoBegN6APoC+gH6A/oABgIGAQYDBgCGAoYBhgOGAEYCRgFGA0YAxgLGAcYDxgAmAiYBJgMmAKYCpgGmA6YAZgJmAWYDZgDmAuYB5gPmABYCFgEWAxYAlgKWAZYDlgBWAlYBVgNWANYC1gHWA9YANgI2ATYDNgC2ArYBtgO2AHYCdgF2A3YA9gL2AfYD9gAOAg4BDgMOAI4CjgGOA44ATgJOAU4DTgDOAs4BzgPOAC4CLgEuAy4ArgKuAa4DrgBuAm4BbgNuAO4C7gHuA+4AHgIeAR4DHgCeAp4BngOeAF4CXgFeA14A3gLeAd4D3gA+Aj4BPgM+AL4CvgG+A74AfgJ+AX4DfgD+Av4B/gP9oCBAAawAAACIEAAAUAAAAaAgQAGsAAAAjBAAAEgAAAGFzc2VydGlvbiBmYWlsZWQ6IG91dF9wb3MgKyAzIDwgb3V0X3NsaWNlLmxlbigpAGgIEABrAAAANgQAAA0AAABhc3NlcnRpb24gZmFpbGVkOiAoc291cmNl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IHBsYXRmb3JtUJUQACgAAAAkAAAAAAAAAAIAAAB4lRAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAMwJEAAdAAAAigEAAB0AAAC5AAAAEAAAAAQAAAC6AAAAuwAAAAEAAAAAAAAAbWlkID4gbGVuAAAA5JUQAAkAAAANBxAALgAAABYBAAApAAAAZW50aXR5IG5vdCBmb3VuZHBlcm1pc3Npb24gZGVuaWVkY29ubmVjdGlvbiByZWZ1c2VkY29ubmVjdGlvbiByZXNldGhvc3QgdW5yZWFjaGFibGVuZXR3b3JrIHVucmVhY2hhYmxlY29ubmVjdGlvbiBhYm9ydGVkbm90IGNvbm5lY3RlZGFkZHJlc3MgaW4gdXNlYWRkcmVzcyBub3QgYXZhaWxhYmxlbmV0d29yayBkb3duYnJva2VuIHBpcGVlbnRpdHkgYWxyZWFkeSBleGlzdHNvcGVyYXRpb24gd291bGQgYmxvY2tub3QgYSBkaXJlY3RvcnlpcyBhIGRpcmVjdG9yeWRpcmVjdG9yeSBub3QgZW1wdHlyZWFkLW9ubHkgZmlsZXN5c3RlbSBvciBzdG9yYWdlIG1lZGl1bWZpbGVzeXN0ZW0gbG9vcCBvciBpbmRpcmVjdGlvbiBsaW1pdCAoZS5nLiBzeW1saW5rIGxvb3Apc3RhbGUgbmV0d29yayBmaWxlIGhhbmRsZWludmFsaWQgaW5wdXQgcGFyYW1ldGVyaW52YWxpZCBkYXRhdGltZWQgb3V0d3JpdGUgemVyb25vIHN0b3JhZ2Ugc3BhY2VzZWVrIG9uIHVuc2Vla2FibGUgZmlsZXF1b3RhIGV4Y2VlZGVkZmlsZSB0b28gbGFyZ2VyZXNvdXJjZSBidXN5ZXhlY3V0YWJsZSBmaWxlIGJ1c3lkZWFkbG9ja2Nyb3NzLWRldmljZSBsaW5rIG9yIHJlbmFtZXRvbyBtYW55IGxpbmtzaW52YWxpZCBmaWxlbmFtZWFyZ3VtZW50IGxpc3QgdG9vIGxvbmdvcGVyYXRpb24gaW50ZXJydXB0ZWR1bnN1cHBvcnRlZHVuZXhwZWN0ZWQgZW5kIG9mIGZpbGVvdXQgb2YgbWVtb3J5aW4gcHJvZ3Jlc3NvdGhlciBlcnJvcnVuY2F0ZWdvcml6ZWQgZXJy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", import.meta.url);
  }
  const imports = __wbg_get_imports();
  if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {
    module_or_path = fetch(module_or_path);
  }
  const { instance, module } = await __wbg_load(await module_or_path, imports);
  return __wbg_finalize_init(instance, module);
}
const Gsplat = { type: "Gsplat" };
const TPackedSplats = { type: "PackedSplats" };
const numPackedSplats = (packedSplats) => new NumPackedSplats({ packedSplats });
const readPackedSplat = (packedSplats, index) => new ReadPackedSplat({ packedSplats, index });
const readPackedSplatRange = (packedSplats, index, base, count) => new ReadPackedSplatRange({ packedSplats, index, base, count });
const splitGsplat = (gsplat) => new SplitGsplat({ gsplat });
const combineGsplat = ({
  gsplat,
  flags,
  index,
  center,
  scales,
  quaternion,
  rgba,
  rgb,
  opacity,
  x,
  y,
  z,
  r,
  g,
  b
}) => {
  return new CombineGsplat({
    gsplat,
    flags,
    index,
    center,
    scales,
    quaternion,
    rgba,
    rgb,
    opacity,
    x,
    y,
    z,
    r,
    g,
    b
  });
};
const gsplatNormal = (gsplat) => new GsplatNormal({ gsplat });
const transformGsplat = (gsplat, {
  scale,
  rotate,
  translate,
  recolor
}) => {
  return new TransformGsplat({ gsplat, scale, rotate, translate, recolor });
};
const defineGsplat = unindent(`
  struct Gsplat {
    vec3 center;
    uint flags;
    vec3 scales;
    int index;
    vec4 quaternion;
    vec4 rgba;
  };
  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;

  bool isGsplatActive(uint flags) {
    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;
  }
`);
const definePackedSplats = unindent(`
  struct PackedSplats {
    usampler2DArray textureArray;
    usampler2D texture;
    int numSplats;
    vec4 rgbMinMaxLnScaleMinMax;
    int flagsFlatLodOpacity;
  };
`);
class NumPackedSplats extends UnaryOp {
  constructor({
    packedSplats
  }) {
    super({ a: packedSplats, outKey: "numSplats", outTypeFunc: () => "int" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.numSplats} = ${inputs.a}.numSplats;`
    ];
  }
}
const defineReadPackedArray = unindent(`
  bool readPackedArray(usampler2DArray texture, int numSplats, vec4 rgbMinMaxLnScaleMinMax, int index, out Gsplat gsplat) {
    if ((index >= 0) && (index < numSplats)) {
      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);
      unpackSplatEncoding(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba, rgbMinMaxLnScaleMinMax);
      return true;
    } else {
      return false;
    }
  }
`);
const defineReadPackedFlat = unindent(`
  bool readPackedFlat(usampler2D texture, int numSplats, vec4 rgbMinMaxLnScaleMinMax, int index, out Gsplat gsplat) {
    if ((index >= 0) && (index < numSplats)) {
      ivec2 coord = ivec2(index & 4095, index >> 12);
      uvec4 packed = texelFetch(texture, coord, 0);
      unpackSplatEncoding(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba, rgbMinMaxLnScaleMinMax);
      return true;
    } else {
      return false;
    }
  }
`);
class ReadPackedSplat extends Dyno {
  constructor({
    packedSplats,
    index
  }) {
    super({
      inTypes: { packedSplats: TPackedSplats, index: "int" },
      outTypes: { gsplat: Gsplat },
      inputs: { packedSplats, index },
      globals: () => [defineGsplat, definePackedSplats, defineReadPackedArray, defineReadPackedFlat],
      statements: ({ inputs, outputs }) => {
        const { gsplat } = outputs;
        if (!gsplat) {
          return [];
        }
        const { packedSplats: packedSplats2, index: index2 } = inputs;
        let statements;
        if (packedSplats2 && index2) {
          statements = unindentLines(`
            ${gsplat}.flags = 0u;
            if ((${packedSplats2}.flagsFlatLodOpacity & 0x1) != 0) {
              if (readPackedFlat(${packedSplats2}.texture, ${packedSplats2}.numSplats, ${packedSplats2}.rgbMinMaxLnScaleMinMax, ${index2}, ${gsplat})) {
                if ((${packedSplats2}.flagsFlatLodOpacity & 0x2) != 0) {
                  ${gsplat}.rgba.a = 2.0 * ${gsplat}.rgba.a;
                }
                bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));
                ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
              }
            } else {
              if (readPackedArray(${packedSplats2}.textureArray, ${packedSplats2}.numSplats, ${packedSplats2}.rgbMinMaxLnScaleMinMax, ${index2}, ${gsplat})) {
                if ((${packedSplats2}.flagsFlatLodOpacity & 0x2) != 0) {
                  ${gsplat}.rgba.a = 2.0 * ${gsplat}.rgba.a;
                }
                bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));
                ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
              }
            }
          `);
        } else {
          statements = [`${gsplat}.flags = 0u;`];
        }
        statements.push(`${gsplat}.index = ${index2 ?? "0"};`);
        return statements;
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "gsplat");
  }
}
class ReadPackedSplatRange extends Dyno {
  constructor({
    packedSplats,
    index,
    base,
    count
  }) {
    super({
      inTypes: {
        packedSplats: TPackedSplats,
        index: "int",
        base: "int",
        count: "int"
      },
      outTypes: { gsplat: Gsplat },
      inputs: { packedSplats, index, base, count },
      globals: () => [defineGsplat, definePackedSplats, defineReadPackedArray, defineReadPackedFlat],
      statements: ({ inputs, outputs }) => {
        const { gsplat } = outputs;
        if (!gsplat) {
          return [];
        }
        const { packedSplats: packedSplats2, index: index2, base: base2, count: count2 } = inputs;
        let statements;
        if (packedSplats2 && index2 && base2 && count2) {
          statements = unindentLines(`
            ${gsplat}.flags = 0u;
            if ((${packedSplats2}.flagsFlatLodOpacity & 0x1) != 0) {
              if (readPackedFlat(${packedSplats2}.texture, ${packedSplats2}.numSplats, ${packedSplats2}.rgbMinMaxLnScaleMinMax, ${index2}, ${gsplat})) {
                if ((${packedSplats2}.flagsFlatLodOpacity & 0x2) != 0) {
                  ${gsplat}.rgba.a = 2.0 * ${gsplat}.rgba.a;
                }
                bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));
                ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
              }
            } else {
              if (readPackedArray(${packedSplats2}.textureArray, ${packedSplats2}.numSplats, ${packedSplats2}.rgbMinMaxLnScaleMinMax, ${index2}, ${gsplat})) {
                if ((${packedSplats2}.flagsFlatLodOpacity & 0x2) != 0) {
                  ${gsplat}.rgba.a = 2.0 * ${gsplat}.rgba.a;
                }
                bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));
                ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
              }
            }
          `);
        } else {
          statements = [`${gsplat}.flags = 0u;`];
        }
        statements.push(`${gsplat}.index = ${index2 ?? "0"};`);
        return statements;
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "gsplat");
  }
}
class SplitGsplat extends Dyno {
  constructor({ gsplat }) {
    super({
      inTypes: { gsplat: Gsplat },
      outTypes: {
        flags: "uint",
        active: "bool",
        index: "int",
        center: "vec3",
        scales: "vec3",
        quaternion: "vec4",
        rgba: "vec4",
        rgb: "vec3",
        opacity: "float",
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      },
      inputs: { gsplat },
      globals: () => [defineGsplat],
      statements: ({ inputs, outputs }) => {
        const { gsplat: gsplat2 } = inputs;
        const {
          flags,
          active,
          index,
          center,
          scales,
          quaternion,
          rgba,
          rgb,
          opacity,
          x,
          y,
          z,
          r,
          g,
          b
        } = outputs;
        return [
          !flags ? null : `${flags} = ${gsplat2 ? `${gsplat2}.flags` : "0u"};`,
          !active ? null : `${active} = isGsplatActive(${gsplat2 ? `${gsplat2}.flags` : "0u"});`,
          !index ? null : `${index} = ${gsplat2 ? `${gsplat2}.index` : "0"};`,
          !center ? null : `${center} = ${gsplat2 ? `${gsplat2}.center` : "vec3(0.0, 0.0, 0.0)"};`,
          !scales ? null : `${scales} = ${gsplat2 ? `${gsplat2}.scales` : "vec3(0.0, 0.0, 0.0)"};`,
          !quaternion ? null : `${quaternion} = ${gsplat2 ? `${gsplat2}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)"};`,
          !rgba ? null : `${rgba} = ${gsplat2 ? `${gsplat2}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)"};`,
          !rgb ? null : `${rgb} = ${gsplat2 ? `${gsplat2}.rgba.rgb` : "vec3(0.0, 0.0, 0.0)"};`,
          !opacity ? null : `${opacity} = ${gsplat2 ? `${gsplat2}.rgba.a` : "0.0"};`,
          !x ? null : `${x} = ${gsplat2 ? `${gsplat2}.center.x` : "0.0"};`,
          !y ? null : `${y} = ${gsplat2 ? `${gsplat2}.center.y` : "0.0"};`,
          !z ? null : `${z} = ${gsplat2 ? `${gsplat2}.center.z` : "0.0"};`,
          !r ? null : `${r} = ${gsplat2 ? `${gsplat2}.rgba.r` : "0.0"};`,
          !g ? null : `${g} = ${gsplat2 ? `${gsplat2}.rgba.g` : "0.0"};`,
          !b ? null : `${b} = ${gsplat2 ? `${gsplat2}.rgba.b` : "0.0"};`
        ].filter(Boolean);
      }
    });
  }
}
class CombineGsplat extends Dyno {
  constructor({
    gsplat,
    flags,
    index,
    center,
    scales,
    quaternion,
    rgba,
    rgb,
    opacity,
    x,
    y,
    z,
    r,
    g,
    b
  }) {
    super({
      inTypes: {
        gsplat: Gsplat,
        flags: "uint",
        index: "int",
        center: "vec3",
        scales: "vec3",
        quaternion: "vec4",
        rgba: "vec4",
        rgb: "vec3",
        opacity: "float",
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      },
      outTypes: { gsplat: Gsplat },
      inputs: {
        gsplat,
        flags,
        index,
        center,
        scales,
        quaternion,
        rgba,
        rgb,
        opacity,
        x,
        y,
        z,
        r,
        g,
        b
      },
      globals: () => [defineGsplat],
      statements: ({ inputs, outputs }) => {
        const { gsplat: outGsplat } = outputs;
        if (!outGsplat) {
          return [];
        }
        const {
          gsplat: gsplat2,
          flags: flags2,
          index: index2,
          center: center2,
          scales: scales2,
          quaternion: quaternion2,
          rgba: rgba2,
          rgb: rgb2,
          opacity: opacity2,
          x: x2,
          y: y2,
          z: z2,
          r: r2,
          g: g2,
          b: b22
        } = inputs;
        return [
          `${outGsplat}.flags = ${flags2 ?? (gsplat2 ? `${gsplat2}.flags` : "0u")};`,
          `${outGsplat}.index = ${index2 ?? (gsplat2 ? `${gsplat2}.index` : "0")};`,
          `${outGsplat}.center = ${center2 ?? (gsplat2 ? `${gsplat2}.center` : "vec3(0.0, 0.0, 0.0)")};`,
          `${outGsplat}.scales = ${scales2 ?? (gsplat2 ? `${gsplat2}.scales` : "vec3(0.0, 0.0, 0.0)")};`,
          `${outGsplat}.quaternion = ${quaternion2 ?? (gsplat2 ? `${gsplat2}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)")};`,
          `${outGsplat}.rgba = ${rgba2 ?? (gsplat2 ? `${gsplat2}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)")};`,
          !rgb2 ? null : `${outGsplat}.rgba.rgb = ${rgb2};`,
          !opacity2 ? null : `${outGsplat}.rgba.a = ${opacity2};`,
          !x2 ? null : `${outGsplat}.center.x = ${x2};`,
          !y2 ? null : `${outGsplat}.center.y = ${y2};`,
          !z2 ? null : `${outGsplat}.center.z = ${z2};`,
          !r2 ? null : `${outGsplat}.rgba.r = ${r2};`,
          !g2 ? null : `${outGsplat}.rgba.g = ${g2};`,
          !b22 ? null : `${outGsplat}.rgba.b = ${b22};`
        ].filter(Boolean);
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "gsplat");
  }
}
const defineGsplatNormal = unindent(`
  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {
    float minScale = min(scales.x, min(scales.y, scales.z));
    vec3 normal;
    if (scales.z == minScale) {
      normal = vec3(0.0, 0.0, 1.0);
    } else if (scales.y == minScale) {
      normal = vec3(0.0, 1.0, 0.0);
    } else {
      normal = vec3(1.0, 0.0, 0.0);
    }
    return quatVec(quaternion, normal);
  }
`);
class GsplatNormal extends UnaryOp {
  constructor({ gsplat }) {
    super({ a: gsplat, outKey: "normal", outTypeFunc: () => "vec3" });
    this.globals = () => [defineGsplat, defineGsplatNormal];
    this.statements = ({ inputs, outputs }) => [
      `${outputs.normal} = gsplatNormal(${inputs.a}.scales, ${inputs.a}.quaternion);`
    ];
  }
}
class TransformGsplat extends Dyno {
  constructor({
    gsplat,
    scale,
    rotate,
    translate,
    recolor
  }) {
    super({
      inTypes: {
        gsplat: Gsplat,
        scale: "float",
        rotate: "vec4",
        translate: "vec3",
        recolor: "vec4"
      },
      outTypes: { gsplat: Gsplat },
      inputs: { gsplat, scale, rotate, translate, recolor },
      globals: () => [defineGsplat],
      statements: ({ inputs, outputs, compile }) => {
        const { gsplat: gsplat2 } = outputs;
        if (!gsplat2 || !inputs.gsplat) {
          return [];
        }
        const { scale: scale2, rotate: rotate2, translate: translate2, recolor: recolor2 } = inputs;
        const indent = compile.indent;
        const statements = [
          `${gsplat2} = ${inputs.gsplat};`,
          `if (isGsplatActive(${gsplat2}.flags)) {`,
          scale2 ? `${indent}${gsplat2}.center *= ${scale2};` : null,
          rotate2 ? `${indent}${gsplat2}.center = quatVec(${rotate2}, ${gsplat2}.center);` : null,
          translate2 ? `${indent}${gsplat2}.center += ${translate2};` : null,
          scale2 ? `${indent}${gsplat2}.scales *= ${scale2};` : null,
          rotate2 ? `${indent}${gsplat2}.quaternion = quatQuat(${rotate2}, ${gsplat2}.quaternion);` : null,
          recolor2 ? `${indent}${gsplat2}.rgba *= ${recolor2};` : null,
          "}"
        ].filter(Boolean);
        return statements;
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "gsplat");
  }
}
const outputPackedSplat = (gsplat, rgbMinMaxLnScaleMinMax) => new OutputPackedSplat({ gsplat, rgbMinMaxLnScaleMinMax });
const outputExtendedSplat = (gsplat) => new OutputExtendedSplat({ gsplat });
const outputSplatDepth = (gsplat, viewCenter, viewDir, sortRadial) => new OutputSplatDepth({ gsplat, viewCenter, viewDir, sortRadial });
const outputRgba8 = (rgba8) => new OutputRgba8({ rgba8 });
class OutputPackedSplat extends Dyno {
  constructor({
    gsplat,
    rgbMinMaxLnScaleMinMax
  }) {
    super({
      inTypes: { gsplat: Gsplat, rgbMinMaxLnScaleMinMax: "vec4" },
      inputs: { gsplat, rgbMinMaxLnScaleMinMax },
      globals: () => [defineGsplat],
      statements: ({ inputs, outputs }) => {
        const { output } = outputs;
        if (!output) {
          return [];
        }
        const { gsplat: gsplat2, rgbMinMaxLnScaleMinMax: rgbMinMaxLnScaleMinMax2 } = inputs;
        if (gsplat2) {
          return unindentLines(`
            if (isGsplatActive(${gsplat2}.flags)) {
              ${output} = packSplatEncoding(${gsplat2}.center, ${gsplat2}.scales, ${gsplat2}.quaternion, ${gsplat2}.rgba, ${rgbMinMaxLnScaleMinMax2});
            } else {
              ${output} = uvec4(0u, 0u, 0u, 0u);
            }
          `);
        }
        return [`${output} = uvec4(0u, 0u, 0u, 0u);`];
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "output");
  }
}
class OutputExtendedSplat extends Dyno {
  constructor({
    gsplat
  }) {
    super({
      inTypes: { gsplat: Gsplat },
      inputs: { gsplat },
      globals: () => [defineGsplat],
      statements: ({ inputs }) => {
        const { gsplat: gsplat2 } = inputs;
        if (gsplat2) {
          return unindentLines(`
            if (isGsplatActive(${gsplat2}.flags)) {
              packSplatExt(target, target2, ${gsplat2}.center, ${gsplat2}.scales, ${gsplat2}.quaternion, ${gsplat2}.rgba);
            } else {
              target = uvec4(0u);
              target2 = uvec4(0u);
            }
          `);
        }
        return ["target = uvec4(0u);", "target2 = uvec4(0u);"];
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "output");
  }
}
class OutputSplatDepth extends Dyno {
  constructor({
    gsplat,
    viewCenter,
    viewDir,
    sortRadial
  }) {
    super({
      inTypes: {
        gsplat: Gsplat,
        viewCenter: "vec3",
        viewDir: "vec3",
        sortRadial: "bool"
      },
      inputs: { gsplat, viewCenter, viewDir, sortRadial },
      globals: () => [defineGsplat],
      statements: ({ inputs }) => {
        const { gsplat: gsplat2, viewCenter: viewCenter2, viewDir: viewDir2, sortRadial: sortRadial2 } = inputs;
        if (gsplat2 && viewCenter2 && viewDir2 && sortRadial2) {
          return unindentLines(`
            float metric = 1.0 / 0.0;
            if (isGsplatActive(${gsplat2}.flags)) {
              vec3 center = ${gsplat2}.center - ${viewCenter2};
              if (${sortRadial2}) {
                metric = length(center);
              } else {
                float bias = 100.0; // reduce popping
                metric = dot(center, ${viewDir2}) + bias;
              }
            }
            target3 = floatToVec4(metric);
          `);
        }
        return [];
      }
    });
  }
}
class OutputRgba8 extends Dyno {
  constructor({ rgba8 }) {
    super({
      inTypes: { rgba8: "vec4" },
      inputs: { rgba8 },
      statements: ({ inputs, outputs }) => [
        `target = ${inputs.rgba8 ?? "vec4(0.0, 0.0, 0.0, 0.0)"};`
      ]
    });
  }
  dynoOut() {
    return new DynoOutput(this, "rgba8");
  }
}
const uniform = (key, type, value) => new DynoUniform({ key, type, value });
const dynoBool = (value = false, key) => new DynoBool({ key, value });
const dynoUint = (value = 0, key) => new DynoUint({ key, value });
const dynoInt = (value = 0, key) => new DynoInt({ key, value });
const dynoFloat = (value = 0, key) => new DynoFloat({ key, value });
const dynoBvec2 = (value, key) => new DynoBvec2({ key, value });
const dynoUvec2 = (value, key) => new DynoUvec2({ key, value });
const dynoIvec2 = (value, key) => new DynoIvec2({ key, value });
const dynoVec2 = (value, key) => new DynoVec2({ key, value });
const dynoBvec3 = (value, key) => new DynoBvec3({ key, value });
const dynoUvec3 = (value, key) => new DynoUvec3({ key, value });
const dynoIvec3 = (value, key) => new DynoIvec3({ key, value });
const dynoVec3 = (value, key) => new DynoVec3({ key, value });
const dynoBvec4 = (value, key) => new DynoBvec4({ key, value });
const dynoUvec4 = (value, key) => new DynoUvec4({ key, value });
const dynoIvec4 = (value, key) => new DynoIvec4({ key, value });
const dynoVec4 = (value, key) => new DynoVec4({ key, value });
const dynoMat2 = (value, key) => new DynoMat2({ key, value });
const dynoMat2x2 = (value, key) => new DynoMat2x2({ key, value });
const dynoMat2x3 = (value, key) => new DynoMat2x3({ key, value });
const dynoMat2x4 = (value, key) => new DynoMat2x4({ key, value });
const dynoMat3 = (value, key) => new DynoMat3({ key, value });
const dynoMat3x2 = (value, key) => new DynoMat3x2({ key, value });
const dynoMat3x3 = (value, key) => new DynoMat3x3({ key, value });
const dynoMat3x4 = (value, key) => new DynoMat3x4({ key, value });
const dynoMat4 = (value, key) => new DynoMat4({ key, value });
const dynoMat4x2 = (value, key) => new DynoMat4x2({ key, value });
const dynoMat4x3 = (value, key) => new DynoMat4x3({ key, value });
const dynoMat4x4 = (value, key) => new DynoMat4x4({ key, value });
const dynoUsampler2D = (value, key) => new DynoUsampler2D({ key, value });
const dynoIsampler2D = (value, key) => new DynoIsampler2D({ key, value });
const dynoSampler2D = (value, key) => new DynoSampler2D({ key, value });
const dynoUsampler2DArray = (value, key) => new DynoUsampler2DArray({ key, value });
const dynoIsampler2DArray = (key, value) => new DynoIsampler2DArray({ key, value });
const dynoSampler2DArray = (value, key) => new DynoSampler2DArray({ key, value });
const dynoUsampler3D = (value, key) => new DynoUsampler3D({ key, value });
const dynoIsampler3D = (value, key) => new DynoIsampler3D({ key, value });
const dynoSampler3D = (value, key) => new DynoSampler3D({ key, value });
const dynoUsamplerCube = (value, key) => new DynoUsamplerCube({ key, value });
const dynoIsamplerCube = (value, key) => new DynoIsamplerCube({ key, value });
const dynoSamplerCube = (value, key) => new DynoSamplerCube({ key, value });
const dynoSampler2DShadow = (value, key) => new DynoSampler2DShadow({ key, value });
const dynoSampler2DArrayShadow = (value, key) => new DynoSampler2DArrayShadow({ key, value });
const dynoSamplerCubeShadow = (value, key) => new DynoSamplerCubeShadow({ key, value });
class DynoUniform extends Dyno {
  constructor({
    key,
    type,
    count,
    value,
    update,
    globals
  }) {
    key = key ?? "value";
    super({
      outTypes: { [key]: type },
      update: () => {
        if (update) {
          const value2 = update(this.value);
          if (value2 !== void 0) {
            this.value = value2;
          }
        }
        this.uniform.value = this.value;
      },
      generate: ({ inputs, outputs }) => {
        const allGlobals = (globals == null ? void 0 : globals({ inputs, outputs })) ?? [];
        const uniforms = {};
        const name = outputs[key];
        if (name) {
          allGlobals.push(`uniform ${dynoDeclare(name, type, count)};`);
          uniforms[name] = this.uniform;
        }
        return { globals: allGlobals, uniforms };
      }
    });
    this.type = type;
    this.count = count;
    this.value = value;
    this.uniform = { value };
    this.outKey = key;
  }
  dynoOut() {
    return new DynoOutput(this, this.outKey);
  }
}
class DynoBool extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "bool", value, update });
  }
}
class DynoUint extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "uint", value, update });
  }
}
class DynoInt extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "int", value, update });
  }
}
class DynoFloat extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "float", value, update });
  }
}
class DynoBvec2 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "bvec2", value, update });
  }
}
class DynoUvec2 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "uvec2", value, update });
  }
}
class DynoIvec2 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "ivec2", value, update });
  }
}
class DynoVec2 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "vec2", value, update });
  }
}
class DynoBvec3 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "bvec3", value, update });
  }
}
class DynoUvec3 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "uvec3", value, update });
  }
}
class DynoIvec3 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "ivec3", value, update });
  }
}
class DynoVec3 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "vec3", value, update });
  }
}
class DynoBvec4 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "bvec4", value, update });
  }
}
class DynoUvec4 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "uvec4", value, update });
  }
}
class DynoIvec4 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "ivec4", value, update });
  }
}
class DynoVec4 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "vec4", value, update });
  }
}
class DynoMat2 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat2", value, update });
  }
}
class DynoMat2x2 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat2x2", value, update });
  }
}
class DynoMat2x3 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat2x3", value, update });
  }
}
class DynoMat2x4 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat2x4", value, update });
  }
}
class DynoMat3 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat3", value, update });
  }
}
class DynoMat3x2 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat3x2", value, update });
  }
}
class DynoMat3x3 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat3x3", value, update });
  }
}
class DynoMat3x4 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat3x4", value, update });
  }
}
class DynoMat4 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat4", value, update });
  }
}
class DynoMat4x2 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat4x2", value, update });
  }
}
class DynoMat4x3 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat4x3", value, update });
  }
}
class DynoMat4x4 extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "mat4x4", value, update });
  }
}
class DynoUsampler2D extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "usampler2D", value, update });
  }
}
class DynoIsampler2D extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "isampler2D", value, update });
  }
}
class DynoSampler2D extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "sampler2D", value, update });
  }
}
class DynoUsampler2DArray extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "usampler2DArray", value, update });
  }
}
class DynoIsampler2DArray extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "isampler2DArray", value, update });
  }
}
class DynoSampler2DArray extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "sampler2DArray", value, update });
  }
}
class DynoUsampler3D extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "usampler3D", value, update });
  }
}
class DynoIsampler3D extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "isampler3D", value, update });
  }
}
class DynoSampler3D extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "sampler3D", value, update });
  }
}
class DynoUsamplerCube extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "usamplerCube", value, update });
  }
}
class DynoIsamplerCube extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "isamplerCube", value, update });
  }
}
class DynoSamplerCube extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "samplerCube", value, update });
  }
}
class DynoSampler2DShadow extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "sampler2DShadow", value, update });
  }
}
class DynoSampler2DArrayShadow extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "sampler2DArrayShadow", value, update });
  }
}
class DynoSamplerCubeShadow extends DynoUniform {
  constructor({
    key,
    value,
    update
  }) {
    super({ key, type: "samplerCubeShadow", value, update });
  }
}
class DynoProgram {
  constructor({
    graph,
    inputs,
    outputs,
    template
  }) {
    this.graph = graph;
    this.template = template;
    this.inputs = inputs ?? {};
    this.outputs = outputs ?? {};
    const compile = new Compilation({ indent: this.template.indent });
    for (const key in this.outputs) {
      if (this.outputs[key]) {
        compile.declares.add(this.outputs[key]);
      }
    }
    const statements = graph.compile({
      inputs: this.inputs,
      outputs: this.outputs,
      compile
    });
    this.shader = template.generate({ globals: compile.globals, statements });
    this.uniforms = compile.uniforms;
    this.updaters = compile.updaters;
  }
  prepareMaterial() {
    return getMaterial(this);
  }
  update() {
    for (const updater of this.updaters) {
      updater();
    }
  }
}
class DynoProgramTemplate {
  constructor(template) {
    const globals = template.match(/^([ \t]*)\{\{\s*GLOBALS\s*\}\}/m);
    const statements = template.match(/^([ \t]*)\{\{\s*STATEMENTS\s*\}\}/m);
    if (!globals || !statements) {
      throw new Error(
        "Template must contain {{ GLOBALS }} and {{ STATEMENTS }}"
      );
    }
    this.before = template.substring(0, globals.index);
    this.between = template.substring(
      globals.index + globals[0].length,
      statements.index
    );
    this.after = template.substring(
      statements.index + statements[0].length
    );
    this.indent = statements[1];
  }
  generate({
    globals,
    statements
  }) {
    return this.before + Array.from(globals).join("\n\n") + this.between + statements.map((s) => this.indent + s).join("\n") + this.after;
  }
}
const programMaterial = /* @__PURE__ */ new Map();
function getMaterial(program) {
  let material = programMaterial.get(program);
  if (material) {
    return material;
  }
  material = new THREE.RawShaderMaterial({
    glslVersion: THREE.GLSL3,
    vertexShader: IDENT_VERTEX_SHADER,
    fragmentShader: program.shader,
    uniforms: program.uniforms
  });
  programMaterial.set(program, material);
  return material;
}
function addOutputType(a, b, operation = "add") {
  const error = () => {
    throw new Error(`Invalid ${operation} types: ${a}, ${b}`);
  };
  if (a === b) return a;
  if (a === "int") {
    if (isIntType(b)) return b;
    error();
  }
  if (b === "int") {
    if (isIntType(a)) return a;
    error();
  }
  if (a === "uint") {
    if (isUintType(b)) return b;
    error();
  }
  if (b === "uint") {
    if (isUintType(a)) return a;
    error();
  }
  if (a === "float") {
    if (isAllFloatType(b)) return b;
    error();
  }
  if (b === "float") {
    if (isAllFloatType(a)) return a;
    error();
  }
  throw new Error(`Invalid ${operation} types: ${a}, ${b}`);
}
function subOutputType(a, b) {
  return addOutputType(a, b, "sub");
}
function mulOutputType(a, b) {
  const error = () => {
    throw new Error(`Invalid mul types: ${a}, ${b}`);
  };
  const result = (value) => value;
  if (a === "int") {
    if (isIntType(b)) return result(b);
    error();
  }
  if (b === "int") {
    if (isIntType(a)) return result(a);
    error();
  }
  if (a === "uint") {
    if (isUintType(b)) return result(b);
    error();
  }
  if (b === "uint") {
    if (isUintType(a)) return result(a);
    error();
  }
  if (a === "float") {
    if (isAllFloatType(b)) return result(b);
    error();
  }
  if (b === "float") {
    if (isAllFloatType(a)) return result(a);
    error();
  }
  if (isIntType(a) || isUintType(a) || isIntType(b) || isUintType(b)) {
    if (a === b) return result(a);
    error();
  }
  if (a === "vec2") {
    if (b === "vec2" || isMat2(b)) return result("vec2");
    if (b === "mat3x2") return result("vec3");
    if (b === "mat4x2") return result("vec4");
    error();
  }
  if (a === "vec3") {
    if (b === "mat2x3") return result("vec2");
    if (b === "vec3" || isMat3(b)) return result("vec3");
    if (b === "mat4x3") return result("vec4");
    error();
  }
  if (a === "vec4") {
    if (b === "mat2x4") return result("vec2");
    if (b === "mat3x4") return result("vec3");
    if (b === "vec4" || isMat4(b)) return result("vec4");
    error();
  }
  if (b === "vec2") {
    if (isMat2(a)) return result("vec2");
    if (a === "mat2x3") return result("vec3");
    if (a === "mat2x4") return result("vec4");
    error();
  }
  if (b === "vec3") {
    if (a === "mat3x2") return result("vec2");
    if (isMat3(a)) return result("vec3");
    if (a === "mat3x4") return result("vec4");
    error();
  }
  if (b === "vec4") {
    if (a === "mat4x2") return result("vec2");
    if (a === "mat4x3") return result("vec3");
    if (isMat4(a)) return result("vec4");
    error();
  }
  if (isMat2(a)) {
    if (isMat2(b)) return result("mat2");
    if (b === "mat3x2") return result("mat3x2");
    if (b === "mat4x2") return result("mat4x2");
    error();
  }
  if (a === "mat2x3") {
    if (isMat2(b)) return result("mat2x3");
    if (b === "mat3x2") return result("mat3");
    if (b === "mat4x2") return result("mat4x3");
    error();
  }
  if (a === "mat2x4") {
    if (isMat2(b)) return result("mat2x4");
    if (b === "mat3x2") return result("mat3x4");
    if (b === "mat4x2") return result("mat4");
    error();
  }
  if (a === "mat3x2") {
    if (b === "mat2x3") return result("mat2");
    if (isMat3(b)) return result("mat3x2");
    if (b === "mat4x3") return result("mat4x2");
    error();
  }
  if (isMat3(a)) {
    if (b === "mat2x3") return result("mat2x3");
    if (isMat3(b)) return result("mat3");
    if (b === "mat4x3") return result("mat4x3");
    error();
  }
  if (a === "mat3x4") {
    if (b === "mat2x3") return result("mat2x4");
    if (isMat3(b)) return result("mat3x4");
    if (b === "mat4x3") return result("mat4");
    error();
  }
  if (a === "mat4x2") {
    if (b === "mat2x4") return result("mat2");
    if (b === "mat3x4") return result("mat3x2");
    if (isMat4(b)) return result("mat4x2");
    error();
  }
  if (a === "mat4x3") {
    if (b === "mat2x4") return result("mat2x3");
    if (b === "mat3x4") return result("mat3");
    if (isMat4(b)) return result("mat4x3");
    error();
  }
  if (isMat4(a)) {
    if (b === "mat2x4") return result("mat2x4");
    if (b === "mat3x4") return result("mat3x4");
    if (isMat4(b)) return result("mat4");
    error();
  }
  throw new Error(`Invalid mul types: ${a}, ${b}`);
}
function divOutputType(a, b) {
  return addOutputType(a, b, "div");
}
function imodOutputType(a, b) {
  if (a === b) return a;
  if (a === "int") {
    if (isIntType(b)) return b;
  } else if (b === "int") {
    if (isIntType(a)) return a;
  } else if (a === "uint") {
    if (isUintType(b)) return b;
  } else if (b === "uint") {
    if (isUintType(a)) return a;
  }
  throw new Error(`Invalid imod types: ${a}, ${b}`);
}
function modOutputType(a, b) {
  if (a === b || b === "float") return a;
  throw new Error(`Invalid mod types: ${a}, ${b}`);
}
function modfOutputType(a) {
  return a;
}
function negOutputType(a) {
  return a;
}
function absOutputType(a) {
  return a;
}
function signOutputType(a) {
  return a;
}
function floorOutputType(a) {
  return a;
}
function ceilOutputType(a) {
  return a;
}
function truncOutputType(a) {
  return a;
}
function roundOutputType(a) {
  return a;
}
function fractOutputType(a) {
  return a;
}
function powOutputType(a) {
  return a;
}
function expOutputType(a) {
  return a;
}
function exp2OutputType(a) {
  return a;
}
function logOutputType(a) {
  return a;
}
function log2OutputType(a) {
  return a;
}
function sqrOutputType(a) {
  return a;
}
function sqrtOutputType(a) {
  return a;
}
function inversesqrtOutputType(a) {
  return a;
}
function minOutputType(a, b, operation = "min") {
  if (a === b) return a;
  if (b === "float") {
    if (isFloatType(a)) return a;
  } else if (b === "int") {
    if (isIntType(a)) return a;
  } else if (b === "uint") {
    if (isUintType(a)) return a;
  }
  throw new Error(`Invalid ${operation} types: ${a}, ${b}`);
}
function maxOutputType(a, b) {
  return minOutputType(a, b, "max");
}
function clampOutputType(a, b, _c) {
  if (b === "float") {
    if (isFloatType(a)) return a;
  } else if (b === "int") {
    if (isIntType(a)) return a;
  } else if (b === "uint") {
    if (isUintType(a)) return a;
  }
  throw new Error(`Invalid clamp types: ${a}, ${b}`);
}
function mixOutputType(a, b, c) {
  if (c === a) return a;
  if (c === "float") return a;
  if (c === "bool" && a === "float") return a;
  if (c === "bvec2" && a === "vec2") return a;
  if (c === "bvec3" && a === "vec3") return a;
  if (c === "bvec4" && a === "vec4") return a;
  throw new Error(`Invalid mix types: ${a}, ${b}, ${c}`);
}
function stepOutputType(a, b) {
  if (a === b || b === "float") return b;
  throw new Error(`Invalid step types: ${a}, ${b}`);
}
function smoothstepOutputType(a, b, c) {
  if (a === b) {
    if (a === c || a === "float") return c;
  }
  throw new Error(`Invalid smoothstep types: ${a}, ${b}, ${c}`);
}
function isNanOutputType(a, operation = "isNan") {
  if (a === "float") return "bool";
  if (a === "vec2") return "bvec2";
  if (a === "vec3") return "bvec3";
  if (a === "vec4") return "bvec4";
  throw new Error(`Invalid ${operation} types: ${a}`);
}
function isInfOutputType(a) {
  return isNanOutputType(a, "isInf");
}
const add = (a, b) => new Add({ a, b });
const sub = (a, b) => new Sub({ a, b });
const mul = (a, b) => new Mul({ a, b });
const div = (a, b) => new Div({ a, b });
const imod = (a, b) => new IMod({ a, b });
const mod = (a, b) => new Mod({ a, b });
const modf = (a) => new Modf({ a }).outputs;
const neg = (a) => new Neg({ a });
const abs = (a) => new Abs({ a });
const sign = (a) => new Sign({ a });
const floor = (a) => new Floor({ a });
const ceil = (a) => new Ceil({ a });
const trunc = (a) => new Trunc({ a });
const round = (a) => new Round({ a });
const fract = (a) => new Fract({ a });
const pow = (a, b) => new Pow({ a, b });
const exp = (a) => new Exp({ a });
const exp2 = (a) => new Exp2({ a });
const log = (a) => new Log({ a });
const log2 = (a) => new Log2({ a });
const sqr = (a) => new Sqr({ a });
const sqrt = (a) => new Sqrt({ a });
const inversesqrt = (a) => new InverseSqrt({ a });
const min = (a, b) => new Min({ a, b });
const max = (a, b) => new Max({ a, b });
const clamp = (a, min2, max2) => new Clamp({ a, min: min2, max: max2 });
const mix = (a, b, t) => new Mix({ a, b, t });
const step = (edge, x) => new Step({ edge, x });
const smoothstep = (edge0, edge1, x) => new Smoothstep({ edge0, edge1, x });
const isNan = (a) => new IsNan({ a });
const isInf = (a) => new IsInf({ a });
class Add extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "sum", outTypeFunc: addOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.sum} = ${inputs.a} + ${inputs.b};`];
    };
  }
}
class Sub extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "difference", outTypeFunc: subOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.difference} = ${inputs.a} - ${inputs.b};`];
    };
  }
}
class Mul extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "product", outTypeFunc: mulOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.product} = ${inputs.a} * ${inputs.b};`];
    };
  }
}
class Div extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "quotient", outTypeFunc: divOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.quotient} = ${inputs.a} / ${inputs.b};`];
    };
  }
}
class IMod extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "remainder", outTypeFunc: imodOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.remainder} = ${inputs.a} % ${inputs.b};`];
    };
  }
}
class Mod extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "remainder", outTypeFunc: modOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.remainder} = mod(${inputs.a}, ${inputs.b});`];
    };
  }
}
class Modf extends Dyno {
  constructor({ a }) {
    const inTypes = { a: valType(a) };
    const outType = modfOutputType(inTypes.a);
    const outTypes = {
      fract: outType,
      integer: outType
    };
    super({ inTypes, outTypes, inputs: { a } });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.fract} = modf(${inputs.a}, ${outputs.integer});`];
    };
  }
}
class Neg extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "neg", outTypeFunc: negOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.neg} = -${inputs.a};`];
    };
  }
}
class Abs extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "abs", outTypeFunc: absOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.abs} = abs(${inputs.a});`];
    };
  }
}
class Sign extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "sign", outTypeFunc: signOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.sign} = sign(${inputs.a});`];
    };
  }
}
class Floor extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "floor", outTypeFunc: floorOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.floor} = floor(${inputs.a});`];
    };
  }
}
class Ceil extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "ceil", outTypeFunc: ceilOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.ceil} = ceil(${inputs.a});`];
    };
  }
}
class Trunc extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "trunc", outTypeFunc: truncOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.trunc} = trunc(${inputs.a});`];
    };
  }
}
class Round extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "round", outTypeFunc: roundOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.round} = round(${inputs.a});`];
    };
  }
}
class Fract extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "fract", outTypeFunc: fractOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.fract} = fract(${inputs.a});`];
    };
  }
}
class Pow extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "power", outTypeFunc: powOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.power} = pow(${inputs.a}, ${inputs.b});`];
    };
  }
}
class Exp extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "exp", outTypeFunc: expOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.exp} = exp(${inputs.a});`];
    };
  }
}
class Exp2 extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "exp2", outTypeFunc: exp2OutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.exp2} = exp2(${inputs.a});`];
    };
  }
}
class Log extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "log", outTypeFunc: logOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.log} = log(${inputs.a});`];
    };
  }
}
class Log2 extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "log2", outTypeFunc: log2OutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.log2} = log2(${inputs.a});`];
    };
  }
}
class Sqr extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "sqr", outTypeFunc: sqrOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.sqr} = ${inputs.a} * ${inputs.a};`];
    };
  }
}
class Sqrt extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "sqrt", outTypeFunc: sqrtOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.sqrt} = sqrt(${inputs.a});`];
    };
  }
}
class InverseSqrt extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "inversesqrt", outTypeFunc: inversesqrtOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.inversesqrt} = inversesqrt(${inputs.a});`];
    };
  }
}
class Min extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "min", outTypeFunc: minOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.min} = min(${inputs.a}, ${inputs.b});`];
    };
  }
}
class Max extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "max", outTypeFunc: maxOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.max} = max(${inputs.a}, ${inputs.b});`];
    };
  }
}
class Clamp extends TrinaryOp {
  constructor({
    a,
    min: min2,
    max: max2
  }) {
    super({
      a,
      b: min2,
      c: max2,
      outKey: "clamp",
      outTypeFunc: clampOutputType
    });
    this.statements = ({ inputs, outputs }) => {
      const { a: a2, b: min3, c: max3 } = inputs;
      return [`${outputs.clamp} = clamp(${a2}, ${min3}, ${max3});`];
    };
  }
}
class Mix extends TrinaryOp {
  constructor({ a, b, t }) {
    super({ a, b, c: t, outKey: "mix", outTypeFunc: mixOutputType });
    this.statements = ({ inputs, outputs }) => {
      const { a: a2, b: b22, c: t2 } = inputs;
      return [`${outputs.mix} = mix(${a2}, ${b22}, ${t2});`];
    };
  }
}
class Step extends BinaryOp {
  constructor({ edge, x }) {
    super({
      a: edge,
      b: x,
      outKey: "step",
      outTypeFunc: stepOutputType
    });
    this.statements = ({ inputs, outputs }) => {
      const { a: edge2, b: x2 } = inputs;
      return [`${outputs.step} = step(${edge2}, ${x2});`];
    };
  }
}
class Smoothstep extends TrinaryOp {
  constructor({
    edge0,
    edge1,
    x
  }) {
    super({
      a: edge0,
      b: edge1,
      c: x,
      outKey: "smoothstep",
      outTypeFunc: smoothstepOutputType
    });
    this.statements = ({ inputs, outputs }) => {
      const { a: edge02, b: edge12, c: x2 } = inputs;
      return [`${outputs.smoothstep} = smoothstep(${edge02}, ${edge12}, ${x2});`];
    };
  }
}
class IsNan extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "isNan", outTypeFunc: isNanOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.isNan} = isNan(${inputs.a});`];
    };
  }
}
class IsInf extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "isInf", outTypeFunc: isInfOutputType });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.isInf} = isInf(${inputs.a});`];
    };
  }
}
const and = (a, b) => new And({ a, b });
const or = (a, b) => new Or({ a, b });
const xor = (a, b) => new Xor({ a, b });
const not = (a) => new Not({ a });
const lessThan = (a, b) => new LessThan({ a, b });
const lessThanEqual = (a, b) => new LessThanEqual({ a, b });
const greaterThan = (a, b) => new GreaterThan({ a, b });
const greaterThanEqual = (a, b) => new GreaterThanEqual({ a, b });
const equal = (a, b) => new Equal({ a, b });
const notEqual = (a, b) => new NotEqual({ a, b });
const any = (a) => new Any({ a });
const all = (a) => new All({ a });
const select = (cond, t, f) => new Select({ cond, t, f });
const compXor = (a) => new CompXor({ a });
class And extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outTypeFunc: (aType, bType) => aType, outKey: "and" });
    this.statements = ({ inputs, outputs }) => {
      if (this.outTypes.and === "bool") {
        return [`${outputs.and} = ${inputs.a} && ${inputs.b};`];
      }
      return [`${outputs.and} = ${inputs.a} & ${inputs.b};`];
    };
  }
}
class Or extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outTypeFunc: (aType, bType) => aType, outKey: "or" });
    this.statements = ({ inputs, outputs }) => {
      if (this.outTypes.or === "bool") {
        return [`${outputs.or} = ${inputs.a} || ${inputs.b};`];
      }
      return [`${outputs.or} = ${inputs.a} | ${inputs.b};`];
    };
  }
}
class Xor extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outTypeFunc: (aType, bType) => aType, outKey: "xor" });
    this.statements = ({ inputs, outputs }) => {
      if (this.outTypes.xor === "bool") {
        return [`${outputs.xor} = ${inputs.a} ^^ ${inputs.b};`];
      }
      return [`${outputs.xor} = ${inputs.a} ^ ${inputs.b};`];
    };
  }
}
class Not extends UnaryOp {
  constructor({ a }) {
    super({ a, outTypeFunc: (aType) => aType, outKey: "not" });
    this.statements = ({ inputs, outputs }) => {
      if (this.outTypes.not === "bool") {
        return [`${outputs.not} = !${inputs.a};`];
      }
      return [`${outputs.not} = not(${inputs.a});`];
    };
  }
}
class LessThan extends BinaryOp {
  constructor({ a, b }) {
    super({
      a,
      b,
      outTypeFunc: (aType, bType) => compareOutputType(aType, "lessThan"),
      outKey: "lessThan"
    });
    this.statements = ({ inputs, outputs }) => {
      if (this.outTypes.lessThan === "bool") {
        return [`${outputs.lessThan} = ${inputs.a} < ${inputs.b};`];
      }
      return [`${outputs.lessThan} = lessThan(${inputs.a}, ${inputs.b});`];
    };
  }
}
class LessThanEqual extends BinaryOp {
  constructor({ a, b }) {
    super({
      a,
      b,
      outTypeFunc: (aType, bType) => compareOutputType(aType, "lessThanEqual"),
      outKey: "lessThanEqual"
    });
    this.statements = ({ inputs, outputs }) => {
      if (this.outTypes.lessThanEqual === "bool") {
        return [`${outputs.lessThanEqual} = ${inputs.a} <= ${inputs.b};`];
      }
      return [
        `${outputs.lessThanEqual} = lessThanEqual(${inputs.a}, ${inputs.b});`
      ];
    };
  }
}
class GreaterThan extends BinaryOp {
  constructor({ a, b }) {
    super({
      a,
      b,
      outTypeFunc: (aType, bType) => compareOutputType(aType, "greaterThan"),
      outKey: "greaterThan"
    });
    this.statements = ({ inputs, outputs }) => {
      if (this.outTypes.greaterThan === "bool") {
        return [`${outputs.greaterThan} = ${inputs.a} > ${inputs.b};`];
      }
      return [
        `${outputs.greaterThan} = greaterThan(${inputs.a}, ${inputs.b});`
      ];
    };
  }
}
class GreaterThanEqual extends BinaryOp {
  constructor({ a, b }) {
    super({
      a,
      b,
      outTypeFunc: (aType, bType) => compareOutputType(aType, "greaterThanEqual"),
      outKey: "greaterThanEqual"
    });
    this.statements = ({ inputs, outputs }) => {
      if (this.outTypes.greaterThanEqual === "bool") {
        return [`${outputs.greaterThanEqual} = ${inputs.a} >= ${inputs.b};`];
      }
      return [
        `${outputs.greaterThanEqual} = greaterThanEqual(${inputs.a}, ${inputs.b});`
      ];
    };
  }
}
class Equal extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outTypeFunc: equalOutputType, outKey: "equal" });
    this.statements = ({ inputs, outputs }) => {
      if (this.outTypes.equal === "bool") {
        return [`${outputs.equal} = ${inputs.a} == ${inputs.b};`];
      }
      return [`${outputs.equal} = equal(${inputs.a}, ${inputs.b});`];
    };
  }
}
class NotEqual extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outTypeFunc: notEqualOutputType, outKey: "notEqual" });
    this.statements = ({ inputs, outputs }) => {
      if (this.outTypes.notEqual === "bool") {
        return [`${outputs.notEqual} = ${inputs.a} != ${inputs.b};`];
      }
      return [`${outputs.notEqual} = notEqual(${inputs.a}, ${inputs.b});`];
    };
  }
}
class Any extends UnaryOp {
  constructor({ a }) {
    super({ a, outTypeFunc: (aType) => "bool", outKey: "any" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.any} = any(${inputs.a});`];
    };
  }
}
class All extends UnaryOp {
  constructor({ a }) {
    super({ a, outTypeFunc: (aType) => "bool", outKey: "all" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.all} = all(${inputs.a});`];
    };
  }
}
class Select extends TrinaryOp {
  constructor({
    cond,
    t,
    f
  }) {
    super({
      a: cond,
      b: t,
      c: f,
      outKey: "select",
      outTypeFunc: (aType, bType, cType) => bType
    });
    this.statements = ({ inputs, outputs }) => {
      const { a: cond2, b: t2, c: f2 } = inputs;
      return [`${outputs.select} = (${cond2}) ? (${t2}) : (${f2});`];
    };
  }
}
function compareOutputType(type, operator) {
  if (isScalarType(type)) {
    return "bool";
  }
  if (type === "ivec2" || type === "uvec2" || type === "vec2") {
    return "bvec2";
  }
  if (type === "ivec3" || type === "uvec3" || type === "vec3") {
    return "bvec3";
  }
  if (type === "ivec4" || type === "uvec4" || type === "vec4") {
    return "bvec4";
  }
  throw new Error(`Invalid ${operator} type: ${type}`);
}
function equalOutputType(type, operator = "equal") {
  if (isScalarType(type)) {
    return "bool";
  }
  if (isBoolType(type)) {
    return type;
  }
  if (type === "ivec2" || type === "uvec2" || type === "vec2") {
    return "bvec2";
  }
  if (type === "ivec3" || type === "uvec3" || type === "vec3") {
    return "bvec3";
  }
  if (type === "ivec4" || type === "uvec4" || type === "vec4") {
    return "bvec4";
  }
  throw new Error(`Invalid ${operator} type: ${type}`);
}
function notEqualOutputType(type) {
  return equalOutputType(type, "notEqual");
}
function compXorOutputType(type) {
  if (isBoolType(type)) {
    return "bool";
  }
  if (isIntType(type)) {
    return "int";
  }
  if (isUintType(type)) {
    return "uint";
  }
  throw new Error(`Invalid compXor type: ${type}`);
}
class CompXor extends UnaryOp {
  constructor({ a }) {
    const outType = compXorOutputType(valType(a));
    super({ a, outTypeFunc: (aType) => outType, outKey: "compXor" });
    this.statements = ({ inputs, outputs }) => {
      if (isScalarType(this.outTypes.compXor)) {
        return [`${outputs.compXor} = ${inputs.a};`];
      }
      const components = isVector2Type(outType) ? ["x", "y"] : isVector3Type(outType) ? ["x", "y", "z"] : ["x", "y", "z", "w"];
      const operands = components.map((c) => `${inputs.a}.${c}`);
      const operator = isBoolType(outType) ? "^^" : "^";
      return [`${outputs.compXor} = ${operands.join(` ${operator} `)};`];
    };
  }
}
const bool = (value) => new Bool({ value });
const int = (value) => new Int({ value });
const uint = (value) => new Uint({ value });
const float = (value) => new Float({ value });
const bvec2 = (value) => new BVec2({ value });
const bvec3 = (value) => new BVec3({ value });
const bvec4 = (value) => new BVec4({ value });
const ivec2 = (value) => new IVec2({ value });
const ivec3 = (value) => new IVec3({ value });
const ivec4 = (value) => new IVec4({ value });
const uvec2 = (value) => new UVec2({ value });
const uvec3 = (value) => new UVec3({ value });
const uvec4 = (value) => new UVec4({ value });
const vec2 = (value) => new Vec2({ value });
const vec3 = (value) => new Vec3({ value });
const vec4 = (value) => new Vec4({ value });
const mat2 = (value) => new Mat2({ value });
const mat3 = (value) => new Mat3({ value });
const mat4 = (value) => new Mat4({ value });
const floatBitsToInt = (value) => new FloatBitsToInt({ value });
const floatBitsToUint = (value) => new FloatBitsToUint({ value });
const intBitsToFloat = (value) => new IntBitsToFloat({ value });
const uintBitsToFloat = (value) => new UintBitsToFloat({ value });
const packSnorm2x16 = (value) => new PackSnorm2x16({ value });
const unpackSnorm2x16 = (value) => new UnpackSnorm2x16({ value });
const packUnorm2x16 = (value) => new PackUnorm2x16({ value });
const unpackUnorm2x16 = (value) => new UnpackUnorm2x16({ value });
const packHalf2x16 = (value) => new PackHalf2x16({ value });
const unpackHalf2x16 = (value) => new UnpackHalf2x16({ value });
const uintToRgba8 = (value) => new UintToRgba8({ value });
class SimpleCast extends UnaryOp {
  constructor({
    value,
    outType,
    outKey
  }) {
    super({ a: value, outTypeFunc: () => outType, outKey });
    this.statements = ({ inputs, outputs }) => [
      `${outputs[outKey]} = ${typeLiteral(outType)}(${inputs.a});`
    ];
  }
}
class Bool extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "bool", outKey: "bool" });
  }
}
class Int extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "int", outKey: "int" });
  }
}
class Uint extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "uint", outKey: "uint" });
  }
}
class Float extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "float", outKey: "float" });
  }
}
class BVec2 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "bvec2", outKey: "bvec2" });
  }
}
class BVec3 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "bvec3", outKey: "bvec3" });
  }
}
class BVec4 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "bvec4", outKey: "bvec4" });
  }
}
class IVec2 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "ivec2", outKey: "ivec2" });
  }
}
class IVec3 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "ivec3", outKey: "ivec3" });
  }
}
class IVec4 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "ivec4", outKey: "ivec4" });
  }
}
class UVec2 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "uvec2", outKey: "uvec2" });
  }
}
class UVec3 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "uvec3", outKey: "uvec3" });
  }
}
class UVec4 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "uvec4", outKey: "uvec4" });
  }
}
class Vec2 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "vec2", outKey: "vec2" });
  }
}
class Vec3 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "vec3", outKey: "vec3" });
  }
}
class Vec4 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "vec4", outKey: "vec4" });
  }
}
class Mat2 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "mat2", outKey: "mat2" });
  }
}
class Mat3 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "mat3", outKey: "mat3" });
  }
}
class Mat4 extends SimpleCast {
  constructor({
    value
  }) {
    super({ value, outType: "mat4", outKey: "mat4" });
  }
}
class FloatBitsToInt extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "int", outTypeFunc: () => "int" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.int} = floatBitsToInt(${inputs.a});`];
    };
  }
}
class FloatBitsToUint extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "uint", outTypeFunc: () => "uint" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.uint} = floatBitsToUint(${inputs.a});`];
    };
  }
}
class IntBitsToFloat extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "float", outTypeFunc: () => "float" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.float} = intBitsToFloat(${inputs.a});`];
    };
  }
}
class UintBitsToFloat extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "float", outTypeFunc: () => "float" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.float} = uintBitsToFloat(${inputs.a});`];
    };
  }
}
class PackSnorm2x16 extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "uint", outTypeFunc: () => "uint" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.uint} = packSnorm2x16(${inputs.a});`];
    };
  }
}
class UnpackSnorm2x16 extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "vec2", outTypeFunc: () => "vec2" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.vec2} = unpackSnorm2x16(${inputs.a});`];
    };
  }
}
class PackUnorm2x16 extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "uint", outTypeFunc: () => "uint" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.uint} = packUnorm2x16(${inputs.a});`];
    };
  }
}
class UnpackUnorm2x16 extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "vec2", outTypeFunc: () => "vec2" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.vec2} = unpackUnorm2x16(${inputs.a});`];
    };
  }
}
class PackHalf2x16 extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "uint", outTypeFunc: () => "uint" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.uint} = packHalf2x16(${inputs.a});`];
    };
  }
}
class UnpackHalf2x16 extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "vec2", outTypeFunc: () => "vec2" });
    this.statements = ({ inputs, outputs }) => {
      return [`${outputs.vec2} = unpackHalf2x16(${inputs.a});`];
    };
  }
}
class UintToRgba8 extends UnaryOp {
  constructor({ value }) {
    super({ a: value, outKey: "rgba8", outTypeFunc: () => "vec4" });
    this.statements = ({ inputs, outputs }) => {
      return [
        `uvec4 uRgba = uvec4(${inputs.a} & 0xffu, (${inputs.a} >> 8u) & 0xffu, (${inputs.a} >> 16u) & 0xffu, (${inputs.a} >> 24u) & 0xffu);`,
        `${outputs.rgba8} = vec4(uRgba) / 255.0;`
      ];
    };
  }
}
const length = (a) => new Length({ a });
const distance = (a, b) => new Distance({ a, b });
const dot = (a, b) => new Dot({ a, b });
const cross = (a, b) => new Cross({ a, b });
const normalize = (a) => new Normalize({ a });
const faceforward = (a, b, c) => new FaceForward({ a, b, c });
const reflectVec = (incident, normal) => new ReflectVec({ incident, normal });
const refractVec = (incident, normal, eta) => new RefractVec({ incident, normal, eta });
const split = (vector) => new Split({ vector });
const combine = ({
  vector,
  vectorType,
  x,
  y,
  z,
  w,
  r,
  g,
  b,
  a
}) => new Combine({ vector, vectorType, x, y, z, w, r, g, b, a });
const projectH = (a) => new ProjectH({ a });
const extendVec = (a, b) => new ExtendVec({ a, b });
const swizzle = (a, select2) => new Swizzle({ vector: a, select: select2 });
const compMult = (a, b) => new CompMult({ a, b });
const outer = (a, b) => new Outer({ a, b });
const transpose = (a) => new Transpose({ a });
const determinant = (a) => new Determinant({ a });
const inverse = (a) => new Inverse({ a });
class Length extends UnaryOp {
  constructor({ a }) {
    super({ a, outTypeFunc: (aType) => "float", outKey: "length" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.length} = length(${inputs.a});`
    ];
  }
}
class Distance extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "distance", outTypeFunc: (aType, bType) => "float" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.distance} = distance(${inputs.a}, ${inputs.b});`
    ];
  }
}
class Dot extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "dot", outTypeFunc: (aType, bType) => "float" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.dot} = dot(${inputs.a}, ${inputs.b});`
    ];
  }
}
class Cross extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "cross", outTypeFunc: (aType, bType) => "vec3" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.cross} = cross(${inputs.a}, ${inputs.b});`
    ];
  }
}
class Normalize extends UnaryOp {
  constructor({ a }) {
    super({ a, outTypeFunc: (aType) => aType, outKey: "normalize" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.normalize} = normalize(${inputs.a});`
    ];
  }
}
function projectHOutputType(type) {
  if (type === "vec3") {
    return "vec2";
  }
  if (type === "vec4") {
    return "vec3";
  }
  throw new Error("Invalid type");
}
class ProjectH extends UnaryOp {
  constructor({ a }) {
    super({
      a,
      outTypeFunc: (aType) => projectHOutputType(aType),
      outKey: "projected"
    });
    this.statements = ({ inputs, outputs }) => {
      if (this.inTypes.a === "vec3") {
        return [`${outputs.projected} = ${inputs.a}.xy / ${inputs.a}.z;`];
      }
      if (this.inTypes.a === "vec4") {
        return [`${outputs.projected} = ${inputs.a}.xyz / ${inputs.a}.w;`];
      }
      throw new Error("Invalid type");
    };
  }
}
function extendVecOutputType(type) {
  if (type === "float") return "vec2";
  if (type === "vec2") return "vec3";
  if (type === "vec3") return "vec4";
  throw new Error("Invalid type");
}
class ExtendVec extends BinaryOp {
  constructor({ a, b }) {
    const type = valType(a);
    const outType = extendVecOutputType(type);
    super({ a, b, outKey: "extend", outTypeFunc: () => outType });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.extend} = ${outType}(${inputs.a}, ${inputs.b});`
    ];
  }
}
class FaceForward extends TrinaryOp {
  constructor({ a, b, c }) {
    super({
      a,
      b,
      c,
      outKey: "forward",
      outTypeFunc: (aType, bType, cType) => aType
    });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.forward} = faceforward(${inputs.a}, ${inputs.b}, ${inputs.c});`
    ];
  }
}
class ReflectVec extends BinaryOp {
  constructor({
    incident,
    normal
  }) {
    super({
      a: incident,
      b: normal,
      outKey: "reflection",
      outTypeFunc: (aType, bType) => aType
    });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.reflection} = reflect(${inputs.a}, ${inputs.b});`
    ];
  }
}
class RefractVec extends TrinaryOp {
  constructor({
    incident,
    normal,
    eta
  }) {
    super({
      a: incident,
      b: normal,
      c: eta,
      outKey: "refraction",
      outTypeFunc: (aType, bType, cType) => aType
    });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.refraction} = refract(${inputs.a}, ${inputs.b}, ${inputs.c});`
    ];
  }
}
class CompMult extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "product", outTypeFunc: (aType, bType) => aType });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.product} = matrixCompMult(${a}, ${b});`
    ];
  }
}
function outerOutputType(aType, bType) {
  if (aType === "vec2") {
    if (bType === "vec2") return "mat2";
    if (bType === "vec3") return "mat3x2";
    if (bType === "vec4") return "mat4x2";
  }
  if (aType === "vec3") {
    if (bType === "vec2") return "mat2x3";
    if (bType === "vec3") return "mat3";
    if (bType === "vec4") return "mat4x3";
  }
  if (aType === "vec4") {
    if (bType === "vec2") return "mat2x4";
    if (bType === "vec3") return "mat3x4";
    if (bType === "vec4") return "mat4";
  }
  throw new Error(`Invalid outer type: ${aType}, ${bType}`);
}
class Outer extends BinaryOp {
  constructor({ a, b }) {
    super({ a, b, outKey: "outer", outTypeFunc: outerOutputType });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.outer} = outerProduct(${inputs.a}, ${inputs.b});`
    ];
  }
}
function transposeOutputType(type) {
  if (type === "mat2") return "mat2";
  if (type === "mat3") return "mat3";
  if (type === "mat4") return "mat4";
  if (type === "mat2x2") return "mat2x2";
  if (type === "mat2x3") return "mat3x2";
  if (type === "mat2x4") return "mat4x2";
  if (type === "mat3x2") return "mat2x3";
  if (type === "mat3x3") return "mat3x3";
  if (type === "mat3x4") return "mat4x3";
  if (type === "mat4x2") return "mat2x4";
  if (type === "mat4x3") return "mat3x4";
  if (type === "mat4x4") return "mat4x4";
  throw new Error(`Invalid transpose type: ${type}`);
}
class Transpose extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "transpose", outTypeFunc: transposeOutputType });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.transpose} = transpose(${inputs.a});`
    ];
  }
}
class Determinant extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "det", outTypeFunc: (aType) => "float" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.det} = determinant(${inputs.a});`
    ];
  }
}
class Inverse extends UnaryOp {
  constructor({ a }) {
    super({ a, outKey: "inverse", outTypeFunc: (aType) => aType });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.inverse} = inverse(${a});`
    ];
  }
}
function splitOutTypes(type) {
  const result = (value) => value;
  switch (type) {
    case "vec2":
      return result({ x: "float", y: "float", r: "float", g: "float" });
    case "vec3":
      return result({
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      });
    case "vec4":
      return result({
        x: "float",
        y: "float",
        z: "float",
        w: "float",
        r: "float",
        g: "float",
        b: "float",
        a: "float"
      });
    case "ivec2":
      return result({ x: "int", y: "int", r: "int", g: "int" });
    case "ivec3":
      return result({
        x: "int",
        y: "int",
        z: "int",
        r: "int",
        g: "int",
        b: "int"
      });
    case "ivec4":
      return result({
        x: "int",
        y: "int",
        z: "int",
        w: "int",
        r: "int",
        g: "int",
        b: "int",
        a: "int"
      });
    case "uvec2":
      return result({ x: "uint", y: "uint", r: "uint", g: "uint" });
    case "uvec3":
      return result({
        x: "uint",
        y: "uint",
        z: "uint",
        r: "uint",
        g: "uint",
        b: "uint"
      });
    case "uvec4":
      return result({
        x: "uint",
        y: "uint",
        z: "uint",
        w: "uint",
        r: "uint",
        g: "uint",
        b: "uint",
        a: "uint"
      });
    default:
      throw new Error(`Invalid vector type: ${type}`);
  }
}
class Split extends Dyno {
  constructor({ vector }) {
    const type = valType(vector);
    const inTypes = { vector: type };
    const outTypes = splitOutTypes(inTypes.vector);
    super({ inTypes, outTypes, inputs: { vector } });
    this.statements = ({ inputs, outputs }) => {
      const { x, y, z, w, r, g, b, a } = outputs;
      const { vector: vector2 } = inputs;
      return [
        x ? `${x} = ${vector2}.x;` : null,
        y ? `${y} = ${vector2}.y;` : null,
        z ? `${z} = ${vector2}.z;` : null,
        w ? `${w} = ${vector2}.w;` : null,
        r ? `${r} = ${vector2}.r;` : null,
        g ? `${g} = ${vector2}.g;` : null,
        b ? `${b} = ${vector2}.b;` : null,
        a ? `${a} = ${vector2}.a;` : null
      ].filter(Boolean);
    };
  }
}
class Combine extends Dyno {
  constructor({
    vector,
    vectorType,
    x,
    y,
    z,
    w,
    r,
    g,
    b,
    a
  }) {
    if (!vector && !vectorType) {
      throw new Error("Either vector or vectorType must be provided");
    }
    const vType = vectorType ?? valType(vector);
    const elType = vectorElementType(vType);
    const dim = vectorDim(vType);
    const inTypes = {
      vector: vType,
      x: elType,
      y: elType,
      r: elType,
      g: elType
    };
    const inputs = { vector, x, y, r, g };
    if (dim >= 3) {
      Object.assign(inTypes, { z: elType, b: elType });
      Object.assign(inputs, { z, b });
    }
    if (dim >= 4) {
      Object.assign(inTypes, { w: elType, a: elType });
      Object.assign(inputs, { w, a });
    }
    super({ inTypes, outTypes: { vector: vType }, inputs });
    this.statements = ({ inputs: inputs2, outputs }) => {
      const { vector: vector2 } = outputs;
      const {
        vector: input,
        x: x2,
        y: y2,
        z: z2,
        w: w2,
        r: r2,
        g: g2,
        b: b22,
        a: a2
      } = inputs2;
      const statements = [
        `${vector2}.x = ${x2 ?? r2 ?? (input ? `${input}.x` : literalZero(elType))};`,
        `${vector2}.y = ${y2 ?? g2 ?? (input ? `${input}.y` : literalZero(elType))};`
      ];
      if (dim >= 3)
        statements.push(
          `${vector2}.z = ${z2 ?? b22 ?? (input ? `${input}.z` : literalZero(elType))};`
        );
      if (dim >= 4)
        statements.push(
          `${vector2}.w = ${w2 ?? a2 ?? (input ? `${input}.w` : literalZero(elType))};`
        );
      return statements;
    };
  }
  dynoOut() {
    return new DynoOutput(
      this,
      "vector"
    );
  }
}
function swizzleOutputType(type, swizzle2) {
  let result = null;
  if (isFloatType(type)) {
    result = swizzle2.length === 1 ? "float" : swizzle2.length === 2 ? "vec2" : swizzle2.length === 3 ? "vec3" : swizzle2.length === 4 ? "vec4" : null;
  } else if (isIntType(type)) {
    result = swizzle2.length === 1 ? "int" : swizzle2.length === 2 ? "ivec2" : swizzle2.length === 3 ? "ivec3" : swizzle2.length === 4 ? "ivec4" : null;
  } else if (isUintType(type)) {
    result = swizzle2.length === 1 ? "uint" : swizzle2.length === 2 ? "uvec2" : swizzle2.length === 3 ? "uvec3" : swizzle2.length === 4 ? "uvec4" : null;
  }
  if (result == null) {
    throw new Error(`Invalid swizzle: ${swizzle2}`);
  }
  return result;
}
class Swizzle extends UnaryOp {
  constructor({ vector, select: select2 }) {
    super({
      a: vector,
      outKey: "swizzle",
      outTypeFunc: (aType) => swizzleOutputType(aType, select2)
    });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.swizzle} = ${inputs.a}.${select2};`
    ];
  }
}
const remapIndex = (index, from, to) => {
  return new DynoRemapIndex({ index, from, to });
};
const pcgMix = (value) => {
  return new PcgMix({ value });
};
const pcgNext = (state) => {
  return new PcgNext({ state });
};
const pcgHash = (state) => {
  return new PcgHash({ state });
};
const hash = (value) => {
  return new Hash({ value });
};
const hash2 = (value) => {
  return new Hash2({ value });
};
const hash3 = (value) => {
  return new Hash3({ value });
};
const hash4 = (value) => {
  return new Hash4({ value });
};
const hashFloat = (value) => {
  return new HashFloat({ value });
};
const hashVec2 = (value) => {
  return new HashVec2({ value });
};
const hashVec3 = (value) => {
  return new HashVec3({ value });
};
const hashVec4 = (value) => {
  return new HashVec4({ value });
};
const normalizedDepth = (z, zNear, zFar) => {
  return new NormalizedDepth({ z, zNear, zFar }).outputs.depth;
};
class DynoRemapIndex extends Dyno {
  constructor({
    from,
    to,
    index
  }) {
    super({
      inTypes: { from: "int", to: "int", index: "int" },
      outTypes: { index: "int" },
      inputs: { from, to, index },
      statements: ({ inputs, outputs }) => {
        return [
          `${outputs.index} = ${inputs.index} - ${inputs.from} + ${inputs.to};`
        ];
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "index");
  }
}
class PcgNext extends Dyno {
  constructor({ state }) {
    const type = valType(state);
    super({
      inTypes: { state: type },
      outTypes: { state: "uint" },
      inputs: { state },
      globals: () => [
        unindent(`
          uint pcg_next(uint state) {
            return state * 747796405u + 2891336453u;
          }
        `)
      ],
      statements: ({ inputs, outputs }) => {
        const toUint = type === "uint" ? `${inputs.state}` : type === "int" ? `uint(${inputs.state})` : `floatBitsToUint(${inputs.state})`;
        return [`${outputs.state} = pcg_next(${toUint});`];
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "state");
  }
}
class PcgHash extends Dyno {
  constructor({ state }) {
    super({
      inTypes: { state: "uint" },
      outTypes: { hash: "uint" },
      inputs: { state },
      globals: () => [
        unindent(`
          uint pcg_hash(uint state) {
            uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
            return (hash >> 22u) ^ hash;
          }
        `)
      ],
      statements: ({ inputs, outputs }) => [
        `${outputs.hash} = pcg_hash(${inputs.state});`
      ]
    });
  }
  dynoOut() {
    return new DynoOutput(this, "hash");
  }
}
class PcgMix extends Dyno {
  constructor({ value }) {
    const type = valType(value);
    const tempType = sameSizeUvec(type);
    super({
      inTypes: { value: type },
      outTypes: { state: "uint" },
      inputs: { value },
      globals: () => [
        unindent(`
          uint pcg_mix(uint value) {
            return value;
          }
          uint pcg_mix(uvec2 value) {
            return value.x + 0x9e3779b9u * value.y;
          }
          uint pcg_mix(uvec3 value) {
            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z;
          }
          uint pcg_mix(uvec4 value) {
            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z + 0xc2b2ae35u * value.w;
          }
        `)
      ],
      statements: ({ inputs, outputs }) => {
        const toUvec = isUintType(type) ? `${inputs.value}` : isIntType(type) ? `${tempType}(${inputs.value})` : `floatBitsToUint(${inputs.value})`;
        return [
          `${tempType} bits = ${toUvec};`,
          `${outputs.state} = pcg_mix(bits);`
        ];
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "state");
  }
}
class Hash extends DynoBlock {
  constructor({ value }) {
    super({
      inTypes: { value: valType(value) },
      outTypes: { hash: "uint" },
      inputs: { value },
      construct: ({ value: value2 }) => {
        if (!value2) {
          throw new Error("value is required");
        }
        let state = new PcgMix({ value: value2 }).outputs.state;
        state = new PcgNext({ state }).outputs.state;
        return new PcgHash({ state }).outputs;
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "hash");
  }
}
class Hash2 extends DynoBlock {
  constructor({ value }) {
    super({
      inTypes: { value: valType(value) },
      outTypes: { hash: "uvec2" },
      inputs: { value },
      construct: ({ value: value2 }) => {
        if (!value2) {
          throw new Error("value is required");
        }
        let state = new PcgMix({ value: value2 }).outputs.state;
        state = new PcgNext({ state }).outputs.state;
        const x = new PcgHash({ state }).outputs.hash;
        state = new PcgNext({ state }).outputs.state;
        const y = new PcgHash({ state }).outputs.hash;
        return { hash: combine({ vectorType: "uvec2", x, y }) };
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "hash");
  }
}
class Hash3 extends DynoBlock {
  constructor({ value }) {
    super({
      inTypes: { value: valType(value) },
      outTypes: { hash: "uvec3" },
      inputs: { value },
      construct: ({ value: value2 }) => {
        if (!value2) {
          throw new Error("value is required");
        }
        let state = new PcgMix({ value: value2 }).outputs.state;
        state = new PcgNext({ state }).outputs.state;
        const x = new PcgHash({ state }).outputs.hash;
        state = new PcgNext({ state }).outputs.state;
        const y = new PcgHash({ state }).outputs.hash;
        state = new PcgNext({ state }).outputs.state;
        const z = new PcgHash({ state }).outputs.hash;
        return { hash: combine({ vectorType: "uvec3", x, y, z }) };
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "hash");
  }
}
class Hash4 extends DynoBlock {
  constructor({ value }) {
    super({
      inTypes: { value: valType(value) },
      outTypes: { hash: "uvec4" },
      inputs: { value },
      construct: ({ value: value2 }) => {
        if (!value2) {
          throw new Error("value is required");
        }
        let state = new PcgMix({ value: value2 }).outputs.state;
        state = new PcgNext({ state }).outputs.state;
        const x = new PcgHash({ state }).outputs.hash;
        state = new PcgNext({ state }).outputs.state;
        const y = new PcgHash({ state }).outputs.hash;
        state = new PcgNext({ state }).outputs.state;
        const z = new PcgHash({ state }).outputs.hash;
        state = new PcgNext({ state }).outputs.state;
        const w = new PcgHash({ state }).outputs.hash;
        return { hash: combine({ vectorType: "uvec4", x, y, z, w }) };
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "hash");
  }
}
class HashFloat extends DynoBlock {
  constructor({ value }) {
    super({
      inTypes: { value: valType(value) },
      outTypes: { hash: "float" },
      inputs: { value },
      construct: ({ value: value2 }) => {
        if (!value2) {
          throw new Error("value is required");
        }
        const word = hash(value2);
        return { hash: mul(float(word), dynoConst("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "hash");
  }
}
class HashVec2 extends DynoBlock {
  constructor({ value }) {
    super({
      inTypes: { value: valType(value) },
      outTypes: { hash: "vec2" },
      inputs: { value },
      construct: ({ value: value2 }) => {
        if (!value2) {
          throw new Error("value is required");
        }
        const words = hash2(value2);
        return { hash: mul(vec2(words), dynoConst("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "hash");
  }
}
class HashVec3 extends DynoBlock {
  constructor({ value }) {
    super({
      inTypes: { value: valType(value) },
      outTypes: { hash: "vec3" },
      inputs: { value },
      construct: ({ value: value2 }) => {
        if (!value2) {
          throw new Error("value is required");
        }
        const words = hash3(value2);
        return { hash: mul(vec3(words), dynoConst("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "hash");
  }
}
class HashVec4 extends DynoBlock {
  constructor({ value }) {
    super({
      inTypes: { value: valType(value) },
      outTypes: { hash: "vec4" },
      inputs: { value },
      construct: ({ value: value2 }) => {
        if (!value2) {
          throw new Error("value is required");
        }
        const words = hash4(value2);
        return { hash: mul(vec4(words), dynoConst("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new DynoOutput(this, "hash");
  }
}
class NormalizedDepth extends Dyno {
  constructor({
    z,
    zNear,
    zFar
  }) {
    super({
      inTypes: { z: "float", zNear: "float", zFar: "float" },
      outTypes: { depth: "float" },
      inputs: { z, zNear, zFar },
      statements: ({ inputs, outputs }) => [
        `float clamped = clamp(${inputs.z}, ${inputs.zNear}, ${inputs.zFar});`,
        `${outputs.depth} = (log2(clamped + 1.0) - log2(${inputs.zNear} + 1.0)) / (log2(${inputs.zFar} + 1.0) - log2(${inputs.zNear} + 1.0));`
      ]
    });
  }
  dynoOut() {
    return new DynoOutput(this, "depth");
  }
}
const transformPos = (position, {
  scale,
  scales,
  rotate,
  translate
}) => {
  return new TransformPosition({ position, scale, scales, rotate, translate }).outputs.position;
};
const transformDir = (dir, {
  scale,
  scales,
  rotate
}) => {
  return new TransformDir({ dir, scale, scales, rotate }).outputs.dir;
};
const transformQuat = (quaternion, { rotate }) => {
  return new TransformQuaternion({ quaternion, rotate }).outputs.quaternion;
};
class TransformPosition extends Dyno {
  constructor({
    position,
    scale,
    scales,
    rotate,
    translate
  }) {
    super({
      inTypes: {
        position: "vec3",
        scale: "float",
        scales: "vec3",
        rotate: "vec4",
        translate: "vec3"
      },
      outTypes: { position: "vec3" },
      inputs: { position, scale, scales, rotate, translate },
      statements: ({ inputs, outputs }) => {
        const { position: position2 } = outputs;
        if (!position2) {
          return [];
        }
        const { scale: scale2, scales: scales2, rotate: rotate2, translate: translate2 } = inputs;
        return [
          `${position2} = ${inputs.position ?? "vec3(0.0, 0.0, 0.0)"};`,
          !scale2 ? null : `${position2} *= ${scale2};`,
          !scales2 ? null : `${position2} *= ${scales2};`,
          !rotate2 ? null : `${position2} = quatVec(${rotate2}, ${position2});`,
          !translate2 ? null : `${position2} += ${translate2};`
        ].filter(Boolean);
      }
    });
  }
}
class TransformDir extends Dyno {
  constructor({
    dir,
    scale,
    scales,
    rotate
  }) {
    super({
      inTypes: { dir: "vec3", scale: "float", scales: "vec3", rotate: "vec4" },
      outTypes: { dir: "vec3" },
      inputs: { dir, scale, scales, rotate },
      statements: ({ inputs, outputs }) => {
        const { dir: dir2 } = outputs;
        if (!dir2) {
          return [];
        }
        const { scale: scale2, scales: scales2, rotate: rotate2 } = inputs;
        return [
          `${dir2} = ${inputs.dir ?? "vec3(0.0, 0.0, 0.0)"};`,
          !scale2 ? null : `${dir2} *= ${scale2};`,
          !scales2 ? null : `${dir2} *= ${scales2};`,
          !rotate2 ? null : `${dir2} = quatVec(${rotate2}, ${dir2});`
        ].filter(Boolean);
      }
    });
  }
}
class TransformQuaternion extends Dyno {
  constructor({
    quaternion,
    rotate
  }) {
    super({
      inTypes: { quaternion: "vec4", rotate: "vec4" },
      outTypes: { quaternion: "vec4" },
      inputs: { quaternion, rotate },
      statements: ({ inputs, outputs }) => {
        const { quaternion: quaternion2 } = outputs;
        if (!quaternion2) {
          return [];
        }
        return [
          `${quaternion2} = ${inputs.quaternion ?? "vec4(0.0, 0.0, 0.0, 1.0)"};`,
          !rotate ? null : `${quaternion2} = quatQuat(${inputs.rotate}, ${quaternion2});`
        ].filter(Boolean);
      }
    });
  }
}
const dynoIf = () => {
  throw new Error("Not implemented");
};
const dynoSwitch = () => {
  throw new Error("Not implemented");
};
const dynoFor = () => {
  throw new Error("Not implemented");
};
const comment = () => {
  throw new Error("Not implemented");
};
const arrayIndex = () => {
  throw new Error("Not implemented");
};
const arrayLength = () => {
  throw new Error("Not implemented");
};
const textureSize = (texture2, lod) => new TextureSize({ texture: texture2, lod });
const texture = (texture2, coord, bias) => new Texture({ texture: texture2, coord, bias });
const texelFetch = (texture2, coord, lod) => new TexelFetch({ texture: texture2, coord, lod });
class TextureSize extends Dyno {
  constructor({ texture: texture2, lod }) {
    const textureType = valType(texture2);
    super({
      inTypes: { texture: textureType, lod: "int" },
      outTypes: { size: textureSizeType(textureType) },
      inputs: { texture: texture2, lod },
      statements: ({ inputs, outputs }) => [
        `${outputs.size} = textureSize(${inputs.texture}, ${inputs.lod ?? "0"});`
      ]
    });
  }
  dynoOut() {
    return new DynoOutput(this, "size");
  }
}
class Texture extends Dyno {
  constructor({
    texture: texture2,
    coord,
    bias
  }) {
    const textureType = valType(texture2);
    super({
      inTypes: {
        texture: textureType,
        coord: textureCoordType(textureType),
        bias: "float"
      },
      outTypes: { sample: textureReturnType(textureType) },
      inputs: { texture: texture2, coord, bias },
      statements: ({ inputs, outputs }) => [
        `${outputs.sample} = texture(${inputs.texture}, ${inputs.coord}${inputs.bias ? `, ${inputs.bias}` : ""});`
      ]
    });
  }
  dynoOut() {
    return new DynoOutput(this, "sample");
  }
}
class TexelFetch extends Dyno {
  constructor({
    texture: texture2,
    coord,
    lod
  }) {
    const textureType = valType(texture2);
    super({
      inTypes: {
        texture: textureType,
        coord: textureSizeType(textureType),
        lod: "int"
      },
      outTypes: { texel: textureReturnType(textureType) },
      inputs: { texture: texture2, coord, lod },
      statements: ({ inputs, outputs }) => [
        `${outputs.texel} = texelFetch(${inputs.texture}, ${inputs.coord}, ${inputs.lod ?? "0"});`
      ]
    });
  }
  dynoOut() {
    return new DynoOutput(this, "texel");
  }
}
function textureSizeType(textureType) {
  switch (textureType) {
    case "sampler2D":
    case "usampler2D":
    case "isampler2D":
    case "samplerCube":
    case "usamplerCube":
    case "isamplerCube":
    case "sampler2DShadow":
    case "samplerCubeShadow":
      return "ivec2";
    case "sampler3D":
    case "usampler3D":
    case "isampler3D":
    case "sampler2DArray":
    case "usampler2DArray":
    case "isampler2DArray":
    case "sampler2DArrayShadow":
      return "ivec3";
    default:
      throw new Error(`Invalid texture type: ${textureType}`);
  }
}
function textureCoordType(textureType) {
  switch (textureType) {
    case "sampler2D":
    case "usampler2D":
    case "isampler2D":
      return "vec2";
    case "sampler3D":
    case "usampler3D":
    case "isampler3D":
    case "samplerCube":
    case "usamplerCube":
    case "isamplerCube":
    case "sampler2DArray":
    case "usampler2DArray":
    case "isampler2DArray":
    case "sampler2DShadow":
      return "vec3";
    case "samplerCubeShadow":
    case "sampler2DArrayShadow":
      return "vec4";
    default:
      throw new Error(`Invalid texture type: ${textureType}`);
  }
}
function textureReturnType(textureType) {
  switch (textureType) {
    case "sampler2D":
    case "sampler2DArray":
    case "sampler3D":
    case "samplerCube":
    case "sampler2DShadow":
      return "vec4";
    case "usampler2D":
    case "usampler2DArray":
    case "usampler3D":
    case "usamplerCube":
      return "uvec4";
    case "isampler2D":
    case "isampler2DArray":
    case "isampler3D":
    case "isamplerCube":
      return "ivec4";
    case "samplerCubeShadow":
    case "sampler2DArrayShadow":
      return "float";
    default:
      throw new Error(`Invalid texture type: ${textureType}`);
  }
}
const radians = (degrees2) => new Radians({ degrees: degrees2 });
const degrees = (radians2) => new Degrees({ radians: radians2 });
const sin = (radians2) => new Sin({ radians: radians2 });
const cos = (radians2) => new Cos({ radians: radians2 });
const tan = (radians2) => new Tan({ radians: radians2 });
const asin = (sin2) => new Asin({ sin: sin2 });
const acos = (cos2) => new Acos({ cos: cos2 });
const atan = (tan2) => new Atan({ tan: tan2 });
const atan2 = (y, x) => new Atan2({ y, x });
const sinh = (x) => new Sinh({ x });
const cosh = (x) => new Cosh({ x });
const tanh = (x) => new Tanh({ x });
const asinh = (x) => new Asinh({ x });
const acosh = (x) => new Acosh({ x });
const atanh = (x) => new Atanh({ x });
class Radians extends UnaryOp {
  constructor({ degrees: degrees2 }) {
    super({ a: degrees2, outTypeFunc: (aType) => aType, outKey: "radians" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.radians} = radians(${inputs.a});`
    ];
  }
}
class Degrees extends UnaryOp {
  constructor({ radians: radians2 }) {
    super({ a: radians2, outTypeFunc: (aType) => aType, outKey: "degrees" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.degrees} = degrees(${inputs.a});`
    ];
  }
}
class Sin extends UnaryOp {
  constructor({ radians: radians2 }) {
    super({ a: radians2, outTypeFunc: (aType) => aType, outKey: "sin" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.sin} = sin(${inputs.a});`
    ];
  }
}
class Cos extends UnaryOp {
  constructor({ radians: radians2 }) {
    super({ a: radians2, outTypeFunc: (aType) => aType, outKey: "cos" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.cos} = cos(${inputs.a});`
    ];
  }
}
class Tan extends UnaryOp {
  constructor({ radians: radians2 }) {
    super({ a: radians2, outTypeFunc: (aType) => aType, outKey: "tan" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.tan} = tan(${inputs.a});`
    ];
  }
}
class Asin extends UnaryOp {
  constructor({ sin: sin2 }) {
    super({ a: sin2, outTypeFunc: (aType) => aType, outKey: "asin" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.asin} = asin(${inputs.a});`
    ];
  }
}
class Acos extends UnaryOp {
  constructor({ cos: cos2 }) {
    super({ a: cos2, outTypeFunc: (aType) => aType, outKey: "acos" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.acos} = acos(${inputs.a});`
    ];
  }
}
class Atan extends UnaryOp {
  constructor({ tan: tan2 }) {
    super({ a: tan2, outTypeFunc: (aType) => aType, outKey: "atan" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.atan} = atan(${inputs.a});`
    ];
  }
}
class Atan2 extends BinaryOp {
  constructor({ y, x }) {
    super({
      a: y,
      b: x,
      outTypeFunc: (aType, bType) => aType,
      outKey: "atan2"
    });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.atan2} = atan2(${inputs.a}, ${inputs.b});`
    ];
  }
}
class Sinh extends UnaryOp {
  constructor({ x }) {
    super({ a: x, outTypeFunc: (aType) => aType, outKey: "sinh" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.sinh} = sinh(${inputs.a});`
    ];
  }
}
class Cosh extends UnaryOp {
  constructor({ x }) {
    super({ a: x, outTypeFunc: (aType) => aType, outKey: "cosh" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.cosh} = cosh(${inputs.a});`
    ];
  }
}
class Tanh extends UnaryOp {
  constructor({ x }) {
    super({ a: x, outTypeFunc: (aType) => aType, outKey: "tanh" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.tanh} = tanh(${inputs.a});`
    ];
  }
}
class Asinh extends UnaryOp {
  constructor({ x }) {
    super({ a: x, outTypeFunc: (aType) => aType, outKey: "asinh" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.asinh} = asinh(${inputs.a});`
    ];
  }
}
class Acosh extends UnaryOp {
  constructor({ x }) {
    super({ a: x, outTypeFunc: (aType) => aType, outKey: "acosh" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.acosh} = acosh(${inputs.a});`
    ];
  }
}
class Atanh extends UnaryOp {
  constructor({ x }) {
    super({ a: x, outTypeFunc: (aType) => aType, outKey: "atanh" });
    this.statements = ({ inputs, outputs }) => [
      `${outputs.atanh} = atanh(${inputs.a});`
    ];
  }
}
const dyno = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Abs,
  Acos,
  Acosh,
  Add,
  All,
  And,
  Any,
  Asin,
  Asinh,
  Atan,
  Atan2,
  Atanh,
  BVec2,
  BVec3,
  BVec4,
  BinaryOp,
  Bool,
  Ceil,
  Clamp,
  Combine,
  CombineGsplat,
  CompMult,
  CompXor,
  Compilation,
  Cos,
  Cosh,
  Cross,
  Degrees,
  Determinant,
  Distance,
  Div,
  Dot,
  Dyno,
  DynoBlock,
  DynoBool,
  DynoBvec2,
  DynoBvec3,
  DynoBvec4,
  DynoConst,
  DynoFloat,
  DynoInt,
  DynoIsampler2D,
  DynoIsampler2DArray,
  DynoIsampler3D,
  DynoIsamplerCube,
  DynoIvec2,
  DynoIvec3,
  DynoIvec4,
  DynoLiteral,
  DynoMat2,
  DynoMat2x2,
  DynoMat2x3,
  DynoMat2x4,
  DynoMat3,
  DynoMat3x2,
  DynoMat3x3,
  DynoMat3x4,
  DynoMat4,
  DynoMat4x2,
  DynoMat4x3,
  DynoMat4x4,
  DynoOutput,
  DynoProgram,
  DynoProgramTemplate,
  DynoRemapIndex,
  DynoSampler2D,
  DynoSampler2DArray,
  DynoSampler2DArrayShadow,
  DynoSampler2DShadow,
  DynoSampler3D,
  DynoSamplerCube,
  DynoSamplerCubeShadow,
  DynoUint,
  DynoUniform,
  DynoUsampler2D,
  DynoUsampler2DArray,
  DynoUsampler3D,
  DynoUsamplerCube,
  DynoUvec2,
  DynoUvec3,
  DynoUvec4,
  DynoValue,
  DynoVec2,
  DynoVec3,
  DynoVec4,
  Equal,
  Exp,
  Exp2,
  ExtendVec,
  FaceForward,
  Float,
  FloatBitsToInt,
  FloatBitsToUint,
  Floor,
  Fract,
  GreaterThan,
  GreaterThanEqual,
  Gsplat,
  GsplatNormal,
  Hash,
  Hash2,
  Hash3,
  Hash4,
  HashFloat,
  HashVec2,
  HashVec3,
  HashVec4,
  IMod,
  IVec2,
  IVec3,
  IVec4,
  Int,
  IntBitsToFloat,
  Inverse,
  InverseSqrt,
  IsInf,
  IsNan,
  Length,
  LessThan,
  LessThanEqual,
  Log,
  Log2,
  Mat2,
  Mat3,
  Mat4,
  Max,
  Min,
  Mix,
  Mod,
  Modf,
  Mul,
  Neg,
  Normalize,
  NormalizedDepth,
  Not,
  NotEqual,
  NumPackedSplats,
  Or,
  Outer,
  OutputExtendedSplat,
  OutputPackedSplat,
  OutputRgba8,
  PackHalf2x16,
  PackSnorm2x16,
  PackUnorm2x16,
  PcgHash,
  PcgMix,
  PcgNext,
  Pow,
  ProjectH,
  Radians,
  ReadPackedSplat,
  ReadPackedSplatRange,
  ReflectVec,
  RefractVec,
  Round,
  Select,
  Sign,
  SimpleCast,
  Sin,
  Sinh,
  Smoothstep,
  Split,
  SplitGsplat,
  Sqr,
  Sqrt,
  Step,
  Sub,
  Swizzle,
  TPackedSplats,
  Tan,
  Tanh,
  TexelFetch,
  Texture,
  TextureSize,
  TransformDir,
  TransformGsplat,
  TransformPosition,
  TransformQuaternion,
  Transpose,
  TrinaryOp,
  Trunc,
  UVec2,
  UVec3,
  UVec4,
  Uint,
  UintBitsToFloat,
  UintToRgba8,
  UnaryOp,
  UnpackHalf2x16,
  UnpackSnorm2x16,
  UnpackUnorm2x16,
  Vec2,
  Vec3,
  Vec4,
  Xor,
  abs,
  acos,
  acosh,
  add,
  all,
  and,
  any,
  arrayIndex,
  arrayLength,
  asin,
  asinh,
  atan,
  atan2,
  atanh,
  bool,
  bvec2,
  bvec3,
  bvec4,
  ceil,
  clamp,
  combine,
  combineGsplat,
  comment,
  compMult,
  compXor,
  cos,
  cosh,
  cross,
  defineGsplat,
  defineGsplatNormal,
  definePackedSplats,
  degrees,
  determinant,
  distance,
  div,
  dot,
  dyno: dyno$1,
  dynoBlock,
  dynoBool,
  dynoBvec2,
  dynoBvec3,
  dynoBvec4,
  dynoConst,
  dynoDeclare,
  dynoFloat,
  dynoFor,
  dynoIf,
  dynoInt,
  dynoIsampler2D,
  dynoIsampler2DArray,
  dynoIsampler3D,
  dynoIsamplerCube,
  dynoIvec2,
  dynoIvec3,
  dynoIvec4,
  dynoLiteral,
  dynoMat2,
  dynoMat2x2,
  dynoMat2x3,
  dynoMat2x4,
  dynoMat3,
  dynoMat3x2,
  dynoMat3x3,
  dynoMat3x4,
  dynoMat4,
  dynoMat4x2,
  dynoMat4x3,
  dynoMat4x4,
  dynoSampler2D,
  dynoSampler2DArray,
  dynoSampler2DArrayShadow,
  dynoSampler2DShadow,
  dynoSampler3D,
  dynoSamplerCube,
  dynoSamplerCubeShadow,
  dynoSwitch,
  dynoUint,
  dynoUsampler2D,
  dynoUsampler2DArray,
  dynoUsampler3D,
  dynoUsamplerCube,
  dynoUvec2,
  dynoUvec3,
  dynoUvec4,
  dynoVec2,
  dynoVec3,
  dynoVec4,
  equal,
  exp,
  exp2,
  extendVec,
  faceforward,
  float,
  floatBitsToInt,
  floatBitsToUint,
  floor,
  fract,
  greaterThan,
  greaterThanEqual,
  gsplatNormal,
  hash,
  hash2,
  hash3,
  hash4,
  hashFloat,
  hashVec2,
  hashVec3,
  hashVec4,
  imod,
  int,
  intBitsToFloat,
  inverse,
  inversesqrt,
  isAllFloatType,
  isBoolType,
  isFloatType,
  isInf,
  isIntType,
  isMat2,
  isMat3,
  isMat4,
  isMatFloatType,
  isNan,
  isScalarType,
  isUintType,
  isVector2Type,
  isVector3Type,
  isVector4Type,
  isVectorType,
  ivec2,
  ivec3,
  ivec4,
  length,
  lessThan,
  lessThanEqual,
  literalNegOne,
  literalOne,
  literalZero,
  log,
  log2,
  mat2,
  mat3,
  mat4,
  max,
  min,
  mix,
  mod,
  modf,
  mul,
  neg,
  normalize,
  normalizedDepth,
  not,
  notEqual,
  numPackedSplats,
  numberAsFloat,
  numberAsInt,
  numberAsUint,
  or,
  outer,
  outputExtendedSplat,
  outputPackedSplat,
  outputRgba8,
  outputSplatDepth,
  packHalf2x16,
  packSnorm2x16,
  packUnorm2x16,
  pcgHash,
  pcgMix,
  pcgNext,
  pow,
  projectH,
  radians,
  readPackedSplat,
  readPackedSplatRange,
  reflectVec,
  refractVec,
  remapIndex,
  round,
  sameSizeIvec,
  sameSizeUvec,
  sameSizeVec,
  select,
  sign,
  sin,
  sinh,
  smoothstep,
  split,
  splitGsplat,
  sqr,
  sqrt,
  step,
  sub,
  swizzle,
  tan,
  tanh,
  texelFetch,
  texture,
  textureSize,
  transformDir,
  transformGsplat,
  transformPos,
  transformQuat,
  transpose,
  trunc,
  typeLiteral,
  uint,
  uintBitsToFloat,
  uintToRgba8,
  uniform,
  unindent,
  unindentLines,
  unpackHalf2x16,
  unpackSnorm2x16,
  unpackUnorm2x16,
  uvec2,
  uvec3,
  uvec4,
  valType,
  vec2,
  vec3,
  vec4,
  vectorDim,
  vectorElementType,
  xor
}, Symbol.toStringTag, { value: "Module" }));
var computeVec4_default = "precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout vec4 target;\n\n{{ GLOBALS }}\n\nvoid computeReadback(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    if ((index >= 0) && (index < targetCount)) {\n        computeReadback(index);\n    } else {\n        target = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}";
const _Readback = class _Readback {
  constructor({ renderer } = {}) {
    this.renderer = renderer;
    this.capacity = 0;
    this.count = 0;
  }
  dispose() {
    if (this.target) {
      this.target.dispose();
      this.target = void 0;
    }
  }
  // Ensure we have a buffer large enough for the readback of count indices.
  // Pass in previous bufer of the desired type.
  static ensureBuffer(count, buffer) {
    const roundedCount = Math.ceil(Math.max(1, count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;
    const bytes = roundedCount * 4;
    if (buffer.byteLength >= bytes) {
      return buffer;
    }
    const newBuffer = new ArrayBuffer(bytes);
    if (buffer instanceof ArrayBuffer) {
      return newBuffer;
    }
    const ctor = buffer.constructor;
    return new ctor(newBuffer);
  }
  ensureBuffer(count, buffer) {
    return _Readback.ensureBuffer(count, buffer);
  }
  // Ensure our render target is large enough for the readback of capacity indices.
  ensureCapacity(capacity) {
    const { width, height, depth, maxSplats } = getTextureSize(capacity);
    if (!this.target || maxSplats > this.capacity) {
      this.dispose();
      this.capacity = maxSplats;
      this.target = new THREE.WebGLArrayRenderTarget(width, height, depth, {
        depthBuffer: false,
        stencilBuffer: false,
        generateMipmaps: false,
        magFilter: THREE.NearestFilter,
        minFilter: THREE.NearestFilter
      });
      this.target.texture.format = THREE.RGBAFormat;
      this.target.texture.type = THREE.UnsignedByteType;
      this.target.texture.internalFormat = "RGBA8";
      this.target.scissorTest = true;
    }
  }
  // Get a program and THREE.RawShaderMaterial for a given Rgba8Readback,
  // generating it if necessary and caching the result.
  prepareProgramMaterial(reader) {
    let program = _Readback.readbackProgram.get(reader);
    if (!program) {
      const graph = dynoBlock(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index }) => {
          reader.inputs.index = index;
          const rgba8 = new OutputRgba8({ rgba8: reader.outputs.rgba8 });
          return { rgba8 };
        }
      );
      if (!_Readback.programTemplate) {
        _Readback.programTemplate = new DynoProgramTemplate(computeVec4_default);
      }
      program = new DynoProgram({
        graph,
        inputs: { index: "index" },
        outputs: { rgba8: "target" },
        template: _Readback.programTemplate
      });
      Object.assign(program.uniforms, {
        targetLayer: { value: 0 },
        targetBase: { value: 0 },
        targetCount: { value: 0 }
      });
      _Readback.readbackProgram.set(reader, program);
    }
    const material = program.prepareMaterial();
    _Readback.fullScreenQuad.material = material;
    return { program, material };
  }
  saveRenderState(renderer) {
    return {
      xrEnabled: renderer.xr.enabled,
      autoClear: renderer.autoClear
    };
  }
  resetRenderState(renderer, state) {
    renderer.setRenderTarget(null);
    renderer.xr.enabled = state.xrEnabled;
    renderer.autoClear = state.autoClear;
  }
  process({
    count,
    material
  }) {
    const renderer = this.renderer;
    if (!renderer) {
      throw new Error("No renderer");
    }
    if (!this.target) {
      throw new Error("No target");
    }
    const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;
    material.uniforms.targetBase.value = 0;
    material.uniforms.targetCount.value = count;
    let baseIndex = 0;
    while (baseIndex < count) {
      const layer = Math.floor(baseIndex / layerSize);
      const layerBase = layer * layerSize;
      const layerYEnd = Math.min(
        SPLAT_TEX_HEIGHT,
        Math.ceil((count - layerBase) / SPLAT_TEX_WIDTH)
      );
      material.uniforms.targetLayer.value = layer;
      this.target.scissor.set(0, 0, SPLAT_TEX_WIDTH, layerYEnd);
      renderer.setRenderTarget(this.target, layer);
      renderer.xr.enabled = false;
      renderer.autoClear = false;
      _Readback.fullScreenQuad.render(renderer);
      baseIndex += SPLAT_TEX_WIDTH * layerYEnd;
    }
    this.count = count;
  }
  async read({
    readback
  }) {
    const renderer = this.renderer;
    if (!renderer) {
      throw new Error("No renderer");
    }
    if (!this.target) {
      throw new Error("No target");
    }
    const roundedCount = Math.ceil(this.count / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;
    if (readback.byteLength < roundedCount * 4) {
      throw new Error(
        `Readback buffer too small: ${readback.byteLength} < ${roundedCount * 4}`
      );
    }
    const readbackUint8 = new Uint8Array(
      readback instanceof ArrayBuffer ? readback : readback.buffer
    );
    const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;
    let baseIndex = 0;
    const promises = [];
    while (baseIndex < this.count) {
      const layer = Math.floor(baseIndex / layerSize);
      const layerBase = layer * layerSize;
      const layerYEnd = Math.min(
        SPLAT_TEX_HEIGHT,
        Math.ceil((this.count - layerBase) / SPLAT_TEX_WIDTH)
      );
      renderer.setRenderTarget(this.target, layer);
      const readbackSize = SPLAT_TEX_WIDTH * layerYEnd * 4;
      const subReadback = readbackUint8.subarray(
        layerBase * 4,
        layerBase * 4 + readbackSize
      );
      const promise = renderer == null ? void 0 : renderer.readRenderTargetPixelsAsync(
        this.target,
        0,
        0,
        SPLAT_TEX_WIDTH,
        layerYEnd,
        subReadback
      );
      promises.push(promise);
      baseIndex += SPLAT_TEX_WIDTH * layerYEnd;
    }
    return Promise.all(promises).then(() => readback);
  }
  // Perform render operation to run the Rgba8Readback program
  // but don't perform the readback yet.
  render({
    reader,
    count,
    renderer
  }) {
    this.renderer = renderer || this.renderer;
    if (!this.renderer) {
      throw new Error("No renderer");
    }
    this.ensureCapacity(count);
    const { program, material } = this.prepareProgramMaterial(reader);
    program.update();
    const renderState = this.saveRenderState(this.renderer);
    this.process({ count, material });
    this.resetRenderState(this.renderer, renderState);
  }
  // Perform a readback of the render target, returning a buffer of the
  // given type.
  async readback({
    readback
  }) {
    if (!this.renderer) {
      throw new Error("No renderer");
    }
    const renderState = this.saveRenderState(this.renderer);
    const promise = this.read({ readback });
    this.resetRenderState(this.renderer, renderState);
    return promise;
  }
  // Perform a render and readback operation for the given Rgba8Readback,
  // and readback buffer (call ensureBuffer first).
  async renderReadback({
    reader,
    count,
    renderer,
    readback
  }) {
    this.renderer = renderer || this.renderer;
    if (!this.renderer) {
      throw new Error("No renderer");
    }
    this.ensureCapacity(count);
    const { program, material } = this.prepareProgramMaterial(reader);
    program.update();
    const renderState = this.saveRenderState(this.renderer);
    this.process({ count, material });
    const promise = this.read({ readback });
    this.resetRenderState(this.renderer, renderState);
    return promise;
  }
  getTexture() {
    var _a2;
    return (_a2 = this.target) == null ? void 0 : _a2.texture;
  }
};
_Readback.programTemplate = null;
_Readback.readbackProgram = /* @__PURE__ */ new Map();
_Readback.fullScreenQuad = new FullScreenQuad(
  new THREE.RawShaderMaterial({ visible: false })
);
let Readback = _Readback;
const _RgbaArray = class _RgbaArray {
  constructor(options = {}) {
    this.capacity = 0;
    this.count = 0;
    this.array = null;
    this.readback = null;
    this.source = null;
    this.needsUpdate = true;
    this.dyno = new DynoUniform({
      key: "rgbaArray",
      type: TRgbaArray,
      globals: () => [defineRgbaArray],
      value: {
        texture: _RgbaArray.getEmpty(),
        count: 0
      },
      update: (value) => {
        var _a2;
        value.texture = ((_a2 = this.readback) == null ? void 0 : _a2.getTexture()) ?? this.source ?? _RgbaArray.getEmpty();
        value.count = this.count;
        return value;
      }
    });
    if (options.array) {
      this.array = options.array;
      this.capacity = Math.floor(this.array.length / 4);
      this.capacity = Math.floor(this.capacity / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;
      this.count = Math.min(
        this.capacity,
        options.count ?? Number.POSITIVE_INFINITY
      );
    } else {
      this.capacity = options.capacity ?? 0;
      this.count = 0;
    }
  }
  // Free up resources
  dispose() {
    if (this.readback) {
      this.readback.dispose();
      this.readback = null;
    }
    if (this.source) {
      this.source.dispose();
      this.source = null;
    }
  }
  // Ensure that our array is large enough to hold capacity RGBA8 values.
  ensureCapacity(capacity) {
    var _a2;
    if (!this.array || capacity > (((_a2 = this.array) == null ? void 0 : _a2.length) ?? 0) / 4) {
      this.capacity = getTextureSize(capacity).maxSplats;
      const newArray2 = new Uint8Array(this.capacity * 4);
      if (this.array) {
        newArray2.set(this.array);
      }
      this.array = newArray2;
    }
    return this.array;
  }
  // Get the THREE.DataArrayTexture from either the readback or the source.
  getTexture() {
    var _a2;
    let texture2 = (_a2 = this.readback) == null ? void 0 : _a2.getTexture();
    if (this.source || this.array) {
      texture2 = this.maybeUpdateSource();
    }
    return texture2 ?? _RgbaArray.getEmpty();
  }
  // Create or get a THREE.DataArrayTexture from the data array.
  maybeUpdateSource() {
    if (!this.array) {
      throw new Error("No array");
    }
    if (this.needsUpdate || !this.source) {
      this.needsUpdate = false;
      if (this.source) {
        const { width, height, depth } = this.source.image;
        if (this.capacity !== width * height * depth) {
          this.source.dispose();
          this.source = null;
        }
      }
      if (!this.source) {
        const { width, height, depth } = getTextureSize(this.capacity);
        this.source = new THREE.DataArrayTexture(
          this.array,
          width,
          height,
          depth
        );
        this.source.format = THREE.RGBAFormat;
        this.source.type = THREE.UnsignedByteType;
        this.source.internalFormat = "RGBA8";
        this.source.needsUpdate = true;
      } else if (this.array.buffer !== this.source.image.data.buffer) {
        this.source.image.data = new Uint8Array(this.array.buffer);
      }
      this.source.needsUpdate = true;
    }
    return this.source;
  }
  // Generate the RGBA8 values from a Rgba8Readback dyno program.
  render({
    reader,
    count,
    renderer
  }) {
    if (!this.readback) {
      this.readback = new Readback({ renderer });
    }
    this.readback.render({ reader, count, renderer });
    this.capacity = this.readback.capacity;
    this.count = this.readback.count;
  }
  // Extract the RGBA8 values from a PackedSplats collection.
  fromPackedSplats({
    packedSplats,
    base,
    count,
    renderer
  }) {
    const { dynoSplats, dynoBase, dynoCount, reader } = _RgbaArray.makeDynos();
    dynoSplats.packedSplats = packedSplats;
    dynoBase.value = base;
    dynoCount.value = count;
    this.render({ reader, count, renderer });
    return this;
  }
  // Read back the RGBA8 values from the readback buffer.
  async read() {
    if (!this.readback) {
      throw new Error("No readback");
    }
    if (!this.array || this.array.length < this.count * 4) {
      this.array = new Uint8Array(this.capacity * 4);
    }
    const result = await this.readback.readback({ readback: this.array });
    return result.subarray(0, this.count * 4);
  }
  // Can be used where you need an uninitialized THREE.DataArrayTexture like
  // a uniform you will update with the result of this.getTexture() later.
  static getEmpty() {
    if (!_RgbaArray.emptySource) {
      const emptyArray = new Uint8Array(1 * 4);
      _RgbaArray.emptySource = new THREE.DataArrayTexture(emptyArray, 1, 1, 1);
      _RgbaArray.emptySource.format = THREE.RGBAFormat;
      _RgbaArray.emptySource.type = THREE.UnsignedByteType;
      _RgbaArray.emptySource.internalFormat = "RGBA8";
      _RgbaArray.emptySource.needsUpdate = true;
    }
    return _RgbaArray.emptySource;
  }
  // Create a dyno program that can extract RGBA8 values from a PackedSplats
  static makeDynos() {
    if (!_RgbaArray.dynos) {
      const dynoSplats = new DynoPackedSplats();
      const dynoBase = new DynoInt({ value: 0 });
      const dynoCount = new DynoInt({ value: 0 });
      const reader = dynoBlock(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index }) => {
          if (!index) {
            throw new Error("index is undefined");
          }
          index = add(index, dynoBase);
          const gsplat = readPackedSplatRange(
            dynoSplats,
            index,
            dynoBase,
            dynoCount
          );
          return { rgba8: splitGsplat(gsplat).outputs.rgba };
        }
      );
      _RgbaArray.dynos = { dynoSplats, dynoBase, dynoCount, reader };
    }
    return _RgbaArray.dynos;
  }
};
_RgbaArray.emptySource = null;
_RgbaArray.dynos = null;
let RgbaArray = _RgbaArray;
const TRgbaArray = { type: "RgbaArray" };
const defineRgbaArray = unindent(`
  struct RgbaArray {
    sampler2DArray texture;
    int count;
  };
`);
function readRgbaArray(rgba, index) {
  const dyno2 = new Dyno({
    inTypes: { rgba: TRgbaArray, index: "int" },
    outTypes: { rgba: "vec4" },
    inputs: { rgba, index },
    globals: () => [defineRgbaArray],
    statements: ({ inputs, outputs }) => unindentLines(`
        if ((index >= 0) && (index < ${inputs.rgba}.count)) {
          ${outputs.rgba} = texelFetch(${inputs.rgba}.texture, splatTexCoord(index), 0);
        } else {
          ${outputs.rgba} = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `)
  });
  return dyno2.outputs.rgba;
}
var SplatEditSdfType = /* @__PURE__ */ ((SplatEditSdfType2) => {
  SplatEditSdfType2["ALL"] = "all";
  SplatEditSdfType2["PLANE"] = "plane";
  SplatEditSdfType2["SPHERE"] = "sphere";
  SplatEditSdfType2["BOX"] = "box";
  SplatEditSdfType2["ELLIPSOID"] = "ellipsoid";
  SplatEditSdfType2["CYLINDER"] = "cylinder";
  SplatEditSdfType2["CAPSULE"] = "capsule";
  SplatEditSdfType2["INFINITE_CONE"] = "infinite_cone";
  return SplatEditSdfType2;
})(SplatEditSdfType || {});
function sdfTypeToNumber(type) {
  switch (type) {
    case "all":
      return 0;
    case "plane":
      return 1;
    case "sphere":
      return 2;
    case "box":
      return 3;
    case "ellipsoid":
      return 4;
    case "cylinder":
      return 5;
    case "capsule":
      return 6;
    case "infinite_cone":
      return 7;
    default:
      throw new Error(`Unknown SDF type: ${type}`);
  }
}
var SplatEditRgbaBlendMode = /* @__PURE__ */ ((SplatEditRgbaBlendMode2) => {
  SplatEditRgbaBlendMode2["MULTIPLY"] = "multiply";
  SplatEditRgbaBlendMode2["SET_RGB"] = "set_rgb";
  SplatEditRgbaBlendMode2["ADD_RGBA"] = "add_rgba";
  return SplatEditRgbaBlendMode2;
})(SplatEditRgbaBlendMode || {});
function rgbaBlendModeToNumber(mode) {
  switch (mode) {
    case "multiply":
      return 0;
    case "set_rgb":
      return 1;
    case "add_rgba":
      return 2;
    default:
      throw new Error(`Unknown blend mode: ${mode}`);
  }
}
class SplatEditSdf extends THREE.Object3D {
  constructor(options = {}) {
    super();
    const { type, invert, opacity, color, displace, radius } = options;
    this.type = type ?? "sphere";
    this.invert = invert ?? false;
    this.opacity = opacity ?? 1;
    this.color = color ?? new THREE.Color(1, 1, 1);
    this.displace = displace ?? new THREE.Vector3(0, 0, 0);
    this.radius = radius ?? 0;
  }
}
const _SplatEdit = class _SplatEdit extends THREE.Object3D {
  constructor(options = {}) {
    const {
      name,
      rgbaBlendMode = "multiply",
      sdfSmooth = 0,
      softEdge = 0,
      invert = false,
      sdfs = null
    } = options;
    super();
    this.rgbaBlendMode = rgbaBlendMode;
    this.sdfSmooth = sdfSmooth;
    this.softEdge = softEdge;
    this.invert = invert;
    this.sdfs = sdfs;
    this.ordering = _SplatEdit.nextOrdering++;
    this.name = name ?? `Edit ${this.ordering}`;
  }
  addSdf(sdf) {
    if (this.sdfs == null) {
      this.sdfs = [];
    }
    if (!this.sdfs.includes(sdf)) {
      this.sdfs.push(sdf);
    }
  }
  removeSdf(sdf) {
    if (this.sdfs == null) {
      return;
    }
    this.sdfs = this.sdfs.filter((s) => s !== sdf);
  }
};
_SplatEdit.nextOrdering = 1;
let SplatEdit = _SplatEdit;
class SplatEdits {
  constructor({ maxSdfs, maxEdits }) {
    this.maxSdfs = Math.max(16, maxSdfs ?? 0);
    this.numSdfs = 0;
    this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);
    this.sdfFloatData = new Float32Array(this.sdfData.buffer);
    this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);
    this.dynoSdfArray = new DynoUniform({
      key: "sdfArray",
      type: SdfArray,
      globals: () => [defineSdfArray],
      value: {
        numSdfs: 0,
        sdfTexture: this.sdfTexture
      },
      update: (uniform2) => {
        uniform2.numSdfs = this.numSdfs;
        uniform2.sdfTexture = this.sdfTexture;
        return uniform2;
      }
    });
    this.maxEdits = Math.max(16, maxEdits ?? 0);
    this.numEdits = 0;
    this.editData = new Uint32Array(this.maxEdits * 4);
    this.editFloatData = new Float32Array(this.editData.buffer);
    this.dynoNumEdits = new DynoInt({ value: 0 });
    this.dynoEdits = this.newEdits(this.editData, this.maxEdits);
  }
  newSdfTexture(data, maxSdfs) {
    const texture2 = new THREE.DataTexture(
      data,
      8,
      maxSdfs,
      THREE.RGBAIntegerFormat,
      THREE.UnsignedIntType
    );
    texture2.internalFormat = "RGBA32UI";
    texture2.needsUpdate = true;
    return texture2;
  }
  newEdits(data, maxEdits) {
    return new DynoUniform({
      key: "edits",
      type: "uvec4",
      count: maxEdits,
      globals: () => [defineEdit],
      value: data
    });
  }
  // Ensure our SDF texture and edits uniform array have enough capacity.
  // Reallocate if not.
  ensureCapacity({
    maxSdfs,
    maxEdits
  }) {
    let dynoUpdated = false;
    if (maxSdfs > this.sdfTexture.image.height) {
      this.sdfTexture.dispose();
      this.maxSdfs = Math.max(this.maxSdfs * 2, maxSdfs);
      this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);
      this.sdfFloatData = new Float32Array(this.sdfData.buffer);
      this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);
    }
    if (maxEdits > (this.dynoEdits.count ?? 0)) {
      this.maxEdits = Math.max(this.maxEdits * 2, maxEdits);
      this.editData = new Uint32Array(this.maxEdits * 4);
      this.editFloatData = new Float32Array(this.editData.buffer);
      this.dynoEdits = this.newEdits(this.editData, this.maxEdits);
      dynoUpdated = true;
    }
    return dynoUpdated;
  }
  updateEditData(offset, value) {
    const updated = this.editData[offset] !== value;
    this.editData[offset] = value;
    return updated;
  }
  updateEditFloatData(offset, value) {
    tempFloat32[0] = value;
    const updated = this.editFloatData[offset] !== tempFloat32[0];
    if (updated) {
      this.editFloatData[offset] = tempFloat32[0];
    }
    return updated;
  }
  encodeEdit(editIndex, {
    sdfFirst,
    sdfCount,
    invert,
    rgbaBlendMode,
    softEdge,
    sdfSmooth
  }) {
    const base = editIndex * 4;
    let updated = false;
    updated = this.updateEditData(base + 0, rgbaBlendMode | (invert ? 1 << 8 : 0)) || updated;
    updated = this.updateEditData(base + 1, sdfFirst | sdfCount << 16) || updated;
    updated = this.updateEditFloatData(base + 2, softEdge) || updated;
    updated = this.updateEditFloatData(base + 3, sdfSmooth) || updated;
    return updated;
  }
  updateSdfData(offset, value) {
    const updated = this.sdfData[offset] !== value;
    this.sdfData[offset] = value;
    return updated;
  }
  updateSdfFloatData(offset, value) {
    tempFloat32[0] = value;
    const updated = this.sdfFloatData[offset] !== tempFloat32[0];
    if (updated) {
      this.sdfFloatData[offset] = tempFloat32[0];
    }
    return updated;
  }
  encodeSdf(sdfIndex, {
    sdfType,
    invert,
    center,
    quaternion,
    scale,
    sizes
  }, values) {
    const base = sdfIndex * (8 * 4);
    const flags = sdfType | (invert ? 1 << 8 : 0);
    let updated = false;
    updated = this.updateSdfFloatData(base + 0, (center == null ? void 0 : center.x) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 1, (center == null ? void 0 : center.y) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 2, (center == null ? void 0 : center.z) ?? 0) || updated;
    updated = this.updateSdfData(base + 3, flags) || updated;
    updated = this.updateSdfFloatData(base + 4, (quaternion == null ? void 0 : quaternion.x) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 5, (quaternion == null ? void 0 : quaternion.y) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 6, (quaternion == null ? void 0 : quaternion.z) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 7, (quaternion == null ? void 0 : quaternion.w) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 8, (scale == null ? void 0 : scale.x) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 9, (scale == null ? void 0 : scale.y) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 10, (scale == null ? void 0 : scale.z) ?? 0) || updated;
    updated = this.updateSdfData(base + 11, 0) || updated;
    updated = this.updateSdfFloatData(base + 12, (sizes == null ? void 0 : sizes.x) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 13, (sizes == null ? void 0 : sizes.y) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 14, (sizes == null ? void 0 : sizes.z) ?? 0) || updated;
    updated = this.updateSdfFloatData(base + 15, (sizes == null ? void 0 : sizes.w) ?? 0) || updated;
    const nValues = Math.min(4, values.length);
    for (let i = 0; i < nValues; ++i) {
      const vBase = base + 16 + i * 4;
      updated = this.updateSdfFloatData(vBase + 0, values[i].x) || updated;
      updated = this.updateSdfFloatData(vBase + 1, values[i].y) || updated;
      updated = this.updateSdfFloatData(vBase + 2, values[i].z) || updated;
      updated = this.updateSdfFloatData(vBase + 3, values[i].w) || updated;
    }
    return updated;
  }
  // Update the SDFs and edits from an array of SplatEdits and their
  // associated SplatEditSdfs, updating it for the dyno shader program.
  update(edits) {
    const sdfCount = edits.reduce((total, { sdfs }) => total + sdfs.length, 0);
    const dynoUpdated = this.ensureCapacity({
      maxEdits: edits.length,
      maxSdfs: sdfCount
    });
    const values = [new THREE.Vector4(), new THREE.Vector4()];
    const center = new THREE.Vector3();
    const quaternion = new THREE.Quaternion();
    const scale = new THREE.Vector3();
    const sizes = new THREE.Vector4();
    let sdfIndex = 0;
    let updated = dynoUpdated;
    if (edits.length !== this.dynoNumEdits.value) {
      this.dynoNumEdits.value = edits.length;
      this.numEdits = edits.length;
      updated = true;
    }
    for (const [editIndex, { edit, sdfs }] of edits.entries()) {
      updated = this.encodeEdit(editIndex, {
        sdfFirst: sdfIndex,
        sdfCount: sdfs.length,
        invert: edit.invert,
        rgbaBlendMode: rgbaBlendModeToNumber(edit.rgbaBlendMode),
        softEdge: edit.softEdge,
        sdfSmooth: edit.sdfSmooth
      }) || updated;
      let sdfUpdated = false;
      for (const sdf of sdfs) {
        sizes.set(sdf.scale.x, sdf.scale.y, sdf.scale.z, sdf.radius);
        sdf.scale.setScalar(1);
        sdf.updateMatrixWorld();
        const worldToSdf = sdf.matrixWorld.clone().invert();
        worldToSdf.decompose(center, quaternion, scale);
        sdf.scale.set(sizes.x, sizes.y, sizes.z);
        sdf.updateMatrixWorld();
        values[0].set(sdf.color.r, sdf.color.g, sdf.color.b, sdf.opacity);
        values[1].set(sdf.displace.x, sdf.displace.y, sdf.displace.z, 1);
        sdfUpdated = this.encodeSdf(
          sdfIndex,
          {
            sdfType: sdfTypeToNumber(sdf.type),
            invert: sdf.invert,
            center,
            quaternion,
            scale,
            sizes
          },
          values
        ) || sdfUpdated;
        sdfIndex += 1;
      }
      this.numSdfs = sdfIndex;
      if (sdfUpdated) {
        this.sdfTexture.needsUpdate = true;
      }
      updated || (updated = sdfUpdated);
    }
    return { updated, dynoUpdated };
  }
  // Modify a Gsplat in a dyno shader program using the current edits and SDFs.
  modify(gsplat) {
    return applyGsplatRgbaDisplaceEdits(
      gsplat,
      this.dynoSdfArray,
      this.dynoNumEdits,
      this.dynoEdits
    );
  }
}
const SdfArray = { type: "SdfArray" };
const defineSdfArray = unindent(`
  struct SdfArray {
    int numSdfs;
    usampler2D sdfTexture;
  };

  void unpackSdfArray(
    usampler2D sdfTexture, int sdfIndex, out uint flags,
    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,
    int numValues, out vec4 values[4]
  ) {
    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);
    flags = temp.w;
    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);
    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);
    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);
    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    for (int i = 0; i < numValues; ++i) {
      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);
      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));
    }
  }

  const uint SDF_FLAG_TYPE = 0xFFu;
  const uint SDF_FLAG_INVERT = 1u << 8u;

  const uint SDF_TYPE_ALL = 0u;
  const uint SDF_TYPE_PLANE = 1u;
  const uint SDF_TYPE_SPHERE = 2u;
  const uint SDF_TYPE_BOX = 3u;
  const uint SDF_TYPE_ELLIPSOID = 4u;
  const uint SDF_TYPE_CYLINDER = 5u;
  const uint SDF_TYPE_CAPSULE = 6u;
  const uint SDF_TYPE_INFINITE_CONE = 7u;

  float evaluateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 outValues[4]
  ) {
    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;
    float maxExp = -1.0 / 0.0;
    for (int i = 0; i < numValues; ++i) {
        outValues[i] = vec4(0.0);
    }

    uint flags;
    vec3 center, scale;
    vec4 quaternion, sizes;
    vec4 values[4];

    int sdfLast = min(sdfFirst + sdfCount, numSdfs);
    for (int index = sdfFirst; index < sdfLast; ++index) {
      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);
      uint sdfType = flags & SDF_FLAG_TYPE;
      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;

      float distance;
      switch (sdfType) {
        case SDF_TYPE_ALL:
          distance = -1.0 / 0.0;
          break;
        case SDF_TYPE_PLANE: {
          distance = sdfPos.z;
          break;
        }
        case SDF_TYPE_SPHERE: {
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_BOX: {
          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;
          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;
          break;
        }
        case SDF_TYPE_ELLIPSOID: {
          vec3 sizes = sizes.xyz;
          float k0 = length(sdfPos / sizes);
          float k1 = length(sdfPos / dot(sizes, sizes));
          distance = k0 * (k0 - 1.0) / k1;
          break;
        }
        case SDF_TYPE_CYLINDER: {
          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;
          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
          break;
        }
        case SDF_TYPE_CAPSULE: {
          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_INFINITE_CONE: {
          float angle = 0.25 * PI * sizes.w;
          vec2 c = vec2(sin(angle), cos(angle));
          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);
          float d = length(q - c * max(dot(q, c), 0.0));
          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);
          break;
        }
      }

      if ((flags & SDF_FLAG_INVERT) != 0u) {
        distance = -distance;
      }

      if (smoothK == 0.0) {
        if (distance < distanceAccum) {
          distanceAccum = distance;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] = values[i];
          }
        }
      } else {
        float scaledDistance = -distance / smoothK;
        if (scaledDistance > maxExp) {
          float scale = exp(maxExp - scaledDistance);
          distanceAccum *= scale;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] *= scale;
          }
          maxExp = scaledDistance;
        }

        float weight = exp(scaledDistance - maxExp);
        distanceAccum += weight;
        for (int i = 0; i < numValues; ++i) {
          outValues[i] += weight * values[i];
        }
      }
    }

    if (smoothK == 0.0) {
      return distanceAccum;
    } else {
      // Very distant SDFs may result in 0 accumulation
      if (distanceAccum == 0.0) {
        return 1.0 / 0.0;
      }
      for (int i = 0; i < numValues; ++i) {
        outValues[i] /= distanceAccum;
      }
      return (-log(distanceAccum) - maxExp) * smoothK;
    }
  }

  float modulateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 values[4],
    float softEdge, bool invert
  ) {
    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);
    if (invert) {
      distance = -distance;
    }

    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)
      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);
  }
`);
const defineEdit = unindent(`
  const uint EDIT_FLAG_BLEND = 0xFFu;
  const uint EDIT_BLEND_MULTIPLY = 0u;
  const uint EDIT_BLEND_SET_RGB = 1u;
  const uint EDIT_BLEND_ADD_RGBA = 2u;
  const uint EDIT_FLAG_INVERT = 0x100u;

  void decodeEdit(
    uvec4 packedEdit, out int sdfFirst, out int sdfCount,
    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth
  ) {
    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;
    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;

    sdfFirst = int(packedEdit.y & 0xFFFFu);
    sdfCount = int(packedEdit.y >> 16u);

    softEdge = uintBitsToFloat(packedEdit.z);
    sdfSmooth = uintBitsToFloat(packedEdit.w);
  }

  void applyRgbaDisplaceEdit(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,
    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba
  ) {
    vec4 values[4];
    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);
    // On Android, moving values[0] is necessary to work around a compiler bug.
    vec4 sdfRgba = values[0];
    vec4 sdfDisplaceScale = values[1];

    vec4 target;
    switch (rgbaBlendMode) {
      case EDIT_BLEND_MULTIPLY:
        target = rgba * sdfRgba;
        break;
      case EDIT_BLEND_SET_RGB:
        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);
        break;
      case EDIT_BLEND_ADD_RGBA:
        target = rgba + sdfRgba;
        break;
      default:
        // Debug output if blend mode not set
        target = vec4(fract(pos), 1.0);
    }
    rgba = mix(rgba, target, modulate);
    pos += sdfDisplaceScale.xyz * modulate;
  }

  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {
    int sdfFirst, sdfCount;
    bool invert;
    uint rgbaBlendMode;
    float softEdge, sdfSmooth;
    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);
    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);
  }
`);
function applyGsplatRgbaDisplaceEdits(gsplat, sdfArray, numEdits, rgbaDisplaceEdits) {
  const dyno2 = new Dyno({
    inTypes: {
      gsplat: Gsplat,
      sdfArray: SdfArray,
      numEdits: "int",
      rgbaDisplaceEdits: "uvec4"
    },
    outTypes: { gsplat: Gsplat },
    globals: () => [defineSdfArray, defineEdit],
    inputs: { gsplat, sdfArray, numEdits, rgbaDisplaceEdits },
    statements: ({ inputs, outputs }) => {
      const { sdfArray: sdfArray2, numEdits: numEdits2, rgbaDisplaceEdits: rgbaDisplaceEdits2 } = inputs;
      const { gsplat: gsplat2 } = outputs;
      return unindentLines(`
        ${gsplat2} = ${inputs.gsplat};
        if (isGsplatActive(${gsplat2}.flags)) {
          for (int editIndex = 0; editIndex < ${numEdits2}; ++editIndex) {
            applyPackedRgbaDisplaceEdit(
              ${rgbaDisplaceEdits2}[editIndex], ${sdfArray2}.sdfTexture, ${sdfArray2}.numSdfs,
              ${gsplat2}.center, ${gsplat2}.rgba
            );
          }
        }
      `);
    }
  });
  return dyno2.outputs.gsplat;
}
const tempFloat32 = new Float32Array(1);
class SplatModifier {
  constructor(modifier) {
    this.modifier = modifier;
    this.cache = /* @__PURE__ */ new Map();
  }
  apply(generator) {
    let modified = this.cache.get(generator);
    if (!modified) {
      modified = dynoBlock(
        { index: "int" },
        { gsplat: Gsplat },
        ({ index }) => {
          const { gsplat } = generator.apply({ index });
          return this.modifier.apply({ gsplat });
        }
      );
      this.cache.set(generator, modified);
    }
    return modified;
  }
}
class SplatTransformer {
  // Create the dyno uniforms that parameterize the transform, setting them
  // to initial values that are different from any valid transform.
  constructor() {
    this.scale = new DynoFloat({ value: Number.NEGATIVE_INFINITY });
    this.rotate = new DynoVec4({
      value: new THREE.Quaternion(
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY
      )
    });
    this.translate = new DynoVec3({
      value: new THREE.Vector3(
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY
      )
    });
  }
  // Apply the transform to a Vec3 position in a dyno program.
  apply(position) {
    return transformPos(position, {
      scale: this.scale,
      rotate: this.rotate,
      translate: this.translate
    });
  }
  applyDir(dir) {
    return transformDir(dir, {
      rotate: this.rotate
    });
  }
  // Apply the transform to a Gsplat in a dyno program.
  applyGsplat(gsplat) {
    return transformGsplat(gsplat, {
      scale: this.scale,
      rotate: this.rotate,
      translate: this.translate
    });
  }
  // Update the uniforms to match the given transform matrix.
  updateFromMatrix(transform) {
    const scale = new THREE.Vector3();
    const quaternion = new THREE.Quaternion();
    const position = new THREE.Vector3();
    transform.decompose(position, quaternion, scale);
    const newScale = (scale.x + scale.y + scale.z) / 3;
    let updated = false;
    if (newScale !== this.scale.value) {
      this.scale.value = newScale;
      updated = true;
    }
    if (!position.equals(this.translate.value)) {
      this.translate.value.copy(position);
      updated = true;
    }
    if (!quaternion.equals(this.rotate.value)) {
      this.rotate.value.copy(quaternion);
      updated = true;
    }
    return updated;
  }
  // Update this transform to match the object's to-world transform.
  update(object) {
    object.updateMatrixWorld();
    return this.updateFromMatrix(object.matrixWorld);
  }
}
class SplatGenerator extends THREE.Object3D {
  constructor({
    numSplats,
    generator,
    construct,
    update
  }) {
    super();
    this.numSplats = numSplats ?? 0;
    this.generator = generator;
    this.frameUpdate = update;
    this.version = 0;
    this.mappingVersion = 0;
    if (construct) {
      const constructed = construct(this);
      Object.assign(this, constructed);
    }
  }
  updateVersion() {
    this.version += 1;
  }
  updateMappingVersion() {
    this.mappingVersion += 1;
    this.version += 1;
  }
  set needsUpdate(value) {
    if (value) {
      this.updateVersion();
    }
  }
}
const _SplatMesh = class _SplatMesh extends SplatGenerator {
  constructor(options = {}) {
    const context = {
      transform: new SplatTransformer(),
      viewToWorld: new SplatTransformer(),
      worldToView: new SplatTransformer(),
      viewToObject: new SplatTransformer(),
      recolor: new DynoVec4({
        value: new THREE.Vector4().setScalar(Number.NEGATIVE_INFINITY)
      }),
      time: new DynoFloat({ value: 0 }),
      deltaTime: new DynoFloat({ value: 0 }),
      numSplats: new DynoInt({ value: 0 }),
      splats: new DynoPackedSplats(),
      enableLod: new DynoBool({ value: false }),
      lodIndices: new DynoUsampler2D({
        value: emptyLodIndices,
        key: "lodIndices"
      })
    };
    super({
      update: (context2) => this.update(context2)
    });
    this.isInitialized = false;
    this.recolor = new THREE.Color(1, 1, 1);
    this.opacity = 1;
    this.enableViewToObject = false;
    this.enableViewToWorld = false;
    this.enableWorldToView = false;
    this.skinning = null;
    this.edits = null;
    this.rgbaDisplaceEdits = null;
    this.splatRgba = null;
    this.maxSh = 3;
    this.packedSplats = options.packedSplats ?? new PackedSplats();
    this.packedSplats.splatEncoding = options.splatEncoding ?? {
      ...DEFAULT_SPLAT_ENCODING
    };
    this.numSplats = this.packedSplats.numSplats;
    this.editable = options.editable ?? true;
    this.onFrame = options.onFrame;
    this.context = context;
    this.objectModifier = options.objectModifier;
    this.worldModifier = options.worldModifier;
    this.enableLod = options.enableLod;
    this.lodScale = options.lodScale ?? 1;
    this.outsideFoveate = options.outsideFoveate;
    this.behindFoveate = options.behindFoveate;
    this.updateGenerator();
    if (options.url || options.fileBytes || options.constructSplats || options.packedSplats && !options.packedSplats.isInitialized) {
      this.initialized = this.asyncInitialize(options).then(async () => {
        this.updateGenerator();
        this.isInitialized = true;
        if (options.onLoad) {
          const maybePromise = options.onLoad(this);
          if (maybePromise instanceof Promise) {
            await maybePromise;
          }
        }
        return this;
      });
    } else {
      this.isInitialized = true;
      this.initialized = Promise.resolve(this);
      if (options.onLoad) {
        const maybePromise = options.onLoad(this);
        if (maybePromise instanceof Promise) {
          this.initialized = maybePromise.then(() => this);
        }
      }
    }
  }
  async asyncInitialize(options) {
    const {
      url,
      fileBytes,
      fileType,
      fileName,
      maxSplats,
      constructSplats,
      onProgress,
      splatEncoding,
      lod,
      nonLod
    } = options;
    if (url || fileBytes || constructSplats) {
      const packedSplatsOptions = {
        url,
        fileBytes,
        fileType,
        fileName,
        maxSplats,
        construct: constructSplats,
        onProgress,
        splatEncoding,
        lod,
        nonLod
      };
      this.packedSplats.reinitialize(packedSplatsOptions);
    }
    if (this.packedSplats) {
      await this.packedSplats.initialized;
      this.numSplats = this.packedSplats.numSplats;
      this.updateGenerator();
    }
  }
  static async staticInitialize() {
    await __wbg_init();
    _SplatMesh.isStaticInitialized = true;
  }
  // Creates a new Gsplat with the provided parameters (all values in "float" space,
  // i.e. 0-1 for opacity and color) and adds it to the end of the packedSplats,
  // increasing numSplats by 1. If necessary, reallocates the buffer with an exponential
  // doubling strategy to fit the new data, so it's fairly efficient to just
  // pushSplat(...) each Gsplat you want to create in a loop.
  pushSplat(center, scales, quaternion, opacity, color) {
    this.packedSplats.pushSplat(center, scales, quaternion, opacity, color);
  }
  // This method iterates over all Gsplats in this instance's packedSplats,
  // invoking the provided callback with index: number in 0..=(this.numSplats-1) and
  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,
  // opacity: number (0..1), and color: THREE.Color (rgb values in 0..1).
  // Note that the objects passed in as center etc. are the same for every callback
  // invocation: these objects are reused for efficiency. Changing these values has
  // no effect as they are decoded/unpacked copies of the underlying data. To update
  // the packedSplats, call .packedSplats.setSplat(index, center, scales,
  // quaternion, opacity, color).
  forEachSplat(callback) {
    this.packedSplats.forEachSplat(callback);
  }
  // Call this when you are finished with the SplatMesh and want to free
  // any buffers it holds (via packedSplats).
  dispose() {
    this.packedSplats.dispose();
  }
  // Returns axis-aligned bounding box of the SplatMesh. If centers_only is true,
  // only the centers of the splats are used to compute the bounding box.
  // IMPORTANT: This should only be called after the SplatMesh is initialized.
  getBoundingBox(centers_only = true) {
    if (!this.initialized) {
      throw new Error(
        "Cannot get bounding box before SplatMesh is initialized"
      );
    }
    const minVec = new THREE.Vector3(
      Number.POSITIVE_INFINITY,
      Number.POSITIVE_INFINITY,
      Number.POSITIVE_INFINITY
    );
    const maxVec = new THREE.Vector3(
      Number.NEGATIVE_INFINITY,
      Number.NEGATIVE_INFINITY,
      Number.NEGATIVE_INFINITY
    );
    const corners = new THREE.Vector3();
    const signs = [-1, 1];
    this.packedSplats.forEachSplat(
      (_index, center, scales, quaternion, _opacity, _color) => {
        if (centers_only) {
          minVec.min(center);
          maxVec.max(center);
        } else {
          for (const x of signs) {
            for (const y of signs) {
              for (const z of signs) {
                corners.set(x * scales.x, y * scales.y, z * scales.z);
                corners.applyQuaternion(quaternion);
                corners.add(center);
                minVec.min(corners);
                maxVec.max(corners);
              }
            }
          }
        }
      }
    );
    const box = new THREE.Box3(minVec, maxVec);
    return box;
  }
  constructGenerator(context) {
    const { transform, viewToObject, recolor } = context;
    const generator = dynoBlock(
      { index: "int" },
      { gsplat: Gsplat },
      ({ index }) => {
        if (!index) {
          throw new Error("index is undefined");
        }
        index = maybeLookupIndex(
          context.lodIndices,
          index,
          context.numSplats,
          context.enableLod
        );
        let gsplat = readPackedSplat(context.splats, index);
        if (this.maxSh >= 1) {
          const { sh1Texture, sh2Texture, sh3Texture } = this.ensureShTextures();
          if (sh1Texture) {
            let rescaleSh = function(sNorm, minMax) {
              const { x: min2, y: max2 } = split(minMax).outputs;
              const mid = mul(add(min2, max2), dynoConst("float", 0.5));
              const scale = mul(sub(max2, min2), dynoConst("float", 0.5));
              return add(mid, mul(sNorm, scale));
            };
            const viewCenterInObject = viewToObject.translate;
            const { center } = splitGsplat(gsplat).outputs;
            const viewDir = normalize(sub(center, viewCenterInObject));
            const sh1Snorm = evaluateSH1(gsplat, sh1Texture, viewDir);
            let rgb = rescaleSh(sh1Snorm, this.packedSplats.dynoSh1MinMax);
            if (this.maxSh >= 2 && sh2Texture) {
              const sh2Snorm = evaluateSH2(gsplat, sh2Texture, viewDir);
              rgb = add(
                rgb,
                rescaleSh(sh2Snorm, this.packedSplats.dynoSh2MinMax)
              );
            }
            if (this.maxSh >= 3 && sh3Texture) {
              const sh3Snorm = evaluateSH3(gsplat, sh3Texture, viewDir);
              rgb = add(
                rgb,
                rescaleSh(sh3Snorm, this.packedSplats.dynoSh3MinMax)
              );
            }
            let { rgba } = splitGsplat(gsplat).outputs;
            rgba = add(rgba, extendVec(rgb, dynoConst("float", 0)));
            gsplat = combineGsplat({ gsplat, rgba });
          }
        }
        if (this.splatRgba) {
          const rgba = readRgbaArray(this.splatRgba.dyno, index);
          gsplat = combineGsplat({ gsplat, rgba });
        }
        if (this.skinning) {
          gsplat = this.skinning.modify(gsplat);
        }
        if (this.objectModifier) {
          gsplat = this.objectModifier.apply({ gsplat }).gsplat;
        }
        gsplat = transform.applyGsplat(gsplat);
        const recolorRgba = mul(recolor, splitGsplat(gsplat).outputs.rgba);
        gsplat = combineGsplat({ gsplat, rgba: recolorRgba });
        if (this.rgbaDisplaceEdits) {
          gsplat = this.rgbaDisplaceEdits.modify(gsplat);
        }
        if (this.worldModifier) {
          gsplat = this.worldModifier.apply({ gsplat }).gsplat;
        }
        return { gsplat };
      }
    );
    this.generator = generator;
  }
  // Call this whenever something changes in the Gsplat processing pipeline,
  // for example changing maxSh or updating objectModifier or worldModifier.
  // Compiled generators are cached for efficiency and re-use when the same
  // pipeline structure emerges after successive changes.
  updateGenerator() {
    this.constructGenerator(this.context);
  }
  // This is called automatically by SparkRenderer and you should not have to
  // call it. It updates parameters for the generated pipeline and calls
  // updateGenerator() if the pipeline needs to change.
  update({
    renderer,
    time,
    deltaTime,
    viewToWorld,
    camera,
    renderSize,
    globalEdits,
    lodIndices
  }) {
    var _a2;
    this.context.time.value = time;
    this.context.deltaTime.value = deltaTime;
    _SplatMesh.dynoTime.value = time;
    const { transform, viewToObject, recolor } = this.context;
    let updated = transform.update(this);
    if (this.context.viewToWorld.updateFromMatrix(viewToWorld) && this.enableViewToWorld) {
      updated = true;
    }
    const worldToView = viewToWorld.clone().invert();
    if (this.context.worldToView.updateFromMatrix(worldToView) && this.enableWorldToView) {
      updated = true;
    }
    const objectToWorld = new THREE.Matrix4().compose(
      transform.translate.value,
      transform.rotate.value,
      new THREE.Vector3().setScalar(transform.scale.value)
    );
    const worldToObject = objectToWorld.invert();
    const viewToObjectMatrix = worldToObject.multiply(viewToWorld);
    if (viewToObject.updateFromMatrix(viewToObjectMatrix) && (this.enableViewToObject || this.packedSplats.extra.sh1)) {
      updated = true;
    }
    new THREE.Vector3().setFromMatrixColumn(
      viewToObjectMatrix,
      3
    );
    new THREE.Vector3().setFromMatrixColumn(viewToObjectMatrix, 2).negate().normalize();
    const newRecolor = new THREE.Vector4(
      this.recolor.r,
      this.recolor.g,
      this.recolor.b,
      this.opacity
    );
    if (!newRecolor.equals(recolor.value)) {
      recolor.value.copy(newRecolor);
      updated = true;
    }
    const edits = this.editable ? (this.edits ?? []).concat(globalEdits) : [];
    if (this.editable && !this.edits) {
      this.traverseVisible((node) => {
        if (node instanceof SplatEdit) {
          edits.push(node);
        }
      });
    }
    edits.sort((a, b) => a.ordering - b.ordering);
    const editsSdfs = edits.map((edit) => {
      if (edit.sdfs != null) {
        return { edit, sdfs: edit.sdfs };
      }
      const sdfs = [];
      edit.traverseVisible((node) => {
        if (node instanceof SplatEditSdf) {
          sdfs.push(node);
        }
      });
      return { edit, sdfs };
    });
    if (editsSdfs.length > 0 && !this.rgbaDisplaceEdits) {
      const edits2 = editsSdfs.length;
      const sdfs = editsSdfs.reduce(
        (total, edit) => total + edit.sdfs.length,
        0
      );
      this.rgbaDisplaceEdits = new SplatEdits({
        maxEdits: edits2,
        maxSdfs: sdfs
      });
      this.updateGenerator();
    }
    if (this.rgbaDisplaceEdits) {
      const editResult = this.rgbaDisplaceEdits.update(editsSdfs);
      updated || (updated = editResult.updated);
      if (editResult.dynoUpdated) {
        this.updateGenerator();
      }
    }
    this.context.enableLod.value = this.packedSplats.lodSplats != null && lodIndices != null;
    if (this.enableLod !== void 0) {
      this.context.enableLod.value = this.enableLod;
    }
    this.context.lodIndices.value = (lodIndices == null ? void 0 : lodIndices.texture) ?? emptyLodIndices;
    this.context.splats.packedSplats = this.packedSplats;
    this.numSplats = this.packedSplats.numSplats;
    if (this.context.enableLod.value) {
      this.context.splats.packedSplats = this.packedSplats.lodSplats;
      this.numSplats = (lodIndices == null ? void 0 : lodIndices.numSplats) ?? 0;
    }
    this.context.numSplats.value = this.numSplats;
    if (updated) {
      this.updateVersion();
    }
    (_a2 = this.onFrame) == null ? void 0 : _a2.call(this, { mesh: this, time, deltaTime });
  }
  // This method conforms to the standard THREE.Raycaster API, performing object-ray
  // intersections using this method to populate the provided intersects[] array
  // with each intersection point.
  raycast(raycaster, intersects) {
    var _a2, _b2;
    if (!this.packedSplats.packedArray || !this.packedSplats.numSplats) {
      return;
    }
    const { near, far, ray } = raycaster;
    const worldToMesh = this.matrixWorld.clone().invert();
    const worldToMeshRot = new THREE.Matrix3().setFromMatrix4(worldToMesh);
    const origin = ray.origin.clone().applyMatrix4(worldToMesh);
    const direction = ray.direction.clone().applyMatrix3(worldToMeshRot);
    const scales = new THREE.Vector3();
    worldToMesh.decompose(new THREE.Vector3(), new THREE.Quaternion(), scales);
    (scales.x * scales.y * scales.z) ** (1 / 3);
    const RAYCAST_ELLIPSOID = true;
    const distances = raycast_splats(
      origin.x,
      origin.y,
      origin.z,
      direction.x,
      direction.y,
      direction.z,
      near,
      far,
      this.packedSplats.numSplats,
      this.packedSplats.packedArray,
      RAYCAST_ELLIPSOID,
      ((_a2 = this.packedSplats.splatEncoding) == null ? void 0 : _a2.lnScaleMin) ?? LN_SCALE_MIN,
      ((_b2 = this.packedSplats.splatEncoding) == null ? void 0 : _b2.lnScaleMax) ?? LN_SCALE_MAX
    );
    for (const distance2 of distances) {
      const point = ray.direction.clone().multiplyScalar(distance2).add(ray.origin);
      intersects.push({
        distance: distance2,
        point,
        object: this
      });
    }
  }
  ensureShTextures() {
    if (!this.packedSplats.extra.sh1) {
      return {};
    }
    let sh1Texture = this.packedSplats.extra.sh1Texture;
    if (!sh1Texture) {
      let sh1 = this.packedSplats.extra.sh1;
      const { width, height, depth, maxSplats } = getTextureSize(
        sh1.length / 2
      );
      if (sh1.length < maxSplats * 2) {
        const newSh1 = new Uint32Array(maxSplats * 2);
        newSh1.set(sh1);
        this.packedSplats.extra.sh1 = newSh1;
        sh1 = newSh1;
      }
      const texture2 = new THREE.DataArrayTexture(sh1, width, height, depth);
      texture2.format = THREE.RGIntegerFormat;
      texture2.type = THREE.UnsignedIntType;
      texture2.internalFormat = "RG32UI";
      texture2.needsUpdate = true;
      sh1Texture = new DynoUsampler2DArray({
        value: texture2,
        key: "sh1"
      });
      this.packedSplats.extra.sh1Texture = sh1Texture;
    }
    if (!this.packedSplats.extra.sh2) {
      return { sh1Texture };
    }
    let sh2Texture = this.packedSplats.extra.sh2Texture;
    if (!sh2Texture) {
      let sh2 = this.packedSplats.extra.sh2;
      const { width, height, depth, maxSplats } = getTextureSize(
        sh2.length / 4
      );
      if (sh2.length < maxSplats * 4) {
        const newSh2 = new Uint32Array(maxSplats * 4);
        newSh2.set(sh2);
        this.packedSplats.extra.sh2 = newSh2;
        sh2 = newSh2;
      }
      const texture2 = new THREE.DataArrayTexture(sh2, width, height, depth);
      texture2.format = THREE.RGBAIntegerFormat;
      texture2.type = THREE.UnsignedIntType;
      texture2.internalFormat = "RGBA32UI";
      texture2.needsUpdate = true;
      sh2Texture = new DynoUsampler2DArray({
        value: texture2,
        key: "sh2"
      });
      this.packedSplats.extra.sh2Texture = sh2Texture;
    }
    if (!this.packedSplats.extra.sh3) {
      return { sh1Texture, sh2Texture };
    }
    let sh3Texture = this.packedSplats.extra.sh3Texture;
    if (!sh3Texture) {
      let sh3 = this.packedSplats.extra.sh3;
      const { width, height, depth, maxSplats } = getTextureSize(
        sh3.length / 4
      );
      if (sh3.length < maxSplats * 4) {
        const newSh3 = new Uint32Array(maxSplats * 4);
        newSh3.set(sh3);
        this.packedSplats.extra.sh3 = newSh3;
        sh3 = newSh3;
      }
      const texture2 = new THREE.DataArrayTexture(sh3, width, height, depth);
      texture2.format = THREE.RGBAIntegerFormat;
      texture2.type = THREE.UnsignedIntType;
      texture2.internalFormat = "RGBA32UI";
      texture2.needsUpdate = true;
      sh3Texture = new DynoUsampler2DArray({
        value: texture2,
        key: "sh3"
      });
      this.packedSplats.extra.sh3Texture = sh3Texture;
    }
    return { sh1Texture, sh2Texture, sh3Texture };
  }
  // ensureLodIndices() {
  //   if (this.lodState) {
  //     const maxSplats = Math.min(this.packedSplats.numSplats, 16 * 1048576);
  //     const numSplats = Math.max(16384, Math.min(this.lodMaxSplats, maxSplats));
  //     const rows = Math.ceil(numSplats / 16384);
  //     const capacity = rows * 16384;
  //     if (capacity > this.lodState.indices.length) {
  //       this.context.lodIndices.value.dispose();
  //       this.lodState.indices = new Uint32Array(capacity);
  //       this.context.lodIndices.value = new THREE.DataTexture(
  //         this.lodState.indices,
  //         4096,
  //         rows,
  //         THREE.RGBAIntegerFormat,
  //         THREE.UnsignedIntType,
  //       );
  //       this.context.lodIndices.value.internalFormat = "RGBA32UI";
  //       this.context.lodIndices.value.needsUpdate = true;
  //     }
  //   }
  // }
};
_SplatMesh.staticInitialized = _SplatMesh.staticInitialize();
_SplatMesh.isStaticInitialized = false;
_SplatMesh.dynoTime = new DynoFloat({ value: 0 });
let SplatMesh = _SplatMesh;
const defineEvaluateSH1 = unindent(`
  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {
    // Extract sint7 values packed into 2 x uint32
    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;
    vec3 sh1_0 = vec3(ivec3(
      int(packed.x << 25u) >> 25,
      int(packed.x << 18u) >> 25,
      int(packed.x << 11u) >> 25
    )) / 63.0;
    vec3 sh1_1 = vec3(ivec3(
      int(packed.x << 4u) >> 25,
      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,
      int(packed.y << 22u) >> 25
    )) / 63.0;
    vec3 sh1_2 = vec3(ivec3(
      int(packed.y << 15u) >> 25,
      int(packed.y << 8u) >> 25,
      int(packed.y << 1u) >> 25
    )) / 63.0;

    return sh1_0 * (-0.4886025 * viewDir.y)
      + sh1_1 * (0.4886025 * viewDir.z)
      + sh1_2 * (-0.4886025 * viewDir.x);
  }
`);
const defineEvaluateSH2 = unindent(`
  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {
    // Extract sint8 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);
    vec3 sh2_0 = vec3(ivec3(
      int(packed.x << 24u) >> 24,
      int(packed.x << 16u) >> 24,
      int(packed.x << 8u) >> 24
    )) / 127.0;
    vec3 sh2_1 = vec3(ivec3(
      int(packed.x) >> 24,
      int(packed.y << 24u) >> 24,
      int(packed.y << 16u) >> 24
    )) / 127.0;
    vec3 sh2_2 = vec3(ivec3(
      int(packed.y << 8u) >> 24,
      int(packed.y) >> 24,
      int(packed.z << 24u) >> 24
    )) / 127.0;
    vec3 sh2_3 = vec3(ivec3(
      int(packed.z << 16u) >> 24,
      int(packed.z << 8u) >> 24,
      int(packed.z) >> 24
    )) / 127.0;
    vec3 sh2_4 = vec3(ivec3(
      int(packed.w << 24u) >> 24,
      int(packed.w << 16u) >> 24,
      int(packed.w << 8u) >> 24
    )) / 127.0;

    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)
      + sh2_1 * (-1.0925484 * viewDir.y * viewDir.z)
      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))
      + sh2_3 * (-1.0925484 * viewDir.x * viewDir.z)
      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));
  }
`);
const defineEvaluateSH3 = unindent(`
  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {
    // Extract sint6 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);
    vec3 sh3_0 = vec3(ivec3(
      int(packed.x << 26u) >> 26,
      int(packed.x << 20u) >> 26,
      int(packed.x << 14u) >> 26
    )) / 31.0;
    vec3 sh3_1 = vec3(ivec3(
      int(packed.x << 8u) >> 26,
      int(packed.x << 2u) >> 26,
      int((packed.x >> 4u) | (packed.y << 28u)) >> 26
    )) / 31.0;
    vec3 sh3_2 = vec3(ivec3(
      int(packed.y << 22u) >> 26,
      int(packed.y << 16u) >> 26,
      int(packed.y << 10u) >> 26
    )) / 31.0;
    vec3 sh3_3 = vec3(ivec3(
      int(packed.y << 4u) >> 26,
      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,
      int(packed.z << 24u) >> 26
    )) / 31.0;
    vec3 sh3_4 = vec3(ivec3(
      int(packed.z << 18u) >> 26,
      int(packed.z << 12u) >> 26,
      int(packed.z << 6u) >> 26
    )) / 31.0;
    vec3 sh3_5 = vec3(ivec3(
      int(packed.z) >> 26,
      int(packed.w << 26u) >> 26,
      int(packed.w << 20u) >> 26
    )) / 31.0;
    vec3 sh3_6 = vec3(ivec3(
      int(packed.w << 14u) >> 26,
      int(packed.w << 8u) >> 26,
      int(packed.w << 2u) >> 26
    )) / 31.0;

    float xx = viewDir.x * viewDir.x;
    float yy = viewDir.y * viewDir.y;
    float zz = viewDir.z * viewDir.z;
    float xy = viewDir.x * viewDir.y;
    float yz = viewDir.y * viewDir.z;
    float zx = viewDir.z * viewDir.x;

    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))
      + sh3_1 * (2.8906114 * xy * viewDir.z) +
      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))
      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))
      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))
      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))
      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));
  }
`);
function evaluateSH1(gsplat, sh1, viewDir) {
  return dyno$1({
    inTypes: { gsplat: Gsplat, sh1: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat, sh1, viewDir },
    globals: () => [defineGsplat, defineEvaluateSH1],
    statements: ({ inputs, outputs }) => {
      const statements = unindentLines(`
        if (isGsplatActive(${inputs.gsplat}.flags)) {
          ${outputs.rgb} = evaluateSH1(${inputs.gsplat}, ${inputs.sh1}, ${inputs.viewDir});
        } else {
          ${outputs.rgb} = vec3(0.0);
        }
      `);
      return statements;
    }
  }).outputs.rgb;
}
function evaluateSH2(gsplat, sh2, viewDir) {
  return dyno$1({
    inTypes: { gsplat: Gsplat, sh2: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat, sh2, viewDir },
    globals: () => [defineGsplat, defineEvaluateSH2],
    statements: ({ inputs, outputs }) => unindentLines(`
        if (isGsplatActive(${inputs.gsplat}.flags)) {
          ${outputs.rgb} = evaluateSH2(${inputs.gsplat}, ${inputs.sh2}, ${inputs.viewDir});
        } else {
          ${outputs.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
function evaluateSH3(gsplat, sh3, viewDir) {
  return dyno$1({
    inTypes: { gsplat: Gsplat, sh3: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat, sh3, viewDir },
    globals: () => [defineGsplat, defineEvaluateSH3],
    statements: ({ inputs, outputs }) => unindentLines(`
        if (isGsplatActive(${inputs.gsplat}.flags)) {
          ${outputs.rgb} = evaluateSH3(${inputs.gsplat}, ${inputs.sh3}, ${inputs.viewDir});
        } else {
          ${outputs.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
function maybeLookupIndex(lodIndices, index, numSplats, enableLod) {
  return dyno$1({
    inTypes: {
      lodIndices: "usampler2D",
      index: "int",
      numSplats: "int",
      enableLod: "bool"
    },
    outTypes: {
      index: "int"
    },
    inputs: {
      lodIndices,
      index,
      numSplats,
      enableLod
    },
    statements: ({ inputs, outputs }) => unindentLines(`
        if (${inputs.index} >= ${inputs.numSplats}) {
          return;
        }
        if (${inputs.enableLod}) {
          ivec2 lodIndexCoord = ivec2((${inputs.index} >> 2) & 4095, ${inputs.index} >> 14);
          uint splatIndex = texelFetch(${inputs.lodIndices}, lodIndexCoord, 0)[${inputs.index} & 3];
          ${outputs.index} = int(splatIndex);
        } else {
          ${outputs.index} = ${inputs.index};
        }
      `)
  }).outputs.index;
}
const emptyLodIndices = (() => {
  const texture2 = new THREE.DataTexture(
    new Uint32Array(16384),
    4096,
    1,
    THREE.RGBAIntegerFormat,
    THREE.UnsignedIntType
  );
  texture2.internalFormat = "RGBA32UI";
  texture2.needsUpdate = true;
  return texture2;
})();
new THREE.BufferGeometry();
new THREE.ShaderMaterial();
const PLY_PROPERTY_TYPES = [
  "char",
  "uchar",
  "short",
  "ushort",
  "int",
  "uint",
  "float",
  "double"
];
const _PlyReader = class _PlyReader {
  // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet
  constructor({ fileBytes }) {
    this.header = "";
    this.littleEndian = true;
    this.elements = {};
    this.comments = [];
    this.data = null;
    this.numSplats = 0;
    this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;
  }
  // Identify and parse the PLY text header (assumed to be <64KB in size).
  // this.elements will contain all the elements in the file, typically
  // "vertex" contains the Gsplat data.
  async parseHeader() {
    const bufferStream = new ReadableStream({
      start: (controller) => {
        controller.enqueue(this.fileBytes.slice(0, 65536));
        controller.close();
      }
    });
    const decoder = bufferStream.pipeThrough(new TextDecoderStream()).getReader();
    this.header = "";
    const headerTerminator = "end_header\n";
    while (true) {
      const { value, done } = await decoder.read();
      if (done) {
        throw new Error("Failed to read header");
      }
      this.header += value;
      const endHeader = this.header.indexOf(headerTerminator);
      if (endHeader >= 0) {
        this.header = this.header.slice(0, endHeader + headerTerminator.length);
        break;
      }
    }
    const headerLen = new TextEncoder().encode(this.header).length;
    this.data = new DataView(this.fileBytes.buffer, headerLen);
    this.elements = {};
    let curElement = null;
    this.comments = [];
    this.header.trim().split("\n").forEach((line, lineIndex) => {
      const trimmedLine = line.trim();
      if (lineIndex === 0) {
        if (trimmedLine !== "ply") {
          throw new Error("Invalid PLY header");
        }
        return;
      }
      if (trimmedLine.length === 0) {
        return;
      }
      const fields = trimmedLine.split(" ");
      switch (fields[0]) {
        case "format":
          if (fields[1] === "binary_little_endian") {
            this.littleEndian = true;
          } else if (fields[1] === "binary_big_endian") {
            this.littleEndian = false;
          } else {
            throw new Error(`Unsupported PLY format: ${fields[1]}`);
          }
          if (fields[2] !== "1.0") {
            throw new Error(`Unsupported PLY version: ${fields[2]}`);
          }
          break;
        case "end_header":
          break;
        case "comment":
          this.comments.push(trimmedLine.slice("comment ".length));
          break;
        case "element": {
          const name = fields[1];
          curElement = {
            name,
            count: Number.parseInt(fields[2]),
            properties: {}
          };
          this.elements[name] = curElement;
          break;
        }
        case "property":
          if (curElement == null) {
            throw new Error("Property must be inside an element");
          }
          if (fields[1] === "list") {
            curElement.properties[fields[4]] = {
              isList: true,
              type: fields[3],
              countType: fields[2]
            };
          } else {
            curElement.properties[fields[2]] = {
              isList: false,
              type: fields[1]
            };
          }
          break;
      }
    });
    if (this.elements.vertex) {
      this.numSplats = this.elements.vertex.count;
    }
  }
  parseData(elementCallback) {
    let offset = 0;
    const data = this.data;
    if (data == null) {
      throw new Error("No data to parse");
    }
    for (const elementName in this.elements) {
      const element = this.elements[elementName];
      const { count, properties } = element;
      const item = createEmptyItem(properties);
      const parseFn = createParseFn(properties, this.littleEndian);
      const callback = elementCallback(element) ?? (() => {
      });
      for (let index = 0; index < count; index++) {
        offset = parseFn(data, offset, item);
        callback(index, item);
      }
    }
  }
  // Parse all the Gsplat data in the PLY file in go, invoking the given
  // callbacks for each Gsplat.
  parseSplats(splatCallback, shCallback) {
    if (this.elements.vertex == null) {
      throw new Error("No vertex element found");
    }
    let isSuperSplat = false;
    const ssChunks = [];
    let numSh = 0;
    let sh1Props = [];
    let sh2Props = [];
    let sh3Props = [];
    let sh1 = void 0;
    let sh2 = void 0;
    let sh3 = void 0;
    function prepareSh() {
      const num_f_rest = NUM_SH_TO_NUM_F_REST[numSh];
      sh1Props = new Array(3).fill(null).flatMap((_, k) => [0, 1, 2].map((_2, d) => k + d * num_f_rest / 3));
      sh2Props = new Array(5).fill(null).flatMap(
        (_, k) => [0, 1, 2].map((_2, d) => 3 + k + d * num_f_rest / 3)
      );
      sh3Props = new Array(7).fill(null).flatMap(
        (_, k) => [0, 1, 2].map((_2, d) => 8 + k + d * num_f_rest / 3)
      );
      sh1 = numSh >= 1 ? new Float32Array(3 * 3) : void 0;
      sh2 = numSh >= 2 ? new Float32Array(5 * 3) : void 0;
      sh3 = numSh >= 3 ? new Float32Array(7 * 3) : void 0;
    }
    function ssShCallback(index, item) {
      if (!sh1) {
        throw new Error("Missing sh1");
      }
      const sh = item.f_rest;
      for (let i = 0; i < sh1Props.length; i++) {
        sh1[i] = sh[sh1Props[i]] * 8 / 255 - 4;
      }
      if (sh2) {
        for (let i = 0; i < sh2Props.length; i++) {
          sh2[i] = sh[sh2Props[i]] * 8 / 255 - 4;
        }
      }
      if (sh3) {
        for (let i = 0; i < sh3Props.length; i++) {
          sh3[i] = sh[sh3Props[i]] * 8 / 255 - 4;
        }
      }
      shCallback == null ? void 0 : shCallback(index, sh1, sh2, sh3);
    }
    function initSuperSplat(element) {
      const {
        min_x,
        min_y,
        min_z,
        max_x,
        max_y,
        max_z,
        min_scale_x,
        min_scale_y,
        min_scale_z,
        max_scale_x,
        max_scale_y,
        max_scale_z
      } = element.properties;
      if (!min_x || !min_y || !min_z || !max_x || !max_y || !max_z || !min_scale_x || !min_scale_y || !min_scale_z || !max_scale_x || !max_scale_y || !max_scale_z) {
        throw new Error("Missing PLY chunk properties");
      }
      isSuperSplat = true;
      return (index, item) => {
        const {
          min_x: min_x2,
          min_y: min_y2,
          min_z: min_z2,
          max_x: max_x2,
          max_y: max_y2,
          max_z: max_z2,
          min_scale_x: min_scale_x2,
          min_scale_y: min_scale_y2,
          min_scale_z: min_scale_z2,
          max_scale_x: max_scale_x2,
          max_scale_y: max_scale_y2,
          max_scale_z: max_scale_z2,
          min_r,
          min_g,
          min_b,
          max_r,
          max_g,
          max_b
        } = item;
        ssChunks.push({
          min_x: min_x2,
          min_y: min_y2,
          min_z: min_z2,
          max_x: max_x2,
          max_y: max_y2,
          max_z: max_z2,
          min_scale_x: min_scale_x2,
          min_scale_y: min_scale_y2,
          min_scale_z: min_scale_z2,
          max_scale_x: max_scale_x2,
          max_scale_y: max_scale_y2,
          max_scale_z: max_scale_z2,
          min_r,
          min_g,
          min_b,
          max_r,
          max_g,
          max_b
        });
      };
    }
    function decodeSuperSplat(element) {
      if (shCallback && element.name === "sh") {
        numSh = getNumSh(element.properties);
        prepareSh();
        return ssShCallback;
      }
      if (element.name !== "vertex") {
        return null;
      }
      const { packed_position, packed_rotation, packed_scale, packed_color } = element.properties;
      if (!packed_position || !packed_rotation || !packed_scale || !packed_color) {
        throw new Error(
          "Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color"
        );
      }
      const SQRT2 = Math.sqrt(2);
      return (index, item) => {
        const chunk = ssChunks[index >>> 8];
        if (chunk == null) {
          throw new Error("Missing PLY chunk");
        }
        const {
          min_x,
          min_y,
          min_z,
          max_x,
          max_y,
          max_z,
          min_scale_x,
          min_scale_y,
          min_scale_z,
          max_scale_x,
          max_scale_y,
          max_scale_z,
          min_r,
          min_g,
          min_b,
          max_r,
          max_g,
          max_b
        } = chunk;
        const { packed_position: packed_position2, packed_rotation: packed_rotation2, packed_scale: packed_scale2, packed_color: packed_color2 } = item;
        const x = (packed_position2 >>> 21 & 2047) / 2047 * (max_x - min_x) + min_x;
        const y = (packed_position2 >>> 11 & 1023) / 1023 * (max_y - min_y) + min_y;
        const z = (packed_position2 & 2047) / 2047 * (max_z - min_z) + min_z;
        const r0 = ((packed_rotation2 >>> 20 & 1023) / 1023 - 0.5) * SQRT2;
        const r1 = ((packed_rotation2 >>> 10 & 1023) / 1023 - 0.5) * SQRT2;
        const r2 = ((packed_rotation2 & 1023) / 1023 - 0.5) * SQRT2;
        const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));
        const rOrder = packed_rotation2 >>> 30;
        const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;
        const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;
        const quatZ = rOrder <= 2 ? r2 : rr;
        const quatW = rOrder === 0 ? rr : r0;
        const scaleX = Math.exp(
          (packed_scale2 >>> 21 & 2047) / 2047 * (max_scale_x - min_scale_x) + min_scale_x
        );
        const scaleY = Math.exp(
          (packed_scale2 >>> 11 & 1023) / 1023 * (max_scale_y - min_scale_y) + min_scale_y
        );
        const scaleZ = Math.exp(
          (packed_scale2 & 2047) / 2047 * (max_scale_z - min_scale_z) + min_scale_z
        );
        const r = (packed_color2 >>> 24 & 255) / 255 * ((max_r ?? 1) - (min_r ?? 0)) + (min_r ?? 0);
        const g = (packed_color2 >>> 16 & 255) / 255 * ((max_g ?? 1) - (min_g ?? 0)) + (min_g ?? 0);
        const b = (packed_color2 >>> 8 & 255) / 255 * ((max_b ?? 1) - (min_b ?? 0)) + (min_b ?? 0);
        const opacity = (packed_color2 & 255) / 255;
        splatCallback(
          index,
          x,
          y,
          z,
          scaleX,
          scaleY,
          scaleZ,
          quatX,
          quatY,
          quatZ,
          quatW,
          opacity,
          r,
          g,
          b
        );
      };
    }
    const elementCallback = (element) => {
      if (element.name === "chunk") {
        return initSuperSplat(element);
      }
      if (isSuperSplat) {
        return decodeSuperSplat(element);
      }
      if (element.name !== "vertex") {
        return null;
      }
      const {
        x,
        y,
        z,
        scale_0,
        scale_1,
        scale_2,
        rot_0,
        rot_1,
        rot_2,
        rot_3,
        opacity,
        f_dc_0,
        f_dc_1,
        f_dc_2,
        red,
        green,
        blue,
        alpha
      } = element.properties;
      if (!x || !y || !z) {
        throw new Error("Missing PLY properties: x, y, z");
      }
      const hasScales = scale_0 && scale_1 && scale_2;
      const hasRots = rot_0 && rot_1 && rot_2 && rot_3;
      const alphaDiv = alpha != null ? FIELD_SCALE[alpha.type] : 1;
      const redDiv = red != null ? FIELD_SCALE[red.type] : 1;
      const greenDiv = green != null ? FIELD_SCALE[green.type] : 1;
      const blueDiv = blue != null ? FIELD_SCALE[blue.type] : 1;
      numSh = getNumSh(element.properties);
      prepareSh();
      return (index, item) => {
        const scaleX = hasScales ? Math.exp(item.scale_0) : _PlyReader.defaultPointScale;
        const scaleY = hasScales ? Math.exp(item.scale_1) : _PlyReader.defaultPointScale;
        const scaleZ = hasScales ? Math.exp(item.scale_2) : _PlyReader.defaultPointScale;
        const quatX = hasRots ? item.rot_1 : 0;
        const quatY = hasRots ? item.rot_2 : 0;
        const quatZ = hasRots ? item.rot_3 : 0;
        const quatW = hasRots ? item.rot_0 : 1;
        const op = opacity != null ? 1 / (1 + Math.exp(-item.opacity)) : alpha != null ? item.alpha / alphaDiv : 1;
        const r = f_dc_0 != null ? item.f_dc_0 * SH_C0$1 + 0.5 : red != null ? item.red / redDiv : 1;
        const g = f_dc_1 != null ? item.f_dc_1 * SH_C0$1 + 0.5 : green != null ? item.green / greenDiv : 1;
        const b = f_dc_2 != null ? item.f_dc_2 * SH_C0$1 + 0.5 : blue != null ? item.blue / blueDiv : 1;
        splatCallback(
          index,
          item.x,
          item.y,
          item.z,
          scaleX,
          scaleY,
          scaleZ,
          quatX,
          quatY,
          quatZ,
          quatW,
          op,
          r,
          g,
          b
        );
        if (shCallback && sh1) {
          const sh = item.f_rest;
          if (sh1) {
            for (let i = 0; i < sh1Props.length; i++) {
              sh1[i] = sh[sh1Props[i]];
            }
          }
          if (sh2) {
            for (let i = 0; i < sh2Props.length; i++) {
              sh2[i] = sh[sh2Props[i]];
            }
          }
          if (sh3) {
            for (let i = 0; i < sh3Props.length; i++) {
              sh3[i] = sh[sh3Props[i]];
            }
          }
          shCallback(index, sh1, sh2, sh3);
        }
      };
    };
    this.parseData(elementCallback);
  }
  // Inject RGBA values into original PLY file, which can be used to modify
  // the color/opacity of the Gsplats and write out the modified PLY file.
  injectRgba(rgba) {
    let offset = 0;
    const data = this.data;
    if (data == null) {
      throw new Error("No parsed data");
    }
    if (rgba.length !== this.numSplats * 4) {
      throw new Error("Invalid RGBA array length");
    }
    for (const elementName in this.elements) {
      const element = this.elements[elementName];
      const { count, properties } = element;
      const parsers = [];
      let rgbaOffset = 0;
      const isVertex = elementName === "vertex";
      if (isVertex) {
        for (const name of ["opacity", "f_dc_0", "f_dc_1", "f_dc_2"]) {
          if (!properties[name] || properties[name].type !== "float") {
            throw new Error(`Can't injectRgba due to property: ${name}`);
          }
        }
      }
      for (const [propertyName, property] of Object.entries(properties)) {
        if (!property.isList) {
          if (isVertex) {
            if (propertyName === "f_dc_0" || propertyName === "f_dc_1" || propertyName === "f_dc_2") {
              const component = Number.parseInt(
                propertyName.slice("f_dc_".length)
              );
              parsers.push(() => {
                const value = (rgba[rgbaOffset + component] / 255 - 0.5) / SH_C0$1;
                SET_FIELD[property.type](
                  data,
                  offset,
                  this.littleEndian,
                  value
                );
              });
            } else if (propertyName === "opacity") {
              parsers.push(() => {
                const value = Math.max(
                  -100,
                  Math.min(
                    100,
                    -Math.log(1 / (rgba[rgbaOffset + 3] / 255) - 1)
                  )
                );
                SET_FIELD[property.type](
                  data,
                  offset,
                  this.littleEndian,
                  value
                );
              });
            }
          }
          parsers.push(() => {
            offset += FIELD_BYTES[property.type];
          });
        } else {
          parsers.push(() => {
            const length2 = PARSE_FIELD[property.countType](
              data,
              offset,
              this.littleEndian
            );
            offset += FIELD_BYTES[property.countType];
            offset += length2 * FIELD_BYTES[property.type];
          });
        }
      }
      for (let index = 0; index < count; index++) {
        for (const parser of parsers) {
          parser();
        }
        if (isVertex) {
          rgbaOffset += 4;
        }
      }
    }
  }
};
_PlyReader.defaultPointScale = 1e-3;
let PlyReader = _PlyReader;
const SH_C0$1 = 0.28209479177387814;
const PARSE_FIELD = {
  char: (data, offset, littleEndian) => {
    return data.getInt8(offset);
  },
  uchar: (data, offset, littleEndian) => {
    return data.getUint8(offset);
  },
  short: (data, offset, littleEndian) => {
    return data.getInt16(offset, littleEndian);
  },
  ushort: (data, offset, littleEndian) => {
    return data.getUint16(offset, littleEndian);
  },
  int: (data, offset, littleEndian) => {
    return data.getInt32(offset, littleEndian);
  },
  uint: (data, offset, littleEndian) => {
    return data.getUint32(offset, littleEndian);
  },
  float: (data, offset, littleEndian) => {
    return data.getFloat32(offset, littleEndian);
  },
  double: (data, offset, littleEndian) => {
    return data.getFloat64(offset, littleEndian);
  }
};
const SET_FIELD = {
  char: (data, offset, littleEndian, value) => {
    data.setInt8(offset, value);
  },
  uchar: (data, offset, littleEndian, value) => {
    data.setUint8(offset, value);
  },
  short: (data, offset, littleEndian, value) => {
    data.setInt16(offset, value, littleEndian);
  },
  ushort: (data, offset, littleEndian, value) => {
    data.setUint16(offset, value, littleEndian);
  },
  int: (data, offset, littleEndian, value) => {
    data.setInt32(offset, value, littleEndian);
  },
  uint: (data, offset, littleEndian, value) => {
    data.setUint32(offset, value, littleEndian);
  },
  float: (data, offset, littleEndian, value) => {
    data.setFloat32(offset, value, littleEndian);
  },
  double: (data, offset, littleEndian, value) => {
    data.setFloat64(offset, value, littleEndian);
  }
};
const FIELD_BYTES = {
  char: 1,
  uchar: 1,
  short: 2,
  ushort: 2,
  int: 4,
  uint: 4,
  float: 4,
  double: 8
};
const FIELD_SCALE = {
  char: 127,
  uchar: 255,
  short: 32767,
  ushort: 65535,
  int: 2147483647,
  uint: 4294967295,
  float: 1,
  double: 1
};
const NUM_F_REST_TO_NUM_SH = {
  0: 0,
  9: 1,
  24: 2,
  45: 3
};
const NUM_SH_TO_NUM_F_REST = {
  0: 0,
  1: 9,
  2: 24,
  3: 45
};
const F_REST_REGEX = /^f_rest_([0-9]{1,2})$/;
function createEmptyItem(properties) {
  const item = {};
  for (const [propertyName, property] of Object.entries(properties)) {
    if (F_REST_REGEX.test(propertyName)) {
      item.f_rest = new Array(getNumSh(properties));
    } else {
      item[propertyName] = property.isList ? [] : 0;
    }
  }
  return item;
}
function createParseFn(properties, littleEndian) {
  if (safeToCompile(properties)) {
    return createCompiledParserFn(properties, littleEndian);
  }
  return createDynamicParserFn(properties, littleEndian);
}
const UNSAFE_EVAL_ALLOWED = (() => {
  try {
    new Function("return 42;");
  } catch (e) {
    return false;
  }
  return true;
})();
const PROPERTY_NAME_REGEX = /^[a-zA-Z0-9_]+$/;
function safeToCompile(properties) {
  if (!UNSAFE_EVAL_ALLOWED) {
    return false;
  }
  for (const [propertyName, property] of Object.entries(properties)) {
    if (!PROPERTY_NAME_REGEX.test(propertyName)) {
      return false;
    }
    if (property.isList && !PLY_PROPERTY_TYPES.includes(property.countType)) {
      return false;
    }
    if (!PLY_PROPERTY_TYPES.includes(property.type)) {
      return false;
    }
  }
  return true;
}
function createCompiledParserFn(properties, littleEndian) {
  const parserSrc = ["let list;"];
  for (const [propertyName, property] of Object.entries(properties)) {
    const fRestMatch = propertyName.match(F_REST_REGEX);
    if (fRestMatch) {
      const fRestIndex = +fRestMatch[1];
      parserSrc.push(
        /*js*/
        `
        item.f_rest[${fRestIndex}] = PARSE_FIELD['${property.type}'](data, offset, ${littleEndian});
        offset += ${FIELD_BYTES[property.type]};
      `
      );
    } else if (!property.isList) {
      parserSrc.push(
        /*js*/
        `
        item['${propertyName}'] = PARSE_FIELD['${property.type}'](data, offset, ${littleEndian});
        offset += ${FIELD_BYTES[property.type]};
      `
      );
    } else {
      parserSrc.push(
        /*js*/
        `
        list = item['${propertyName}'];
        list.length = PARSE_FIELD['${property.countType}'](data, offset, ${littleEndian});
        offset += ${FIELD_BYTES[property.countType]};
        for (let i = 0; i < list.length; i++) {
          list[i] = PARSE_FIELD['${property.type}'](data, offset, ${littleEndian});
          offset += ${FIELD_BYTES[property.type]};
        }
      `
      );
    }
  }
  parserSrc.push("return offset;");
  const fn = new Function(
    "data",
    "offset",
    "item",
    "PARSE_FIELD",
    parserSrc.join("\n")
  );
  return (data, offset, item) => fn(data, offset, item, PARSE_FIELD);
}
function createDynamicParserFn(properties, littleEndian) {
  const parsers = [];
  for (const [propertyName, property] of Object.entries(properties)) {
    const fRestMatch = propertyName.match(F_REST_REGEX);
    if (fRestMatch) {
      const fRestIndex = +fRestMatch[1];
      parsers.push(
        (data, offset, item) => {
          item.f_rest[fRestIndex] = PARSE_FIELD[property.type](
            data,
            offset,
            littleEndian
          );
          return offset + FIELD_BYTES[property.type];
        }
      );
    } else if (!property.isList) {
      parsers.push(
        (data, offset, item) => {
          item[propertyName] = PARSE_FIELD[property.type](
            data,
            offset,
            littleEndian
          );
          return offset + FIELD_BYTES[property.type];
        }
      );
    } else {
      parsers.push(
        (data, offset, item) => {
          const list = item[propertyName];
          list.length = PARSE_FIELD[property.countType](
            data,
            offset,
            littleEndian
          );
          let currentOffset = offset + FIELD_BYTES[property.countType];
          for (let i = 0; i < list.length; i++) {
            list[i] = PARSE_FIELD[property.type](
              data,
              currentOffset,
              littleEndian
            );
            currentOffset += FIELD_BYTES[property.type];
          }
          return currentOffset;
        }
      );
    }
  }
  return (data, offset, item) => {
    let currentOffset = offset;
    for (let parserIndex = 0; parserIndex < parsers.length; parserIndex++) {
      currentOffset = parsers[parserIndex](data, currentOffset, item);
    }
    return currentOffset;
  };
}
function getNumSh(properties) {
  let num_f_rest = 0;
  while (properties[`f_rest_${num_f_rest}`]) {
    num_f_rest += 1;
  }
  const numSh = NUM_F_REST_TO_NUM_SH[num_f_rest];
  if (numSh == null) {
    throw new Error(`Unsupported number of SH coefficients: ${num_f_rest}`);
  }
  return numSh;
}
const jsContent = '(function() {\n  "use strict";\n  let wasm;\n  function addToExternrefTable0(obj) {\n    const idx = wasm.__externref_table_alloc();\n    wasm.__wbindgen_export_2.set(idx, obj);\n    return idx;\n  }\n  function handleError(f, args) {\n    try {\n      return f.apply(this, args);\n    } catch (e) {\n      const idx = addToExternrefTable0(e);\n      wasm.__wbindgen_exn_store(idx);\n    }\n  }\n  function debugString(val) {\n    const type = typeof val;\n    if (type == "number" || type == "boolean" || val == null) {\n      return `${val}`;\n    }\n    if (type == "string") {\n      return `"${val}"`;\n    }\n    if (type == "symbol") {\n      const description = val.description;\n      if (description == null) {\n        return "Symbol";\n      } else {\n        return `Symbol(${description})`;\n      }\n    }\n    if (type == "function") {\n      const name = val.name;\n      if (typeof name == "string" && name.length > 0) {\n        return `Function(${name})`;\n      } else {\n        return "Function";\n      }\n    }\n    if (Array.isArray(val)) {\n      const length = val.length;\n      let debug = "[";\n      if (length > 0) {\n        debug += debugString(val[0]);\n      }\n      for (let i2 = 1; i2 < length; i2++) {\n        debug += ", " + debugString(val[i2]);\n      }\n      debug += "]";\n      return debug;\n    }\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches && builtInMatches.length > 1) {\n      className = builtInMatches[1];\n    } else {\n      return toString.call(val);\n    }\n    if (className == "Object") {\n      try {\n        return "Object(" + JSON.stringify(val) + ")";\n      } catch (_) {\n        return "Object";\n      }\n    }\n    if (val instanceof Error) {\n      return `${val.name}: ${val.message}\n${val.stack}`;\n    }\n    return className;\n  }\n  let WASM_VECTOR_LEN = 0;\n  let cachedUint8ArrayMemory0 = null;\n  function getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n      cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n  }\n  const cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: () => {\n    throw Error("TextEncoder not available");\n  } };\n  const encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n  } : function(arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n      read: arg.length,\n      written: buf.length\n    };\n  };\n  function passStringToWasm0(arg, malloc, realloc) {\n    if (realloc === void 0) {\n      const buf = cachedTextEncoder.encode(arg);\n      const ptr2 = malloc(buf.length, 1) >>> 0;\n      getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);\n      WASM_VECTOR_LEN = buf.length;\n      return ptr2;\n    }\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n    const mem = getUint8ArrayMemory0();\n    let offset = 0;\n    for (; offset < len; offset++) {\n      const code = arg.charCodeAt(offset);\n      if (code > 127) break;\n      mem[ptr + offset] = code;\n    }\n    if (offset !== len) {\n      if (offset !== 0) {\n        arg = arg.slice(offset);\n      }\n      ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n      const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n      const ret = encodeString(arg, view);\n      offset += ret.written;\n      ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n  }\n  let cachedDataViewMemory0 = null;\n  function getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {\n      cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n  }\n  const cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {\n    throw Error("TextDecoder not available");\n  } };\n  if (typeof TextDecoder !== "undefined") {\n    cachedTextDecoder.decode();\n  }\n  function getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n  }\n  function takeFromExternrefTable0(idx) {\n    const value = wasm.__wbindgen_export_2.get(idx);\n    wasm.__externref_table_dealloc(idx);\n    return value;\n  }\n  function sort_splats(num_splats, readback, ordering) {\n    const ret = wasm.sort_splats(num_splats, readback, ordering);\n    return ret >>> 0;\n  }\n  function sort32_splats(num_splats, readback, ordering) {\n    const ret = wasm.sort32_splats(num_splats, readback, ordering);\n    return ret >>> 0;\n  }\n  function raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid, ln_scale_min, ln_scale_max) {\n    const ret = wasm.raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid, ln_scale_min, ln_scale_max);\n    return ret;\n  }\n  typeof FinalizationRegistry === "undefined" ? {} : new FinalizationRegistry((ptr) => wasm.__wbg_chunkdecoder_free(ptr >>> 0, 1));\n  const GsplatArrayFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {\n  }, unregister: () => {\n  } } : new FinalizationRegistry((ptr) => wasm.__wbg_gsplatarray_free(ptr >>> 0, 1));\n  class GsplatArray {\n    static __wrap(ptr) {\n      ptr = ptr >>> 0;\n      const obj = Object.create(GsplatArray.prototype);\n      obj.__wbg_ptr = ptr;\n      GsplatArrayFinalization.register(obj, obj.__wbg_ptr, obj);\n      return obj;\n    }\n    __destroy_into_raw() {\n      const ptr = this.__wbg_ptr;\n      this.__wbg_ptr = 0;\n      GsplatArrayFinalization.unregister(this);\n      return ptr;\n    }\n    free() {\n      const ptr = this.__destroy_into_raw();\n      wasm.__wbg_gsplatarray_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    get numSplats() {\n      const ret = wasm.__wbg_get_gsplatarray_numSplats(this.__wbg_ptr);\n      return ret >>> 0;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set numSplats(arg0) {\n      wasm.__wbg_set_gsplatarray_numSplats(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {number}\n     */\n    get maxShDegree() {\n      const ret = wasm.__wbg_get_gsplatarray_maxShDegree(this.__wbg_ptr);\n      return ret >>> 0;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set maxShDegree(arg0) {\n      wasm.__wbg_set_gsplatarray_maxShDegree(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {number}\n     */\n    len() {\n      const ret = wasm.gsplatarray_len(this.__wbg_ptr);\n      return ret >>> 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    has_lod() {\n      const ret = wasm.gsplatarray_has_lod(this.__wbg_ptr);\n      return ret !== 0;\n    }\n    /**\n     * @param {number} lod_base\n     */\n    quick_lod(lod_base) {\n      wasm.gsplatarray_quick_lod(this.__wbg_ptr, lod_base);\n    }\n    /**\n     * @returns {object}\n     */\n    to_packedsplats() {\n      const ret = wasm.gsplatarray_to_packedsplats(this.__wbg_ptr);\n      if (ret[2]) {\n        throw takeFromExternrefTable0(ret[1]);\n      }\n      return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @returns {object}\n     */\n    to_packedsplats_lod() {\n      const ret = wasm.gsplatarray_to_packedsplats_lod(this.__wbg_ptr);\n      if (ret[2]) {\n        throw takeFromExternrefTable0(ret[1]);\n      }\n      return takeFromExternrefTable0(ret[0]);\n    }\n  }\n  async function __wbg_load(module, imports) {\n    if (typeof Response === "function" && module instanceof Response) {\n      if (typeof WebAssembly.instantiateStreaming === "function") {\n        try {\n          return await WebAssembly.instantiateStreaming(module, imports);\n        } catch (e) {\n          if (module.headers.get("Content-Type") != "application/wasm") {\n            console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n", e);\n          } else {\n            throw e;\n          }\n        }\n      }\n      const bytes = await module.arrayBuffer();\n      return await WebAssembly.instantiate(bytes, imports);\n    } else {\n      const instance = await WebAssembly.instantiate(module, imports);\n      if (instance instanceof WebAssembly.Instance) {\n        return { instance, module };\n      } else {\n        return instance;\n      }\n    }\n  }\n  function __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\n      const ret = arg0.buffer;\n      return ret;\n    };\n    imports.wbg.__wbg_get_67b2ba62fc30de12 = function() {\n      return handleError(function(arg0, arg1) {\n        const ret = Reflect.get(arg0, arg1);\n        return ret;\n      }, arguments);\n    };\n    imports.wbg.__wbg_get_b9b93047fe3cf45b = function(arg0, arg1) {\n      const ret = arg0[arg1 >>> 0];\n      return ret;\n    };\n    imports.wbg.__wbg_gsplatarray_new = function(arg0) {\n      const ret = GsplatArray.__wrap(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_a446193dc22c12f8 = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_e2d2a49132c1b256 = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_new_405e22f390576ce2 = function() {\n      const ret = new Object();\n      return ret;\n    };\n    imports.wbg.__wbg_new_78feb108b6472713 = function() {\n      const ret = new Array();\n      return ret;\n    };\n    imports.wbg.__wbg_new_9fee97a409b32b68 = function(arg0) {\n      const ret = new Uint16Array(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_new_a12002a7f91c75be = function(arg0) {\n      const ret = new Uint8Array(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {\n      const ret = new Uint32Array(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(arg0, arg1, arg2) {\n      const ret = new Float32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(arg0, arg1, arg2) {\n      const ret = new Uint32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {\n      const ret = new Float32Array(arg0 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithlength_bd3de93688d68fbc = function(arg0) {\n      const ret = new Uint32Array(arg0 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_push_737cfc8c1432c2c6 = function(arg0, arg1) {\n      const ret = arg0.push(arg1);\n      return ret;\n    };\n    imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_3f1d0b984ed272ed = function(arg0, arg1, arg2) {\n      arg0[arg1] = arg2;\n    };\n    imports.wbg.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_bb8cecf6a62b9f46 = function() {\n      return handleError(function(arg0, arg1, arg2) {\n        const ret = Reflect.set(arg0, arg1, arg2);\n        return ret;\n      }, arguments);\n    };\n    imports.wbg.__wbg_set_d23661d19148b229 = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_subarray_769e1e0f81bb259b = function(arg0, arg1, arg2) {\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(arg0, arg1, arg2) {\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n      const ret = debugString(arg1);\n      const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n      const len1 = WASM_VECTOR_LEN;\n      getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n      getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbindgen_init_externref_table = function() {\n      const table = wasm.__wbindgen_export_2;\n      const offset = table.grow(4);\n      table.set(0, void 0);\n      table.set(offset + 0, void 0);\n      table.set(offset + 1, null);\n      table.set(offset + 2, true);\n      table.set(offset + 3, false);\n    };\n    imports.wbg.__wbindgen_is_falsy = function(arg0) {\n      const ret = !arg0;\n      return ret;\n    };\n    imports.wbg.__wbindgen_memory = function() {\n      const ret = wasm.memory;\n      return ret;\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n      const ret = arg0;\n      return ret;\n    };\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n      const ret = getStringFromWasm0(arg0, arg1);\n      return ret;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n      throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    return imports;\n  }\n  function __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedDataViewMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n    wasm.__wbindgen_start();\n    return wasm;\n  }\n  async function __wbg_init(module_or_path) {\n    if (wasm !== void 0) return wasm;\n    if (typeof module_or_path !== "undefined") {\n      if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n        ({ module_or_path } = module_or_path);\n      } else {\n        console.warn("using deprecated parameters for the initialization function; pass a single object instead");\n      }\n    }\n    if (typeof module_or_path === "undefined") {\n      module_or_path = new URL("data:application/wasm;base64,AGFzbQEAAAAB+ANEYAN/f38Bf2ACf38Bf2ACf38AYAF/AGABfwF/YAN/f38AYAADf39/YAR/f39/AGAFf39/f38AYAF9AX1gAABgAW8Bf2AGf39/f39/AGAAAX9gA29/fwFvYAV/f39/fwF/YAFvAW9gA29vfwBgBH9/f38Bf2ADf35+AGADf35+AX9gAX8Bb2AAAW9gB39/f39/f38AYAF/A39/f2ACf30AYAR/fX9/AX9gB39/f39/f38Bf2AGf39/f39/AX9gBH9/f38Df39/YAN/b28Bf2ACfX0BfWAAAn9/YAJ/fwFvYANvb28Bf2ABfAFvYANvb28AYAJvfwFvYAJvbwF/YAJvbwFvYAJ/bwBgCX9/f39/f39/fwBgBn9/fX9/fwBgBH9/fX0BfWACf34AYAN/fX8Bf2AEfn5/fwF+YAF/AX1gCX9/f39/f35+fgBgA39+fwBgAn9+AX9gA319fQF9YAF+AX9gDn99fX1/f39/f39/f39/A39/f2AJf39/f39/f39vA39/f2AIf39/f39/f38Df39/YA19fX19fX19fX9vf319AW9gBH9vf30Df39/YAN/b38Df39/YAJ/bwN/f39gAn9vAn9/YAV/f31/fwBgBH99f38AYAV/f3x/fwBgBH98f38AYAV/f35/fwBgBH9+f38AYAF8AX8CwQkjA3diZxVfX3diZ19nc3BsYXRhcnJheV9uZXcAFQN3YmcVX193YmluZGdlbl9zdHJpbmdfbmV3ACEDd2JnGl9fd2JnX3NldF9iYjhjZWNmNmE2MmI5ZjQ2ACIDd2JnH19fd2JnX3N1YmFycmF5XzNhYWVlYzg5YmIyNTQ0ZjAADgN3YmcaX193YmdfbmV3XzQwNWUyMmYzOTA1NzZjZTIAFgN3YmcVX193YmluZGdlbl9udW1iZXJfbmV3ACMDd2JnGl9fd2JnX3NldF8zZjFkMGI5ODRlZDI3MmVkACQDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfYmQzZGU5MzY4OGQ2OGZiYwAVA3diZx1fX3diZ19sZW5ndGhfYTQ0NjE5M2RjMjJjMTJmOAALA3diZx9fX3diZ19zdWJhcnJheV9hYTkwNjVmYTlkYzVkZjk2AA4Dd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABYDd2JnHV9fd2JnX2J1ZmZlcl82MDljYzNlZWU1MWVkMTU4ABADd2JnGl9fd2JnX25ld19hMTIwMDJhN2Y5MWM3NWJlABADd2JnGl9fd2JnX3NldF82NTU5NWJkZDg2OGIzMDA5ABEDd2JnHV9fd2JnX2xlbmd0aF9lMmQyYTQ5MTMyYzFiMjU2AAsDd2JnGl9fd2JnX2dldF9iOWI5MzA0N2ZlM2NmNDViACUDd2JnGl9fd2JnX25ld183OGZlYjEwOGI2NDcyNzEzABYDd2JnG19fd2JnX3B1c2hfNzM3Y2ZjOGMxNDMyYzJjNgAmA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAALA3diZx9fX3diZ19zdWJhcnJheV83NjllMWUwZjgxYmIyNTliAA4Dd2JnGl9fd2JnX25ld185ZmVlOTdhNDA5YjMyYjY4ABADd2JnGl9fd2JnX3NldF9mNGYxZjBkYWEzMDY5NmZjABEDd2JnHV9fd2JnX2xlbmd0aF82Y2E1Mjc2NjVkODk2OTRkAAsDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfNWE1ZWZlMzEzY2ZkNTlmMQAVA3diZx1fX3diZ19sZW5ndGhfM2I0ZjAyMjE4OGFlOGRiNgALA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9lNmI3ZTY5YWNkNGM3MzU0AA4Dd2JnGl9fd2JnX3NldF8xMGJhZDliZWUwZTljNThiABEDd2JnGl9fd2JnX2dldF82N2IyYmE2MmZjMzBkZTEyACcDd2JnE19fd2JpbmRnZW5faXNfZmFsc3kACwN3YmcaX193YmdfbmV3X2UzYjMyMWRjZmVmODlmYzcAEAN3YmcaX193Ymdfc2V0X2QyMzY2MWQxOTE0OGIyMjkAEQN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZjFkZWFkNDRkMWZjNzIxMgAOA3diZxBfX3diaW5kZ2VuX3Rocm93AAIDd2JnF19fd2JpbmRnZW5fZGVidWdfc3RyaW5nACgDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFibGUACgOxA68DBRkIAAQXAwMaBQIEAAoHASkBFwcEBAoHBAcFBwUIAQUBDAIIAgQEBQMCAwgBBwECBCoCKwkICQcDBAEH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g0IIhoSEICFCCIhCgICA+A+DICFCGIhCgID8B4OEICFCKIhCgP4DgyAhQjiIhISEICBC2KLR78Kp5b8tfoUiIEI4hiAgQoD+A4NCKIaEICBCgID8B4NCGIYgIEKAgID4D4NCCIaEhCAgQgiIQoCAgPgPgyAgQhiIQoCA/AeDhCAgQiiIQoD+A4MgIEI4iISEhEKOip+43Pep+HF+IiFCOIYgIUKA/gODQiiGhCAhQoCA/AeDQhiGICFCgICA+A+DQgiGhIQgIUIIiEKAgID4D4MgIUIYiEKAgPwHg4QgIUIoiEKA/gODICFCOIiEhIQgIEKOnuCShIe+nXF+hSAgiTcDcAJAIAMoAlgiBCADKAJUTwRAQv///////////wAhLUKAgICAgICAgIB/IS5CgICAgICAgICAfyEvQoCAgICAgICAgH8hMEL///////////8AITFC////////////ACEyDAELQoCAgICAgICAgH8hMEL///////////8AITJC////////////ACExQv///////////wAhLUKAgICAgICAgIB/IS9CgICAgICAgICAfyEuAkADQCAAKAIUIgIgBEsEQCAAKAIQIARB0ABsai4BTCADLgFSSg0DIAQgACgCCCICTw0CIAMpA3ghIyADKQNwISUgAyAAKAIEIARBMGxq/QAEACAD/QkCXP3nAf1oIjf9HwH8BCIqNwOIAiADKQOAASEgIAMgN/0fAvwEIis3A5ACIAMpA4gBISEgAyA3/R8A/AQiJzcDgAIgJSAlICNCA4UiIkI4hiAiQoD+A4NCKIaEICJCgID8B4NCGIYgIkKAgID4D4NCCIaEhCAjQgiIQoCAgPgPgyAjQhiIQoCA/AeDhCAjQiiIQoD+A4MgI0I4iISEhELSgaqbq/qC16d/fiIjQjiGICNCgP4Dg0IohoQgI0KAgPwHg0IYhiAjQoCAgPgPg0IIhoSEICNCCIhCgICA+A+DICNCGIhCgID8B4OEICNCKIhCgP4DgyAjQjiIhISEICJC2KLR78Kp5b8tfoVCrf7V5NSF/ajYAH58QrjYj/Dyh7nXxwB8ICAgKoUiKEI4hiAoQoD+A4NCKIaEIChCgID8B4NCGIYgKEKAgID4D4NCCIaEhCAoQgiIQoCAgPgPgyAoQhiIQoCA/AeDhCAoQiiIQoD+A4MgKEI4iISE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ASIGQQlPBEAgAygCZCEFIAMoAmghByAIDAELIAYhBSAIIQdBCCEGIAsLIQIgBCgCACEKIAUgBkYEQCADQeAAahCNAiADKAJkIQUgAygCaCEHIAghAgsgByAFQQJ0aiAKNgIAIAIgAigCAEEBajYCACATIARBBGoiBEcNAAsMAQsgDyACNgIACyADQcgCaiADQYABaikCADcDACADQbgCaiADQfAAav0AAgD9CwMAIAMgA/0AAmD9CwOoAgJAAkACQAJ/An8CQCADKALMAiIGQQlJIgxFBEAgAygCrAIiAg0BQQEMAwsgDiAGIgINARpBAQwCCyADKAKwAgsiBCgCACIFIAAoAhQiD08NASAAKAIQIgogBUHQAGxqLwFMIQUgAkEBRwRAIARBBGohBCACQQFrQf////8DcSECA0AgBCgCACIHIA9PDQQgCiAHQdAAbGouAUwiByAFwSIFIAUgB0gbIQUgBEEEaiEEIAJBAWsiAg0ACwsgBcEgAy8BUkECa8FKBEAgAyADKAK8ASIFIAMoArABIgJGBH8gA0GwAWpBuJ/CABD7ASADKAK8ASEFIAMoArABBSACCyADKAK4AUEBayIEaiICIAQgAiAESRsiAjYCuAEgAygCtAEgAkEsbGoiAiAWNgIAIAIgAykDqAI3AgQgAkEMaiADQbACav0AAwD9CwIAIAJBHGogA0HAAmr9AAMA/QsCACADIAVBAWo2ArwBQQAMAQsgAygCrAEiAiADKAKgASIERgRAIANBoAFqQcifwgAQ+wEgAygCoAEhBCADKAKsASECCyADKAKkASADKAKoASACaiIFIARBACAEIAVNG2tBLGxqIgUgFjYCACAFIAMpA6gCNwIEIAVBDGogA0GwAmr9AAMA/QsCACAFQRxqIANBwAJq/QADAP0LAgAgAyACQQFqNgKsAUEACyADKAKcASIKIAMoApQBRgRAQQAhByMAQSBrIhIkAAJAAkAgA0GUAWoiEygCACIPQf////8BSw0AQQQgD0EBdCICIAJBBE0bIgVBAnQiAkH8////B0sNACASIA8EfyASIA9BAnQ2AhwgEiATKAIENgIUQQQFQQALNgIYIBJBCGpBBCACIBJBFGoQiAIgEigCCEEBRw0BIBIoAhAaIBIoAgwhBwsgB0HYn8IAEIMDAAsgEigCDCECIBMgBTYCACATIAI2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yMIAIAQ2AgBBpMjCAEGkyMIAKAIAIAVqIgA2AgAgBCAAQQFyNgIEDAULQajIwgAgBDYCAEGgyMIAQaDIwgAoAgAgBWoiADYCACAEIABBAXI2AgQgACAEaiAANgIADAQLQQAhA0GkyMIAKAIAIgAgBU0NAEGkyMIAIAAgBWsiATYCAEGsyMIAQazIwgAoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQgAEEIag8LIAMPC0GcyMIAQZzIwgAoAgBBfiACKAIcd3E2AgALAkAgA0EQTwRAIAIgBUEDcjYCBCACIAVqIgEgA0EBcjYCBCABIANqIAM2AgAgA0GAAk8EQCABIAMQywEMAgsgA0H4AXFBkMbCAGohAAJ/QZjIwgAoAgAiBEEBIANBA3Z0IgNxRQRAQZjIwgAgAyAEcjYCACAADAELIAAoAggLIQMgACABNgIIIAMgATYCDCABIAA2AgwgASADNgIIDAELIAIgAyAFaiIAQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIECyACQQhqDwsgAUEIagvuFwIbfwJ8IwBBsARrIgMkACADQgA3A5gBIANCADcDkAEgA0IANwOIASADQgA3A4ABIANCADcDeCADQgA3A3AgA0IANwNoIANCADcDYCADQgA3A1ggA0IANwNQIANCADcDSCADQgA3A0AgA0IANwM4IANCADcDMCADQgA3AyggA0IANwMgIANCADcDGCADQgA3AxAgA0IANwMIIANCADcDACADQgA3A7gCIANCADcDsAIgA0IANwOoAiADQgA3A6ACIANCADcDmAIgA0IANwOQAiADQgA3A4gCIANCADcDgAIgA0IANwP4ASADQgA3A/ABIANCADcD6AEgA0IANwPgASADQgA3A9gBIANCADcD0AEgA0IANwPIASADQgA3A8ABIANCADcDuAEgA0IANwOwASADQgA3A6gBIANCADcDoAEgA0IANwPYAyADQgA3A9ADIANCADcDyAMgA0IANwPAAyADQgA3A7gDIANCADcDsAMgA0IANwOoAyADQgA3A6ADIANCADcDmAMgA0IANwOQAyADQgA3A4gDIANCADcDgAMgA0IANwP4AiADQgA3A/ACIANCADcD6AIgA0IANwPgAiADQgA3A9gCIANCADcD0AIgA0IANwPIAiADQgA3A8ACIANB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IgMgASABoqIgAUSnRjuMh83GPqJEdOfK4vkAKr+goiACIAMgAUSy+26JEBGBP6JEd6zLVFVVxb+goqCgtgwECyABRBgtRFT7Ifk/oCICIAIgAqIiAaIiAyABIAGioiABRKdGO4yHzcY+okR058ri+QAqv6CiIAIgAyABRLL7bokQEYE/okR3rMtUVVXFv6CioKC2DAMLIARBgICAzANPBEAgASABoiIBRIFeDP3//9+/okQAAAAAAADwP6AgASABoiICREI6BeFTVaU/oqAgASACoiABRGlQ7uBCk/k+okQnHg/oh8BWv6CioLYMAwsgBSAAQwAAgHuSOAIIIAUqAggaQwAAgD8MAgtEGC1EVPshGcBEGC1EVPshGUAgBkEAThsgAaAiASABoiIBRIFeDP3//9+/okQAAAAAAADwP6AgASABoiICREI6BeFTVaU/oqAgASACoiABRGlQ7uBCk/k+okQnHg/oh8BWv6CioLYMAQtEGC1EVPshCcBEGC1EVPshCUAgBkEAThsgAaAiASABoiIBRIFeDP3//9+/okQAAAAAAADwP6AgASABoiICREI6BeFTVaU/oqAgASACoiABRGlQ7uBCk/k+okQnHg/oh8BWv6CioLaMCyAFQRBqJAALvQcBCn8jAEEgayIIJAACQAJAIAEoAhBFBEAgAUF/NgIQIAMgAyACQQNqQXxxIAJrIgprQQdxQQAgAyAKTxsiBGshCSADIARJDQECQAJAAkACfwJAIARFDQACfyAEQQFrIAIgA2oiBUEBayIGLQAAQQpGDQAaIAYgAiAJaiIGRg0BIARBAmsgBUECayIHLQAAQQpGDQAaIAYgB0YNASAEQQNrIAVBA2siBy0AAEEKRg0AGiAGIAdGDQEgBEEEayAFQQRrIgctAABBCkYNABogBiAHRg0BIARBBWsgBUEFayIHLQAAQQpGDQAaIAYgB0YNASAEQQZrIAVBBmsiBy0AAEEKRg0AGiAGIAdGDQEgBEEHayAFQQdrIgUtAABBCkYNABogBSAGRg0BIARBeHILIAlqQQFqDAELIAogAyADIApLGyEMQQAgBGshCiACQQRrIQ0gBEF/cyACaiEHA0ACQCAHIQUgCiEEIAkiBiAMTQ0AIARBCGshCiAFQQhrIQdBgIKECCACIAZBCGsiCWooAgAiC0GKlKjQAHNrIAtyQYCChAggBiANaigCACILQYqUqNAAc2sgC3JxQYCBgoR4cUGAgYKEeEYNAQsLIAMgBkkNBgNAIAMgBGpFDQIgBEEBayEEIAMgBWogBUEBayEFLQAAQQpHDQALIAMgBGpBAWoLIgQgA00NASAIQQA2AhggCEEBNgIMIAhB8KvCADYCCCAIQgQ3AhAgCEEIakH4q8IAENoCAAsCQCABKAIcIgRFBEBBACEEDAELIAEoAhggBGpBAWstAABBCkcNAEEAIQQgAUEANgIcIAFBADoAIAsgASgCFCAEayADTQRAIAAgAUEUaiACIAMQlgIMAgsgAwRAIAEoAhggBGogAiAD/AoAAAsgAEEEOgAAIAEgAyAEajYCHAwBCwJAIAEoAhwiBUUNAAJAAkAgASgCFCAFayAETQRAIAhBCGogAUEUaiACIAQQlgIgCC0ACEEERg0BIAAgCCkDCDcCAAwECyAEBEAgASgCGCAFaiACIAT8CgAACyABIAQgBWoiBTYCHAwBCyABKAIcIQULIAVFDQAgAUEANgIcIAFBADoAIAsgAiAEaiEFIAMgBGsiAiABKAIUTwRAIAAgAUEUaiAFIAIQlgIMAQsgAgRAIAEoAhggBSAC/AoAAAsgAEEEOgAAIAEgAjYCHAsgASABKAIQQQFqNgIQIAhBIGokAA8LQZiywgAQuAIACyAJIANB3PzAABCuAwALIAYgA0Hs/MAAEKwDAAuyCAEFfyAAQQhrIgEgAEEEaygCACIDQXhxIgBqIQICQAJAIANBAXENACADQQJxRQ0BIAEoAgAiAyAAaiEAIAEgA2siAUGoyMIAKAIARgRAIAIoAgRBA3FBA0cNAUGgyMIAIAA2AgAgAiACKAIEQX5xNgIEIAEgAEEBcjYCBCACIAA2AgAPCyABIAMQtAELAkACQAJAAkACQAJAAkAgAigCBCIDQQJxRQRAIAJBrMjCACgCAEYNAiACQajIwgAoAgBGDQMgAiADQXhxIgIQtAEgASAAIAJqIgBBAXI2AgQgACABaiAANgIAIAFBqMjCACgCAEcNAUGgyMIAIAA2AgAPCyACIANBfnE2AgQgASAAQQFyNgIEIAAgAWogADYCAAsgAEGAAkkNAkEfIQIgAUIANwIQIABB////B00EQCAAQQYgAEEIdmciAmt2QQFxIAJBAXRrQT5qIQILIAEgAjYCHCACQQJ0QYDFwgBqIQNBASACdCIEQZzIwgAoAgBxDQMgAyABNgIAIAEgAzYCGCABIAE2AgwgASABNgIIQZzIwgBBnMjCACgCACAEcjYCAAwEC0GsyMIAIAE2AgBBpMjCAEGkyMIAKAIAIABqIgA2AgAgASAAQQFyNgIEQajIwgAoAgAgAUYEQEGgyMIAQQA2AgBBqMjCAEEANgIACyAAQbjIwgAoAgAiAk0NBUGsyMIAKAIAIgBFDQVBpMjCACgCACIDQSlJDQRBgMbCACEBA0AgACABKAIAIgVPBEAgACAFIAEoAgRqSQ0GCyABKAIIIQEMAAsAC0GoyMIAIAE2AgBBoMjCAEGgyMIAKAIAIABqIgA2AgAgASAAQQFyNgIEIAAgAWogADYCAA8LIABB+AFxQZDGwgBqIQICf0GYyMIAKAIAIgNBASAAQQN2dCIAcUUEQEGYyMIAIAAgA3I2AgAgAgwBCyACKAIICyEAIAIgATYCCCAAIAE2AgwgASACNgIMIAEgADYCCA8LAkACQCAAIAMoAgAiAygCBEF4cUYEQCADIQIMAQsgAEEZIAJBAXZrQQAgAkEfRxt0IQQDQCADIARBHXZBBHFqIgUoAhAiAkUNAiAEQQF0IQQgAiEDIAIoAgRBeHEgAEcNAAsLIAIoAggiACABNgIMIAIgATYCCCABQQA2AhggASACNgIMIAEgADYCCAwBCyAFQRBqIAE2AgAgASADNgIYIAEgATYCDCABIAE2AggLQQAhAUHAyMIAQcDIwgAoAgBBAWsiADYCACAADQFBiMbCACgCACIABEADQCABQQFqIQEgACgCCCIADQALC0HAyMIAQf8fIAEgAUH/H00bNgIADwtBiMbCACgCACIBBEADQCAEQQFqIQQgASgCCCIBDQALC0HAyMIAQf8fIAQgBEH/H00bNgIAIAIgA08NAEG4yMIAQX82AgALC7EHAQl/IwBB0ABrIgEkAEGBgMQAIQICQAJAIAAoAgQiBCAAKAIQIgNJDQAgACAEIANrIgQ2AgQgACAAKAIAIgIgA2oiCDYCAAJAAkAgA0ECRgRAIAItAAAiA0HBAGtBX3FBCmogA0EwayADQTlLGyIFQQ9LDQQgAi0AASIDQcEAa0FfcUEKaiADQTBrIANBOUsbIgNBEE8NBCAFQQR0IANyIgXAQQBODQFBgIDEACECIAVB/wFxIgNBwAFJDQMCf0ECIANB4AFJDQAaQQMgA0HwAUkNABogA0H4AU8NBEEECyEDQQAhAiABQQA6ABMgAUEAOwARIAEgBToAECABIAM2AgwgA0EBdEECayEJIAEgAUEQajYCCCABQRFqIQUDQCAEQQJJBEBBgIDEACECDAULIAAgBEECayIENgIEIAAgAiAIaiIGQQJqNgIAIAYtAAAiB0HBAGtBX3FBCmogB0EwayAHQTlLGyIHQQ9LDQUgBkEBai0AACIGQcEAa0FfcUEKaiAGQTBrIAZBOUsbIgZBEE8NBSAFIAdBBHQgBnI6AAAgBUEBaiEFIAkgAkECaiICRw0ACwwCC0Hon8IAQShBtIbCABDEAgALQQEhAyABQQE2AgwgAUEAOgATIAFBADsAESABIAU6ABAgASABQRBqNgIICyABQThqIAFBEGogAxB6QYCAxAAhAiABKAI4DQAgASgCPCEAIAEgASgCQCICNgIYIAEgADYCFCAAIAJqIQMCQCACRQ0AIAMCfyAALAAAIgJBAE4EQCACQf8BcSECIABBAWoMAQsgAC0AAUE/cSEFIAJBH3EhBCACQV9NBEAgBEEGdCAFciECIABBAmoMAQsgAC0AAkE/cSAFQQZ0ciEFIAJBcEkEQCAFIARBDHRyIQIgAEEDagwBCyAEQRJ0QYCA8ABxIAAtAANBP3EgBUEGdHJyIQIgAEEEagsiBEcEQCAELAAAGgwBCyACQYCAxABHDQELIAECf0EAIQIgAyAAayIEQRBPBEAgACAEEF0MAQsgACADRwRAA0AgAiAALAAAQb9/SmohAiAAQQFqIQAgBEEBayIEDQALCyACCzYCNCABQQQ2AiAgAUHEh8IANgIcIAFCAzcCKCABIAFBNGqtQoCAgIDgAIQ3A0ggASABQRRqrUKAgICA4ASENwNAIAEgAUEIaq1CgICAgPAEhDcDOCABIAFBOGo2AiQgAUEcakHkh8IAENoCAAsgAUHQAGokACACDwtBxIbCABCrAwAL4wcCCn8DeyABIAAgAEEDakF8cSICayIEaiIFQQNxIQZBACEBIAAgAkcEQANAIAEgACwAAEG/f0pqIQEgAEEBaiEAIARBAWoiBA0ACwsCQCAGRQ0AIAIgBUF8cWoiACwAAEG/f0ohAyAGQQFGDQAgAyAALAABQb9/SmohAyAGQQJGDQAgAyAALAACQb9/SmohAwsgBUECdiEEIAEgA2ohBQJAA0AgAiEDIARFDQFBwAEgBCAEQcABTxsiB0EDcSEIIAdBAnQhCUEAIQACQCAEQQRJDQAgB0ECdiIKQQFrQf////8AcSIBQQNPBEAgAiABQQFqIgtB/P///wFxIgZBBHRqIQL9DAAAAAAAAAAAAAAAAAAAAAAhDCAGIQEgAyEAA0AgAEE8aiAAQSxqIABBHGogAEEMav1cAgD9VgIAAf1WAgAC/VYCAAMiDf1NQQf9rQEgDUEG/a0B/VD9DAEBAQEBAQEBAQEBAQEBAQEiDf1OIABBOGogAEEoaiAAQRhqIABBCGr9XAIA/VYCAAH9VgIAAv1WAgADIg79TUEH/a0BIA5BBv2tAf1QIA39TiAAQTRqIABBJGogAEEUaiAAQQRq/VwCAP1WAgAB/VYCAAL9VgIAAyIO/U1BB/2tASAOQQb9rQH9UCAN/U4gAEEwaiAAQSBqIABBEGogAP1cAgD9VgIAAf1WAgAC/VYCAAMiDv1NQQf9rQEgDkEG/a0B/VAgDf1OIAz9rgH9rgH9rgH9rgEhDCAAQUBrIQAgAUEEayIBDQALIAwgDCAN/Q0ICQoLDA0ODwABAgMAAQID/a4BIgwgDCAM/Q0EBQYHAAECAwABAgMAAQID/a4B/RsAIQAgBiALRg0BCyADIApBBHRqIQEDQCAAIAIoAgAiAEF/c0EHdiAAQQZ2ckGBgoQIcWogAkEEaigCACIAQX9zQQd2IABBBnZyQYGChAhxaiACQQhqKAIAIgBBf3NBB3YgAEEGdnJBgYKECHFqIAJBDGooAgAiAEF/c0EHdiAAQQZ2ckGBgoQIcWohACACQRBqIgIgAUcNAAsLIAQgB2shBCADIAlqIQIgAEEIdkH/gfwHcSAAQf+B/AdxakGBgARsQRB2IAVqIQUgCEUNAAsCfyADIAdB/AFxQQJ0aiIBKAIAIgBBf3NBB3YgAEEGdnJBgYKECHEiACAIQQFGDQAaIAAgASgCBCIAQX9zQQd2IABBBnZyQYGChAhxaiIAIAhBAkYNABogACABKAIIIgBBf3NBB3YgAEEGdnJBgYKECHFqCyIAQQh2Qf+BHHEgAEH/gfwHcWpBgYAEbEEQdiAFaiEFCyAFC8cbAwd+FX8BeyABKQMYIgQgAq2FIgVCOIYgBUKA/gODQiiGhCAFQoCA/AeDQhiGIAVCgICA+A+DQgiGhIQgBEIIiEKAgID4D4MgBEIYiEKAgPwHg4QgBEIoiEKA/gODIARCOIiEhIRC0oGqm6v6gtenf34iBEI4hiAEQoD+A4NCKIaEIARCgID8B4NCGIYgBEKAgID4D4NCCIaEhCAEQgiIQoCAgPgPgyAEQhiIQoCA/AeDhCAEQiiIQoD+A4MgBEI4iISEhCAFQtii0e/CqeW/LX6FIgRCOIYgBEKA/gODQiiGhCAEQoCA/AeDQhiGIARCgICA+A+DQgiGhIQgBEIIiEKAgID4D4MgBEIYiEKAgPwHg4QgBEIoiEKA/gODIARCOIiEhIQgASkDECIFQn+FfiIGQjiGIAZCgP4Dg0IohoQgBkKAgPwHg0IYhiAGQoCAgPgPg0IIhoSEIAZCCIhCgICA+A+DIAZCGIhCgID8B4OEIAZCKIhCgP4DgyAGQjiIhISEIAQgBUI4hiAFQoD+A4NCKIaEIAVCgID8B4NCGIYgBUKAgID4D4NCCIaEhCAFQgiIQoCAgPgPgyAFQhiIQoCA/AeDhCAFQiiIQoD+A4MgBUI4iISEhH6FIASJIQkgASgCCEUEQAJAIAFBEGohDCMAQSBrIhQkAAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABKAIMIhZBf0cEQCABKAIEIhIgEkEBaiIRQQN2Ig5BB2wiGyASQQhJGyILQQF2IBZNBEAgCyAWIAsgFksbIgtBDkkNAiALQf7///8BTQRAQX8gC0EDdEEIakEHbkEBa2d2IgtB/v///wFLDQcgC0EBaiELDAYLDA0LQQAhCyABKAIAIQ0gDiARQQdxQQBHaiIPRQ0DQQEhECAPQQFGDQIgD0EBcSEQIA0hCyAPQf7///8DcSITIQ4DQCALIAv9AAMAIiD9TUEH/c0B/QwBAQEBAQEBAQEBAQEBAQEB/U4gIP0Mf39/f39/f39/f39/f39/f/1Q/c4B/QsDACALQRBqIQsgDkECayIODQALIA8gE0YNAyATQQN0IQsMAgsMCwtBBEEIQRAgC0EHSRsgC0EDSRshCwwCCyALIA1qIQsDQCALIAspAwAiBEJ/hUIHiEKBgoSIkKDAgAGDIARC//79+/fv37//AIR8NwMAIAtBCGohCyAQQQFrIhANAAsLIAECfwJAIBFBCE8EQCANIBFqIA0pAAA3AAAMAQsgEQRAIA1BCGogDSAR/AoAAAsgEQ0AQQAMAQsgDCkDACIEQjiGIARCgP4Dg0IohoQgBEKAgPwHg0IYhiAEQoCAgPgPg0IIhoSEIARCCIhCgICA+A+DIARCGIhCgID8B4OEIARCKIhCgP4DgyAEQjiIhISEIQcgDUEIaiETIA1BCGshHCAEQn+FIQggDCkDCCEGQQEhDCANIQ5BACELA0AgCyEQIAwhCwJAIA0gEGoiGi0AAEGAAUcNACAcIBBBA3RrIR0gDSAQQX9zQQN0aiEeAkADQCASIAYgHTUCAIUiBUI4hiAFQoD+A4NCKIaEIAVCgID8B4NCGIYgBUKAgID4D4NCCIaEhCAGQgiIQoCAgPgPgyAGQhiIQoCA/AeDhCAGQiiIQoD+A4MgBkI4iISEhELSgaqbq/qC16d/fiIEQjiGIARCgP4Dg0IohoQgBEKAgPwHg0IYhiAEQoCAgPgPg0IIhoSEIARCCIhCgICA+A+DIARCGIhCgID8B4OEIARCKIhCgP4DgyAEQjiIhISEIAVC2KLR78Kp5b8tfoUiBEI4hiAEQoD+A4NCKIaEIARCgID8B4NCGIYgBEKAgID4D4NCCIaEhCAEQgiIQoCAgPgPgyAEQhiIQoCA/AeDhCAEQiiIQoD+A4MgBEI4iISEhCAIfiIFQjiGIAVCgP4Dg0IohoQgBUKAgPwHg0IYhiAFQoCAgPgPg0IIhoSEIAVCCIhCgICA+A+DIAVCGIhCgID8B4OEIAVCKIhCgP4DgyAFQjiIhISEIAQgB36FIASJpyIXcSIVIQwgDSAVaikAAEKAgYKEiJCgwIB/gyIEUARAQQghDwNAIAwgD2ohDCAPQQhqIQ8gDSAMIBJxIgxqKQAAQoCBgoSIkKDAgH+DIgRQDQALCyANIAR6p0EDdiAMaiAScSIMaiwAAEEATgRAIA0pAwBCgIGChIiQoMCAf4N6p0EDdiEMCyAMIBVrIBAgFWtzIBJxQQhPBEAgDCANaiIPLQAAIA8gF0EZdiIPOgAAIBMgDEEIayAScWogDzoAAEH/AUYNAiANIAxBA3RrIQ9BeCEMA0AgDCAOaiIVKAAAIRcgFSAMIA9qIhUoAAA2AAAgFSAXNgAAIAxBBGoiDA0ACwwBCwsgGiAXQRl2Igw6AAAgEyASIBBBCGtxaiAMOgAADAELIBpB/wE6AAAgEyASIBBBCGtxakH/AToAACANIAxBf3NBA3RqIB4pAAA3AAALIA5BCGshDiALIAsgEUkiEGohDCAQDQALIBIgGyASQQhJGwsgFms2AggMBQsgC0EDdCINIAtBCGoiDmoiECANSSAQQfj///8HS3INACAQEC4iEEUNASANIBBqIREgDgRAIBFB/wEgDvwLAAsgC0EBayITIAtBA3ZBB2wgE0EISRshFSAWDQIgASgCACENDAMLIBRBADYCGCAUQQE2AgwgFEGQ78EANgIIIBRCBDcCECAUQQhqQZjvwQAQ2gILAAsgEUEIaiEaIAwpAwAiBEI4hiAEQoD+A4NCKIaEIARCgID8B4NCGIYgBEKAgID4D4NCCIaEhCAEQgiIQoCAgPgPgyAEQhiIQoCA/AeDhCAEQiiIQoD+A4MgBEI4iISEhCEIIARCf4UhCiABKAIAIg1BCGshFyANKQMAQn+FQoCBgoSIkKDAgH+DIQYgDCkDCCEHQQAhCyAWIQwgDSEQA0AgBlAEQANAIAtBCGohCyAQQQhqIhApAwBCgIGChIiQoMCAf4MiBEKAgYKEiJCgwIB/UQ0ACyAEQoCBgoSIkKDAgH+FIQYLIBEgEyAHIBcgBnqnQQN2IAtqIhtBA3RrNQIAhSIFQjiGIAVCgP4Dg0IohoQgBUKAgPwHg0IYhiAFQoCAgPgPg0IIhoSEIAdCCIhCgICA+A+DIAdCGIhCgID8B4OEIAdCKIhCgP4DgyAHQjiIhISEQtKBqpur+oLXp39+IgRCOIYgBEKA/gODQiiGhCAEQoCA/AeDQhiGIARCgICA+A+DQgiGhIQgBEIIiEKAgID4D4MgBEIYiEKAgPwHg4QgBEIoiEKA/gODIARCOIiEhIQgBULYotHvwqnlvy1+hSIEQjiGIARCgP4Dg0IohoQgBEKAgPwHg0IYhiAEQoCAgPgPg0IIhoSEIARCCIhCgICA+A+DIARCGIhCgID8B4OEIARCKIhCgP4DgyAEQjiIhISEIAp+IgVCOIYgBUKA/gODQiiGhCAFQoCA/AeDQhiGIAVCgICA+A+DQgiGhIQgBUIIiEKAgID4D4MgBUIYiEKAgPwHg4QgBUIoiEKA/gODIAVCOIiEhIQgBCAIfoUgBImnIhxxIg5qKQAAQoCBgoSIkKDAgH+DIgRQBEBBCCEPA0AgDiAPaiEOIA9BCGohDyARIA4gE3EiDmopAABCgIGChIiQoMCAf4MiBFANAAsLIAZCAX0gBoMhBiARIAR6p0EDdiAOaiATcSIOaiwAAEEATgRAIBEpAwBCgIGChIiQoMCAf4N6p0EDdiEOCyAOIBFqIBxBGXYiDzoAACAaIA5BCGsgE3FqIA86AAAgESAOQX9zQQN0aiANIBtBf3NBA3RqKQAANwMAIAxBAWsiDA0ACwsgASATNgIEIAEgETYCACABIBUgFms2AgggEkUNACASIBJBA3RBD2pBeHEiDGpBCWoiC0UNACANIAxrIgxBBGsoAgAiDUF4cSIOQQRBCCANQQNxIg0bIAtqSQ0BIA1BACAOIAtBJ2pLGw0CIAwQWwsgFEEgaiQADAMLQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIACyAUQQA2AhggFEEBNgIMIBRBkO/BADYCCCAUQgQ3AhAgFEEIakGY78EAENoCAAsLIAEoAgQiDSAJp3EhCyAJQhmIIgZC/wCDQoGChIiQoMCAAX4hByABKAIAIQwDQAJ/AkACQAJAIAsgDGopAAAiBSAHhSIEQn+FIARCgYKEiJCgwIABfYNCgIGChIiQoMCAf4MiBFBFBEADQCACIAwgBHqnQQN2IAtqIA1xQQN0ayIOQQhrKAIARg0CIARCAX0gBIMiBFBFDQALCyAFQoCBgoSIkKDAgH+DIQQgGUEBRwRAIARQDQMgBHqnQQN2IAtqIA1xIRgLQQEgBCAFQgGGg1ANAxpBACELIAwgGGosAAAiGUEATgRAIAwgDCkDAEKAgYKEiJCgwIB/g3qnQQN2IhhqLQAAIRkLIAwgGGogBqdB/wBxIg46AAAgDCAYQQhrIA1xakEIaiAOOgAAIAEgASgCCCAZQQFxazYCCCABIAEoAgxBAWo2AgwgDCAYQQN0ayIBQQhrIAI2AgAgAUEEayADNgIADAELIA5BBGsiAigCACEBIAIgAzYCAEEBIQsLIAAgATYCBCAAIAs2AgAPC0EACyEZIAsgH0EIaiIfaiANcSELDAALAAuQBwEKfyADQQRqIgMoAgAgACgCBCAAKAIAEIoBIQQgAygCACAAKAIMIAAoAggQigEhBSADKAIAIABBDEEIIAUbaiIGKAIAIAAgBEECdGoiCCgCABCKASEHIAMoAgAgAEEIQQwgBRtqIgkoAgAgACAEQQFzQQJ0aiIEKAIAEIoBIQUgAygCACAJIAQgBiAHGyAFGyIKKAIAIAggBiAEIAUbIAcbIgsoAgAQigEhDCACIAYgCCAHGygCADYCACACIAogCyAMGygCADYCBCACIAsgCiAMGygCADYCCCACQQxqIgggBCAJIAUbKAIANgIAIAMoAgAgACgCFCAAKAIQEIoBIQQgAygCACAAKAIcIAAoAhgQigEhBSADKAIAIABBEGoiAEEMQQggBRtqIgYoAgAgACAEQQJ0aiIJKAIAEIoBIQcgAygCACAAQQhBDCAFG2oiBSgCACAAIARBAXNBAnRqIgAoAgAQigEhBCADKAIAIAUgACAGIAcbIAQbIgooAgAgCSAGIAAgBBsgBxsiCygCABCKASEMIAJBEGoiDSAGIAkgBxsoAgAiBjYCACACQRRqIAogCyAMGygCADYCACACQRhqIAsgCiAMGygCADYCACACQRxqIgcgACAFIAQbKAIAIgA2AgAgASAGIAIoAgAiBCADKAIAIAYgBBCKASIGGzYCACABIAgoAgAiBCAAIAMoAgAgACAEEIoBIgQbNgIcIAEgDSAGQQJ0aiIFKAIAIgAgAiAGQQFzQQJ0aiIGKAIAIgIgAygCACAAIAIQigEiABs2AgQgByAEQQJ0IgdqQQRrIgQoAgAhAiABIAggB2siBygCACIIIAIgAygCACACIAgQigEiAhs2AhggASAFIABBAnRqIgUoAgAiCCAGIABBAXNBAnRqIgYoAgAiACADKAIAIAggABCKASIAGzYCCCAEIAJBAnQiBGpBBGsiCCgCACECIAEgByAEayIHKAIAIgQgAiADKAIAIAIgBBCKASICGzYCFCABIAUgAEECdGoiBCgCACIFIAYgAEEBc0ECdGoiBigCACIAIAMoAgAgBSAAEIoBIgAbNgIMIAJBAnQiBSAIakEEayIIKAIAIQIgASAHIAVrIgEoAgAiByACIAMoAgAgAiAHEIoBIgIbNgIQIAYgAEEBc0ECdGogASACQQJ0IgFrQQRqRiAEIABBAnRqIAEgCGpGcUUEQBDMAgALC9kGAg1/An0gAEH0wsIAKAIAIgcEfyMAQRBrIQhB9MLCACAHQQFrIgY2AgBB8MLCACgCACIFIAZBDGxqIgQoAgghASAEKAIEIQMgBCgCACEEAkAgBkUEQCABIQogAyELIAQhDAwBCyAFKAAAIQwgBSAENgAAIAUoAAQhCyAFIAM2AAQgBUEIaiIDKAAAIQogAyABNgAAIAhBCGogAygCADYCACAIIAUpAgA3AwBBASEBIAdBBE8EQCAGQQJrIgFBACABIAZNGyEGQQEhAQNAAn8gBSABQQxsaiIDQQxqIgQqAgAiDiAOWyAOIAMqAgAiD2BFcSIJIAlBfyAOIA9fGyAPIA9cGyIJBEAgCUEATAwBCyADKAIEIgkgBCgCBCINRwRAIAkgDU0MAQsgAygCCCAEKAIITQshAyAFIAJBDGxqIgQgBSABIANqIgJBDGxqIgEpAgA3AgAgBEEIaiABQQhqKAIANgIAIAJBAXQiA0EBciEBIAMgBkkNAAsLAkAgB0ECayABRwRAIAIhAQwBCyAFIAJBDGxqIgIgBSABQQxsaiIDKQIANwIAIAJBCGogA0EIaigCADYCAAsgBSABQQxsaiICIAgpAwA3AgAgAkEIaiAIQQhqKAIAIgg2AgAgAigCBCEDIAIqAgAhDgJAIAFFBEBBACEBDAELIA4gDlsEQANAAkAgBSABIgJBAWsiBkEBdiIBQQxsaiIEKgIAIg8gD1sgDiAPX0VxQX8gDiAPYBsiBwRAIAdBAEoNASACIQEMBAsgBCgCBCIHIANHBEAgAyAHSw0BIAIhAQwECyAIIAQoAghLDQAgAiEBDAMLIAUgAkEMbGoiAiAEKQIANwIAIAJBCGogBEEIaigCADYCACAGQQFLDQAMAgsACwNAAkAgBSABIgJBAWsiBkEBdiIBQQxsaiIEKgIAIg8gD1sgDiAPX0VxDQAgBCgCBCIHIANHBEAgAyAHSw0BIAIhAQwDCyAIIAQoAghLDQAgAiEBDAILIAUgAkEMbGoiAiAEKQIANwIAIAJBCGogBEEIaigCADYCACAGQQJPDQALCyAFIAFBDGxqIgEgCDYCCCABIAM2AgQgASAOOAIACyAAIAo2AgwgACALNgIIIAAgDDYCBEEBBSABCzYCAAvJBgEMfyMAQRBrIggkAEEBIQsCQCACKAIAIglBIiACKAIEIgwoAhAiDREBAA0AAkACQCABRQRAQQAhAUEAIQIMAQsgACEFIAEhBgNAIAUgBmohDkEAIQICQAJAA0AgAiAFaiIHLQAAIgpB/wBrQf8BcUGhAUkgCkEiRnIgCkHcAEZyDQEgBiACQQFqIgJHDQALIAMgBmohAwwBCyACIANqIQMCQAJAIAcsAAAiAkEATgRAIAdBAWohBSACQf8BcSECDAELIActAAFBP3EhBSACQR9xIQYgAkFfTQRAIAZBBnQgBXIhAiAHQQJqIQUMAQsgBy0AAkE/cSAFQQZ0ciEKIAJBcEkEQCAKIAZBDHRyIQIgB0EDaiEFDAELIAdBBGohBSAGQRJ0QYCA8ABxIActAANBP3EgCkEGdHJyIgJBgIDEAEYNAQsgCCACQYGABBB3AkAgCC0ADSAILQAMa0H/AXFBAUYNAAJAAkACQCADIARJDQACQCAERQ0AIAEgBE0EQCABIARHDQIMAQsgACAEaiwAAEG/f0wNAQsCQCADRQ0AIAEgA00EQCABIANGDQEMAgsgACADaiwAAEG/f0wNAQsgCSAAIARqIAMgBGsgDCgCDCIEEQAARQ0BDAILIAAgASAEIANBvPzAABCVAwALAkAgCC0ADSIGQYEBTwRAIAkgCCgCACANEQEADQIMAQsgCSAIIAgtAAwiB2ogBiAHayAEEQAADQELIAJBgAFJBEAgA0EBaiEEDAILIAJBgBBJBEAgA0ECaiEEDAILQQNBBCACQYCABEkbIANqIQQMAQsMBgsCf0EBIAJBgAFJDQAaQQIgAkGAEEkNABpBA0EEIAJBgIAESRsLIANqIQMLIA4gBWsiBg0BCwsgAyAESQ0BQQAhAgJAIARFDQAgASAETQRAIAQgASICRw0DDAELIAQiAiAAaiwAAEG/f0wNAgsgA0UEQEEAIQEMAQsgASADTQRAIAEgA0YNASACIQQMAgsgACADaiwAAEG/f0wEQCACIQQMAgsgAyEBCyAJIAAgAmogASACayAMKAIMEQAADQEgCUEiIA0RAQAhCwwBCyAAIAEgBCADQcz8wAAQlQMACyAIQRBqJAAgCwvsBgEFfwJAAkACQAJAAkAgAEEEayIFKAIAIgdBeHEiBEEEQQggB0EDcSIGGyABak8EQCAGQQAgAUEnaiIIIARJGw0BAkACQCACQQlPBEAgAiADELIBIgINAUEADwtBACECIANBzP97Sw0BQRAgA0ELakF4cSADQQtJGyEBAkAgBkUEQCABQYACSSAEIAFBBHJJciAEIAFrQYGACE9yDQEMCQsgAEEIayIGIARqIQgCQAJAAkACQCABIARLBEAgCEGsyMIAKAIARg0EIAhBqMjCACgCAEYNAiAIKAIEIgdBAnENBSAHQXhxIgcgBGoiBCABSQ0FIAggBxC0ASAEIAFrIgJBEEkNASAFIAEgBSgCAEEBcXJBAnI2AgAgASAGaiIBIAJBA3I2AgQgBCAGaiIDIAMoAgRBAXI2AgQgASACEHAMDQsgBCABayICQQ9LDQIMDAsgBSAEIAUoAgBBAXFyQQJyNgIAIAQgBmoiASABKAIEQQFyNgIEDAsLQaDIwgAoAgAgBGoiBCABSQ0CAkAgBCABayIDQQ9NBEAgBSAHQQFxIARyQQJyNgIAIAQgBmoiASABKAIEQQFyNgIEQQAhA0EAIQEMAQsgBSABIAdBAXFyQQJyNgIAIAEgBmoiASADQQFyNgIEIAQgBmoiAiADNgIAIAIgAigCBEF+cTYCBAtBqMjCACABNgIAQaDIwgAgAzYCAAwKCyAFIAEgB0EBcXJBAnI2AgAgASAGaiIBIAJBA3I2AgQgCCAIKAIEQQFyNgIEIAEgAhBwDAkLQaTIwgAoAgAgBGoiBCABSw0HCyADEC4iAUUNASADQXxBeCAFKAIAIgJBA3EbIAJBeHFqIgIgAiADSxsiAgRAIAEgACAC/AoAAAsgABBbIAEPCyADIAEgASADSxsiAwRAIAIgACAD/AoAAAsgBSgCACIDQXhxIgUgAUEEQQggA0EDcSIBG2pJDQMgAUEAIAUgCEsbDQQgABBbCyACDwtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgALQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIACyAFIAEgB0EBcXJBAnI2AgAgASAGaiICIAQgAWsiAUEBcjYCBEGkyMIAIAE2AgBBrMjCACACNgIAIAAPCyAAC8wIAgN8A38jAEEQayIFJAAgALshAQJAIAC8IgZB/////wdxIgRB25+k+gNPBEAgBEHSp+2DBE8EQCAEQdbjiIcETwRAIARB////+wdNBEAgBUIANwMIAkAgBEHan6TuBE0EQCABIAFEg8jJbTBf5D+iRAAAAAAAADhDoEQAAAAAAAA4w6AiAkQAAABQ+yH5v6KgIAJEY2IaYbQQUb6ioCEBIAL8AiEEDAELIAUgBCAEQRd2QZYBayIEQRd0a767OQMAIAUgBUEIaiAEEC8hBCAGQQBOBEAgBSsDCCEBDAELQQAgBGshBCAFKwMImiEBC0QAAAAAAADwvyABIAEgASABoiIBoiICIAFEcp+ZOP0SwT+iRJ/JGDRNVdU/oKKgIAIgASABoiICoiABRM4zjJDzHZk/okT+WoYdyVSrP6AgAiABRM0bl7+5YoM/okRO9Oz8rV1oP6CioKKgIgGjIAEgBEEBcRu2IQAMBAsgACAAkyEADAMLIARB4Nu/hQRPBEBEGC1EVPshGcBEGC1EVPshGUAgBkEAThsgAaAiASABIAEgAaIiAaIiAiABRHKfmTj9EsE/okSfyRg0TVXVP6CioCACIAEgAaIiAqIgAUTOM4yQ8x2ZP6JE/lqGHclUqz+gIAIgAUTNG5e/uWKDP6JETvTs/K1daD+goqCioLYhAAwDC0QAAAAAAADwv0TSITN/fNkSwETSITN/fNkSQCAGQQBOGyABoCIBIAEgASABoiIBoiICIAFEcp+ZOP0SwT+iRJ/JGDRNVdU/oKKgIAIgASABoiICoiABRM4zjJDzHZk/okT+WoYdyVSrP6AgAiABRM0bl7+5YoM/okRO9Oz8rV1oP6CioKKgo7YhAAwCCyAEQeSX24AETwRARBgtRFT7IQnARBgtRFT7IQlAIAZBAE4bIAGgIgEgASABIAGiIgGiIgIgAURyn5k4/RLBP6JEn8kYNE1V1T+goqAgAiABIAGiIgKiIAFEzjOMkPMdmT+iRP5ahh3JVKs/oCACIAFEzRuXv7ligz+iRE707PytXWg/oKKgoqC2IQAMAgtEAAAAAAAA8L9EGC1EVPsh+b9EGC1EVPsh+T8gBkEAThsgAaAiASABIAEgAaIiAaIiAiABRHKfmTj9EsE/okSfyRg0TVXVP6CioCACIAEgAaIiAqIgAUTOM4yQ8x2ZP6JE/lqGHclUqz+gIAIgAUTNG5e/uWKDP6JETvTs/K1daD+goqCioKO2IQAMAQsgBEGAgIDMA08EQCABIAGiIgIgAaIiAyACRHKfmTj9EsE/okSfyRg0TVXVP6CiIAGgIAMgAiACoiIBoiACRM4zjJDzHZk/okT+WoYdyVSrP6AgASACRM0bl7+5YoM/okRO9Oz8rV1oP6CioKKgtiEADAELIAUgAEMAAIADlCAAQwAAgHuSIARBgICABEkbOAIIIAUqAggaCyAFQRBqJAAgAAvXBgEGf0HEw8IAKAIAIgMgAEkEQCAAIAMiAWsiAkG8w8IAKAIAIAFrSwRAQbzDwgAgASACQQRBBBDZAUHEw8IAKAIAIQELQcDDwgAoAgAiBSABQQJ0aiEEIAJBAkkEfyABBSAAIANBf3NqQQJ0IgYEQCAEQQAgBvwLAAsgBSAAIAFqIANrQQJ0akEEayEEIAEgAmpBAWsLIQIgBEEANgIAQcTDwgAgAkEBajYCAAtB0MPCACgCACIDIABJBEAgACADIgFrIgJByMPCACgCACABa0sEQEHIw8IAIAEgAkEEQQQQ2QFB0MPCACgCACEBC0HMw8IAKAIAIgUgAUECdGohBCACQQJJBH8gAQUgACADQX9zakECdCIGBEAgBEEAIAb8CwALIAUgACABaiADa0ECdGpBBGshBCABIAJqQQFrCyECIARBADYCAEHQw8IAIAJBAWo2AgALQfTDwgAoAgAiAyAASQRAIAAgAyIBayICQezDwgAoAgAgAWtLBEBB7MPCACABIAJBBEEEENkBQfTDwgAoAgAhAQtB8MPCACgCACIFIAFBAnRqIQQgAkECSQR/IAEFIAAgA0F/c2pBAnQiBgRAIARBACAG/AsACyAFIAAgAWogA2tBAnRqQQRrIQQgASACakEBawshAiAEQQA2AgBB9MPCACACQQFqNgIAC0Hcw8IAKAIAIgJB//8DTQRAIAIhAEGAgAQgAmsiAUHUw8IAKAIAIAJrSwRAQdTDwgAgAiABQQRBBBDZAUHcw8IAKAIAIQALQdjDwgAoAgAiAyAAQQJ0aiEBIAJB//8DRwR/Qfz/DyACQQJ0ayIEBEAgAUEAIAT8CwALIAAgAmsiAUH//wNqIQAgAyABQQJ0akH8/w9qBSABC0EANgIAQdzDwgAgAEEBajYCAAtB6MPCACgCACICQf//A00EQCACIQBBgIAEIAJrIgFB4MPCACgCACACa0sEQEHgw8IAIAIgAUEEQQQQ2QFB6MPCACgCACEAC0Hkw8IAKAIAIgMgAEECdGohASACQf//A0cEf0H8/w8gAkECdGsiBARAIAFBACAE/AsACyAAIAJrIgFB//8DaiEAIAMgAUECdGpB/P8PagUgAQtBADYCAEHow8IAIABBAWo2AgALC/QFAgV/AX4gAUIgiCABQhCIpyEFAn8gAaciA0H//wFxRQRAIANBEHQMAQsgA0H/B3EhBiADQYCAAnEhAiADQYD4AXEiA0GA+AFGBEAgAkEQdCEDIANBgICA/AdyIAZFDQEaIAMgBkENdHJBgICA/gdyDAELIAJBEHQhAiADQQ10QYCAgPwAcSAGQQ10ckGAgIDAA2ogAnIgAw0AGiAGIAZnQRBrIgZB//8DcUEIanRB////A3EgAkGAgIDYA3IgBkEXdGtyCyEGIAFCMIghAachAwJ/IAVB//8BcQRAIAVB/wdxIQIgBUGAgAJxIQQgBUGA+AFxIgVBgPgBRwRAIARBEHQhBCAFQQ10QYCAgPwAcSACQQ10ckGAgIDAA2ogBHIgBQ0CGiACIAJnQRBrIgVB//8DcUEIanRB////A3EgBEGAgIDYA3IgBUEXdGtyDAILIARBEHQhBSAFIAJBDXRyQYCAgP4HciACDQEaIAVBgICA/AdyDAELIAVBEHQLIQUgAachAiAAIAb9ESAF/RwBAn8gA0H//wFxBEAgA0H/B3EhBCADQYCAAnEhACADQYD4AXEiA0GA+AFHBEAgAEEQdCEAIANBDXRBgICA/ABxIARBDXRyQYCAgMADaiAAciADDQIaIAQgBGdBEGsiA0H//wNxQQhqdEH///8DcSAAQYCAgNgDciADQRd0a3IMAgsgAEEQdCEDIAMgBEENdHJBgICA/gdyIAQNARogA0GAgID8B3IMAQsgA0EQdAv9HAICfyACQf//AXEEQCACQf8HcSEEIAJBgIACcSEAIAJBgPgBcSICQYD4AUcEQCAAQRB0IQAgAkENdEGAgID8AHEgBEENdHJBgICAwANqIAByIAINAhogBCAEZ0EQayICQf//A3FBCGp0Qf///wNxIABBgICA2ANyIAJBF3RrcgwCCyAAQRB0IQIgAiAEQQ10ckGAgID+B3IgBA0BGiACQYCAgPwHcgwBCyACQRB0C/0cA/0LBAAL4AYCBn8BfiMAQUBqIgEkAAJAAkAgACgCAEUEQCAAKAIQIgBFDQEgAEGticIAQQEQhAEhAgwCCyABQQxqIAAQ5QECQAJ/IAEoAgwiAkUEQCABLQAQIQQgACgCECIDBEBBASECIANBlInCAEGEicIAIARBAXEiAxtBGUEQIAMbEIQBDQULIAAgBDoABEEADAELAkAgASgCECIEQQFxDQAgAUKAgICAIDcCGCABIAI2AgwgASAENgIQIAEgAiAEaiIFNgIUA0ACQCABQQxqEFxBgIDEAGsOAgIAAQsLIAAoAhAiA0UNAyADKAIAQSIgAygCBCgCEBEBAA0CIAFCgICAgCA3AhggASAFNgIUIAEgBDYCECABIAI2AgwDQAJ/AkACQAJAAkACQAJAAkAgAUEMahBcIgBBgYDEAEcEQCAAQYCAxABGDQEgAEEnRg0CAkACQAJAAkACQAJAIABBIUwEQCAAQQlrDgUBAwYGAgULIABBIkYNAyAAQdwARw0FIAFCADcBIiABQdy4ATsBIAwNCyABQgA3ASIgAUHc6AE7ASAMDAsgAUIANwEiIAFB3OQBOwEgDAsLIAFCADcBIiABQdzcATsBIAwKCyABQgA3ASIgAUHcxAA7ASAMCQsgAEUNBwsgAEH/BU0NAyAAELcBRQ0DDAQLIAMoAgBBIiADKAIEKAIQEQEAIQIMDQtBqI3CAEErIAFBMGpBgIHCAEGwgMIAEJMCAAsgAygCAEEnIAMoAgQoAhARAQANCQwGCyAAEPoBDQELIAFBMGogABDfASABQShqIAFBOGovAAA7AQAgASABKQAwNwMgIAEtADshAiABLQA6DAMLIAEgADYCIEGBASECQYABDAILIAFCADcBIiABQdzgADsBIAtBAiECQQALIAFBOGogAUEoai8BADsBACABIAEpAyAiBzcDMEH/AXEiACACQf8BcSIFIAAgBUsbIQYgB6chBANAIAAgBkYNASAEIQIgBUGAAU0EQCABQTBqIABqLQAAIQILIABBAWohACADKAIAIAIgAygCBCgCEBEBAEUNAAsLDAILIAAoAhAiAgRAIAJBhInCAEEQEIQBDQILIABBADoABEEACyECIAAgAjYCAAwCC0EBIQIMAQtBACECCyABQUBrJAAgAgu+BgEGfyMAQfAAayICJAACfwJAAkACQCAAKAIAIgFFDQACQCAAKAIIIgMgACgCBCIFTw0AIAEgA2otAABB1QBHDQBBASEEIAAgA0EBaiIDNgIICwJAAkACQCADIAVJBEAgASADai0AAEHLAEYNAQsgBEUNA0EAIQMMAQsgACADQQFqIgY2AggCQAJAIAUgBk0NACABIAZqLQAAQcMARw0AIAAgA0ECajYCCEEBIQFB9IPCACEDDAELIAJByABqIAAQdiACKAJIIgNFBEAgAi0ATCEBIAAoAhAiBARAQQEgBEGUicIAQYSJwgAgAUEBcSIEG0EZQRAgBBsQhAENCBoLIAAgAToABCAAQQA2AgBBAAwHCyACKAJMIgEEQCACKAJURQ0BCyAAKAIQIgEEQCABQYSJwgBBEBCEAQ0FCyAAQQA6AAQgAEEANgIAQQAMBgsgBEUNAQsgACgCECIEBEAgBEHgicIAQQcQhAENAwsgA0UNAQsgACgCECIEBEAgBEHnicIAQQgQhAENAgsgAkEBOwFEIAIgATYCQCACQQA2AjwgAkEBOgA4IAJB3wA2AjQgAiABNgIwIAJBADYCLCACIAE2AiggAiADNgIkIAJB3wA2AiAgAkEYaiACQSBqEKoBIAIoAhgiAQRAIAQEQCAEIAEgAigCHBCEAQ0DCyACQcgAaiACQSBqQSj8CgAAIAQhAQNAIAEhAwJAA0AgAyEFIAJBEGogAkHIAGoQqgEgAigCECIGRQ0BQQAhAyAFRQ0ACyACKAIUIQMgBUGhhsIAQQEQhAENBEEAIQEgBEUNASAEIgEgBiADEIQBDQQMAQsLIAFFDQEgAUGAisIAQQIQhAFFDQEMAgtB8InCABCrAwALIAAoAhAiAQRAIAFBgorCAEEDEIQBDQELIAJBCGogABCAAkEBIAIoAghBAXENAhogACgCECIBBEBBASABQdq4wgBBARCEAQ0DGgsgACgCACIDRQ0BIAAoAggiASAAKAIETw0BIAEgA2otAABB9QBHDQEgACABQQFqNgIIQQAMAgtBAQwBCyAAKAIQIgEEQEEBIAFBhYrCAEEEEIQBDQEaCyAAEFMLIAJB8ABqJAALygoBBn8jAEHQAGsiByQAIAAoAgQhDCAAKAIAIQkgB0EANgIEAkACQAJAIAktABBBAUcNACAJKAIAIQgCQCAMRQRAIAcgCUEMaq1CgICAgOAAhDcDMCAHQQE2AhwgB0GQtcIANgIYIAdBAjYCDCAHQYC1wgA2AgggB0EBNgIUIAhBBGooAgAhCiAHIAdBMGoiCzYCECAIKAIAIAogB0EIahCMAQ0DIAktABBBAUcNASAJKAIAIQggB0KAgICAoAE3AzggByAHQQRqrUKAgICAsAKENwMwIAdBATYCHCAHQby1wgA2AhggB0ECNgIMIAdBrLXCADYCCCAHQQI2AhQgCEEEaigCACEKIAcgCzYCECAIKAIAIAogB0EIahCMAQ0DDAELIAgoAgBB1LXCAEEGIAhBBGooAgAoAgwRAAANAiAJLQAQQQFHDQAgCSgCACEIIAdCgICAgNABNwM4IAdB3KvCADYCCCAHQtyrwoAgNwMwIAdBATYCHCAHQby1wgA2AhggB0EBNgIMIAdBAjYCFCAIQQRqKAIAIQogByAHQTBqNgIQIAgoAgAgCiAHQQhqEIwBDQILAkACQCABKAIAQQNHBEAgCS0AEEUNASAHQShqIAFBIGopAgA3AwAgB0EYaiABQRBq/QACAP0LAwAgByAB/QACAP0LAwggCSgCACEBIAcgB0EIaq1CgICAgMAChDcDSCAHQQE2AjQgB0Hcq8IANgIwIAdCATcCPCABQQRqKAIAIQggByAHQcgAajYCOCABKAIAIAggB0EwahCMAUUNAgwECyAJKAIAIgEoAgBB4LTCAEEJIAFBBGooAgAoAgwRAAANAwwBCyAHQShqIAFBIGopAgA3AwAgB0EYaiABQRBq/QACAP0LAwAgByAB/QACAP0LAwggCSgCACEBIAcgB0EIaq1CgICAgMAChDcDSCAHQQE2AkQgB0G4qsIANgJAIAdBATYCNCAHQdyrwgA2AjAgB0EBNgI8IAFBBGooAgAhCCAHIAdByABqNgI4IAEoAgAgCCAHQTBqEIwBDQILIAkoAgAiASgCAEHstMIAQQEgASgCBCgCDBEAAA0BIAIoAgBBAkYNAEEBIQEgA0EBcUUNACMAQUBqIgMkACADIAQ2AgwCQCAJLQAQQQFGBEAgCSgCACEIIANCgICAgKABNwMYIANB3KvCADYCKCADQtyrwoAgNwMQQQEhBCADQQE2AjwgA0G8tcIANgI4IANBATYCLCADQQI2AjQgCEEEaigCACEKIAMgA0EQajYCMCAIKAIAIAogA0EoahCMAQ0BCyAJKAIAIgQoAgBB2rXCAEEQIARBBGooAgAoAgwRAAAEQEEBIQQMAQsgCSgCBCAJKAIIIQogA0E0aiACQQhqKAIANgIAIAMgCSgCACILNgIoIAMgAikCADcCLEEBIQQgCyADQSxqIAooAhARAAANACAJKAIAIQIgAyADQQxqrUKAgICA4ACENwMQIANBATYCLCADQey1wgA2AiggA0IBNwI0IAJBBGooAgAhCCADIANBEGoiCjYCMCACKAIAIAggA0EoaiIIEIwBDQAgBUEBcQRAIAMgBjYCJCAJKAIAIQIgAyADQSRqrUKAgICA4ACENwMQIANBATYCLCADQey1wgA2AiggA0IBNwI0IAJBBGooAgAhBSADIAo2AjAgAigCACAFIAgQjAENAQsgCSgCACICKAIAQey0wgBBASACQQRqKAIAKAIMEQAAIQQLIANBQGskACAEDQILIAAgDEEBajYCBEEAIQEMAQtBASEBCyAHQdAAaiQAIAELtAYCF38BfSMAQRBrIgkkAAJAAkACQAJAIAIEQCAAKAIIIhAgAWsiBUEAIAUgEE0bIRUgAkEMbCEWIAAoAgQgAUEwbGohBiADKAIkIREgAygCICEOIAMoAhghFyADKAIcIRIgAygCECEYIAMoAhQhEyADKAIIIRkgAygCDCEPIAMoAgQhFCADKAIAIRpBAyEFA0ACQAJAIAwgFUcEQCAFIBRNBEAgBiALIBpqIgT9XQIAIARBCGoqAgAiG/0gAiAb/SAD/QsEACAMIA9HBEAgDSAZaigCACIKQf///wNxIQcgCkGAgICAeHEhBCAKQYCAgPwHcSIIQYCAgPwHRgRAIAdBDXYgBEEQdnIgB0EAR0EJdHJBgPgBciEEDAULIARBEHYhBCAIQYCAgLgESw0DIAhBgICAxANPBEAgCkEMdiAKQf/fAHFBAEdxIAhBDXYgB0ENdmpBgIABaiAEcmohBAwFCyAIQYCAgJgDSQ0EIAdBgICABHIiCkEeIAhBF3YiB2t2IQggCkEdIAdrIgd2QQFxBH8gCEEDIAd0QQFrIApxQQBHagUgCAsgBHIhBAwECyAPIA9BoJfCABCdAgALIAUgFEGQl8IAEKwDAAsgASAMaiAQQYCXwgAQnQIACyAEQYD4AXIhBAsgBkEYaiAEOwEAIAUgE0sNAiAJIAsgGGoiBP1dAgAgBEEIaioCACIb/SACIBv9IAP9CwQAIAYgCRBuIAUgEksNAyAJIAsgF2oiBP1dAgAgBEEIaioCACIb/SACIBv9IAP9CwQAIAYgCRBrIA1BBGoiDSARSw0EIAkgDv0AAgD9CwQAIAxBAWohDCAFQQNqIQUgDkEQaiEOIAYgCRBSIAZBMGohBiAWIAtBDGoiC0cNAAsLIAAgASACIAMoAiggAygCLCADKAIwIAMoAjQgAygCOCADKAI8EDMgAygCRCIFRQ0DIAMoAkwiBEUNAyAAKAIQIgYgACgCFCIAIAEgAiADKAJIIAQQfyAGIAAgASACIAMoAkAgBRCIAQwDCyAFIBNBsJfCABCsAwALIAUgEkHAl8IAEKwDAAsgDSARQdCXwgAQrAMACyAJQRBqJAALiAYCEX8BfiMAQTBrIgQkACAEQQxqrUKAgICA4ACEIRQgAC0ADCEQIAAoAgQhEiAAKAIAIREgACgCCCIJQQRqIQoCfwNAAkAgDCITDQAgByELQQEhDAJ/IAIgBU8EQANAIAEgBWohCAJAAkACQAJAAkAgAiAFayINQQdNBEAgAiAFRg0BQQAhAwNAIAMgCGotAABBCkYNBiANIANBAWoiA0cNAAsMAwsCQAJAIAhBA2pBfHEiByAIayIGBEBBACEDA0AgAyAIai0AAEEKRg0IIAYgA0EBaiIDRw0ACyAGIA1BCGsiA0sNAgwBCyANQQhrIQNBACEGCwNAQYCChAggBygCACIPQYqUqNAAc2sgD3JBgIKECCAHQQRqKAIAIg9BipSo0ABzayAPcnFBgIGChHhxQYCBgoR4Rw0BIAdBCGohByAGQQhqIgYgA00NAAsLIAYgDUcNAQsgAiEFIAIhAyALDAYLIAYgCGohByACIAZrIAVrIQhBACEDA0AgAyAHai0AAEEKRg0CIAggA0EBaiIDRw0ACwsgAiEFIAIhAyALDAQLIAMgBmohAwsgAyAFaiIDQQFqIQUCQCACIANNDQAgASADai0AAEEKRw0AQQAhDCAFDAMLIAIgBU8NAAsLIAIhAyALCyEHAkAgEEEBcUUEQCAAQQE6AAwgEUEBcQRAIAQgEjYCDCAEIBQ3AyggBEEBNgIkIARBiNDAADYCICAEQQI2AhQgBEGAtcIANgIQIARBATYCHCAKKAIAIQggBCAEQShqNgIYQQEgCSgCACAIIARBEGoQjAENBRoMAgsgCSgCAEH8+MAAQQQgCigCACgCDBEAAA0CDAELIA5FDQAgCSgCAEEKIAooAgAoAhARAQANASARBEAgCSgCAEGg0MAAQQcgCigCACgCDBEAAA0CDAELIAkoAgBB/PjAAEEEIAooAgAoAgwRAAANAQsgDkEBaiEOQQEhECAJKAIAIAEgC2ogAyALayAKKAIAKAIMEQAARQ0BCwsgE0EBcwsgBEEwaiQAQQFxC+8FAgV/An0gASoCABDkAbwiAkH///8DcSEDIAJBgICAgHhxIQUgASoCBAJAIAJBgICA/AdxIgRBgICA/AdGBEAgA0ENdiAFQRB2ciADQQBHQQl0ckGA+AFyIQUMAQsgBUEQdiEFIARBgICAuARNBEAgBEGAgIDEA08EQCACQQx2IAJB/98AcUEAR3EgBEENdiADQQ12akGAgAFqIAVyaiEFDAILIARBgICAmANJDQEgA0GAgIAEciICQR4gBEEXdiIDa3YhBCACQR0gA2siA3ZBAXEEfyAEQQMgA3RBAWsgAnFBAEdqBSAECyAFciEFDAELIAVBgPgBciEFCyABKgIIIQgQ5AG8IgJB////A3EhAyACQYCAgIB4cSEEAkAgAkGAgID8B3EiAUGAgID8B0cEQCAEQRB2IQQgAUGAgIC4BE0EQCABQYCAgMQDTwRAIAJBDHYgAkH/3wBxQQBHcSABQQ12IANBDXZqQYCAAWogBHJqIQQMAwsgAUGAgICYA0kNAiADQYCAgARyIgJBHiABQRd2IgNrdiEBIAJBHSADayIDdkEBcQR/IAFBAyADdEEBayACcUEAR2oFIAELIARyIQQMAgsgBEGA+AFyIQQMAQsgA0ENdiAEQRB2ciADQQBHQQl0ckGA+AFyIQQLIAgQ5AG8IgNB////A3EhBiADQYCAgIB4cSECAkAgA0GAgID8B3EiAUGAgID8B0cEQCACQRB2IQIgAUGAgIC4BE0EQCABQYCAgMQDTwRAIANBDHYgA0H/3wBxQQBHcSABQQ12IAZBDXZqQYCAAWogAnJqIQIMAwsgAUGAgICYA0kNAiAGQYCAgARyIgNBHiABQRd2IgZrdiEBIANBHSAGayIGdkEBcQR/IAFBAyAGdEEBayADcUEAR2oFIAELIAJyIQIMAgsgAkGA+AFyIQIMAQsgBkENdiACQRB2ciAGQQBHQQl0ckGA+AFyIQILIAAgAjsBJCAAIAQ7ASIgACAFOwEgC5UGAgx/A30jAEEQayILJAAgAkECdCIGIAAoAigiB0sEQCAGIAciBWsiCCAAKAIgIAVrSwRAIABBIGogBSAIQQRBBBDZASAAKAIoIQULIAAoAiQiCSAFQQJ0aiEKIAhBAk8EfyAGIAdBf3NqQQJ0IgcEQCAKQQAgB/wLAAsgBSAIaiIHQQFrIQUgCSAHQQJ0akEEawUgCgtBADYCACAFQQFqIQYLIAAgBjYCKAJAAkACQAJAAkACQAJAIAAoAhBBAUcNACAAKAIkIQggAgRAQwAAeEIgACoCaCIRIAAqAmQiEpOVIRMgEiARkkMAAAA/lCESQQAhCgNAIApBFWxBFWoiBSAESw0DIApBAnQhByAKQQFqIQogC/0MAAAAAAAAAAAAAAAAAAAAAP0LAwBBACEMQQYhCSADIQVBACENA0AgCyAJQQZrIg9BA3ZB/P///wFxaiIOQf8AQwAA+EFDAAD4wSATIAUqAgAgEpOUIhEgEUMAAPjBXRsiESARQwAA+EFeGxCtAiIR/ABBgH8gEUMAAADDYBsgEUMAAP5CXhtBACARIBFbG0E/cSIQIA9BHnF0IA4oAgByNgIAIA9B4AFxQSBqIAlJBEAgDUEQTw0GIA4gDigCBCAQIAxBHnF2cjYCBAsgBUEEaiEFIAlBBmohCSAMQQZrIQwgDUEBaiINQRVHDQALIAYgB00NBSALKAIMIQkgCygCCCEMIAsoAgQhDSAIIAdBAnRqIAsoAgA2AgAgB0EBciIFIAZPDQYgCCAFQQJ0aiANNgIAIAdBAnIiBSAGTw0HIAggBUECdGogDDYCACAHQQNyIgUgBk8NCCAIIAVBAnRqIAk2AgAgA0HUAGohAyACIApHDQALCyAAKAIUIAFBAnQgASACakECdBD6AiIAIAggBhCBAiAAQYQBSQ0AIAAQtQILIAtBEGokAA8LIAUgBEGop8IAEKwDAAtBBEEEQfinwgAQnQIACyAHIAZBuKfCABCdAgALIAUgBkHIp8IAEJ0CAAsgBSAGQdinwgAQnQIACyAFIAZB6KfCABCdAgAL4AUBEH8jAEEQayILJAACQCABLQAlDQAgASgCBCEKAkAgASgCECIGIAEoAggiDksNACAGIAEoAgwiA0kNACABQRRqIhEgAS0AGCIIakEBay0AACEJAkAgCEEFTwRAA0AgAyAKaiEEAkAgBiADayIFQQhPBEAgC0EIaiAJIAQgBRDSASALKAIIQQFxRQ0EIAsoAgwhAgwBCyADIAZGDQNBACECA0AgAiAEai0AACAJRg0BIAUgAkEBaiICRw0ACwwDCyABIAIgA2pBAWoiAzYCDCADIA5NIAMgCE9xRQRAIAMgBk0NAQwECwsgCEEEQdSjwAAQrAMACyAJQYGChAhsIQ8DQCADIApqIQcCQCAGIANrIgxBB00EQCADIAZGDQNBACECA0AgAiAHai0AACAJRg0CIAwgAkEBaiICRw0ACwwDCwJAAkAgB0EDakF8cSIFIAdrIgQEQEEAIQIDQCACIAdqLQAAIAlGDQQgBCACQQFqIgJHDQALIAQgDEEIayIQSw0CDAELIAxBCGshEEEAIQQLA0BBgIKECCAFKAIAIA9zIgJrIAJyQYCChAggBUEEaigCACAPcyICayACcnFBgIGChHhxQYCBgoR4Rw0BIAVBCGohBSAEQQhqIgQgEE0NAAsLIAQgDEYNAiAEIAdqIQUgBiAEayADayEHQQAhAgNAIAkgAiAFai0AAEcEQCAHIAJBAWoiAkcNAQwECwsgAiAEaiECCyABIAIgA2pBAWoiAzYCDAJAIAMgCEkgAyAOS3INACAKIAMgCGtqIBEgCBC6Ag0AIAEoAhwhAiABIAM2AhwgAiAKaiENIAMgAmshAgwECyADIAZNDQALDAELIAEgBjYCDAsgAUEBOgAlAkAgAS0AJEEBRgRAIAEoAiAhBSABKAIcIQEMAQsgASgCICIFIAEoAhwiAUYNAQsgASAKaiENIAUgAWshAgsgACACNgIEIAAgDTYCACALQRBqJAAL4QUBBX8gASgCACICQf///wNxIQMgAkGAgICAeHEhBiABKAIEIQQCQCACQYCAgPwHcSIFQYCAgPwHRgRAIANBDXYgBkEQdnIgA0EAR0EJdHJBgPgBciEGDAELIAZBEHYhBiAFQYCAgLgETQRAIAVBgICAxANPBEAgAkEMdiACQf/fAHFBAEdxIAVBDXYgA0ENdmpBgIABaiAGcmohBgwCCyAFQYCAgJgDSQ0BIANBgICABHIiAkEeIAVBF3YiA2t2IQUgAkEdIANrIgN2QQFxBH8gBUEDIAN0QQFrIAJxQQBHagUgBQsgBnIhBgwBCyAGQYD4AXIhBgsgASgCCCEBIARB////A3EhAyAEQYCAgIB4cSEFAkAgBEGAgID8B3EiAkGAgID8B0cEQCAFQRB2IQUgAkGAgIC4BE0EQCACQYCAgMQDTwRAIARBDHYgBEH/3wBxQQBHcSACQQ12IANBDXZqQYCAAWogBXJqIQUMAwsgAkGAgICYA0kNAiADQYCAgARyIgNBHiACQRd2IgJrdiEEIANBHSACayICdkEBcQR/IARBAyACdEEBayADcUEAR2oFIAQLIAVyIQUMAgsgBUGA+AFyIQUMAQsgA0ENdiAFQRB2ciADQQBHQQl0ckGA+AFyIQULIAFB////A3EhAyABQYCAgIB4cSEEAkAgAUGAgID8B3EiAkGAgID8B0cEQCAEQRB2IQQgAkGAgIC4BE0EQCACQYCAgMQDTwRAIAFBDHYgAUH/3wBxQQBHcSACQQ12IANBDXZqQYCAAWogBHJqIQQMAwsgAkGAgICYA0kNAiADQYCAgARyIgNBHiACQRd2IgJrdiEBIANBHSACayICdkEBcQR/IAFBAyACdEEBayADcUEAR2oFIAELIARyIQQMAgsgBEGA+AFyIQQMAQsgA0ENdiAEQRB2ciADQQBHQQl0ckGA+AFyIQQLIAAgBDsBHiAAIAU7ARwgACAGOwEaC48GAgZ/A34jAEGgAWsiAyQAIAG8IQYCf0EDIAGLQwAAgH9bDQAaQQIgBkGAgID8B3EiBUGAgID8B0YNABogBkH///8DcSIHQYCAgARyIAZBAXRB/v//B3EgBkEXdkH/AXEiBBsiCK0iCUIBgyEKIAVFBEBBBCAHRQ0BGiAEQZYBayEEQgEhCyAKUAwBC0KAgIAQIAlCAYYgCEGAgIAERiIHGyEJQgJCASAHGyELQeh+Qel+IAcbIARqIQQgClALIQUgAyAEOwGIASADIAs3A4ABIANCATcDeCADIAk3A3AgAyAFOgCKAQJAAkACQAJAAkACQCAFQQJrIgUEQEEBIQRBoYbCAEGb9MAAIAZBAEgiBxtBoYbCAEEBIAcbIAIbIQdBASAGQR92IAIbIQZBAyAFIAVBA08bQQJrDgICAwELIANBAzYCICADQZz0wAA2AhwgA0ECOwEYQQEhB0EAIQZBASEEDAMLIANBAzYCICADQZ/0wAA2AhwgA0ECOwEYDAILIANBAzYCICADQaL0wAA2AhwgA0ECOwEYDAELIANB4ABqIANB8ABqIANBB2oQQgJAIAMoAmAEQCADQZgBaiADQegAaigCADYCACADIAMpAmA3A5ABDAELIANBkAFqIANB8ABqIANBB2oQLAsgAygClAEiBEUNASADKAKQASIILQAAQTBNDQIgAy4BmAEhAiADIAg2AhwgA0ECOwEYIANBATYCIAJ/IARBAUYEQEEDIQQgA0EkagwBCyADQQI7ATAgA0GwhMIANgIoIANBAjsBJCADIARBAWs2AjggA0EBNgIsIAMgCEEBajYCNEEFIQQgA0E8agsiBUEBOwEMIAVBAjsBACAFQQEgAmsgAkEBayACQQBMIgIbOwEOIAVBAkEBIAIbNgIIIAVBmfTAAEGY9MAAIAIbNgIECyADIAQ2AmwgAyAGNgJkIAMgBzYCYCADIANBGGo2AmggACADQeAAahCNASADQaABaiQADwtBsPLAAEEhQfjzwAAQxAIAC0HE88AAQR9BiPTAABDEAgALqwYBBH8gACABaiECAkACQCAAKAIEIgNBAXENACADQQJxRQ0BIAAoAgAiAyABaiEBIAAgA2siAEGoyMIAKAIARgRAIAIoAgRBA3FBA0cNAUGgyMIAIAE2AgAgAiACKAIEQX5xNgIEIAAgAUEBcjYCBCACIAE2AgAMAgsgACADELQBCwJAAkACQCACKAIEIgNBAnFFBEAgAkGsyMIAKAIARg0CIAJBqMjCACgCAEYNAyACIANBeHEiAxC0ASAAIAEgA2oiAUEBcjYCBCAAIAFqIAE2AgAgAEGoyMIAKAIARw0BQaDIwgAgATYCAA8LIAIgA0F+cTYCBCAAIAFBAXI2AgQgACABaiABNgIACyABQYACTwRAQR8hAiAAQgA3AhAgAUH///8HTQRAIAFBBiABQQh2ZyIDa3ZBAXEgA0EBdGtBPmohAgsgACACNgIcIAJBAnRBgMXCAGohBEEBIAJ0IgNBnMjCACgCAHFFBEAgBCAANgIAIAAgBDYCGCAAIAA2AgwgACAANgIIQZzIwgBBnMjCACgCACADcjYCAA8LAkACQCABIAQoAgAiAygCBEF4cUYEQCADIQIMAQsgAUEZIAJBAXZrQQAgAkEfRxt0IQUDQCADIAVBHXZBBHFqIgQoAhAiAkUNAiAFQQF0IQUgAiEDIAIoAgRBeHEgAUcNAAsLIAIoAggiASAANgIMIAIgADYCCCAAQQA2AhggACACNgIMIAAgATYCCA8LIARBEGogADYCACAAIAM2AhggACAANgIMIAAgADYCCA8LIAFB+AFxQZDGwgBqIQMCf0GYyMIAKAIAIgJBASABQQN2dCIBcUUEQEGYyMIAIAEgAnI2AgAgAwwBCyADKAIICyEBIAMgADYCCCABIAA2AgwgACADNgIMIAAgATYCCA8LQazIwgAgADYCAEGkyMIAQaTIwgAoAgAgAWoiATYCACAAIAFBAXI2AgQgAEGoyMIAKAIARw0BQaDIwgBBADYCAEGoyMIAQQA2AgAPC0GoyMIAIAA2AgBBoMjCAEGgyMIAKAIAIAFqIgE2AgAgACABQQFyNgIEIAAgAWogATYCAAsL7QQBDH8jAEEgayIEJAACQAJAAkAgACgCACIBQQNGIAFBAklyDQACQAJAIAAtABRBAWsOAgIAAQsgBEEANgIYIARBATYCDCAEQbiRwgA2AgggBEIENwIQIARBCGpBwJHCABDaAgALIAAoAgghCiAAKAIMIgwEQANAIAogB0EMbGoiBSgCBCELIAUoAggiCQRAIAtBJGohAQNAIAFBBGsoAgAiAkGAgICAeHJBgICAgHhHBEAgASgCACIGQQRrKAIAIgNBeHEiCEEEQQggA0EDcSIDGyACakkNByADQQAgCCACQSdqSxsNBiAGEFsLAkAgAUEUaygCACIGQQJGDQAgAUEQayECAkAgBkUEQCACKAIAIgJFDQIgAUEMaygCACIGQQRrKAIAIgNBeHEiCEEEQQggA0EDcSIDGyACakkNCSADRSAIIAJBJ2pNcg0BDAgLIAIoAgAiAkUNASABQQxrKAIAIgZBBGsoAgAiA0F4cSIIIAJBAXQiAkEEQQggA0EDcSIDG2pJDQggA0UNACAIIAJBJ2pLDQcLIAYQWwsgAUEsaiEBIAlBAWsiCQ0ACwsgBSgCACIBBEAgC0EEaygCACIFQXhxIgkgAUEsbCIBQQRBCCAFQQNxIgUbakkNBSAFQQAgCSABQSdqSxsNBCALEFsLIAdBAWoiByAMRw0ACwsgACgCBCIARQ0AIApBBGsoAgAiAUF4cSIHIABBDGwiAEEEQQggAUEDcSIBG2pJDQIgAUEAIAcgAEEnaksbDQEgChBbCyAEQSBqJAAPC0GYqcIAQS5ByKnCABDEAgALQdiowgBBLkGIqcIAEMQCAAuzCAIFfwN+IwBBQGoiASQAIAFBBjYCBCABQdyywgA2AgBB2MTCAC0AAEEDRwRAAkAjAEEgayICJAACQAJAAkACQEHYxMIALQAAQQJrDgIDAQALQdjEwgBBAjoAAEGACBAuIgNFDQFB2MTCAEEDOgAAQcjEwgAgAzYCAEHAxMIAQoCAgICAgAE3AwBBsMTCAEIANwMAQdDEwgBBADoAAEHMxMIAQQA2AgBBvMTCAEEAOgAAQbjEwgBBADYCAAsgAkEgaiQADAILAAsgAkEANgIYIAJBATYCDCACQfS2wgA2AgggAkIENwIQIAJBCGpBmLTCABDaAgALCwJAAkACQAJAAkACQEHwxMIAKQMAIgZQBEBB+MTCACkDACEHA0AgB0J/UQ0CQfjEwgAgB0IBfCIGQfjEwgApAwAiCCAHIAhRIgIbNwMAIAghByACRQ0AC0HwxMIAIAY3AwALAkACQEGwxMIAKQMAIAZSBEBBvMTCAC0AACECQQEhA0G8xMIAQQE6AAAgASACOgAYIAJFDQEgAUIANwI0IAFCgYCAgMAANwIsIAFB8LPCADYCKCABQRhqIAFBKGoQ0QIAC0G4xMIAKAIAIgJBf0cEQCACQQFqIQMMAgtBqLTCAEEmQdC0wgAQqQIAC0GwxMIAIAY3AwALQbjEwgAgAzYCACABQbDEwgA2AhAgACgCBBogAUEEOgAYIAEgAUEQajYCIAJAAkAgAUEYakHAqMIAIAAQjAEEQCABLQAYQQRHDQEgAUEANgI4IAFBATYCLCABQbizwgA2AiggAUIENwIwIAFBKGpBwLPCABDaAgALIAFBBDoACCABKAIcIQAgAS0AGCICQQRNIAJBA0dxDQEgACgCACECIABBBGooAgAiAygCACIEBEAgAiAEEQMACyADKAIEIgMEQCACQQRrKAIAIgRBeHEiBUEEQQggBEEDcSIEGyADakkNBCAEQQAgBSADQSdqSxsNBSACEFsLIABBBGsoAgAiAkF4cSIDQRBBFCACQQNxIgIbSQ0FIAJBACADQTRPGw0GIAAQWwwBCyABIAEpAxg3AwgLIAEoAhAiACAAKAIIQQFrIgI2AgggAkUEQCAAQQA6AAwgAEIANwMACyABLQAIQQRHDQUgAUFAayQADwsjAEEgayIAJAAgAEEANgIYIABBATYCDCAAQZCqwgA2AgggAEIENwIQIABBCGpBmKrCABDaAgALQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIAC0HYqMIAQS5BiKnCABDEAgALQZipwgBBLkHIqcIAEMQCAAsgASABKQMINwMQIAFBAjYCLCABQbyywgA2AiggAUICNwI0IAEgAUEQaq1CgICAgNAFhDcDICABIAGtQoCAgIAghDcDGCABIAFBGGo2AjAgAUEoakHMssIAENoCAAvKBgIIfwF+IwBBMGsiAiQAQQEhBCABKAIAQZWKwgBBASABKAIEKAIMEQAAIQMgAkEBOgALIAJBADsACSACIAM6AAggAiABNgIEAkACQAJAIAAoAgwiBgRAIAJBC2ohByAAKAIAIgRBCGohASAEKQMAQn+FQoCBgoSIkKDAgH+DIQpBACEAA0AgClAEQANAIARBQGohBCABKQMAIAFBCGohAUKAgYKEiJCgwIB/gyIKQoCBgoSIkKDAgH9RDQALIApCgIGChIiQoMCAf4UhCgsgACEFQQEhACADQQFxIQMCf0EBIAMNABoCQAJAAkACQAJAIAItAApFBEAgBCAKeqdB+ABxayIJQQhrIQggAigCBCIDLQAKQYABcUUEQCAFQQFxDQIMAwsgBUEBcUUEQEEBIAMoAgBB7LTCAEEBIAMoAgQoAgwRAAANBxoLIAJBAToACyACIAc2AhQgAkHk+MAANgIcIAIgAykCADcCDCACIAMpAgg3AiAgAiACQQxqNgIYIAggAkEYahDWAQ0EIAIoAhhBqqjCAEECIAIoAhwoAgwRAAANBAwDCyACQQA2AiggAkEBNgIcIAJB1PnAADYCGCACQgQ3AiAgAkEYakHc+cAAENoCAAtBASADKAIAQbWJwgBBAiADKAIEKAIMEQAADQQaC0EBIAggAxDWAQ0DGkEBIAMoAgBBqqjCAEECIAMoAgQoAgwRAAANAxoLIAlBBGshAyACQQA6AAggAkEBOgAKIAIoAgQiBS0ACkGAAXFFBEBBASADIAUQxAENAxoMAgsgAiAHNgIUIAJB5PjAADYCHCACIAUpAgA3AgwgAiAFKQIINwIgIAIgAkEMajYCGCADIAJBGGoQxAENACACKAIYQYP5wABBAiACKAIcKAIMEQAARQ0BC0EBDAELIAJBADoACkEACyEDIApCAX0gCoMhCiACQQE6AAkgAiADOgAIIAZBAWsiBg0AC0EBIQQgAw0CIAIoAgQhAQwBCyADDQELIAItAAoNASABKAIAQaKGwgBBASABKAIEKAIMEQAAIQQLIAJBMGokACAEDwsgAkEANgIoIAJBATYCHCACQZz6wAA2AhggAkIENwIgIAJBGGpBpPrAABDaAgAL8gUCBH4Gf0G8wsIAKAIAIgdB0MLCACkDACICIAGthSIDQjiGIANCgP4Dg0IohoQgA0KAgPwHg0IYhiADQoCAgPgPg0IIhoSEIAJCCIhCgICA+A+DIAJCGIhCgID8B4OEIAJCKIhCgP4DgyACQjiIhISEQtKBqpur+oLXp39+IgJCOIYgAkKA/gODQiiGhCACQoCA/AeDQhiGIAJCgICA+A+DQgiGhIQgAkIIiEKAgID4D4MgAkIYiEKAgPwHg4QgAkIoiEKA/gODIAJCOIiEhIQgA0LYotHvwqnlvy1+hSICQjiGIAJCgP4Dg0IohoQgAkKAgPwHg0IYhiACQoCAgPgPg0IIhoSEIAJCCIhCgICA+A+DIAJCGIhCgID8B4OEIAJCKIhCgP4DgyACQjiIhISEQcjCwgApAwAiA0J/hX4iBEI4hiAEQoD+A4NCKIaEIARCgID8B4NCGIYgBEKAgID4D4NCCIaEhCAEQgiIQoCAgPgPgyAEQhiIQoCA/AeDhCAEQiiIQoD+A4MgBEI4iISEhCACIANCOIYgA0KA/gODQiiGhCADQoCA/AeDQhiGIANCgICA+A+DQgiGhIQgA0IIiEKAgID4D4MgA0IYiEKAgPwHg4QgA0IoiEKA/gODIANCOIiEhIR+hSACiSIDp3EhBiADQhmIQv8Ag0KBgoSIkKDAgAF+IQVBuMLCACgCACIIQShrIQoCQANAAkAgBiAIaikAACIEIAWFIgJCf4UgAkKBgoSIkKDAgAF9g0KAgYKEiJCgwIB/gyICUEUEQANAIApBACACeqdBA3YgBmogB3FrIgtBKGxqKAIAIAFGDQIgAkIBfSACgyICUEUNAAsLIAQgBEIBhoNCgIGChIiQoMCAf4NQRQ0CIAYgCUEIaiIJaiAHcSEGDAELCyAAQbjCwgA2AgQgACAIIAtBKGxqNgIAIABBADYCDA8LQcDCwgAoAgBFBEAQOQsgACABNgIIIAAgAzcDACAAQbjCwgA2AgwLkgYBBX8jAEHA0gBrIgMkAAJAAkACQAJAIAJBCU0EQCAAQYCAgIB4NgIADAELAkACQCABLQAAQR9HDQAgAS0AAUGLAUcNACABLQACQQhHDQBBCiEEIAEtAAMiBUEEcUUNASACQQxJBEAgAEGAgICAeDYCAAwDCyACIAEvAApBDGoiBE8NASAAQYCAgIB4NgIADAILIANBADYCHCADQQE2AhAgA0HQpcIANgIMIANCBDcCFCADQQxqEKACIQEgAEGBgICAeDYCACAAIAE2AgQMAQsgBUEIcQRAAkAgAiAESwRAA0AgASAEai0AAEUNAiACIARBAWoiBEcNAAsLIABBgICAgHg2AgAMAgsgBEEBaiEECwJAIAVBEHFFDQAgAiAESwRAA0AgASAEai0AAEUEQCAEQQFqIQQMAwsgAiAEQQFqIgRHDQALCyAAQYCAgIB4NgIADAELAkACQCAFQQJxBEAgAiAEQQJqIgRJDQELIAIgBEsNASAAQYCAgIB4NgIADAILIABBgICAgHg2AgAMAQtBBBAuIgVFDQEgBUEEayIGLQAAQQNxBEAgBUEANgAACyADQQxqIgdBAEGB0gD8CwAgA0Gg0gBqIAcgASAEaiACIARrIAVBBEEAECggAyADLQCkUiIBOgCTUgJAAkACQAJAIAEOAwECAQALIAFB/wFHBEAgA0EBNgKkUiADQbCmwgA2AqBSIANCATcCrFIgAyADQZPSAGqtQoCAgICgAYQ3A7hSIAMgA0G40gBqNgKoUiADQZTSAGoiASADQaDSAGoQ/gEgARCeAiEBIABBgYCAgHg2AgAgACABNgIEDAMLIABBADYCCCAAQoCAgIAQNwIADAILIAMoAqhSIQEgACAFNgIEIABBBDYCACAAQQQgASABQQRPGzYCCAwCCyAAQYCAgIB4NgIACyAGKAIAIgBBeHEiAUEIQQwgAEEDcSIAG0kNAiAAQQAgAUEsTxsNAyAFEFsLIANBwNIAaiQADwsAC0HYqMIAQS5BiKnCABDEAgALQZipwgBBLkHIqcIAEMQCAAuYBQIGfwF+AkAgASgCCCICIAEoAgQiBE8NACABKAIAIAJqLQAAQfUARw0AQQEhByABIAJBAWoiAjYCCAsCQAJAIAIgBEkEQCABKAIAIgYgAmotAABBMGsiA0H/AXEiBUEKSQ0BCwwBCyABIAJBAWoiAjYCCAJAAkAgBUUEQEEAIQMMAQsgA0H/AXEhAwNAIAIgBEYEQCAEIQIMAwsgAiAGai0AAEEwa0H/AXEiBUEJSw0BIAEgAkEBaiICNgIIIAOtQgp+IghCIIhQBEAgBSAIpyIFaiIDIAVPDQELCwwCCyACIARPDQAgAiAGai0AAEHfAEcNACABIAJBAWoiAjYCCAsgAiACIANqIgVLBEAMAQsgASAFNgIIAkACQAJAIAQgBU8EQCACRSACIARPcg0BIAIgBmosAABBv39KDQEMAgsMAwsgBUUgBCAFTXJFBEAgBSAGaiwAAEG/f0wNAQsgAiAGaiEEIAcNASAAQgE3AgggACADNgIEIAAgBDYCAA8LIAYgBCACIAVBxIjCABCVAwALIAIgBmpBAWshBiADIQECfwNAIAEiAkUEQEEAIQEgBCEFQQEMAgsgAkEBayEBIAIgBmotAABB3wBHDQALAkACQCABRQ0AAkAgASADTwRAIAEgA0cNASACDQJBACEGDAMLIAEgBGosAABBv39KDQELIAQgA0EAIAFB1IjCABCVAwALAkAgAiADTwRAIAMhBiACIANHDQEMAgsgAiAEaiwAAEG/f0wNACACIQYMAQsgBCADIAIgA0HkiMIAEJUDAAsgBCAGaiEFIAMgBmshAyAECyECIANFBEAMAQsgACADNgIMIAAgBTYCCCAAIAE2AgQgACACNgIADwsgAEEANgIAIABBADoABAuWBgEDfyMAQSBrIgMkACAAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEOKAIBAQEBAQEBAQMFAQEEAQEBAQEBAQEBAQEBAQEBAQEBAQEIAQEBAQcACyABQdwARg0FCyACQQFxRSABQf8FTXINByABELcBRQ0HIANBDmpBADoAACADQQA7AQwgAyABQRR2QfCAwgBqLQAAOgAPIAMgAUEEdkEPcUHwgMIAai0AADoAEyADIAFBCHZBD3FB8IDCAGotAAA6ABIgAyABQQx2QQ9xQfCAwgBqLQAAOgARIAMgAUEQdkEPcUHwgMIAai0AADoAECABQQFyZ0ECdiICIANBDGoiBWoiBEH7ADoAACAEQQFrQfUAOgAAIAUgAkECayICakHcADoAACADQRRqIgQgAUEPcUHwgMIAai0AADoAACAAIAMpAQw3AAAgA0H9ADoAFQwICyAAQgA3AQIgAEHc4AA7AQAMCgsgAEIANwECIABB3OgBOwEADAkLIABCADcBAiAAQdzkATsBAAwICyAAQgA3AQIgAEHc3AE7AQAMBwsgAEIANwECIABB3LgBOwEADAYLIAJBgAJxRQ0BIABCADcBAiAAQdzOADsBAAwFCyACQf///wdxQYCABE8NAwsgARD6AQ0BIANBGGpBADoAACADQQA7ARYgAyABQRR2QfCAwgBqLQAAOgAZIAMgAUEEdkEPcUHwgMIAai0AADoAHSADIAFBCHZBD3FB8IDCAGotAAA6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QYCAgNgDciADQRd0a3ILIQUgAS8BJCEBAn8gAkH//wFxBEAgAkH/B3EhAyACQYCAAnEhBCACQYD4AXEiAkGA+AFHBEAgBEEQdCIEIAJBDXRBgICA/ABxIANBDXRyQYCAgMADanIgAg0CGiADIANnQRBrIgJB//8DcUEIanRB////A3EgBEGAgIDYA3IgAkEXdGtyDAILIARBEHQiAiADQQ10ckGAgID+B3IgAw0BGiACQYCAgPwHcgwBCyACQRB0CyEDIAACfyABQf//AXEEQCABQf8HcSEAIAFBgIACcSECIAFBgPgBcSIBQYD4AUcEQCACQRB0IgIgAUENdEGAgID8AHEgAEENdHJBgICAwANqciABDQIaIAAgAGdBEGsiAEH//wNxQQhqdEH///8DcSACQYCAgNgDciAAQRd0a3IMAgsgAkEQdCIBIABBDXRyQYCAgP4HciAADQEaIAFBgICA/AdyDAELIAFBEHQLvhCcAf0TIAW+EJwB/SAAIAO+EJwB/SAB/QsEAAu2BAEEfyABLwEcIQQCfyABLwEaIgJB//8BcUUEQCACQRB0DAELIAJB/wdxIQUgAkGAgAJxIQMgAkGA+AFxIgJBgPgBRgRAIANBEHQhAiACQYCAgPwHciAFRQ0BGiACIAVBDXRyQYCAgP4HcgwBCyADQRB0IQMgAkENdEGAgID8AHEgBUENdHJBgICAwANqIANyIAINABogBSAFZ0EQayIFQf//A3FBCGp0Qf///wNxIANBgICA2ANyIAVBF3RrcgshBSABLwEeIQECfyAEQf//AXEEQCAEQf8HcSECIARBgIACcSEDIARBgPgBcSIEQYD4AUcEQCADQRB0IQMgBEENdEGAgID8AHEgAkENdHJBgICAwANqIANyIAQNAhogAiACZ0EQayIEQf//A3FBCGp0Qf///wNxIANBgICA2ANyIARBF3RrcgwCCyADQRB0IQQgBCACQQ10ckGAgID+B3IgAg0BGiAEQYCAgPwHcgwBCyAEQRB0CyEEIAACfyABQf//AXEEQCABQf8HcSECIAFBgIACcSEDIAFBgPgBcSIBQYD4AUcEQCADQRB0IQMgAUENdEGAgID8AHEgAkENdHJBgICAwANqIANyIAENAhogAiACZ0EQayIBQf//A3FBCGp0Qf///wNxIANBgICA2ANyIAFBF3RrcgwC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IAEoAhwhAQwBCyABKAIgIgIgASgCHCIBRg0BCyABIAdqIQggAiABayEDCyAAIAM2AgQgACAINgIAIAZBEGokAAuWAwEDfyMAQYABayIEJAACfwJAIAEoAggiAkGAgIAQcUUEQCACQYCAgCBxDQFBAyECIAAtAAAiACEDIABBCk8EQCAEIAAgAEHkAG4iA0HkAGxrQf8BcUEBdCICQbX6wABqLQAAOgACIAQgAkG0+sAAai0AADoAAUEBIQILQQAgACADG0UEQCAEIAJBAWsiAmogA0EBdEH+AXFBtfrAAGotAAA6AAALIAFBAUEBQQAgAiAEakEDIAJrEI4BDAILIAAtAAAhAkGBASEAA0AgACAEakECayACQQ9xIgNBMHIgA0HXAGogA0EKSRs6AAAgAkH/AXEiA0EEdiECIABBAWshACADQQ9LDQALIAFBAUGbisIAQQIgACAEakEBa0GBASAAaxCOAQwBCyAALQAAIQJBgQEhAANAIAAgBGpBAmsgAkEPcSIDQTByIANBN2ogA0EKSRs6AAAgAkH/AXEiA0EEdiECIABBAWshACADQQ9LDQALIAFBAUGbisIAQQIgACAEakEBa0GBASAAaxCOAQsgBEGAAWokAAu8AwIGfwF+IwBB0ABrIgIkACACQSBqIAAgACgCACgCBBECACACIAJByABqrUKAgICAwAGENwMoQQEhAyACQQE2AjQgAkHcq8IANgIwIAJCATcCPCACIAIpAyA3AkggAiACQShqNgI4AkAgASgCACIGIAEoAgQiByACQTBqEIwBDQAgAS0ACkGAAXFFBEBBACEDDAELIAJBGGogACAAKAIAKAIEEQIAIAJBEGogAigCGCACKAIcKAIYEQIAIAIoAhAiBEUEQEEAIQMMAQsgAkEIaiAEIAIoAhQiBSgCGBECACACKAIMIQAgAigCCCEBIAIgBTYCLCACIAQ2AiggAkEBNgI0IAJBoM/AADYCMCACQgE3AjwgAiACQShqrUKAgICAwAGEIgg3A0ggAiACQcgAajYCOCAGIAcgAkEwahCKAw0AA0AgAUUEQEEAIQMMAgsgAiABIAAoAhgRAgAgAigCBCACKAIAIAIgADYCLCACIAE2AiggAkEBNgI0IAJBoM/AADYCMCACQgE3AjwgAiAINwNIIAIgAkHIAGo2AjghASEAIAYgByACQTBq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A0F4cSIEQQRBCCADQQNxIgMbIAJqSQ0BIANBACAEIAJBJ2pLGw0CIAEQWwsgACgCFCEBIAAoAhgiAigCACIDBEAgASADEQMACyACKAIEIgIEQCABQQRrKAIAIgNBeHEiBEEEQQggA0EDcSIDGyACakkNASADQQAgBCACQSdqSxsNAiABEFsLAkAgAEF/Rg0AIAAgACgCBEEBayIBNgIEIAENACAAQQRrKAIAIgFBeHEiAkEgQSQgAUEDcSIBG0kNASABQQAgAkHEAE8bDQIgABBbCw8LQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIAC9cCAQV/QRFBACAAQa+wBE8bIgIgAkEIciIBIABBC3QiAiABQQJ0QYSUwQBqKAIAQQt0SRsiASABQQRyIgEgAUECdEGElMEAaigCAEELdCACSxsiASABQQJyIgEgAUECdEGElMEAaigCAEELdCACSxsiASABQQFqIgEgAUECdEGElMEAaigCAEELdCACSxsiASABQQFqIgEgAUECdEGElMEAaigCAEELdCACSxsiAUECdEGElMEAaigCAEELdCIEIAJGIAIgBEtqIAFqIgRBAnRBhJTBAGoiBSgCAEEVdiECQe8FIQECQCAEQSBNBEAgBSgCBEEVdiEBIARFDQELIAVBBGsoAgBB////AHEhAwsCQCABIAJBf3NqRQ0AIAAgA2shAyABQQFrIQFBACEAA0AgACACQe/ZwABqLQAAaiIAIANLDQEgASACQQFqIgJHDQALCyACQQFxC9cCAQV/QRJBACAAQbC4BE8bIgIgAkEJciIBIABBC3QiAiABQQJ0QZiSwQBqKAIAQQt0SRsiASABQQVqIgEgAUECdEGYksEAaigCAEELdCACSxsiASABQQJqIgEgAUECdEGYksEAaigCAEELdCACSxsiASABQQFqIgEgAUECdEGYksEAaigCAEELdCACSxsiASABQQFqIgEgAUECdEGYksEAaigCAEELdCACSxsiAUECdEGYksEAaigCAEELdCIEIAJGIAIgBEtqIAFqIgRBAnRBmJLBAGoiBSgCAEEVdiECQYkHIQECQCAEQSNNBEAgBSgCBEEVdiEBIARFDQELIAVBBGsoAgBB////AHEhAwsCQCABIAJBf3NqRQ0AIAAgA2shAyABQQFrIQFBACEAA0AgACAC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AiAGaiADIAQQ9gEhAgsgBCgCAEEEaigCACAAKAIAIAEoAgAQigEiAyAEKAIAQQRqKAIAIAAoAgAgAigCABCKAUYEfyACIAEgBCgCAEEEaigCACABKAIAIAIoAgAQigEgA3MbBSAACwu9AQEEfyMAQRBrIgIkACACQQhqIgMgAUEkaigCADYCACACIAEpAhw3AwACQAJAQQwQLiIEBEAgBCACKQMANwIAIARBCGogAygCADYCACABQQRqEHEgAUEEaygCACIDQXhxQSxBMCADQQNxIgUbSQ0BIAVBACADQdAATxsNAiABEFsgAEHMjsIANgIEIAAgBDYCACACQRBqJAAPCwALQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIAC6gBAQN/IwBBEGsiAyQAQQMhAiAALQAAIgAhBCAAQQpPBEAgAyAAIABB5ABuIgRB5ABsa0H/AXFBAXQiAkG1+sAAai0AADoADyADIAJBtPrAAGotAAA6AA5BASECC0EAIAAgBBtFBEAgAkEBayICIANBDWpqIARBAXRB/gFxQbX6wABqLQAAOgAACyABQQFBAUEAIANBDWogAmpBAyACaxCOASADQRBqJAALqgMBCH8jAEEQayIDJAAgACgCBCEFIAAoAgAhAEEBIQcgASgCAEG3icIAQQEgASgCBCgCDBEAACECIANBADoACSADIAI6AAggAyABNgIEAkACQCAFBEADQCADIAA2AgwgA0EMaiEIIwBBIGsiASQAQQEhBgJAIANBBGoiBC0ABA0AIAQtAAUhCQJAIAQoAgAiAi0ACkGAAXFFBEAgCUEBcUUNASACKAIAQbWJwgBBAiACKAIEKAIMEQAARQ0BDAILIAlBAXFFBEAgAigCAEHstMIAQQEgAigCBCgCDBEAAA0CCyABQQE6AA8gAUHk+MAANgIUIAEgAikCADcCACABIAIpAgg3AhggASABQQ9qNgIIIAEgATYCECAIIAFBEGoQxgINASABKAIQQYP5wABBAiABKAIUKAIMEQAAIQYMAQsgCCACEMYCIQYLIARBAToABSAEIAY6AAQgAUEgaiQAIABBAWohACAFQQFrIgUNAAsgAy0ACEEBcUUNAQwCCyACDQELIAMoAgQiACgCAEG4icIAQQEgACgCBCgCDBEAACEHCyADQRBqJAAgBwvhAQAgAEEg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DygCEBEAACIJRQ0ACyACQQA2AhAgAkKAgICAEDcCCCACQdydwAA2AhwgAkKggICADjcCICACIAJBCGo2AhggCSACQRhqEKwBDQggAigCCCEAIAIoAgwiBCACKAIQEIADIQMgAARAIARBBGsoAgAiBUF4cSIIQQRBCCAFQQNxIgUbIABqSQ0KIAVBACAIIABBJ2pLGw0LIAQQWwsgCSAJKAIAKAIAEQMAQQEhAEGUwsIAQZTCwgAoAgBBAWo2AgAgBkGDAUsNAQwCC0EAIQBBlMLCAEGUwsIAKAIAQQFqNgIAIAZBhAFJDQELIAcgEUkhACAGELUCCyALQQA2AgAgDCAMKAIAQQFrIgY2AgAgBkUEQCAMELYBCyAKIAA2AgQgCiADQQAgABs2AgAgAkEwaiQADAgLELMDCwALELUDAAtBzJ3AABC4AgALIAJBADYCGCACQRRqIAJBCGogAkEYakHc78EAEM8CAAtBvM3AAEE3IAJBFGpB9J3AAEH0zcAAEJMCAAtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgALIAooAgAgCigCBCAKQRBqJAALKgAgACABLQAAQQJ0IgFBpMvAAGooAgA2AgQgACABQbjLwABqKAIANgIACyEAAkAgAARAIAAoAgBFDQEQtQMACxCzAwALIAAgATYCRAshAAJAIAAEQCAAKAIARQ0BELUDAAsQswMACyAAIAE2AkgLJQAgAEUEQEGo78EAQTIQtAMACyAAIAIgAyAEIAUgASgCEBEPAAslACABIAAtAABBAnQiAEGAucIAaigCACAAQey4wgBqKAIAEIQBCyMAIABFBEBBqO/BAEEyELQDAAsgACACIAMgBCABKAIQERIACyMAIABFBEBBqO/BAEEyELQDAAsgACACIAMgBCABKAIQEQcACyMAIABFBEBBqO/BAEEyELQDAAsgACACIAMgBCABKAIQET4ACyMAIABFBEBBqO/BAEEyELQDAAsgACACIAMgBCABKAIQEUAACyMAIABFBEBBqO/BAEEyELQDAAsgACACIAMgBCABKAIQEUIACycAIAAoAgAtAABFBEAgAUGMisIAQQUQhAEPCyABQZGKwgBBBBCEAQsnACAAQRxqQQAgAkKtoMydv86x+lJRG0EAIAFCucS3xZeH/65OURsLKAAgAEEcakEAIAJC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ZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2NvcmUvc3JjL3NsaWNlL2luZGV4LnJzAGxpYnJhcnkvY29yZS9zcmMvbnVtL2ZsdDJkZWMvc3RyYXRlZ3kvZ3Jpc3UucnMAc3BhcmstaW50ZXJuYWwtcnMvc3JjL3JheWNhc3QucnMAbGlicmFyeS9jb3JlL3NyYy9zbGljZS9zb3J0L3NoYXJlZC9zbWFsbHNvcnQucnMAL1VzZXJzL2FzdW5kcXVpLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9zb3J0L3N0YWJsZS9xdWlja3NvcnQucnMAc3BhcmstaW50ZXJuYWwtcnMvc3JjL3NvcnQucnMAbGlicmFyeS9hbGxvYy9zcmMvZm10LnJzAC9Vc2Vycy9hc3VuZHF1aS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2FueWhvdy0xLjAuOTgvc3JjL2ZtdC5ycwBsaWJyYXJ5L2NvcmUvc3JjL251bS9kaXlfZmxvYXQucnMAc3BhcmstbGliL3NyYy9nc3BsYXQucnMAc3BhcmstaW50ZXJuYWwtcnMvc3JjL3BhY2tlZF9zcGxhdHMucnMAbGlicmFyeS9jb3JlL3NyYy9mbXQvYnVpbGRlcnMucnMAbGlicmFyeS9zdGQvc3JjL3N5cy9zeW5jL211dGV4L25vX3RocmVhZHMucnMAL1VzZXJzL2FzdW5kcXVpLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9zdGQvc3JjL3N5cy9zeW5jL29uY2Uvbm9fdGhyZWFkcy5ycwBsaWJyYXJ5L2FsbG9jL3NyYy9zdHIucnMAL1VzZXJzL2FzdW5kcXVpLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9jb3JlL3NyYy9pdGVyL3RyYWl0cy9pdGVyYXRvci5ycwAvVXNlcnMvYXN1bmRxdWkvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9hbnlob3ctMS4wLjk4L3NyYy9lcnJvci5ycwBsaWJyYXJ5L2NvcmUvc3JjL3NsaWNlL21lbWNoci5ycwAvVXNlcnMvYXN1bmRxdWkvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9taW5pel9veGlkZS0wLjguOS9zcmMvaW5mbGF0ZS9vdXRwdXRfYnVmZmVyLnJzAC9Vc2Vycy9hc3VuZHF1aS9zcGFyazMvcnVzdC9zcGFyay1saWIvc3JjL2RlY29kZXIucnMAbGlicmFyeS9zdGQvc3JjL2lvL3N0ZGlvLnJzAC9Vc2Vycy9hc3VuZHF1aS8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvY29yZS9zcmMvc3RyL3BhdHRlcm4ucnMAL3J1c3RjLzI5NDgzODgzZWVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9jb3JlL3NyYy9zdHIvcGF0dGVybi5ycwAvcnVzdGMvMjk0ODM4ODNlZWQ2OWQ1ZmI0ZGIwMTk2NGNkZjJhZjRkODZlOWNiMi9saWJyYXJ5L2NvcmUvc3JjL29wcy9mdW5jdGlvbi5ycwBsaWJyYXJ5L2NvcmUvc3JjL251bS9mbHQyZGVjL3N0cmF0ZWd5L2RyYWdvbi5ycwBsaWJyYXJ5L2NvcmUvc3JjL251bS9iaWdudW0ucnMAbGlicmFyeS9zdGQvc3JjL2lvL2J1ZmZlcmVkL2xpbmV3cml0ZXJzaGltLnJzAC9Vc2Vycy9hc3VuZHF1aS8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvc3RkL3NyYy90aHJlYWQvbG9jYWwucnMAbGlicmFyeS9zdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzAGxpYnJhcnkvc3RkL3NyYy9zeW5jL3JlZW50cmFudF9sb2NrLnJzAC9Vc2Vycy9hc3VuZHF1aS8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAvVXNlcnMvYXN1bmRxdWkvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9taW5pel9veGlkZS0wLjguOS9zcmMvaW5mbGF0ZS9jb3JlLnJzAGxpYnJhcnkvY29yZS9zcmMvdW5pY29kZS9wcmludGFibGUucnMAc3BhcmstaW50ZXJuYWwtcnMvc3JjL2xvZF90cmVlLnJzAHNwYXJrLWxpYi9zcmMvc3BsYXRfZW5jb2RlLnJzAGxpYnJhcnkvc3RkL3NyYy9zeW5jL3BvaXNvbi9vbmNlLnJzAC9Vc2Vycy9hc3VuZHF1aS8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJzAGxpYnJhcnkvc3RkL3NyYy9iYWNrdHJhY2UucnMAL3J1c3QvZGVwcy9oYXNoYnJvd24tMC4xNS40L3NyYy9yYXcvbW9kLnJzAGxpYnJhcnkvY29yZS9zcmMvZm10L21vZC5ycwBsaWJyYXJ5L2NvcmUvc3JjL3N0ci9tb2QucnMAL1VzZXJzL2FzdW5kcXVpLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvYmluYXJ5X2hlYXAvbW9kLnJzAGxpYnJhcnkvc3RkL3NyYy9pby9tb2QucnMAbGlicmFyeS9zdGQvc3JjLy4uLy4uL2JhY2t0cmFjZS9zcmMvc3ltYm9saXplL21vZC5ycwBsaWJyYXJ5L3N0ZC9zcmMvdGhyZWFkL21vZC5ycwAvVXNlcnMvYXN1bmRxdWkvLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjL21vZC5ycwAvVXNlcnMvYXN1bmRxdWkvLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy92ZWMvbW9kLnJzAGxpYnJhcnkvY29yZS9zcmMvbnVtL2ZsdDJkZWMvbW9kLnJzAHNwYXJrLWxpYi9zcmMvcXVpY2tfbG9kLnJzAC9ydXN0L2RlcHMvZGxtYWxsb2MtMC4yLjkvc3JjL2RsbWFsbG9jLnJzAHNwYXJrLWludGVybmFsLXJzL3NyYy9saWIucnMAL1VzZXJzL2FzdW5kcXVpLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvanMtc3lzLTAuMy43Ny9zcmMvbGliLnJzAC9ydXN0L2RlcHMvcnVzdGMtZGVtYW5nbGUtMC4xLjI1L3NyYy9saWIucnMAL1VzZXJzL2FzdW5kcXVpLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvc2VyZGUtd2FzbS1iaW5kZ2VuLTAuNi41L3NyYy9saWIucnMAL1VzZXJzL2FzdW5kcXVpLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvb25jZV9jZWxsLTEuMjEuMy9zcmMvbGliLnJzAC9Vc2Vycy9hc3VuZHF1aS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3NtYWxsdmVjLTEuMTUuMS9zcmMvbGliLnJzAGxpYnJhcnkvY29yZS9zcmMvdW5pY29kZS91bmljb2RlX2RhdGEucnMAc3BhcmstbGliL3NyYy9zeW1tYXQzLnJzAC9ydXN0L2RlcHMvcnVzdGMtZGVtYW5nbGUtMC4xLjI1L3NyYy92MC5y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AgYBAWUBAQECBAEFAAkBAgACAQEEAZAEAgIEASAKKAYCBAgBCQYCAy4NAQIABwEGAQFSFgIHAQIBAnoGAwEBAgEHAQFIAgMBAQEAAgsCNAUFAQEBFwEAEQYPAAwDAwAFOwcJBAADKAIAAT8RQAIBAgAEAQcBAgACAQQALgIXAAMJEAIHHgSUAwA3BDIIAQ4BFgUBDwAHARECBwECAQUFPiEBoA4AAT0EAAX+AgAHbQgABQABHmCA8ABBGgYaLwEKAQQBBRcBHwHDAQQE0AEkBwIeBWABKgQCAgIEAQEGAQEDAQEBFAFTAYsIpgEmCSkAJgEBBQECKwEEAFYCBgALBSsCA0DAQAACBgImAgYCCAEBAQEBAQEfAjUBBwEBAwMBBwMEAgYEDQUDAQd0AQ0BEA1lAQQBAgoBAQMFBgEBAQEBAQQBBgQBAgQFBQQBESADAgA0AOUGBAMCDCYBAQUBAC4SHoRmAwQBPgICAQEBCBUFAQMAKwEOBlAABwwFABoGGgBQYCQEJHQLAQ8BBwECAQsBDwEHAQIAAQIDASoBCQAzDTNdFgoWAEAAQABVAUcBAgIBAgICBAEMAQEBBwFBAQQCCAEHARwBBAEFAQEDBwEAAhkBGQEfARkBHwEZAR8BGQEfARkBCAAKARQGBgA+AEQAGgYaBhoAAHAABwAtAQEBAgECAQFICzAVEAFlBwIGAgIBBCMBHhtbCzoJCQEYBAEJAQMBBSsDOwkqGAEgNwEBAQQIBAEDBwoCHQE6AQEBAgQIAQkBCgIaAQICOQEEAgQCAgMDAR4CAwELAjkBBAUBAgQBFAIWBgEBOgEBAgEECAEHAwoCHgE7AQEBDAEJASgBAwE3AQEDBQMBBAcCCwIdAToBAgIBAQMDAQQHAgsCHAI5AgEBAgQIAQkBCgIdAUgBBAECAwEBCAFRAQIHDAhiAQIJCwdJAhsBAQEBATcOAQUBAgULASQJAWYEAQYBAgICGQIEAxAEDQECAgYBDwEAAwAEHAMdAh4CQAIBBwgBAgsJAS0DAQF1AiIBdgMEAgkBBgPbAgIBOgEBBwEBAQECCAYKAgEwHzEEMAoEAyYJDAIgBAIGOAEBAgMBAQU4CAICmAMBDQEHBAEGAQMCxkAAAcMhAAONAWAgAAZpAgAEAQogAlACAAEDAQQBGQIFAZcCGhINASYIGQsBASwDMAECBAIC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AQAAAgEAAAMBAAAEAQAABQEAAAYBAAAHAQAACAEAAAkBAAAKAQAACwEAAAwBAAANAQAADgEAAA8BAAAQAQAAEQEAABIBAAATAQAAFAEAABUBAAAWAQAAFwEAABgBAAAZAQAAGgEAABsBAAAcAQAAHQEAAB4BAAAfAQAAIAEAACEBAAAiAQAAIwEAACQBAAAlAQAAJgEAACcBAAAoAQAAKQEAACoBAAArAQAALAEAAC0BAAAuAQAALwEAADABAAAAAEAAMgEAADMBAAA0AQAANQEAADYBAAA3AQAAOQEAADoBAAA7AQAAPAEAAD0BAAA+AQAAPwEAAEABAABBAQAAQgEAAEMBAABEAQAARQEAAEYBAABHAQAASAEAAEoBAABLAQAATAEAAE0BAABOAQAATwEAAFABAABRAQAAUgEAAFMBAABUAQAAVQEAAFYBAABXAQAAWAEAAFkBAABaAQAAWwEAAFwBAABdAQAAXgEAAF8BAABgAQAAYQEAAGIBAABjAQAAZAEAAGUBAABmAQAAZwEAAGgBAABpAQAAagEAAGsBAABsAQAAbQEAAG4BAABvAQAAcAEAAHEBAAByAQAAcwEAAHQBAAB1AQAAdgEAAHcBAAB4AQAA/wAAAHkBAAB6AQAAewEAAHwBAAB9AQAAfgEAAIEBAABTAgAAggEAAIMBAACEAQAAhQEAAIYBAABUAgAAhwEAAIgBAACJAQAAVgIAAIoBAABXAgAAiwEAAIwBAACOAQAA3QEAAI8BAABZAgAAkAEAAFsCAACRAQAAkgEAAJMBAABgAgAAlAEAAGMCAACWAQAAaQIAAJcBAABoAgAAmAEAAJkBAACcAQAAbwIAAJ0BAAByAgAAnwEAAHUCAACgAQAAoQEAAKIBAACjAQAApAEAAKUBAACmAQAAgAIAAKcBAACoAQAAqQEAAIMCAACsAQAArQEAAK4BAACIAgAArwEAALABAACxAQAAigIAALIBAACLAgAAswEAALQBAAC1AQAAtgEAALcBAACSAgAAuAEAALkBAAC8AQAAvQEAAMQBAADGAQAAxQEAAMYBAADHAQAAyQEAAMgBAADJAQAAygEAAMwBAADLAQAAzAEAAM0BAADOAQAAzwEAANABAADRAQAA0gEAANMBAADUAQAA1QEAANYBAADXAQAA2AEAANkBAADaAQAA2wEAANwBAADeAQAA3wEAAOABAADhAQAA4gEAAOMBAADkAQAA5QEAAOYBAADnAQAA6AEAAOkBAADqAQAA6wEAAOwBAADtAQAA7gEAAO8BAADxAQAA8wEAAPIBAADzAQAA9AEAAPUBAAD2AQAAlQEAAPcBAAC/AQAA+AEAAPkBAAD6AQAA+wEAAPwBAAD9AQAA/gEAAP8BAAAAAgAAAQIAAAICAAADAgAABAIAAAUCAAAGAgAABwIAAAgCAAAJAgAACgIAAAsCAAAMAgAADQIAAA4CAAAPAgAAEAIAABECAAASAgAAEwIAABQCAAAVAgAAFgIAABcCAAAYAgAAGQIAABoCAAAbAgAAHAIAAB0CAAAeAgAAHwIAACACAACeAQAAIgIAACMCAAAkAgAAJQIAACYCAAAnAgAAKAIAACkCAAAqAgAAKwIAACwCAAAtAgAALgIAAC8CAAAwAgAAMQIAADICAAAzAgAAOgIAAGUsAAA7AgAAPAIAAD0CAACaAQAAPgIAAGYsAABBAgAAQgIAAEMCAACAAQAARAIAAIkCAABFAgAAjAIAAEYCAABHAgAASAIAAEkCAABKAgAASwIAAEwCAABNAgAATgIAAE8CAABwAwAAcQMAAHIDAABzAwAAdgMAAHcDAAB/AwAA8wMAAIYDAACsAwAAiAMAAK0DAACJAwAArgMAAIoDAACvAwAAjAMAAMwDAACOAwAAzQMAAI8DAADOAwAAkQMAALEDAACSAwAAsgMAAJMDAACzAwAAlAMAALQDAACVAwAAtQMAAJYDAAC2AwAAlwMAALcDAACYAwAAuAMAAJkDAAC5AwAAmgMAALoDAACbAwAAuwMAAJwDAAC8AwAAnQMAAL0DAACeAwAAvgMAAJ8DAAC/AwAAoAMAAMADAAChAwAAwQMAAKMDAADDAwAApAMAAMQDAAClAwAAxQMAAKYDAADGAwAApwMAAMcDAACoAwAAyAMAAKkDAADJAwAAqgMAAMoDAACrAwAAywMAAM8DAADXAwAA2AMAANkDAADaAwAA2wMAANwDAADdAwAA3gMAAN8DAADgAwAA4QMAAOIDAADjAwAA5AMAAOUDAADmAwAA5wMAAOgDAADpAwAA6gMAAOsDAADsAwAA7QMAAO4DAADvAwAA9AMAALgDAAD3AwAA+AMAAPkDAADyAwAA+gMAAPsDAAD9AwAAewMAAP4DAAB8AwAA/wMAAH0DAAAABAAAUAQAAAEEAABRBAAAAgQAAFIEAAADBAAAUwQAAAQEAABUBAAABQQAAFUEAAAGBAAAVgQAAAcEAABXBAAACAQAAFgEAAAJBAAAWQQAAAoEAABaBAAACwQAAFsEAAAMBAAAXAQAAA0EAABdBAAADgQAAF4EAAAPBAAAXwQAABAEAAAwBAAAEQQAADEEAAASBAAAMgQAABMEAAAzBAAAFAQAADQEAAAVBAAANQQAABYEAAA2BAAAFwQAADcEAAAYBAAAOAQAABkEAAA5BAAAGgQAADoEAAAbBAAAOwQAABwEAAA8BAAAHQQAAD0EAAAeBAAAPgQAAB8EAAA/BAAAIAQAAEAEAAAhBAAAQQQAACIEAABCBAAAIwQAAEMEAAAkBAAARAQAACUEAABFBAAAJgQAAEYEAAAnBAAARwQAACgEAABIBAAAKQQAAEkEAAAqBAAASgQAACsEAABLBAAALAQAAEwEAAAtBAAATQQAAC4EAABOBAAALwQAAE8EAABgBAAAYQQAAGIEAABjBAAAZAQAAGUEAABmBAAAZwQAAGgEAABpBAAAagQAAGsEAABsBAAAbQQAAG4EAABvBAAAcAQAAHEEAAByBAAAcwQAAHQEAAB1BAAAdgQAAHcEAAB4BAAAeQQAAHoEAAB7BAAAfAQAAH0EAAB+BAAAfwQAAIAEAACBBAAAigQAAIsEAACMBAAAjQQAAI4EAACPBAAAkAQAAJEEAACSBAAAkwQAAJQEAACVBAAAlgQAAJcEAACYBAAAmQQAAJoEAACbBAAAnAQAAJ0EAACeBAAAnwQAAKAEAAChBAAAogQAAKMEAACkBAAApQQAAKYEAACnBAAAqAQAAKkEAACqBAAAqwQAAKwEAACtBAAArgQAAK8EAACwBAAAsQQAALIEAACzBAAAtAQAALUEAAC2BAAAtwQAALgEAAC5BAAAugQAALsEAAC8BAAAvQQAAL4EAAC/BAAAwAQAAM8EAADBBAAAwgQAAMMEAADEBAAAxQQAAMYEAADHBAAAyAQAAMkEAADKBAAAywQAAMwEAADNBAAAzgQAANAEAADRBAAA0gQAANMEAADUBAAA1QQAANYEAADXBAAA2AQAANkEAADaBAAA2wQAANwEAADdBAAA3gQAAN8EAADgBAAA4QQAAOIEAADjBAAA5AQAAOUEAADmBAAA5wQAAOgEAADpBAAA6gQAAOsEAADsBAAA7QQAAO4EAADvBAAA8AQAAPEEAADyBAAA8wQAAPQEAAD1BAAA9gQAAPcEAAD4BAAA+QQAAPoEAAD7BAAA/AQAAP0EAAD+BAAA/wQAAAAFAAABBQAAAgUAAAMFAAAEBQAABQUAAAYFAAAHBQAACAUAAAkFAAAKBQAACwUAAAwFAAANBQAADgUAAA8FAAAQBQAAEQUAABIFAAATBQAAFAUAABUFAAAWBQAAFwUAABgFAAAZBQAAGgUAABsFAAAcBQAAHQUAAB4FAAAfBQAAIAUAACEFAAAiBQAAIwUAACQFAAAlBQAAJgUAACcFAAAoBQAAKQUAACoFAAArBQAALAUAAC0FAAAuBQAALwUAADEFAABhBQAAMgUAAGIFAAAzBQAAYwUAADQFAABkBQAANQUAAGUFAAA2BQAAZgUAADcFAABnBQAAOAUAAGgFAAA5BQAAaQUAADoFAABqBQAAOwUAAGsFAAA8BQAAbAUAAD0FAABtBQAAPgUAAG4FAAA/BQAAbwUAAEAFAABwBQAAQQUAAHEFAABCBQAAcgUAAEMFAABzBQAARAUAAHQFAABFBQAAdQUAAEYFAAB2BQAARwUAAHcFAABIBQAAeAUAAEkFAAB5BQAASgUAAHoFAABLBQAAewUAAEwFAAB8BQAATQUAAH0FAABOBQAAfgUAAE8FAAB/BQAAUAUAAIAFAABRBQAAgQUAAFIFAACCBQAAUwUAAIMFAABUBQAAhAUAAFUFAACFBQAAVgUAAIYFAACgEAAAAC0AAKEQAAABLQAAohAAAAItAACjEAAAAy0AAKQQAAAELQAApRAAAAUtAACmEAAABi0AAKcQAAAHLQAAqBAAAAgtAACpEAAACS0AAKoQAAAKLQAAqxAAAAstAACsEAAADC0AAK0QAAANLQAArhAAAA4tAACvEAAADy0AALAQAAAQLQAAsRAAABEtAACyEAAAEi0AALMQAAATLQAAtBAAABQtAAC1EAAAFS0AALYQAAAWLQAAtxAAABctAAC4EAAAGC0AALkQAAAZLQAAuhAAABotAAC7EAAAGy0AALwQAAAcLQAAvRAAAB0tAAC+EAAAHi0AAL8QAAAfLQAAwBAAACAtAADBEAAAIS0AAMIQAAAiLQAAwxAAACMtAADEEAAAJC0AAMUQAAAlLQAAxxAAACctAADNEAAALS0AAKATAABwqwAAoRMAAHGrAACiEwAAcqsAAKMTAABzqwAApBMAAHSrAAClEwAAdasAAKYTAAB2qwAApxMAAHerAACoEwAAeKsAAKkTAAB5qwAAqhMAAHqrAACrEwAAe6sAAKwTAAB8qwAArRMAAH2rAACuEwAAfqsAAK8TAAB/qwAAsBMAAICrAACxEwAAgasAALITAACCqwAAsxMAAIOrAAC0EwAAhKsAALUTAACFqwAAthMAAIarAAC3EwAAh6sAALgTAACIqwAAuRMAAImrAAC6EwAAiqsAALsTAACLqwAAvBMAAIyrAAC9EwAAjasAAL4TAACOqwAAvxMAAI+rAADAEwAAkKsAAMETAACRqwAAwhMAAJKrAADDEwAAk6sAAMQTAACUqwAAxRMAAJWrAADGEwAAlqsAAMcTAACXqwAAyBMAAJirAADJEwAAmasAAMoTAACaqwAAyxMAAJurAADMEwAAnKsAAM0TAACdqwAAzhMAAJ6rAADPEwAAn6sAANATAACgqwAA0RMAAKGrAADSEwAAoqsAANMTAACjqwAA1BMAAKSrAADVEwAApasAANYTAACmqwAA1xMAAKerAADYEwAAqKsAANkTAACpqwAA2hMAAKqrAADbEwAAq6sAANwTAACsqwAA3RMAAK2rAADeEwAArqsAAN8TAACvqwAA4BMAALCrAADhEwAAsasAAOITAACyqwAA4xMAALOrAADkEwAAtKsAAOUTAAC1qwAA5hMAALarAADnEwAAt6sAAOgTAAC4qwAA6RMAALmrAADqEwAAuqsAAOsTAAC7qwAA7BMAALyrAADtEwAAvasAAO4TAAC+qwAA7xMAAL+rAADwEwAA+BMAAPETAAD5EwAA8hMAAPoTAADzEwAA+xMAAPQTAAD8EwAA9RMAAP0TAACJHAAAihwAAJAcAADQEAAAkRwAANEQAACSHAAA0hAAAJMcAADTEAAAlBwAANQQAACVHAAA1RAAAJYcAADWEAAAlxwAANcQAACYHAAA2BAAAJkcAADZEAAAmhwAANoQAACbHAAA2xAAAJwcAADcEAAAnRwAAN0QAACeHAAA3hAAAJ8cAADfEAAAoBwAAOAQAAChHAAA4RAAAKIcAADiEAAAoxwAAOMQAACkHAAA5BAAAKUcAADlEAAAphwAAOYQAACnHAAA5xAAAKgcAADoEAAAqRwAAOkQAACqHAAA6hAAAKscAADrEAAArBwAAOwQAACtHAAA7RAAAK4cAADuEAAArxwAAO8QAACwHAAA8BAAALEcAADxEAAAshwAAPIQAACzHAAA8xAAALQcAAD0EAAAtRwAAPUQAAC2HAAA9hAAALccAAD3EAAAuBwAAPgQAAC5HAAA+RAAALocAAD6EAAAvRwAAP0QAAC+HAAA/hAAAL8cAAD/EAAAAB4AAAEeAAACHgAAAx4AAAQeAAAFHgAABh4AAAceAAAIHgAACR4AAAoeAAALHgAADB4AAA0eAAAOHgAADx4AABAeAAARHgAAEh4AABMeAAAUHgAAFR4AABYeAAAXHgAAGB4AABkeAAAaHgAAGx4AABweAAAdHgAAHh4AAB8eAAAgHgAAIR4AACIeAAAjHgAAJB4AACUeAAAmHgAAJx4AACgeAAApHgAAKh4AACseAAAsHgAALR4AAC4eAAAvHgAAMB4AADEeAAAyHgAAMx4AADQeAAA1HgAANh4AADceAAA4HgAAOR4AADoeAAA7HgAAPB4AAD0eAAA+HgAAPx4AAEAeAABBHgAAQh4AAEMeAABEHgAARR4AAEYeAABHHgAASB4AAEkeAABKHgAASx4AAEweAABNHgAATh4AAE8eAABQHgAAUR4AAFIeAABTHgAAVB4AAFUeAABWHgAAVx4AAFgeAABZHgAAWh4AAFseAABcHgAAXR4AAF4eAABfHgAAYB4AAGEeAABiHgAAYx4AAGQeAABlHgAAZh4AAGceAABoHgAAaR4AAGoeAABrHgAAbB4AAG0eAABuHgAAbx4AAHAeAABxHgAAch4AAHMeAAB0HgAAdR4AAHYeAAB3HgAAeB4AAHkeAAB6HgAAex4AAHweAAB9HgAAfh4AAH8eAACAHgAAgR4AAIIeAACDHgAAhB4AAIUeAACGHgAAhx4AAIgeAACJHgAAih4AAIseAACMHgAAjR4AAI4eAACPHgAAkB4AAJEeAACSHgAAkx4AAJQeAACVHgAAnh4AAN8AAACgHgAAoR4AAKIeAACjHgAApB4AAKUeAACmHgAApx4AAKgeAACpHgAAqh4AAKseAACsHgAArR4AAK4eAACvHgAAsB4AALEeAACyHgAAsx4AALQeAAC1HgAAth4AALceAAC4HgAAuR4AALoeAAC7HgAAvB4AAL0eAAC+HgAAvx4AAMAeAADBHgAAwh4AAMMeAADEHgAAxR4AAMYeAADHHgAAyB4AAMkeAADKHgAAyx4AAMweAADNHgAAzh4AAM8eAADQHgAA0R4AANIeAADTHgAA1B4AANUeAADWHgAA1x4AANgeAADZHgAA2h4AANseAADcHgAA3R4AAN4eAADfHgAA4B4AAOEeAADiHgAA4x4AAOQeAADlHgAA5h4AAOceAADoHgAA6R4AAOoeAADrHgAA7B4AAO0eAADuHgAA7x4AAPAeAADxHgAA8h4AAPMeAAD0HgAA9R4AAPYeAAD3HgAA+B4AAPkeAAD6HgAA+x4AAPweAAD9HgAA/h4AAP8eAAAIHwAAAB8AAAkfAAABHwAACh8AAAIfAAALHwAAAx8AAAwfAAAEHwAADR8AAAUfAAAOHwAABh8AAA8fAAAHHwAAGB8AABAfAAAZHwAAER8AABofAAASHwAAGx8AABMfAAAcHwAAFB8AAB0fAAAVHwAAKB8AACAfAAApHwAAIR8AACofAAAiHwAAKx8AACMfAAAsHwAAJB8AAC0fAAAlHwAALh8AACYfAAAvHwAAJx8AADgfAAAwHwAAOR8AADEfAAA6HwAAMh8AADsfAAAzHwAAPB8AADQfAAA9HwAANR8AAD4fAAA2HwAAPx8AADcfAABIHwAAQB8AAEkfAABBHwAASh8AAEIfAABLHwAAQx8AAEwfAABEHwAATR8AAEUfAABZHwAAUR8AAFsfAABTHwAAXR8AAFUfAABfHwAAVx8AAGgfAABgHwAAaR8AAGEfAABqHwAAYh8AAGsfAABjHwAAbB8AAGQfAABtHwAAZR8AAG4fAABmHwAAbx8AAGcfAACIHwAAgB8AAIkfAACBHwAAih8AAIIfAACLHwAAgx8AAIwfAACEHwAAjR8AAIUfAACOHwAAhh8AAI8fAACHHwAAmB8AAJAfAACZHwAAkR8AAJofAACSHwAAmx8AAJMfAACcHwAAlB8AAJ0fAACVHwAAnh8AAJYfAACfHwAAlx8AAKgfAACgHwAAqR8AAKEfAACqHwAAoh8AAKsfAACjHwAArB8AAKQfAACtHwAApR8AAK4fAACmHwAArx8AAKcfAAC4HwAAsB8AALkfAACxHwAAuh8AAHAfAAC7HwAAcR8AALwfAACzHwAAyB8AAHIfAADJHwAAcx8AAMofAAB0HwAAyx8AAHUfAADMHwAAwx8AANgfAADQHwAA2R8AANEfAADaHwAAdh8AANsfAAB3HwAA6B8AAOAfAADpHwAA4R8AAOofAAB6HwAA6x8AAHsfAADsHwAA5R8AAPgfAAB4HwAA+R8AAHkfAAD6HwAAfB8AAPsfAAB9HwAA/B8AAPMfAAAmIQAAyQMAACohAABrAAAAKyEAAOUAAAAyIQAATiEAAGAhAABwIQAAYSEAAHEhAABiIQAAciEAAGMhAABzIQAAZCEAAHQhAABlIQAAdSEAAGYhAAB2IQAAZyEAAHchAABoIQAAeCEAAGkhAAB5IQAAaiEAAHohAABrIQAAeyEAAGwhAAB8IQAAbSEAAH0hAABuIQAAfiEAAG8hAAB/IQAAgyEAAIQhAAC2JAAA0CQAALckAADRJAAAuCQAANIkAAC5JAAA0yQAALokAADUJAAAuyQAANUkAAC8JAAA1iQAAL0kAADXJAAAviQAANgkAAC/JAAA2SQAAMAkAADaJAAAwSQAANskAADCJAAA3CQAAMMkAADdJAAAxCQAAN4kAADFJAAA3yQAAMYkAADgJAAAxyQAAOEkAADIJAAA4iQAAMkkAADjJAAAyiQAAOQkAADLJAAA5SQAAMwkAADmJAAAzSQAAOckAADOJAAA6CQAAM8kAADpJAAAACwAADAsAAABLAAAMSwAAAIsAAAyLAAAAywAADMsAAAELAAANCwAAAUsAAA1LAAABiwAADYsAAAHLAAANywAAAgsAAA4LAAACSwAADksAAAKLAAAOiwAAAssAAA7LAAADCwAADwsAAANLAAAPSwAAA4sAAA+LAAADywAAD8sAAAQLAAAQCwAABEsAABBLAAAEiwAAEIsAAATLAAAQywAABQsAABELAAAFSwAAEUsAAAWLAAARiwAABcsAABHLAAAGCwAAEgsAAAZLAAASSwAABosAABKLAAAGywAAEssAAAcLAAATCwAAB0sAABNLAAAHiwAAE4sAAAfLAAATywAACAsAABQLAAAISwAAFEsAAAiLAAAUiwAACMsAABTLAAAJCwAAFQsAAAlLAAAVSwAACYsAABWLAAAJywAAFcsAAAoLAAAWCwAACksAABZLAAAKiwAAFosAAArLAAAWywAACwsAABcLAAALSwAAF0sAAAuLAAAXiwAAC8sAABfLAAAYCwAAGEsAABiLAAAawIAAGMsAAB9HQAAZCwAAH0CAABnLAAAaCwAAGksAABqLAAAaywAAGwsAABtLAAAUQIAAG4sAABxAgAAbywAAFACAABwLAAAUgIAAHIsAABzLAAAdSwAAHYsAAB+LAAAPwIAAH8sAABAAgAAgCwAAIEsAACCLAAAgywAAIQsAACFLAAAhiwAAIcsAACILAAAiSwAAIosAACLLAAAjCwAAI0sAACOLAAAjywAAJAsAACRLAAAkiwAAJMsAACULAAAlSwAAJYsAACXLAAAmCwAAJksAACaLAAAmywAAJwsAACdLAAAniwAAJ8sAACgLAAAoSwAAKIsAACjLAAApCwAAKUsAACmLAAApywAAKgsAACpLAAAqiwAAKssAACsLAAArSwAAK4sAACvLAAAsCwAALEsAACyLAAAsywAALQsAAC1LAAAtiwAALcsAAC4LAAAuSwAALosAAC7LAAAvCwAAL0sAAC+LAAAvywAAMAsAADBLAAAwiwAAMMsAADELAAAxSwAAMYsAADHLAAAyCwAAMksAADKLAAAyywAAMwsAADNLAAAziwAAM8sAADQLAAA0SwAANIsAADTLAAA1CwAANUsAADWLAAA1ywAANgsAADZLAAA2iwAANssAADcLAAA3SwAAN4sAADfLAAA4CwAAOEsAADiLAAA4ywAAOssAADsLAAA7SwAAO4sAADyLAAA8ywAAECmAABBpgAAQqYAAEOmAABEpgAARaYAAEamAABHpgAASKYAAEmmAABKpgAAS6YAAEymAABNpgAATqYAAE+mAABQpgAAUaYAAFKmAABTpgAAVKYAAFWmAABWpgAAV6YAAFimAABZpgAAWqYAAFumAABcpgAAXaYAAF6mAABfpgAAYKYAAGGmAABipgAAY6YAAGSmAABlpgAAZqYAAGemAABopgAAaaYAAGqmAABrpgAAbKYAAG2mAACApgAAgaYAAIKmAACDpgAAhKYAAIWmAACGpgAAh6YAAIimAACJpgAAiqYAAIumAACMpgAAjaYAAI6mAACPpgAAkKYAAJGmAACSpgAAk6YAAJSmAACVpgAAlqYAAJemAACYpgAAmaYAAJqmAACbpgAAIqcAACOnAAAkpwAAJacAACanAAAnpwAAKKcAACmnAAAqpwAAK6cAACynAAAtpwAALqcAAC+nAAAypwAAM6cAADSnAAA1pwAANqcAADenAAA4pwAAOacAADqnAAA7pwAAPKcAAD2nAAA+pwAAP6cAAECnAABBpwAAQqcAAEOnAABEpwAARacAAEanAABHpwAASKcAAEmnAABKpwAAS6cAAEynAABNpwAATqcAAE+nAABQpwAAUacAAFKnAABTpwAAVKcAAFWnAABWpwAAV6cAAFinAABZpwAAWqcAAFunAABcpwAAXacAAF6nAABfpwAAYKcAAGGnAABipwAAY6cAAGSnAABlpwAAZqcAAGenAABopwAAaacAAGqnAABrpwAAbKcAAG2nAABupwAAb6cAAHmnAAB6pwAAe6cAAHynAAB9pwAAeR0AAH6nAAB/pwAAgKcAAIGnAACCpwAAg6cAAISnAACFpwAAhqcAAIenAACLpwAAjKcAAI2nAABlAgAAkKcAAJGnAACSpwAAk6cAAJanAACXpwAAmKcAAJmnAACapwAAm6cAAJynAACdpwAAnqcAAJ+nAACgpwAAoacAAKKnAACjpwAApKcAAKWnAACmpwAAp6cAAKinAACppwAAqqcAAGYCAACrpwAAXAIAAKynAABhAgAAracAAGwCAACupwAAagIAALCnAACeAgAAsacAAIcCAACypwAAnQIAALOnAABTqwAAtKcAALWnAAC2pwAAt6cAALinAAC5pwAAuqcAALunAAC8pwAAvacAAL6nAAC/pwAAwKcAAMGnAADCpwAAw6cAAMSnAACUpwAAxacAAIICAADGpwAAjh0AAMenAADIpwAAyacAAMqnAADLpwAAZAIAAMynAADNpwAA0KcAANGnAADWpwAA16cAANinAADZpwAA2qcAANunAADcpwAAmwEAAPWnAAD2pwAAIf8AAEH/AAAi/wAAQv8AACP/AABD/wAAJP8AAET/AAAl/wAARf8AACb/AABG/wAAJ/8AAEf/AAAo/wAASP8AACn/AABJ/wAAKv8AAEr/AAAr/wAAS/8AACz/AABM/wAALf8AAE3/AAAu/wAATv8AAC//AABP/wAAMP8AAFD/AAAx/wAAUf8AADL/AABS/wAAM/8AAFP/AAA0/wAAVP8AADX/AABV/wAANv8AAFb/AAA3/wAAV/8AADj/AABY/wAAOf8AAFn/AAA6/wAAWv8AAAAEAQAoBAEAAQQBACkEAQACBAEAKgQBAAMEAQArBAEABAQBACwEAQAFBAEALQQBAAYEAQAuBAEABwQBAC8EAQAIBAEAMAQBAAkEAQAxBAEACgQBADIEAQALBAEAMwQBAAwEAQA0BAEADQQBADUEAQAOBAEANgQBAA8EAQA3BAEAEAQBADgEAQARBAEAOQQBABIEAQA6BAEAEwQBADsEAQAUBAEAPAQBABUEAQA9BAEAFgQBAD4EAQAXBAEAPwQBABgEAQBABAEAGQQBAEEEAQAaBAEAQgQBABsEAQBDBAEAHAQBAEQEAQAdBAEARQQBAB4EAQBGBAEAHwQBAEcEAQAgBAEASAQBACEEAQBJBAEAIgQBAEoEAQAjBAEASwQBACQEAQBMBAEAJQQBAE0EAQAmBAEATgQBACcEAQBPBAEAsAQBANgEAQCxBAEA2QQBALIEAQDaBAEAswQBANsEAQC0BAEA3AQBALUEAQDdBAEAtgQBAN4EAQC3BAEA3wQBALgEAQDgBAEAuQQBAOEEAQC6BAEA4gQBALsEAQDjBAEAvAQBAOQEAQC9BAEA5QQBAL4EAQDmBAEAvwQBAOcEAQDABAEA6AQBAMEEAQDpBAEAwgQBAOoEAQDDBAEA6wQBAMQEAQDsBAEAxQQBAO0EAQDGBAEA7gQBAMcEAQDvBAEAyAQBAPAEAQDJBAEA8QQBAMoEAQDyBAEAywQBAPMEAQDMBAEA9AQBAM0EAQD1BAEAzgQBAPYEAQDPBAEA9wQBANAEAQD4BAEA0QQBAPkEAQDSBAEA+gQBANMEAQD7BAEAcAUBAJcFAQBxBQEAmAUBAHIFAQCZBQEAcwUBAJoFAQB0BQEAmwUBAHUFAQCcBQEAdgUBAJ0FAQB3BQEAngUBAHgFAQCfBQEAeQUBAKAFAQB6BQEAoQUBAHwFAQCjBQEAfQUBAKQFAQB+BQEApQUBAH8FAQCmBQEAgAUBAKcFAQCBBQEAqAUBAIIFAQCpBQEAgwUBAKoFAQCEBQEAqwUBAIUFAQCsBQEAhgUBAK0FAQCHBQEArgUBAIgFAQCvBQEAiQUBALAFAQCKBQEAsQUBAIwFAQCzBQEAjQUBALQFAQCOBQEAtQUBAI8FAQC2BQEAkAUBALcFAQCRBQEAuAUBAJIFAQC5BQEAlAUBALsFAQCVBQEAvAUBAIAMAQDADAEAgQwBAMEMAQCCDAEAwgwBAIMMAQDDDAEAhAwBAMQMAQCFDAEAxQwBAIYMAQDGDAEAhwwBAMcMAQCIDAEAyAwBAIkMAQDJDAEAigwBAMoMAQCLDAEAywwBAIwMAQDMDAEAjQwBAM0MAQCODAEAzgwBAI8MAQDPDAEAkAwBANAMAQCRDAEA0QwBAJIMAQDSDAEAkwwBANMMAQCUDAEA1AwBAJUMAQDVDAEAlgwBANYMAQCXDAEA1wwBAJgMAQDYDAEAmQwBANkMAQCaDAEA2gwBAJsMAQDbDAEAnAwBANwMAQCdDAEA3QwBAJ4MAQDeDAEAnwwBAN8MAQCgDAEA4AwBAKEMAQDhDAEAogwBAOIMAQCjDAEA4wwBAKQMAQDkDAEApQwBAOUMAQCmDAEA5gwBAKcMAQDnDAEAqAwBAOgMAQCpDAEA6QwBAKoMAQDqDAEAqwwBAOsMAQCsDAEA7AwBAK0MAQDtDAEArgwBAO4MAQCvDAEA7wwBALAMAQDwDAEAsQwBAPEMAQCyDAEA8gwBAFANAQBwDQEAUQ0BAHENAQBSDQEAcg0BAFMNAQBzDQEAVA0BAHQNAQBVDQEAdQ0BAFYNAQB2DQEAVw0BAHcNAQBYDQEAeA0BAFkNAQB5DQEAWg0BAHoNAQBbDQEAew0BAFwNAQB8DQEAXQ0BAH0NAQBeDQEAfg0BAF8NAQB/DQEAYA0BAIANAQBhDQEAgQ0BAGINAQCCDQEAYw0BAIMNAQBkDQEAhA0BAGUNAQCFDQEAoBgBAMAYAQChGAEAwRgBAKIYAQDCGAEAoxgBAMMYAQCkGAEAxBgBAKUYAQDFGAEAphgBAMYYAQCnGAEAxxgBAKgYAQDIGAEAqRgBAMkYAQCqGAEAyhgBAKsYAQDLGAEArBgBAMwYAQCtGAEAzRgBAK4YAQDOGAEArxgBAM8YAQCwGAEA0BgBALEYAQDRGAEAshgBANIYAQCzGAEA0xgBALQYAQDUGAEAtRgBANUYAQC2GAEA1hgBALcYAQDXGAEAuBgBANgYAQC5GAEA2RgBALoYAQDaGAEAuxgBANsYAQC8GAEA3BgBAL0YAQDdGAEAvhgBAN4YAQC/GAEA3xgBAEBuAQBgbgEAQW4BAGFuAQBCbgEAYm4BAENuAQBjbgEARG4BAGRuAQBFbgEAZW4BAEZuAQBmbgEAR24BAGduAQBIbgEAaG4BAEluAQBpbgEASm4BAGpuAQBLbgEAa24BAExuAQBsbgEATW4BAG1uAQBObgEAbm4BAE9uAQBvbgEAUG4BAHBuAQBRbgEAcW4BAFJuAQBybgEAU24BAHNuAQBUbgEAdG4BAFVuAQB1bgEAVm4BAHZuAQBXbgEAd24BAFhuAQB4bgEAWW4BAHluAQBabgEAem4BAFtuAQB7bgEAXG4BAHxuAQBdbgEAfW4BAF5uAQB+bgEAX24BAH9uAQAA6QEAIukBAAHpAQAj6QEAAukBACTpAQAD6QEAJekBAATpAQAm6QEABekBACfpAQAG6QEAKOkBAAfpAQAp6QEACOkBACrpAQAJ6QEAK+kBAArpAQAs6QEAC+kBAC3pAQAM6QEALukBAA3pAQAv6QEADukBADDpAQAP6QEAMekBABDpAQAy6QEAEekBADPpAQAS6QEANOkBABPpAQA16QEAFOkBADbpAQAV6QEAN+kBABbpAQA46QEAF+kBADnpAQAY6QEAOukBABnpAQA76QEAGukBADzpAQAb6QEAPekBABzpAQA+6QEAHekBAD/pAQAe6QEAQOkBAB/pAQBB6QEAIOkBAELpAQAh6QEAQ+kBAFZlYzNBSGFzaCB0YWJsZSBjYXBhY2l0eSBvdmVyZmxvdwAAAHF3EAAcAAAA6QkQACsAAAAlAAAAKAAAAGNsb3N1cmUgaW52b2tlZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkAACqDBAAXgAAAPsYAAABAAAAZGVzdCBpcyBvdXQgb2YgYm91bmRzAAAA7HcQABUAAACRABAAdAAAAFIDAAAyAAAAEBESAAgHCQYKBQsEDAMNAg4BDwBoCBAAawAAABECAAAoAAAAaAgQAGsAAACGAgAAHQAAAAAAAIAAQADAACAAoABgAOAAEACQAFAA0AAwALAAcADwAAgAiABIAMgAKACoAGgA6AAYAJgAWADYADgAuAB4APgABACEAEQAxAAkAKQAZADkABQAlABUANQANAC0AHQA9AAMAIwATADMACwArABsAOwAHACcAFwA3AA8ALwAfAD8AAIAggBCAMIAIgCiAGIA4gASAJIAUgDSADIAsgByAPIACgCKAEoAygAqAKoAagDqABoAmgBaANoAOgC6AHoA+gAGAIYARgDGACYApgBmAOYAFgCWAFYA1gA2ALYAdgD2AA4AjgBOAM4ALgCuAG4A7gAeAJ4AXgDeAD4AvgB+AP4AAQCBAEEAwQAhAKEAYQDhABEAkQBRANEAMQCxAHEA8QAJAIkASQDJACkAqQBpAOkAGQCZAFkA2QA5ALkAeQD5AAUAhQBFAMUAJQClAGUA5QAVAJUAVQDVADUAtQB1APUADQCNAE0AzQAtAK0AbQDtAB0AnQBdAN0APQC9AH0A/QADAIMAQwDDACMAowBjAOMAEwCTAFMA0wAzALMAcwDzAAsAiwBLAMsAKwCrAGsA6wAbAJsAWwDbADsAuwB7APsABwCHAEcAxwAnAKcAZwDnABcAlwBXANcANwC3AHcA9wAPAI8ATwDPAC8ArwBvAO8AHwCfAF8A3wA/AL8AfwD/gACAgIBAgMCAIICggGCA4IAQgJCAUIDQgDCAsIBwgPCACICIgEiAyIAogKiAaIDogBiAmIBYgNiAOIC4gHiA+IAEgISARIDEgCSApIBkgOSAFICUgFSA1IA0gLSAdID0gAyAjIBMgMyALICsgGyA7IAcgJyAXIDcgDyAvIB8gPyAAoCCgEKAwoAigKKAYoDigBKAkoBSgNKAMoCygHKA8oAKgIqASoDKgCqAqoBqgOqAGoCagFqA2oA6gLqAeoD6gAaAhoBGgMaAJoCmgGaA5oAWgJaAVoDWgDaAtoB2gPaADoCOgE6AzoAugK6AboDugB6AnoBegN6APoC+gH6A/oABgIGAQYDBgCGAoYBhgOGAEYCRgFGA0YAxgLGAcYDxgAmAiYBJgMmAKYCpgGmA6YAZgJmAWYDZgDmAuYB5gPmABYCFgEWAxYAlgKWAZYDlgBWAlYBVgNWANYC1gHWA9YANgI2ATYDNgC2ArYBtgO2AHYCdgF2A3YA9gL2AfYD9gAOAg4BDgMOAI4CjgGOA44ATgJOAU4DTgDOAs4BzgPOAC4CLgEuAy4ArgKuAa4DrgBuAm4BbgNuAO4C7gHuA+4AHgIeAR4DHgCeAp4BngOeAF4CXgFeA14A3gLeAd4D3gA+Aj4BPgM+AL4CvgG+A74AfgJ+AX4DfgD+Av4B/gP9oCBAAawAAACIEAAAUAAAAaAgQAGsAAAAjBAAAEgAAAGFzc2VydGlvbiBmYWlsZWQ6IG91dF9wb3MgKyAzIDwgb3V0X3NsaWNlLmxlbigpAGgIEABrAAAANgQAAA0AAABhc3NlcnRpb24gZmFpbGVkOiAoc291cmNl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IHBsYXRmb3JtUJUQACgAAAAkAAAAAAAAAAIAAAB4lRAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAMwJEAAdAAAAigEAAB0AAAC5AAAAEAAAAAQAAAC6AAAAuwAAAAEAAAAAAAAAbWlkID4gbGVuAAAA5JUQAAkAAAANBxAALgAAABYBAAApAAAAZW50aXR5IG5vdCBmb3VuZHBlcm1pc3Npb24gZGVuaWVkY29ubmVjdGlvbiByZWZ1c2VkY29ubmVjdGlvbiByZXNldGhvc3QgdW5yZWFjaGFibGVuZXR3b3JrIHVucmVhY2hhYmxlY29ubmVjdGlvbiBhYm9ydGVkbm90IGNvbm5lY3RlZGFkZHJlc3MgaW4gdXNlYWRkcmVzcyBub3QgYXZhaWxhYmxlbmV0d29yayBkb3duYnJva2VuIHBpcGVlbnRpdHkgYWxyZWFkeSBleGlzdHNvcGVyYXRpb24gd291bGQgYmxvY2tub3QgYSBkaXJlY3RvcnlpcyBhIGRpcmVjdG9yeWRpcmVjdG9yeSBub3QgZW1wdHlyZWFkLW9ubHkgZmlsZXN5c3RlbSBvciBzdG9yYWdlIG1lZGl1bWZpbGVzeXN0ZW0gbG9vcCBvciBpbmRpcmVjdGlvbiBsaW1pdCAoZS5nLiBzeW1saW5rIGxvb3Apc3RhbGUgbmV0d29yayBmaWxlIGhhbmRsZWludmFsaWQgaW5wdXQgcGFyYW1ldGVyaW52YWxpZCBkYXRhdGltZWQgb3V0d3JpdGUgemVyb25vIHN0b3JhZ2Ugc3BhY2VzZWVrIG9uIHVuc2Vla2FibGUgZmlsZXF1b3RhIGV4Y2VlZGVkZmlsZSB0b28gbGFyZ2VyZXNvdXJjZSBidXN5ZXhlY3V0YWJsZSBmaWxlIGJ1c3lkZWFkbG9ja2Nyb3NzLWRldmljZSBsaW5rIG9yIHJlbmFtZXRvbyBtYW55IGxpbmtzaW52YWxpZCBmaWxlbmFtZWFyZ3VtZW50IGxpc3QgdG9vIGxvbmdvcGVyYXRpb24gaW50ZXJydXB0ZWR1bnN1cHBvcnRlZHVuZXhwZWN0ZWQgZW5kIG9mIGZpbGVvdXQgb2YgbWVtb3J5aW4gcHJvZ3Jlc3NvdGhlciBlcnJvcnVuY2F0ZWdvcml6ZWQgZXJy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", self.location.href);\n    }\n    const imports = __wbg_get_imports();\n    if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {\n      module_or_path = fetch(module_or_path);\n    }\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n    return __wbg_finalize_init(instance, module);\n  }\n  var ch2 = {};\n  var wk = function(c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n      c + \';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})\'\n    ], { type: "text/javascript" }))));\n    w.onmessage = function(e) {\n      var d = e.data, ed = d.$e$;\n      if (ed) {\n        var err2 = new Error(ed[0]);\n        err2["code"] = ed[1];\n        err2.stack = ed[2];\n        cb(err2, null);\n      } else\n        cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n  };\n  var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\n  var fleb = new u8([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0,\n    /* unused */\n    0,\n    0,\n    /* impossible */\n    0\n  ]);\n  var fdeb = new u8([\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13,\n    /* unused */\n    0,\n    0\n  ]);\n  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n  var freb = function(eb, start) {\n    var b = new u16(31);\n    for (var i2 = 0; i2 < 31; ++i2) {\n      b[i2] = start += 1 << eb[i2 - 1];\n    }\n    var r = new i32(b[30]);\n    for (var i2 = 1; i2 < 30; ++i2) {\n      for (var j = b[i2]; j < b[i2 + 1]; ++j) {\n        r[j] = j - b[i2] << 5 | i2;\n      }\n    }\n    return { b, r };\n  };\n  var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\n  fl[28] = 258, revfl[258] = 28;\n  var _b = freb(fdeb, 0), fd = _b.b;\n  var rev = new u16(32768);\n  for (var i = 0; i < 32768; ++i) {\n    var x = (i & 43690) >> 1 | (i & 21845) << 1;\n    x = (x & 52428) >> 2 | (x & 13107) << 2;\n    x = (x & 61680) >> 4 | (x & 3855) << 4;\n    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;\n  }\n  var hMap = function(cd, mb, r) {\n    var s = cd.length;\n    var i2 = 0;\n    var l = new u16(mb);\n    for (; i2 < s; ++i2) {\n      if (cd[i2])\n        ++l[cd[i2] - 1];\n    }\n    var le = new u16(mb);\n    for (i2 = 1; i2 < mb; ++i2) {\n      le[i2] = le[i2 - 1] + l[i2 - 1] << 1;\n    }\n    var co;\n    if (r) {\n      co = new u16(1 << mb);\n      var rvb = 15 - mb;\n      for (i2 = 0; i2 < s; ++i2) {\n        if (cd[i2]) {\n          var sv = i2 << 4 | cd[i2];\n          var r_1 = mb - cd[i2];\n          var v = le[cd[i2] - 1]++ << r_1;\n          for (var m = v | (1 << r_1) - 1; v <= m; ++v) {\n            co[rev[v] >> rvb] = sv;\n          }\n        }\n      }\n    } else {\n      co = new u16(s);\n      for (i2 = 0; i2 < s; ++i2) {\n        if (cd[i2]) {\n          co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];\n        }\n      }\n    }\n    return co;\n  };\n  var flt = new u8(288);\n  for (var i = 0; i < 144; ++i)\n    flt[i] = 8;\n  for (var i = 144; i < 256; ++i)\n    flt[i] = 9;\n  for (var i = 256; i < 280; ++i)\n    flt[i] = 7;\n  for (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n  var fdt = new u8(32);\n  for (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);\n  var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);\n  var max = function(a) {\n    var m = a[0];\n    for (var i2 = 1; i2 < a.length; ++i2) {\n      if (a[i2] > m)\n        m = a[i2];\n    }\n    return m;\n  };\n  var bits = function(d, p, m) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n  };\n  var bits16 = function(d, p) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n  };\n  var shft = function(p) {\n    return (p + 7) / 8 | 0;\n  };\n  var slc = function(v, s, e) {\n    if (s == null || s < 0)\n      s = 0;\n    if (e == null || e > v.length)\n      e = v.length;\n    return new u8(v.subarray(s, e));\n  };\n  var ec = [\n    "unexpected EOF",\n    "invalid block type",\n    "invalid length/literal",\n    "invalid distance",\n    "stream finished",\n    "no stream handler",\n    ,\n    "no callback",\n    "invalid UTF-8 data",\n    "extra field too long",\n    "date not in range 1980-2099",\n    "filename too long",\n    "stream finishing",\n    "invalid zip data"\n    // determined by unknown compression method\n  ];\n  var err = function(ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(e, err);\n    if (!nt)\n      throw e;\n    return e;\n  };\n  var inflt = function(dat, st, buf, dict) {\n    var sl = dat.length, dl = dict ? dict.length : 0;\n    if (!sl || st.f && !st.l)\n      return buf || new u8(0);\n    var noBuf = !buf;\n    var resize = noBuf || st.i != 2;\n    var noSt = st.i;\n    if (noBuf)\n      buf = new u8(sl * 3);\n    var cbuf = function(l2) {\n      var bl = buf.length;\n      if (l2 > bl) {\n        var nbuf = new u8(Math.max(bl * 2, l2));\n        nbuf.set(buf);\n        buf = nbuf;\n      }\n    };\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    var tbts = sl * 8;\n    do {\n      if (!lm) {\n        final = bits(dat, pos, 1);\n        var type = bits(dat, pos + 1, 3);\n        pos += 3;\n        if (!type) {\n          var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\n          if (t > sl) {\n            if (noSt)\n              err(0);\n            break;\n          }\n          if (resize)\n            cbuf(bt + l);\n          buf.set(dat.subarray(s, t), bt);\n          st.b = bt += l, st.p = pos = t * 8, st.f = final;\n          continue;\n        } else if (type == 1)\n          lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n        else if (type == 2) {\n          var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n          var tl = hLit + bits(dat, pos + 5, 31) + 1;\n          pos += 14;\n          var ldt = new u8(tl);\n          var clt = new u8(19);\n          for (var i2 = 0; i2 < hcLen; ++i2) {\n            clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);\n          }\n          pos += hcLen * 3;\n          var clb = max(clt), clbmsk = (1 << clb) - 1;\n          var clm = hMap(clt, clb, 1);\n          for (var i2 = 0; i2 < tl; ) {\n            var r = clm[bits(dat, pos, clbmsk)];\n            pos += r & 15;\n            var s = r >> 4;\n            if (s < 16) {\n              ldt[i2++] = s;\n            } else {\n              var c = 0, n = 0;\n              if (s == 16)\n                n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];\n              else if (s == 17)\n                n = 3 + bits(dat, pos, 7), pos += 3;\n              else if (s == 18)\n                n = 11 + bits(dat, pos, 127), pos += 7;\n              while (n--)\n                ldt[i2++] = c;\n            }\n          }\n          var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n          lbt = max(lt);\n          dbt = max(dt);\n          lm = hMap(lt, lbt, 1);\n          dm = hMap(dt, dbt, 1);\n        } else\n          err(1);\n        if (pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n        }\n      }\n      if (resize)\n        cbuf(bt + 131072);\n      var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n      var lpos = pos;\n      for (; ; lpos = pos) {\n        var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n        pos += c & 15;\n        if (pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n        }\n        if (!c)\n          err(2);\n        if (sym < 256)\n          buf[bt++] = sym;\n        else if (sym == 256) {\n          lpos = pos, lm = null;\n          break;\n        } else {\n          var add2 = sym - 254;\n          if (sym > 264) {\n            var i2 = sym - 257, b = fleb[i2];\n            add2 = bits(dat, pos, (1 << b) - 1) + fl[i2];\n            pos += b;\n          }\n          var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n          if (!d)\n            err(3);\n          pos += d & 15;\n          var dt = fd[dsym];\n          if (dsym > 3) {\n            var b = fdeb[dsym];\n            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n          }\n          if (pos > tbts) {\n            if (noSt)\n              err(0);\n            break;\n          }\n          if (resize)\n            cbuf(bt + 131072);\n          var end = bt + add2;\n          if (bt < dt) {\n            var shift = dl - dt, dend = Math.min(dt, end);\n            if (shift + bt < 0)\n              err(3);\n            for (; bt < dend; ++bt)\n              buf[bt] = dict[shift + bt];\n          }\n          for (; bt < end; ++bt)\n            buf[bt] = buf[bt - dt];\n        }\n      }\n      st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n      if (lm)\n        final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n  };\n  var et = /* @__PURE__ */ new u8(0);\n  var mrg = function(a, b) {\n    var o = {};\n    for (var k in a)\n      o[k] = a[k];\n    for (var k in b)\n      o[k] = b[k];\n    return o;\n  };\n  var wcln = function(fn, fnStr, td2) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/\\s+/g, "").split(",");\n    for (var i2 = 0; i2 < dt.length; ++i2) {\n      var v = dt[i2], k = ks[i2];\n      if (typeof v == "function") {\n        fnStr += ";" + k + "=";\n        var st_1 = v.toString();\n        if (v.prototype) {\n          if (st_1.indexOf("[native code]") != -1) {\n            var spInd = st_1.indexOf(" ", 8) + 1;\n            fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));\n          } else {\n            fnStr += st_1;\n            for (var t in v.prototype)\n              fnStr += ";" + k + ".prototype." + t + "=" + v.prototype[t].toString();\n          }\n        } else\n          fnStr += st_1;\n      } else\n        td2[k] = v;\n    }\n    return fnStr;\n  };\n  var ch = [];\n  var cbfs = function(v) {\n    var tl = [];\n    for (var k in v) {\n      if (v[k].buffer) {\n        tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n      }\n    }\n    return tl;\n  };\n  var wrkr = function(fns, init, id, cb) {\n    if (!ch[id]) {\n      var fnStr = "", td_1 = {}, m = fns.length - 1;\n      for (var i2 = 0; i2 < m; ++i2)\n        fnStr = wcln(fns[i2], fnStr, td_1);\n      ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };\n    }\n    var td2 = mrg({}, ch[id].e);\n    return wk(ch[id].c + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init.toString() + "}", id, td2, cbfs(td2), cb);\n  };\n  var bInflt = function() {\n    return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt];\n  };\n  var pbf = function(msg) {\n    return postMessage(msg, [msg.buffer]);\n  };\n  var gopt = function(o) {\n    return o && {\n      out: o.size && new u8(o.size),\n      dictionary: o.dictionary\n    };\n  };\n  var cbify = function(dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function(err2, dat2) {\n      w.terminate();\n      cb(err2, dat2);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function() {\n      w.terminate();\n    };\n  };\n  var b2 = function(d, b) {\n    return d[b] | d[b + 1] << 8;\n  };\n  var b4 = function(d, b) {\n    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;\n  };\n  var b8 = function(d, b) {\n    return b4(d, b) + b4(d, b + 4) * 4294967296;\n  };\n  var gzs = function(d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n      err(6, "invalid gzip data");\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n      st += (d[10] | d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n      ;\n    return st + (flg & 2);\n  };\n  var Inflate = /* @__PURE__ */ function() {\n    function Inflate2(opts, cb) {\n      if (typeof opts == "function")\n        cb = opts, opts = {};\n      this.ondata = cb;\n      var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n      this.s = { i: 0, b: dict ? dict.length : 0 };\n      this.o = new u8(32768);\n      this.p = new u8(0);\n      if (dict)\n        this.o.set(dict);\n    }\n    Inflate2.prototype.e = function(c) {\n      if (!this.ondata)\n        err(5);\n      if (this.d)\n        err(4);\n      if (!this.p.length)\n        this.p = c;\n      else if (c.length) {\n        var n = new u8(this.p.length + c.length);\n        n.set(this.p), n.set(c, this.p.length), this.p = n;\n      }\n    };\n    Inflate2.prototype.c = function(final) {\n      this.s.i = +(this.d = final || false);\n      var bts = this.s.b;\n      var dt = inflt(this.p, this.s, this.o);\n      this.ondata(slc(dt, bts, this.s.b), this.d);\n      this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n      this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;\n    };\n    Inflate2.prototype.push = function(chunk, final) {\n      this.e(chunk), this.c(final);\n    };\n    return Inflate2;\n  }();\n  function inflate(data, opts, cb) {\n    if (!cb)\n      cb = opts, opts = {};\n    if (typeof cb != "function")\n      err(7);\n    return cbify(data, opts, [\n      bInflt\n    ], function(ev) {\n      return pbf(inflateSync(ev.data[0], gopt(ev.data[1])));\n    }, 1, cb);\n  }\n  function inflateSync(data, opts) {\n    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);\n  }\n  var Gunzip = /* @__PURE__ */ function() {\n    function Gunzip2(opts, cb) {\n      this.v = 1;\n      this.r = 0;\n      Inflate.call(this, opts, cb);\n    }\n    Gunzip2.prototype.push = function(chunk, final) {\n      Inflate.prototype.e.call(this, chunk);\n      this.r += chunk.length;\n      if (this.v) {\n        var p = this.p.subarray(this.v - 1);\n        var s = p.length > 3 ? gzs(p) : 4;\n        if (s > p.length) {\n          if (!final)\n            return;\n        } else if (this.v > 1 && this.onmember) {\n          this.onmember(this.r - p.length);\n        }\n        this.p = p.subarray(s), this.v = 0;\n      }\n      Inflate.prototype.c.call(this, final);\n      if (this.s.f && !this.s.l && !final) {\n        this.v = shft(this.s.p) + 9;\n        this.s = { i: 0 };\n        this.o = new u8(0);\n        this.push(new u8(0), final);\n      }\n    };\n    return Gunzip2;\n  }();\n  var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();\n  try {\n    td.decode(et, { stream: true });\n  } catch (e) {\n  }\n  var dutf8 = function(d) {\n    for (var r = "", i2 = 0; ; ) {\n      var c = d[i2++];\n      var eb = (c > 127) + (c > 223) + (c > 239);\n      if (i2 + eb > d.length)\n        return { s: r, r: slc(d, i2 - 1) };\n      if (!eb)\n        r += String.fromCharCode(c);\n      else if (eb == 3) {\n        c = ((c & 15) << 18 | (d[i2++] & 63) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);\n      } else if (eb & 1)\n        r += String.fromCharCode((c & 31) << 6 | d[i2++] & 63);\n      else\n        r += String.fromCharCode((c & 15) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63);\n    }\n  };\n  function strFromU8(dat, latin1) {\n    if (latin1) {\n      var r = "";\n      for (var i2 = 0; i2 < dat.length; i2 += 16384)\n        r += String.fromCharCode.apply(null, dat.subarray(i2, i2 + 16384));\n      return r;\n    } else if (td) {\n      return td.decode(dat);\n    } else {\n      var _a2 = dutf8(dat), s = _a2.s, r = _a2.r;\n      if (r.length)\n        err(8);\n      return s;\n    }\n  }\n  var slzh = function(d, b) {\n    return b + 30 + b2(d, b + 26) + b2(d, b + 28);\n  };\n  var zh = function(d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a2 = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a2[0], su = _a2[1], off = _a2[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n  };\n  var z64e = function(d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n      ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n  };\n  var mt = typeof queueMicrotask == "function" ? queueMicrotask : typeof setTimeout == "function" ? setTimeout : function(fn) {\n    fn();\n  };\n  function unzip(data, opts, cb) {\n    if (!cb)\n      cb = opts, opts = {};\n    if (typeof cb != "function")\n      err(7);\n    var term = [];\n    var tAll = function() {\n      for (var i3 = 0; i3 < term.length; ++i3)\n        term[i3]();\n    };\n    var files = {};\n    var cbd = function(a, b) {\n      mt(function() {\n        cb(a, b);\n      });\n    };\n    mt(function() {\n      cbd = cb;\n    });\n    var e = data.length - 22;\n    for (; b4(data, e) != 101010256; --e) {\n      if (!e || data.length - e > 65558) {\n        cbd(err(13, 0, 1), null);\n        return tAll;\n      }\n    }\n    var lft = b2(data, e + 8);\n    if (lft) {\n      var c = lft;\n      var o = b4(data, e + 16);\n      var z = o == 4294967295 || c == 65535;\n      if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 101075792;\n        if (z) {\n          c = lft = b4(data, ze + 32);\n          o = b4(data, ze + 48);\n        }\n      }\n      var fltr = opts && opts.filter;\n      var _loop_3 = function(i3) {\n        var _a2 = zh(data, o, z), c_1 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);\n        o = no;\n        var cbl = function(e2, d) {\n          if (e2) {\n            tAll();\n            cbd(e2, null);\n          } else {\n            if (d)\n              files[fn] = d;\n            if (!--lft)\n              cbd(null, files);\n          }\n        };\n        if (!fltr || fltr({\n          name: fn,\n          size: sc,\n          originalSize: su,\n          compression: c_1\n        })) {\n          if (!c_1)\n            cbl(null, slc(data, b, b + sc));\n          else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (su < 524288 || sc > 0.8 * su) {\n              try {\n                cbl(null, inflateSync(infl, { out: new u8(su) }));\n              } catch (e2) {\n                cbl(e2, null);\n              }\n            } else\n              term.push(inflate(infl, { size: su }, cbl));\n          } else\n            cbl(err(14, "unknown compression type " + c_1, 1), null);\n        } else\n          cbl(null, null);\n      };\n      for (var i2 = 0; i2 < c; ++i2) {\n        _loop_3(i2);\n      }\n    } else\n      cbd(null, {});\n    return tAll;\n  }\n  function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 101010256; --e) {\n      if (!e || data.length - e > 65558)\n        err(13);\n    }\n    var c = b2(data, e + 8);\n    if (!c)\n      return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n      var ze = b4(data, e - 12);\n      z = b4(data, ze) == 101075792;\n      if (z) {\n        c = b4(data, ze + 32);\n        o = b4(data, ze + 48);\n      }\n    }\n    var fltr = opts && opts.filter;\n    for (var i2 = 0; i2 < c; ++i2) {\n      var _a2 = zh(data, o, z), c_2 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);\n      o = no;\n      if (!fltr || fltr({\n        name: fn,\n        size: sc,\n        originalSize: su,\n        compression: c_2\n      })) {\n        if (!c_2)\n          files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8)\n          files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });\n        else\n          err(14, "unknown compression type " + c_2);\n      }\n    }\n    return files;\n  }\n  /**\n   * @license\n   * Copyright 2010-2025 Three.js Authors\n   * SPDX-License-Identifier: MIT\n   */\n  const REVISION = "180";\n  const FrontSide = 0;\n  const BackSide = 1;\n  const NormalBlending = 1;\n  const AddEquation = 100;\n  const SrcAlphaFactor = 204;\n  const OneMinusSrcAlphaFactor = 205;\n  const LessEqualDepth = 3;\n  const MultiplyOperation = 0;\n  const UVMapping = 300;\n  const RepeatWrapping = 1e3;\n  const ClampToEdgeWrapping = 1001;\n  const MirroredRepeatWrapping = 1002;\n  const NearestFilter = 1003;\n  const LinearFilter = 1006;\n  const LinearMipmapLinearFilter = 1008;\n  const UnsignedByteType = 1009;\n  const UnsignedIntType = 1014;\n  const FloatType = 1015;\n  const RGBAFormat = 1023;\n  const RGIntegerFormat = 1031;\n  const RGBAIntegerFormat = 1033;\n  const NoColorSpace = "";\n  const SRGBColorSpace = "srgb";\n  const LinearSRGBColorSpace = "srgb-linear";\n  const LinearTransfer = "linear";\n  const SRGBTransfer = "srgb";\n  const KeepStencilOp = 7680;\n  const AlwaysStencilFunc = 519;\n  const StaticDrawUsage = 35044;\n  const GLSL3 = "300 es";\n  const WebGLCoordinateSystem = 2e3;\n  const WebGPUCoordinateSystem = 2001;\n  class EventDispatcher {\n    /**\n     * Adds the given event listener to the given event type.\n     *\n     * @param {string} type - The type of event to listen to.\n     * @param {Function} listener - The function that gets called when the event is fired.\n     */\n    addEventListener(type, listener) {\n      if (this._listeners === void 0) this._listeners = {};\n      const listeners = this._listeners;\n      if (listeners[type] === void 0) {\n        listeners[type] = [];\n      }\n      if (listeners[type].indexOf(listener) === -1) {\n        listeners[type].push(listener);\n      }\n    }\n    /**\n     * Returns `true` if the given event listener has been added to the given event type.\n     *\n     * @param {string} type - The type of event.\n     * @param {Function} listener - The listener to check.\n     * @return {boolean} Whether the given event listener has been added to the given event type.\n     */\n    hasEventListener(type, listener) {\n      const listeners = this._listeners;\n      if (listeners === void 0) return false;\n      return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;\n    }\n    /**\n     * Removes the given event listener from the given event type.\n     *\n     * @param {string} type - The type of event.\n     * @param {Function} listener - The listener to remove.\n     */\n    removeEventListener(type, listener) {\n      const listeners = this._listeners;\n      if (listeners === void 0) return;\n      const listenerArray = listeners[type];\n      if (listenerArray !== void 0) {\n        const index = listenerArray.indexOf(listener);\n        if (index !== -1) {\n          listenerArray.splice(index, 1);\n        }\n      }\n    }\n    /**\n     * Dispatches an event object.\n     *\n     * @param {Object} event - The event that gets fired.\n     */\n    dispatchEvent(event) {\n      const listeners = this._listeners;\n      if (listeners === void 0) return;\n      const listenerArray = listeners[event.type];\n      if (listenerArray !== void 0) {\n        event.target = this;\n        const array = listenerArray.slice(0);\n        for (let i2 = 0, l = array.length; i2 < l; i2++) {\n          array[i2].call(this, event);\n        }\n        event.target = null;\n      }\n    }\n  }\n  const _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];\n  function generateUUID() {\n    const d0 = Math.random() * 4294967295 | 0;\n    const d1 = Math.random() * 4294967295 | 0;\n    const d2 = Math.random() * 4294967295 | 0;\n    const d3 = Math.random() * 4294967295 | 0;\n    const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];\n    return uuid.toLowerCase();\n  }\n  function clamp(value, min, max2) {\n    return Math.max(min, Math.min(max2, value));\n  }\n  function euclideanModulo(n, m) {\n    return (n % m + m) % m;\n  }\n  function lerp(x2, y, t) {\n    return (1 - t) * x2 + t * y;\n  }\n  function denormalize(value, array) {\n    switch (array.constructor) {\n      case Float32Array:\n        return value;\n      case Uint32Array:\n        return value / 4294967295;\n      case Uint16Array:\n        return value / 65535;\n      case Uint8Array:\n        return value / 255;\n      case Int32Array:\n        return Math.max(value / 2147483647, -1);\n      case Int16Array:\n        return Math.max(value / 32767, -1);\n      case Int8Array:\n        return Math.max(value / 127, -1);\n      default:\n        throw new Error("Invalid component type.");\n    }\n  }\n  function normalize$2(value, array) {\n    switch (array.constructor) {\n      case Float32Array:\n        return value;\n      case Uint32Array:\n        return Math.round(value * 4294967295);\n      case Uint16Array:\n        return Math.round(value * 65535);\n      case Uint8Array:\n        return Math.round(value * 255);\n      case Int32Array:\n        return Math.round(value * 2147483647);\n      case Int16Array:\n        return Math.round(value * 32767);\n      case Int8Array:\n        return Math.round(value * 127);\n      default:\n        throw new Error("Invalid component type.");\n    }\n  }\n  class Vector2 {\n    /**\n     * Constructs a new 2D vector.\n     *\n     * @param {number} [x=0] - The x value of this vector.\n     * @param {number} [y=0] - The y value of this vector.\n     */\n    constructor(x2 = 0, y = 0) {\n      Vector2.prototype.isVector2 = true;\n      this.x = x2;\n      this.y = y;\n    }\n    /**\n     * Alias for {@link Vector2#x}.\n     *\n     * @type {number}\n     */\n    get width() {\n      return this.x;\n    }\n    set width(value) {\n      this.x = value;\n    }\n    /**\n     * Alias for {@link Vector2#y}.\n     *\n     * @type {number}\n     */\n    get height() {\n      return this.y;\n    }\n    set height(value) {\n      this.y = value;\n    }\n    /**\n     * Sets the vector components.\n     *\n     * @param {number} x - The value of the x component.\n     * @param {number} y - The value of the y component.\n     * @return {Vector2} A reference to this vector.\n     */\n    set(x2, y) {\n      this.x = x2;\n      this.y = y;\n      return this;\n    }\n    /**\n     * Sets the vector components to the same value.\n     *\n     * @param {number} scalar - The value to set for all vector components.\n     * @return {Vector2} A reference to this vector.\n     */\n    setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      return this;\n    }\n    /**\n     * Sets the vector\'s x component to the given value\n     *\n     * @param {number} x - The value to set.\n     * @return {Vector2} A reference to this vector.\n     */\n    setX(x2) {\n      this.x = x2;\n      return this;\n    }\n    /**\n     * Sets the vector\'s y component to the given value\n     *\n     * @param {number} y - The value to set.\n     * @return {Vector2} A reference to this vector.\n     */\n    setY(y) {\n      this.y = y;\n      return this;\n    }\n    /**\n     * Allows to set a vector component with an index.\n     *\n     * @param {number} index - The component index. `0` equals to x, `1` equals to y.\n     * @param {number} value - The value to set.\n     * @return {Vector2} A reference to this vector.\n     */\n    setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n        case 1:\n          this.y = value;\n          break;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n      return this;\n    }\n    /**\n     * Returns the value of the vector component which matches the given index.\n     *\n     * @param {number} index - The component index. `0` equals to x, `1` equals to y.\n     * @return {number} A vector component value.\n     */\n    getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n        case 1:\n          return this.y;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n    }\n    /**\n     * Returns a new vector with copied values from this instance.\n     *\n     * @return {Vector2} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor(this.x, this.y);\n    }\n    /**\n     * Copies the values of the given vector to this instance.\n     *\n     * @param {Vector2} v - The vector to copy.\n     * @return {Vector2} A reference to this vector.\n     */\n    copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      return this;\n    }\n    /**\n     * Adds the given vector to this instance.\n     *\n     * @param {Vector2} v - The vector to add.\n     * @return {Vector2} A reference to this vector.\n     */\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      return this;\n    }\n    /**\n     * Adds the given scalar value to all components of this instance.\n     *\n     * @param {number} s - The scalar to add.\n     * @return {Vector2} A reference to this vector.\n     */\n    addScalar(s) {\n      this.x += s;\n      this.y += s;\n      return this;\n    }\n    /**\n     * Adds the given vectors and stores the result in this instance.\n     *\n     * @param {Vector2} a - The first vector.\n     * @param {Vector2} b - The second vector.\n     * @return {Vector2} A reference to this vector.\n     */\n    addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      return this;\n    }\n    /**\n     * Adds the given vector scaled by the given factor to this instance.\n     *\n     * @param {Vector2} v - The vector.\n     * @param {number} s - The factor that scales `v`.\n     * @return {Vector2} A reference to this vector.\n     */\n    addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      return this;\n    }\n    /**\n     * Subtracts the given vector from this instance.\n     *\n     * @param {Vector2} v - The vector to subtract.\n     * @return {Vector2} A reference to this vector.\n     */\n    sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      return this;\n    }\n    /**\n     * Subtracts the given scalar value from all components of this instance.\n     *\n     * @param {number} s - The scalar to subtract.\n     * @return {Vector2} A reference to this vector.\n     */\n    subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      return this;\n    }\n    /**\n     * Subtracts the given vectors and stores the result in this instance.\n     *\n     * @param {Vector2} a - The first vector.\n     * @param {Vector2} b - The second vector.\n     * @return {Vector2} A reference to this vector.\n     */\n    subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      return this;\n    }\n    /**\n     * Multiplies the given vector with this instance.\n     *\n     * @param {Vector2} v - The vector to multiply.\n     * @return {Vector2} A reference to this vector.\n     */\n    multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      return this;\n    }\n    /**\n     * Multiplies the given scalar value with all components of this instance.\n     *\n     * @param {number} scalar - The scalar to multiply.\n     * @return {Vector2} A reference to this vector.\n     */\n    multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      return this;\n    }\n    /**\n     * Divides this instance by the given vector.\n     *\n     * @param {Vector2} v - The vector to divide.\n     * @return {Vector2} A reference to this vector.\n     */\n    divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      return this;\n    }\n    /**\n     * Divides this vector by the given scalar.\n     *\n     * @param {number} scalar - The scalar to divide.\n     * @return {Vector2} A reference to this vector.\n     */\n    divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n    /**\n     * Multiplies this vector (with an implicit 1 as the 3rd component) by\n     * the given 3x3 matrix.\n     *\n     * @param {Matrix3} m - The matrix to apply.\n     * @return {Vector2} A reference to this vector.\n     */\n    applyMatrix3(m) {\n      const x2 = this.x, y = this.y;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[3] * y + e[6];\n      this.y = e[1] * x2 + e[4] * y + e[7];\n      return this;\n    }\n    /**\n     * If this vector\'s x or y value is greater than the given vector\'s x or y\n     * value, replace that value with the corresponding min value.\n     *\n     * @param {Vector2} v - The vector.\n     * @return {Vector2} A reference to this vector.\n     */\n    min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      return this;\n    }\n    /**\n     * If this vector\'s x or y value is less than the given vector\'s x or y\n     * value, replace that value with the corresponding max value.\n     *\n     * @param {Vector2} v - The vector.\n     * @return {Vector2} A reference to this vector.\n     */\n    max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      return this;\n    }\n    /**\n     * If this vector\'s x or y value is greater than the max vector\'s x or y\n     * value, it is replaced by the corresponding value.\n     * If this vector\'s x or y value is less than the min vector\'s x or y value,\n     * it is replaced by the corresponding value.\n     *\n     * @param {Vector2} min - The minimum x and y values.\n     * @param {Vector2} max - The maximum x and y values in the desired range.\n     * @return {Vector2} A reference to this vector.\n     */\n    clamp(min, max2) {\n      this.x = clamp(this.x, min.x, max2.x);\n      this.y = clamp(this.y, min.y, max2.y);\n      return this;\n    }\n    /**\n     * If this vector\'s x or y values are greater than the max value, they are\n     * replaced by the max value.\n     * If this vector\'s x or y values are less than the min value, they are\n     * replaced by the min value.\n     *\n     * @param {number} minVal - The minimum value the components will be clamped to.\n     * @param {number} maxVal - The maximum value the components will be clamped to.\n     * @return {Vector2} A reference to this vector.\n     */\n    clampScalar(minVal, maxVal) {\n      this.x = clamp(this.x, minVal, maxVal);\n      this.y = clamp(this.y, minVal, maxVal);\n      return this;\n    }\n    /**\n     * If this vector\'s length is greater than the max value, it is replaced by\n     * the max value.\n     * If this vector\'s length is less than the min value, it is replaced by the\n     * min value.\n     *\n     * @param {number} min - The minimum value the vector length will be clamped to.\n     * @param {number} max - The maximum value the vector length will be clamped to.\n     * @return {Vector2} A reference to this vector.\n     */\n    clampLength(min, max2) {\n      const length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));\n    }\n    /**\n     * The components of this vector are rounded down to the nearest integer value.\n     *\n     * @return {Vector2} A reference to this vector.\n     */\n    floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      return this;\n    }\n    /**\n     * The components of this vector are rounded up to the nearest integer value.\n     *\n     * @return {Vector2} A reference to this vector.\n     */\n    ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      return this;\n    }\n    /**\n     * The components of this vector are rounded to the nearest integer value\n     *\n     * @return {Vector2} A reference to this vector.\n     */\n    round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      return this;\n    }\n    /**\n     * The components of this vector are rounded towards zero (up if negative,\n     * down if positive) to an integer value.\n     *\n     * @return {Vector2} A reference to this vector.\n     */\n    roundToZero() {\n      this.x = Math.trunc(this.x);\n      this.y = Math.trunc(this.y);\n      return this;\n    }\n    /**\n     * Inverts this vector - i.e. sets x = -x and y = -y.\n     *\n     * @return {Vector2} A reference to this vector.\n     */\n    negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      return this;\n    }\n    /**\n     * Calculates the dot product of the given vector with this instance.\n     *\n     * @param {Vector2} v - The vector to compute the dot product with.\n     * @return {number} The result of the dot product.\n     */\n    dot(v) {\n      return this.x * v.x + this.y * v.y;\n    }\n    /**\n     * Calculates the cross product of the given vector with this instance.\n     *\n     * @param {Vector2} v - The vector to compute the cross product with.\n     * @return {number} The result of the cross product.\n     */\n    cross(v) {\n      return this.x * v.y - this.y * v.x;\n    }\n    /**\n     * Computes the square of the Euclidean length (straight-line length) from\n     * (0, 0) to (x, y). If you are comparing the lengths of vectors, you should\n     * compare the length squared instead as it is slightly more efficient to calculate.\n     *\n     * @return {number} The square length of this vector.\n     */\n    lengthSq() {\n      return this.x * this.x + this.y * this.y;\n    }\n    /**\n     * Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).\n     *\n     * @return {number} The length of this vector.\n     */\n    length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    /**\n     * Computes the Manhattan length of this vector.\n     *\n     * @return {number} The length of this vector.\n     */\n    manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y);\n    }\n    /**\n     * Converts this vector to a unit vector - that is, sets it equal to a vector\n     * with the same direction as this one, but with a vector length of `1`.\n     *\n     * @return {Vector2} A reference to this vector.\n     */\n    normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n    /**\n     * Computes the angle in radians of this vector with respect to the positive x-axis.\n     *\n     * @return {number} The angle in radians.\n     */\n    angle() {\n      const angle = Math.atan2(-this.y, -this.x) + Math.PI;\n      return angle;\n    }\n    /**\n     * Returns the angle between the given vector and this instance in radians.\n     *\n     * @param {Vector2} v - The vector to compute the angle with.\n     * @return {number} The angle in radians.\n     */\n    angleTo(v) {\n      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n      if (denominator === 0) return Math.PI / 2;\n      const theta = this.dot(v) / denominator;\n      return Math.acos(clamp(theta, -1, 1));\n    }\n    /**\n     * Computes the distance from the given vector to this instance.\n     *\n     * @param {Vector2} v - The vector to compute the distance to.\n     * @return {number} The distance.\n     */\n    distanceTo(v) {\n      return Math.sqrt(this.distanceToSquared(v));\n    }\n    /**\n     * Computes the squared distance from the given vector to this instance.\n     * If you are just comparing the distance with another distance, you should compare\n     * the distance squared instead as it is slightly more efficient to calculate.\n     *\n     * @param {Vector2} v - The vector to compute the squared distance to.\n     * @return {number} The squared distance.\n     */\n    distanceToSquared(v) {\n      const dx = this.x - v.x, dy = this.y - v.y;\n      return dx * dx + dy * dy;\n    }\n    /**\n     * Computes the Manhattan distance from the given vector to this instance.\n     *\n     * @param {Vector2} v - The vector to compute the Manhattan distance to.\n     * @return {number} The Manhattan distance.\n     */\n    manhattanDistanceTo(v) {\n      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\n    }\n    /**\n     * Sets this vector to a vector with the same direction as this one, but\n     * with the specified length.\n     *\n     * @param {number} length - The new length of this vector.\n     * @return {Vector2} A reference to this vector.\n     */\n    setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n    /**\n     * Linearly interpolates between the given vector and this instance, where\n     * alpha is the percent distance along the line - alpha = 0 will be this\n     * vector, and alpha = 1 will be the given one.\n     *\n     * @param {Vector2} v - The vector to interpolate towards.\n     * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.\n     * @return {Vector2} A reference to this vector.\n     */\n    lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      return this;\n    }\n    /**\n     * Linearly interpolates between the given vectors, where alpha is the percent\n     * distance along the line - alpha = 0 will be first vector, and alpha = 1 will\n     * be the second one. The result is stored in this instance.\n     *\n     * @param {Vector2} v1 - The first vector.\n     * @param {Vector2} v2 - The second vector.\n     * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.\n     * @return {Vector2} A reference to this vector.\n     */\n    lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      return this;\n    }\n    /**\n     * Returns `true` if this vector is equal with the given one.\n     *\n     * @param {Vector2} v - The vector to test for equality.\n     * @return {boolean} Whether this vector is equal with the given one.\n     */\n    equals(v) {\n      return v.x === this.x && v.y === this.y;\n    }\n    /**\n     * Sets this vector\'s x value to be `array[ offset ]` and y\n     * value to be `array[ offset + 1 ]`.\n     *\n     * @param {Array<number>} array - An array holding the vector component values.\n     * @param {number} [offset=0] - The offset into the array.\n     * @return {Vector2} A reference to this vector.\n     */\n    fromArray(array, offset = 0) {\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      return this;\n    }\n    /**\n     * Writes the components of this vector to the given array. If no array is provided,\n     * the method returns a new instance.\n     *\n     * @param {Array<number>} [array=[]] - The target array holding the vector components.\n     * @param {number} [offset=0] - Index of the first element in the array.\n     * @return {Array<number>} The vector components.\n     */\n    toArray(array = [], offset = 0) {\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      return array;\n    }\n    /**\n     * Sets the components of this vector from the given buffer attribute.\n     *\n     * @param {BufferAttribute} attribute - The buffer attribute holding vector data.\n     * @param {number} index - The index into the attribute.\n     * @return {Vector2} A reference to this vector.\n     */\n    fromBufferAttribute(attribute, index) {\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      return this;\n    }\n    /**\n     * Rotates this vector around the given center by the given angle.\n     *\n     * @param {Vector2} center - The point around which to rotate.\n     * @param {number} angle - The angle to rotate, in radians.\n     * @return {Vector2} A reference to this vector.\n     */\n    rotateAround(center, angle) {\n      const c = Math.cos(angle), s = Math.sin(angle);\n      const x2 = this.x - center.x;\n      const y = this.y - center.y;\n      this.x = x2 * c - y * s + center.x;\n      this.y = x2 * s + y * c + center.y;\n      return this;\n    }\n    /**\n     * Sets each component of this vector to a pseudo-random value between `0` and\n     * `1`, excluding `1`.\n     *\n     * @return {Vector2} A reference to this vector.\n     */\n    random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      return this;\n    }\n    *[Symbol.iterator]() {\n      yield this.x;\n      yield this.y;\n    }\n  }\n  class Quaternion {\n    /**\n     * Constructs a new quaternion.\n     *\n     * @param {number} [x=0] - The x value of this quaternion.\n     * @param {number} [y=0] - The y value of this quaternion.\n     * @param {number} [z=0] - The z value of this quaternion.\n     * @param {number} [w=1] - The w value of this quaternion.\n     */\n    constructor(x2 = 0, y = 0, z = 0, w = 1) {\n      this.isQuaternion = true;\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._w = w;\n    }\n    /**\n     * Interpolates between two quaternions via SLERP. This implementation assumes the\n     * quaternion data are managed  in flat arrays.\n     *\n     * @param {Array<number>} dst - The destination array.\n     * @param {number} dstOffset - An offset into the destination array.\n     * @param {Array<number>} src0 - The source array of the first quaternion.\n     * @param {number} srcOffset0 - An offset into the first source array.\n     * @param {Array<number>} src1 -  The source array of the second quaternion.\n     * @param {number} srcOffset1 - An offset into the second source array.\n     * @param {number} t - The interpolation factor in the range `[0,1]`.\n     * @see {@link Quaternion#slerp}\n     */\n    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\n      let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];\n      const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];\n      if (t === 0) {\n        dst[dstOffset + 0] = x0;\n        dst[dstOffset + 1] = y0;\n        dst[dstOffset + 2] = z0;\n        dst[dstOffset + 3] = w0;\n        return;\n      }\n      if (t === 1) {\n        dst[dstOffset + 0] = x1;\n        dst[dstOffset + 1] = y1;\n        dst[dstOffset + 2] = z1;\n        dst[dstOffset + 3] = w1;\n        return;\n      }\n      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n        let s = 1 - t;\n        const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;\n        if (sqrSin > Number.EPSILON) {\n          const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);\n          s = Math.sin(s * len) / sin;\n          t = Math.sin(t * len) / sin;\n        }\n        const tDir = t * dir;\n        x0 = x0 * s + x1 * tDir;\n        y0 = y0 * s + y1 * tDir;\n        z0 = z0 * s + z1 * tDir;\n        w0 = w0 * s + w1 * tDir;\n        if (s === 1 - t) {\n          const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n          x0 *= f;\n          y0 *= f;\n          z0 *= f;\n          w0 *= f;\n        }\n      }\n      dst[dstOffset] = x0;\n      dst[dstOffset + 1] = y0;\n      dst[dstOffset + 2] = z0;\n      dst[dstOffset + 3] = w0;\n    }\n    /**\n     * Multiplies two quaternions. This implementation assumes the quaternion data are managed\n     * in flat arrays.\n     *\n     * @param {Array<number>} dst - The destination array.\n     * @param {number} dstOffset - An offset into the destination array.\n     * @param {Array<number>} src0 - The source array of the first quaternion.\n     * @param {number} srcOffset0 - An offset into the first source array.\n     * @param {Array<number>} src1 -  The source array of the second quaternion.\n     * @param {number} srcOffset1 - An offset into the second source array.\n     * @return {Array<number>} The destination array.\n     * @see {@link Quaternion#multiplyQuaternions}.\n     */\n    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {\n      const x0 = src0[srcOffset0];\n      const y0 = src0[srcOffset0 + 1];\n      const z0 = src0[srcOffset0 + 2];\n      const w0 = src0[srcOffset0 + 3];\n      const x1 = src1[srcOffset1];\n      const y1 = src1[srcOffset1 + 1];\n      const z1 = src1[srcOffset1 + 2];\n      const w1 = src1[srcOffset1 + 3];\n      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n      return dst;\n    }\n    /**\n     * The x value of this quaternion.\n     *\n     * @type {number}\n     * @default 0\n     */\n    get x() {\n      return this._x;\n    }\n    set x(value) {\n      this._x = value;\n      this._onChangeCallback();\n    }\n    /**\n     * The y value of this quaternion.\n     *\n     * @type {number}\n     * @default 0\n     */\n    get y() {\n      return this._y;\n    }\n    set y(value) {\n      this._y = value;\n      this._onChangeCallback();\n    }\n    /**\n     * The z value of this quaternion.\n     *\n     * @type {number}\n     * @default 0\n     */\n    get z() {\n      return this._z;\n    }\n    set z(value) {\n      this._z = value;\n      this._onChangeCallback();\n    }\n    /**\n     * The w value of this quaternion.\n     *\n     * @type {number}\n     * @default 1\n     */\n    get w() {\n      return this._w;\n    }\n    set w(value) {\n      this._w = value;\n      this._onChangeCallback();\n    }\n    /**\n     * Sets the quaternion components.\n     *\n     * @param {number} x - The x value of this quaternion.\n     * @param {number} y - The y value of this quaternion.\n     * @param {number} z - The z value of this quaternion.\n     * @param {number} w - The w value of this quaternion.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    set(x2, y, z, w) {\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._w = w;\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Returns a new quaternion with copied values from this instance.\n     *\n     * @return {Quaternion} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor(this._x, this._y, this._z, this._w);\n    }\n    /**\n     * Copies the values of the given quaternion to this instance.\n     *\n     * @param {Quaternion} quaternion - The quaternion to copy.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    copy(quaternion) {\n      this._x = quaternion.x;\n      this._y = quaternion.y;\n      this._z = quaternion.z;\n      this._w = quaternion.w;\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Sets this quaternion from the rotation specified by the given\n     * Euler angles.\n     *\n     * @param {Euler} euler - The Euler angles.\n     * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    setFromEuler(euler, update = true) {\n      const x2 = euler._x, y = euler._y, z = euler._z, order = euler._order;\n      const cos = Math.cos;\n      const sin = Math.sin;\n      const c1 = cos(x2 / 2);\n      const c2 = cos(y / 2);\n      const c3 = cos(z / 2);\n      const s1 = sin(x2 / 2);\n      const s2 = sin(y / 2);\n      const s3 = sin(z / 2);\n      switch (order) {\n        case "XYZ":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case "YXZ":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        case "ZXY":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case "ZYX":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        case "YZX":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case "XZY":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        default:\n          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);\n      }\n      if (update === true) this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Sets this quaternion from the given axis and angle.\n     *\n     * @param {Vector3} axis - The normalized axis.\n     * @param {number} angle - The angle in radians.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    setFromAxisAngle(axis, angle) {\n      const halfAngle = angle / 2, s = Math.sin(halfAngle);\n      this._x = axis.x * s;\n      this._y = axis.y * s;\n      this._z = axis.z * s;\n      this._w = Math.cos(halfAngle);\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Sets this quaternion from the given rotation matrix.\n     *\n     * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    setFromRotationMatrix(m) {\n      const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;\n      if (trace > 0) {\n        const s = 0.5 / Math.sqrt(trace + 1);\n        this._w = 0.25 / s;\n        this._x = (m32 - m23) * s;\n        this._y = (m13 - m31) * s;\n        this._z = (m21 - m12) * s;\n      } else if (m11 > m22 && m11 > m33) {\n        const s = 2 * Math.sqrt(1 + m11 - m22 - m33);\n        this._w = (m32 - m23) / s;\n        this._x = 0.25 * s;\n        this._y = (m12 + m21) / s;\n        this._z = (m13 + m31) / s;\n      } else if (m22 > m33) {\n        const s = 2 * Math.sqrt(1 + m22 - m11 - m33);\n        this._w = (m13 - m31) / s;\n        this._x = (m12 + m21) / s;\n        this._y = 0.25 * s;\n        this._z = (m23 + m32) / s;\n      } else {\n        const s = 2 * Math.sqrt(1 + m33 - m11 - m22);\n        this._w = (m21 - m12) / s;\n        this._x = (m13 + m31) / s;\n        this._y = (m23 + m32) / s;\n        this._z = 0.25 * s;\n      }\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Sets this quaternion to the rotation required to rotate the direction vector\n     * `vFrom` to the direction vector `vTo`.\n     *\n     * @param {Vector3} vFrom - The first (normalized) direction vector.\n     * @param {Vector3} vTo - The second (normalized) direction vector.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    setFromUnitVectors(vFrom, vTo) {\n      let r = vFrom.dot(vTo) + 1;\n      if (r < 1e-8) {\n        r = 0;\n        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n          this._x = -vFrom.y;\n          this._y = vFrom.x;\n          this._z = 0;\n          this._w = r;\n        } else {\n          this._x = 0;\n          this._y = -vFrom.z;\n          this._z = vFrom.y;\n          this._w = r;\n        }\n      } else {\n        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n        this._w = r;\n      }\n      return this.normalize();\n    }\n    /**\n     * Returns the angle between this quaternion and the given one in radians.\n     *\n     * @param {Quaternion} q - The quaternion to compute the angle with.\n     * @return {number} The angle in radians.\n     */\n    angleTo(q) {\n      return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));\n    }\n    /**\n     * Rotates this quaternion by a given angular step to the given quaternion.\n     * The method ensures that the final quaternion will not overshoot `q`.\n     *\n     * @param {Quaternion} q - The target quaternion.\n     * @param {number} step - The angular step in radians.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    rotateTowards(q, step) {\n      const angle = this.angleTo(q);\n      if (angle === 0) return this;\n      const t = Math.min(1, step / angle);\n      this.slerp(q, t);\n      return this;\n    }\n    /**\n     * Sets this quaternion to the identity quaternion; that is, to the\n     * quaternion that represents "no rotation".\n     *\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    identity() {\n      return this.set(0, 0, 0, 1);\n    }\n    /**\n     * Inverts this quaternion via {@link Quaternion#conjugate}. The\n     * quaternion is assumed to have unit length.\n     *\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    invert() {\n      return this.conjugate();\n    }\n    /**\n     * Returns the rotational conjugate of this quaternion. The conjugate of a\n     * quaternion represents the same rotation in the opposite direction about\n     * the rotational axis.\n     *\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    conjugate() {\n      this._x *= -1;\n      this._y *= -1;\n      this._z *= -1;\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Calculates the dot product of this quaternion and the given one.\n     *\n     * @param {Quaternion} v - The quaternion to compute the dot product with.\n     * @return {number} The result of the dot product.\n     */\n    dot(v) {\n      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n    }\n    /**\n     * Computes the squared Euclidean length (straight-line length) of this quaternion,\n     * considered as a 4 dimensional vector. This can be useful if you are comparing the\n     * lengths of two quaternions, as this is a slightly more efficient calculation than\n     * {@link Quaternion#length}.\n     *\n     * @return {number} The squared Euclidean length.\n     */\n    lengthSq() {\n      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n    }\n    /**\n     * Computes the Euclidean length (straight-line length) of this quaternion,\n     * considered as a 4 dimensional vector.\n     *\n     * @return {number} The Euclidean length.\n     */\n    length() {\n      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n    }\n    /**\n     * Normalizes this quaternion - that is, calculated the quaternion that performs\n     * the same rotation as this one, but has a length equal to `1`.\n     *\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    normalize() {\n      let l = this.length();\n      if (l === 0) {\n        this._x = 0;\n        this._y = 0;\n        this._z = 0;\n        this._w = 1;\n      } else {\n        l = 1 / l;\n        this._x = this._x * l;\n        this._y = this._y * l;\n        this._z = this._z * l;\n        this._w = this._w * l;\n      }\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Multiplies this quaternion by the given one.\n     *\n     * @param {Quaternion} q - The quaternion.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    multiply(q) {\n      return this.multiplyQuaternions(this, q);\n    }\n    /**\n     * Pre-multiplies this quaternion by the given one.\n     *\n     * @param {Quaternion} q - The quaternion.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    premultiply(q) {\n      return this.multiplyQuaternions(q, this);\n    }\n    /**\n     * Multiplies the given quaternions and stores the result in this instance.\n     *\n     * @param {Quaternion} a - The first quaternion.\n     * @param {Quaternion} b - The second quaternion.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    multiplyQuaternions(a, b) {\n      const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n      const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Performs a spherical linear interpolation between quaternions.\n     *\n     * @param {Quaternion} qb - The target quaternion.\n     * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    slerp(qb, t) {\n      if (t === 0) return this;\n      if (t === 1) return this.copy(qb);\n      const x2 = this._x, y = this._y, z = this._z, w = this._w;\n      let cosHalfTheta = w * qb._w + x2 * qb._x + y * qb._y + z * qb._z;\n      if (cosHalfTheta < 0) {\n        this._w = -qb._w;\n        this._x = -qb._x;\n        this._y = -qb._y;\n        this._z = -qb._z;\n        cosHalfTheta = -cosHalfTheta;\n      } else {\n        this.copy(qb);\n      }\n      if (cosHalfTheta >= 1) {\n        this._w = w;\n        this._x = x2;\n        this._y = y;\n        this._z = z;\n        return this;\n      }\n      const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;\n      if (sqrSinHalfTheta <= Number.EPSILON) {\n        const s = 1 - t;\n        this._w = s * w + t * this._w;\n        this._x = s * x2 + t * this._x;\n        this._y = s * y + t * this._y;\n        this._z = s * z + t * this._z;\n        this.normalize();\n        return this;\n      }\n      const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n      const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n      const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n      this._w = w * ratioA + this._w * ratioB;\n      this._x = x2 * ratioA + this._x * ratioB;\n      this._y = y * ratioA + this._y * ratioB;\n      this._z = z * ratioA + this._z * ratioB;\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Performs a spherical linear interpolation between the given quaternions\n     * and stores the result in this quaternion.\n     *\n     * @param {Quaternion} qa - The source quaternion.\n     * @param {Quaternion} qb - The target quaternion.\n     * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    slerpQuaternions(qa, qb, t) {\n      return this.copy(qa).slerp(qb, t);\n    }\n    /**\n     * Sets this quaternion to a uniformly random, normalized quaternion.\n     *\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    random() {\n      const theta1 = 2 * Math.PI * Math.random();\n      const theta2 = 2 * Math.PI * Math.random();\n      const x0 = Math.random();\n      const r1 = Math.sqrt(1 - x0);\n      const r2 = Math.sqrt(x0);\n      return this.set(\n        r1 * Math.sin(theta1),\n        r1 * Math.cos(theta1),\n        r2 * Math.sin(theta2),\n        r2 * Math.cos(theta2)\n      );\n    }\n    /**\n     * Returns `true` if this quaternion is equal with the given one.\n     *\n     * @param {Quaternion} quaternion - The quaternion to test for equality.\n     * @return {boolean} Whether this quaternion is equal with the given one.\n     */\n    equals(quaternion) {\n      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n    }\n    /**\n     * Sets this quaternion\'s components from the given array.\n     *\n     * @param {Array<number>} array - An array holding the quaternion component values.\n     * @param {number} [offset=0] - The offset into the array.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    fromArray(array, offset = 0) {\n      this._x = array[offset];\n      this._y = array[offset + 1];\n      this._z = array[offset + 2];\n      this._w = array[offset + 3];\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Writes the components of this quaternion to the given array. If no array is provided,\n     * the method returns a new instance.\n     *\n     * @param {Array<number>} [array=[]] - The target array holding the quaternion components.\n     * @param {number} [offset=0] - Index of the first element in the array.\n     * @return {Array<number>} The quaternion components.\n     */\n    toArray(array = [], offset = 0) {\n      array[offset] = this._x;\n      array[offset + 1] = this._y;\n      array[offset + 2] = this._z;\n      array[offset + 3] = this._w;\n      return array;\n    }\n    /**\n     * Sets the components of this quaternion from the given buffer attribute.\n     *\n     * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.\n     * @param {number} index - The index into the attribute.\n     * @return {Quaternion} A reference to this quaternion.\n     */\n    fromBufferAttribute(attribute, index) {\n      this._x = attribute.getX(index);\n      this._y = attribute.getY(index);\n      this._z = attribute.getZ(index);\n      this._w = attribute.getW(index);\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * This methods defines the serialization result of this class. Returns the\n     * numerical elements of this quaternion in an array of format `[x, y, z, w]`.\n     *\n     * @return {Array<number>} The serialized quaternion.\n     */\n    toJSON() {\n      return this.toArray();\n    }\n    _onChange(callback) {\n      this._onChangeCallback = callback;\n      return this;\n    }\n    _onChangeCallback() {\n    }\n    *[Symbol.iterator]() {\n      yield this._x;\n      yield this._y;\n      yield this._z;\n      yield this._w;\n    }\n  }\n  class Vector3 {\n    /**\n     * Constructs a new 3D vector.\n     *\n     * @param {number} [x=0] - The x value of this vector.\n     * @param {number} [y=0] - The y value of this vector.\n     * @param {number} [z=0] - The z value of this vector.\n     */\n    constructor(x2 = 0, y = 0, z = 0) {\n      Vector3.prototype.isVector3 = true;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n    }\n    /**\n     * Sets the vector components.\n     *\n     * @param {number} x - The value of the x component.\n     * @param {number} y - The value of the y component.\n     * @param {number} z - The value of the z component.\n     * @return {Vector3} A reference to this vector.\n     */\n    set(x2, y, z) {\n      if (z === void 0) z = this.z;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n      return this;\n    }\n    /**\n     * Sets the vector components to the same value.\n     *\n     * @param {number} scalar - The value to set for all vector components.\n     * @return {Vector3} A reference to this vector.\n     */\n    setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      this.z = scalar;\n      return this;\n    }\n    /**\n     * Sets the vector\'s x component to the given value\n     *\n     * @param {number} x - The value to set.\n     * @return {Vector3} A reference to this vector.\n     */\n    setX(x2) {\n      this.x = x2;\n      return this;\n    }\n    /**\n     * Sets the vector\'s y component to the given value\n     *\n     * @param {number} y - The value to set.\n     * @return {Vector3} A reference to this vector.\n     */\n    setY(y) {\n      this.y = y;\n      return this;\n    }\n    /**\n     * Sets the vector\'s z component to the given value\n     *\n     * @param {number} z - The value to set.\n     * @return {Vector3} A reference to this vector.\n     */\n    setZ(z) {\n      this.z = z;\n      return this;\n    }\n    /**\n     * Allows to set a vector component with an index.\n     *\n     * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.\n     * @param {number} value - The value to set.\n     * @return {Vector3} A reference to this vector.\n     */\n    setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n        case 1:\n          this.y = value;\n          break;\n        case 2:\n          this.z = value;\n          break;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n      return this;\n    }\n    /**\n     * Returns the value of the vector component which matches the given index.\n     *\n     * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.\n     * @return {number} A vector component value.\n     */\n    getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n        case 1:\n          return this.y;\n        case 2:\n          return this.z;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n    }\n    /**\n     * Returns a new vector with copied values from this instance.\n     *\n     * @return {Vector3} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor(this.x, this.y, this.z);\n    }\n    /**\n     * Copies the values of the given vector to this instance.\n     *\n     * @param {Vector3} v - The vector to copy.\n     * @return {Vector3} A reference to this vector.\n     */\n    copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      this.z = v.z;\n      return this;\n    }\n    /**\n     * Adds the given vector to this instance.\n     *\n     * @param {Vector3} v - The vector to add.\n     * @return {Vector3} A reference to this vector.\n     */\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      this.z += v.z;\n      return this;\n    }\n    /**\n     * Adds the given scalar value to all components of this instance.\n     *\n     * @param {number} s - The scalar to add.\n     * @return {Vector3} A reference to this vector.\n     */\n    addScalar(s) {\n      this.x += s;\n      this.y += s;\n      this.z += s;\n      return this;\n    }\n    /**\n     * Adds the given vectors and stores the result in this instance.\n     *\n     * @param {Vector3} a - The first vector.\n     * @param {Vector3} b - The second vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      this.z = a.z + b.z;\n      return this;\n    }\n    /**\n     * Adds the given vector scaled by the given factor to this instance.\n     *\n     * @param {Vector3|Vector4} v - The vector.\n     * @param {number} s - The factor that scales `v`.\n     * @return {Vector3} A reference to this vector.\n     */\n    addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      this.z += v.z * s;\n      return this;\n    }\n    /**\n     * Subtracts the given vector from this instance.\n     *\n     * @param {Vector3} v - The vector to subtract.\n     * @return {Vector3} A reference to this vector.\n     */\n    sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      this.z -= v.z;\n      return this;\n    }\n    /**\n     * Subtracts the given scalar value from all components of this instance.\n     *\n     * @param {number} s - The scalar to subtract.\n     * @return {Vector3} A reference to this vector.\n     */\n    subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      this.z -= s;\n      return this;\n    }\n    /**\n     * Subtracts the given vectors and stores the result in this instance.\n     *\n     * @param {Vector3} a - The first vector.\n     * @param {Vector3} b - The second vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      this.z = a.z - b.z;\n      return this;\n    }\n    /**\n     * Multiplies the given vector with this instance.\n     *\n     * @param {Vector3} v - The vector to multiply.\n     * @return {Vector3} A reference to this vector.\n     */\n    multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      this.z *= v.z;\n      return this;\n    }\n    /**\n     * Multiplies the given scalar value with all components of this instance.\n     *\n     * @param {number} scalar - The scalar to multiply.\n     * @return {Vector3} A reference to this vector.\n     */\n    multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      this.z *= scalar;\n      return this;\n    }\n    /**\n     * Multiplies the given vectors and stores the result in this instance.\n     *\n     * @param {Vector3} a - The first vector.\n     * @param {Vector3} b - The second vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    multiplyVectors(a, b) {\n      this.x = a.x * b.x;\n      this.y = a.y * b.y;\n      this.z = a.z * b.z;\n      return this;\n    }\n    /**\n     * Applies the given Euler rotation to this vector.\n     *\n     * @param {Euler} euler - The Euler angles.\n     * @return {Vector3} A reference to this vector.\n     */\n    applyEuler(euler) {\n      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));\n    }\n    /**\n     * Applies a rotation specified by an axis and an angle to this vector.\n     *\n     * @param {Vector3} axis - A normalized vector representing the rotation axis.\n     * @param {number} angle - The angle in radians.\n     * @return {Vector3} A reference to this vector.\n     */\n    applyAxisAngle(axis, angle) {\n      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));\n    }\n    /**\n     * Multiplies this vector with the given 3x3 matrix.\n     *\n     * @param {Matrix3} m - The 3x3 matrix.\n     * @return {Vector3} A reference to this vector.\n     */\n    applyMatrix3(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[3] * y + e[6] * z;\n      this.y = e[1] * x2 + e[4] * y + e[7] * z;\n      this.z = e[2] * x2 + e[5] * y + e[8] * z;\n      return this;\n    }\n    /**\n     * Multiplies this vector by the given normal matrix and normalizes\n     * the result.\n     *\n     * @param {Matrix3} m - The normal matrix.\n     * @return {Vector3} A reference to this vector.\n     */\n    applyNormalMatrix(m) {\n      return this.applyMatrix3(m).normalize();\n    }\n    /**\n     * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and\n     * divides by perspective.\n     *\n     * @param {Matrix4} m - The matrix to apply.\n     * @return {Vector3} A reference to this vector.\n     */\n    applyMatrix4(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      const w = 1 / (e[3] * x2 + e[7] * y + e[11] * z + e[15]);\n      this.x = (e[0] * x2 + e[4] * y + e[8] * z + e[12]) * w;\n      this.y = (e[1] * x2 + e[5] * y + e[9] * z + e[13]) * w;\n      this.z = (e[2] * x2 + e[6] * y + e[10] * z + e[14]) * w;\n      return this;\n    }\n    /**\n     * Applies the given Quaternion to this vector.\n     *\n     * @param {Quaternion} q - The Quaternion.\n     * @return {Vector3} A reference to this vector.\n     */\n    applyQuaternion(q) {\n      const vx = this.x, vy = this.y, vz = this.z;\n      const qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n      const tx = 2 * (qy * vz - qz * vy);\n      const ty = 2 * (qz * vx - qx * vz);\n      const tz = 2 * (qx * vy - qy * vx);\n      this.x = vx + qw * tx + qy * tz - qz * ty;\n      this.y = vy + qw * ty + qz * tx - qx * tz;\n      this.z = vz + qw * tz + qx * ty - qy * tx;\n      return this;\n    }\n    /**\n     * Projects this vector from world space into the camera\'s normalized\n     * device coordinate (NDC) space.\n     *\n     * @param {Camera} camera - The camera.\n     * @return {Vector3} A reference to this vector.\n     */\n    project(camera) {\n      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\n    }\n    /**\n     * Unprojects this vector from the camera\'s normalized device coordinate (NDC)\n     * space into world space.\n     *\n     * @param {Camera} camera - The camera.\n     * @return {Vector3} A reference to this vector.\n     */\n    unproject(camera) {\n      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);\n    }\n    /**\n     * Transforms the direction of this vector by a matrix (the upper left 3 x 3\n     * subset of the given 4x4 matrix and then normalizes the result.\n     *\n     * @param {Matrix4} m - The matrix.\n     * @return {Vector3} A reference to this vector.\n     */\n    transformDirection(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[4] * y + e[8] * z;\n      this.y = e[1] * x2 + e[5] * y + e[9] * z;\n      this.z = e[2] * x2 + e[6] * y + e[10] * z;\n      return this.normalize();\n    }\n    /**\n     * Divides this instance by the given vector.\n     *\n     * @param {Vector3} v - The vector to divide.\n     * @return {Vector3} A reference to this vector.\n     */\n    divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      this.z /= v.z;\n      return this;\n    }\n    /**\n     * Divides this vector by the given scalar.\n     *\n     * @param {number} scalar - The scalar to divide.\n     * @return {Vector3} A reference to this vector.\n     */\n    divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n    /**\n     * If this vector\'s x, y or z value is greater than the given vector\'s x, y or z\n     * value, replace that value with the corresponding min value.\n     *\n     * @param {Vector3} v - The vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      this.z = Math.min(this.z, v.z);\n      return this;\n    }\n    /**\n     * If this vector\'s x, y or z value is less than the given vector\'s x, y or z\n     * value, replace that value with the corresponding max value.\n     *\n     * @param {Vector3} v - The vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      this.z = Math.max(this.z, v.z);\n      return this;\n    }\n    /**\n     * If this vector\'s x, y or z value is greater than the max vector\'s x, y or z\n     * value, it is replaced by the corresponding value.\n     * If this vector\'s x, y or z value is less than the min vector\'s x, y or z value,\n     * it is replaced by the corresponding value.\n     *\n     * @param {Vector3} min - The minimum x, y and z values.\n     * @param {Vector3} max - The maximum x, y and z values in the desired range.\n     * @return {Vector3} A reference to this vector.\n     */\n    clamp(min, max2) {\n      this.x = clamp(this.x, min.x, max2.x);\n      this.y = clamp(this.y, min.y, max2.y);\n      this.z = clamp(this.z, min.z, max2.z);\n      return this;\n    }\n    /**\n     * If this vector\'s x, y or z values are greater than the max value, they are\n     * replaced by the max value.\n     * If this vector\'s x, y or z values are less than the min value, they are\n     * replaced by the min value.\n     *\n     * @param {number} minVal - The minimum value the components will be clamped to.\n     * @param {number} maxVal - The maximum value the components will be clamped to.\n     * @return {Vector3} A reference to this vector.\n     */\n    clampScalar(minVal, maxVal) {\n      this.x = clamp(this.x, minVal, maxVal);\n      this.y = clamp(this.y, minVal, maxVal);\n      this.z = clamp(this.z, minVal, maxVal);\n      return this;\n    }\n    /**\n     * If this vector\'s length is greater than the max value, it is replaced by\n     * the max value.\n     * If this vector\'s length is less than the min value, it is replaced by the\n     * min value.\n     *\n     * @param {number} min - The minimum value the vector length will be clamped to.\n     * @param {number} max - The maximum value the vector length will be clamped to.\n     * @return {Vector3} A reference to this vector.\n     */\n    clampLength(min, max2) {\n      const length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));\n    }\n    /**\n     * The components of this vector are rounded down to the nearest integer value.\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      this.z = Math.floor(this.z);\n      return this;\n    }\n    /**\n     * The components of this vector are rounded up to the nearest integer value.\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      this.z = Math.ceil(this.z);\n      return this;\n    }\n    /**\n     * The components of this vector are rounded to the nearest integer value\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      this.z = Math.round(this.z);\n      return this;\n    }\n    /**\n     * The components of this vector are rounded towards zero (up if negative,\n     * down if positive) to an integer value.\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    roundToZero() {\n      this.x = Math.trunc(this.x);\n      this.y = Math.trunc(this.y);\n      this.z = Math.trunc(this.z);\n      return this;\n    }\n    /**\n     * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      this.z = -this.z;\n      return this;\n    }\n    /**\n     * Calculates the dot product of the given vector with this instance.\n     *\n     * @param {Vector3} v - The vector to compute the dot product with.\n     * @return {number} The result of the dot product.\n     */\n    dot(v) {\n      return this.x * v.x + this.y * v.y + this.z * v.z;\n    }\n    // TODO lengthSquared?\n    /**\n     * Computes the square of the Euclidean length (straight-line length) from\n     * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should\n     * compare the length squared instead as it is slightly more efficient to calculate.\n     *\n     * @return {number} The square length of this vector.\n     */\n    lengthSq() {\n      return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    /**\n     * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).\n     *\n     * @return {number} The length of this vector.\n     */\n    length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n    /**\n     * Computes the Manhattan length of this vector.\n     *\n     * @return {number} The length of this vector.\n     */\n    manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n    }\n    /**\n     * Converts this vector to a unit vector - that is, sets it equal to a vector\n     * with the same direction as this one, but with a vector length of `1`.\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n    /**\n     * Sets this vector to a vector with the same direction as this one, but\n     * with the specified length.\n     *\n     * @param {number} length - The new length of this vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n    /**\n     * Linearly interpolates between the given vector and this instance, where\n     * alpha is the percent distance along the line - alpha = 0 will be this\n     * vector, and alpha = 1 will be the given one.\n     *\n     * @param {Vector3} v - The vector to interpolate towards.\n     * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.\n     * @return {Vector3} A reference to this vector.\n     */\n    lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      this.z += (v.z - this.z) * alpha;\n      return this;\n    }\n    /**\n     * Linearly interpolates between the given vectors, where alpha is the percent\n     * distance along the line - alpha = 0 will be first vector, and alpha = 1 will\n     * be the second one. The result is stored in this instance.\n     *\n     * @param {Vector3} v1 - The first vector.\n     * @param {Vector3} v2 - The second vector.\n     * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.\n     * @return {Vector3} A reference to this vector.\n     */\n    lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      this.z = v1.z + (v2.z - v1.z) * alpha;\n      return this;\n    }\n    /**\n     * Calculates the cross product of the given vector with this instance.\n     *\n     * @param {Vector3} v - The vector to compute the cross product with.\n     * @return {Vector3} The result of the cross product.\n     */\n    cross(v) {\n      return this.crossVectors(this, v);\n    }\n    /**\n     * Calculates the cross product of the given vectors and stores the result\n     * in this instance.\n     *\n     * @param {Vector3} a - The first vector.\n     * @param {Vector3} b - The second vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    crossVectors(a, b) {\n      const ax = a.x, ay = a.y, az = a.z;\n      const bx = b.x, by = b.y, bz = b.z;\n      this.x = ay * bz - az * by;\n      this.y = az * bx - ax * bz;\n      this.z = ax * by - ay * bx;\n      return this;\n    }\n    /**\n     * Projects this vector onto the given one.\n     *\n     * @param {Vector3} v - The vector to project to.\n     * @return {Vector3} A reference to this vector.\n     */\n    projectOnVector(v) {\n      const denominator = v.lengthSq();\n      if (denominator === 0) return this.set(0, 0, 0);\n      const scalar = v.dot(this) / denominator;\n      return this.copy(v).multiplyScalar(scalar);\n    }\n    /**\n     * Projects this vector onto a plane by subtracting this\n     * vector projected onto the plane\'s normal from this vector.\n     *\n     * @param {Vector3} planeNormal - The plane normal.\n     * @return {Vector3} A reference to this vector.\n     */\n    projectOnPlane(planeNormal) {\n      _vector$c.copy(this).projectOnVector(planeNormal);\n      return this.sub(_vector$c);\n    }\n    /**\n     * Reflects this vector off a plane orthogonal to the given normal vector.\n     *\n     * @param {Vector3} normal - The (normalized) normal vector.\n     * @return {Vector3} A reference to this vector.\n     */\n    reflect(normal) {\n      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));\n    }\n    /**\n     * Returns the angle between the given vector and this instance in radians.\n     *\n     * @param {Vector3} v - The vector to compute the angle with.\n     * @return {number} The angle in radians.\n     */\n    angleTo(v) {\n      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n      if (denominator === 0) return Math.PI / 2;\n      const theta = this.dot(v) / denominator;\n      return Math.acos(clamp(theta, -1, 1));\n    }\n    /**\n     * Computes the distance from the given vector to this instance.\n     *\n     * @param {Vector3} v - The vector to compute the distance to.\n     * @return {number} The distance.\n     */\n    distanceTo(v) {\n      return Math.sqrt(this.distanceToSquared(v));\n    }\n    /**\n     * Computes the squared distance from the given vector to this instance.\n     * If you are just comparing the distance with another distance, you should compare\n     * the distance squared instead as it is slightly more efficient to calculate.\n     *\n     * @param {Vector3} v - The vector to compute the squared distance to.\n     * @return {number} The squared distance.\n     */\n    distanceToSquared(v) {\n      const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n      return dx * dx + dy * dy + dz * dz;\n    }\n    /**\n     * Computes the Manhattan distance from the given vector to this instance.\n     *\n     * @param {Vector3} v - The vector to compute the Manhattan distance to.\n     * @return {number} The Manhattan distance.\n     */\n    manhattanDistanceTo(v) {\n      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n    }\n    /**\n     * Sets the vector components from the given spherical coordinates.\n     *\n     * @param {Spherical} s - The spherical coordinates.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromSpherical(s) {\n      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n    }\n    /**\n     * Sets the vector components from the given spherical coordinates.\n     *\n     * @param {number} radius - The radius.\n     * @param {number} phi - The phi angle in radians.\n     * @param {number} theta - The theta angle in radians.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromSphericalCoords(radius, phi, theta) {\n      const sinPhiRadius = Math.sin(phi) * radius;\n      this.x = sinPhiRadius * Math.sin(theta);\n      this.y = Math.cos(phi) * radius;\n      this.z = sinPhiRadius * Math.cos(theta);\n      return this;\n    }\n    /**\n     * Sets the vector components from the given cylindrical coordinates.\n     *\n     * @param {Cylindrical} c - The cylindrical coordinates.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromCylindrical(c) {\n      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);\n    }\n    /**\n     * Sets the vector components from the given cylindrical coordinates.\n     *\n     * @param {number} radius - The radius.\n     * @param {number} theta - The theta angle in radians.\n     * @param {number} y - The y value.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromCylindricalCoords(radius, theta, y) {\n      this.x = radius * Math.sin(theta);\n      this.y = y;\n      this.z = radius * Math.cos(theta);\n      return this;\n    }\n    /**\n     * Sets the vector components to the position elements of the\n     * given transformation matrix.\n     *\n     * @param {Matrix4} m - The 4x4 matrix.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromMatrixPosition(m) {\n      const e = m.elements;\n      this.x = e[12];\n      this.y = e[13];\n      this.z = e[14];\n      return this;\n    }\n    /**\n     * Sets the vector components to the scale elements of the\n     * given transformation matrix.\n     *\n     * @param {Matrix4} m - The 4x4 matrix.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromMatrixScale(m) {\n      const sx = this.setFromMatrixColumn(m, 0).length();\n      const sy = this.setFromMatrixColumn(m, 1).length();\n      const sz = this.setFromMatrixColumn(m, 2).length();\n      this.x = sx;\n      this.y = sy;\n      this.z = sz;\n      return this;\n    }\n    /**\n     * Sets the vector components from the specified matrix column.\n     *\n     * @param {Matrix4} m - The 4x4 matrix.\n     * @param {number} index - The column index.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromMatrixColumn(m, index) {\n      return this.fromArray(m.elements, index * 4);\n    }\n    /**\n     * Sets the vector components from the specified matrix column.\n     *\n     * @param {Matrix3} m - The 3x3 matrix.\n     * @param {number} index - The column index.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromMatrix3Column(m, index) {\n      return this.fromArray(m.elements, index * 3);\n    }\n    /**\n     * Sets the vector components from the given Euler angles.\n     *\n     * @param {Euler} e - The Euler angles to set.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromEuler(e) {\n      this.x = e._x;\n      this.y = e._y;\n      this.z = e._z;\n      return this;\n    }\n    /**\n     * Sets the vector components from the RGB components of the\n     * given color.\n     *\n     * @param {Color} c - The color to set.\n     * @return {Vector3} A reference to this vector.\n     */\n    setFromColor(c) {\n      this.x = c.r;\n      this.y = c.g;\n      this.z = c.b;\n      return this;\n    }\n    /**\n     * Returns `true` if this vector is equal with the given one.\n     *\n     * @param {Vector3} v - The vector to test for equality.\n     * @return {boolean} Whether this vector is equal with the given one.\n     */\n    equals(v) {\n      return v.x === this.x && v.y === this.y && v.z === this.z;\n    }\n    /**\n     * Sets this vector\'s x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`\n     * and z value to be `array[ offset + 2 ]`.\n     *\n     * @param {Array<number>} array - An array holding the vector component values.\n     * @param {number} [offset=0] - The offset into the array.\n     * @return {Vector3} A reference to this vector.\n     */\n    fromArray(array, offset = 0) {\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      this.z = array[offset + 2];\n      return this;\n    }\n    /**\n     * Writes the components of this vector to the given array. If no array is provided,\n     * the method returns a new instance.\n     *\n     * @param {Array<number>} [array=[]] - The target array holding the vector components.\n     * @param {number} [offset=0] - Index of the first element in the array.\n     * @return {Array<number>} The vector components.\n     */\n    toArray(array = [], offset = 0) {\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      array[offset + 2] = this.z;\n      return array;\n    }\n    /**\n     * Sets the components of this vector from the given buffer attribute.\n     *\n     * @param {BufferAttribute} attribute - The buffer attribute holding vector data.\n     * @param {number} index - The index into the attribute.\n     * @return {Vector3} A reference to this vector.\n     */\n    fromBufferAttribute(attribute, index) {\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      this.z = attribute.getZ(index);\n      return this;\n    }\n    /**\n     * Sets each component of this vector to a pseudo-random value between `0` and\n     * `1`, excluding `1`.\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      this.z = Math.random();\n      return this;\n    }\n    /**\n     * Sets this vector to a uniformly random point on a unit sphere.\n     *\n     * @return {Vector3} A reference to this vector.\n     */\n    randomDirection() {\n      const theta = Math.random() * Math.PI * 2;\n      const u = Math.random() * 2 - 1;\n      const c = Math.sqrt(1 - u * u);\n      this.x = c * Math.cos(theta);\n      this.y = u;\n      this.z = c * Math.sin(theta);\n      return this;\n    }\n    *[Symbol.iterator]() {\n      yield this.x;\n      yield this.y;\n      yield this.z;\n    }\n  }\n  const _vector$c = /* @__PURE__ */ new Vector3();\n  const _quaternion$4 = /* @__PURE__ */ new Quaternion();\n  class Matrix3 {\n    /**\n     * Constructs a new 3x3 matrix. The arguments are supposed to be\n     * in row-major order. If no arguments are provided, the constructor\n     * initializes the matrix as an identity matrix.\n     *\n     * @param {number} [n11] - 1-1 matrix element.\n     * @param {number} [n12] - 1-2 matrix element.\n     * @param {number} [n13] - 1-3 matrix element.\n     * @param {number} [n21] - 2-1 matrix element.\n     * @param {number} [n22] - 2-2 matrix element.\n     * @param {number} [n23] - 2-3 matrix element.\n     * @param {number} [n31] - 3-1 matrix element.\n     * @param {number} [n32] - 3-2 matrix element.\n     * @param {number} [n33] - 3-3 matrix element.\n     */\n    constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n      Matrix3.prototype.isMatrix3 = true;\n      this.elements = [\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ];\n      if (n11 !== void 0) {\n        this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);\n      }\n    }\n    /**\n     * Sets the elements of the matrix.The arguments are supposed to be\n     * in row-major order.\n     *\n     * @param {number} [n11] - 1-1 matrix element.\n     * @param {number} [n12] - 1-2 matrix element.\n     * @param {number} [n13] - 1-3 matrix element.\n     * @param {number} [n21] - 2-1 matrix element.\n     * @param {number} [n22] - 2-2 matrix element.\n     * @param {number} [n23] - 2-3 matrix element.\n     * @param {number} [n31] - 3-1 matrix element.\n     * @param {number} [n32] - 3-2 matrix element.\n     * @param {number} [n33] - 3-3 matrix element.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n      const te = this.elements;\n      te[0] = n11;\n      te[1] = n21;\n      te[2] = n31;\n      te[3] = n12;\n      te[4] = n22;\n      te[5] = n32;\n      te[6] = n13;\n      te[7] = n23;\n      te[8] = n33;\n      return this;\n    }\n    /**\n     * Sets this matrix to the 3x3 identity matrix.\n     *\n     * @return {Matrix3} A reference to this matrix.\n     */\n    identity() {\n      this.set(\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Copies the values of the given matrix to this instance.\n     *\n     * @param {Matrix3} m - The matrix to copy.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    copy(m) {\n      const te = this.elements;\n      const me = m.elements;\n      te[0] = me[0];\n      te[1] = me[1];\n      te[2] = me[2];\n      te[3] = me[3];\n      te[4] = me[4];\n      te[5] = me[5];\n      te[6] = me[6];\n      te[7] = me[7];\n      te[8] = me[8];\n      return this;\n    }\n    /**\n     * Extracts the basis of this matrix into the three axis vectors provided.\n     *\n     * @param {Vector3} xAxis - The basis\'s x axis.\n     * @param {Vector3} yAxis - The basis\'s y axis.\n     * @param {Vector3} zAxis - The basis\'s z axis.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    extractBasis(xAxis, yAxis, zAxis) {\n      xAxis.setFromMatrix3Column(this, 0);\n      yAxis.setFromMatrix3Column(this, 1);\n      zAxis.setFromMatrix3Column(this, 2);\n      return this;\n    }\n    /**\n     * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.\n     *\n     * @param {Matrix4} m - The 4x4 matrix.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    setFromMatrix4(m) {\n      const me = m.elements;\n      this.set(\n        me[0],\n        me[4],\n        me[8],\n        me[1],\n        me[5],\n        me[9],\n        me[2],\n        me[6],\n        me[10]\n      );\n      return this;\n    }\n    /**\n     * Post-multiplies this matrix by the given 3x3 matrix.\n     *\n     * @param {Matrix3} m - The matrix to multiply with.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    multiply(m) {\n      return this.multiplyMatrices(this, m);\n    }\n    /**\n     * Pre-multiplies this matrix by the given 3x3 matrix.\n     *\n     * @param {Matrix3} m - The matrix to multiply with.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    premultiply(m) {\n      return this.multiplyMatrices(m, this);\n    }\n    /**\n     * Multiples the given 3x3 matrices and stores the result\n     * in this matrix.\n     *\n     * @param {Matrix3} a - The first matrix.\n     * @param {Matrix3} b - The second matrix.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    multiplyMatrices(a, b) {\n      const ae = a.elements;\n      const be = b.elements;\n      const te = this.elements;\n      const a11 = ae[0], a12 = ae[3], a13 = ae[6];\n      const a21 = ae[1], a22 = ae[4], a23 = ae[7];\n      const a31 = ae[2], a32 = ae[5], a33 = ae[8];\n      const b11 = be[0], b12 = be[3], b13 = be[6];\n      const b21 = be[1], b22 = be[4], b23 = be[7];\n      const b31 = be[2], b32 = be[5], b33 = be[8];\n      te[0] = a11 * b11 + a12 * b21 + a13 * b31;\n      te[3] = a11 * b12 + a12 * b22 + a13 * b32;\n      te[6] = a11 * b13 + a12 * b23 + a13 * b33;\n      te[1] = a21 * b11 + a22 * b21 + a23 * b31;\n      te[4] = a21 * b12 + a22 * b22 + a23 * b32;\n      te[7] = a21 * b13 + a22 * b23 + a23 * b33;\n      te[2] = a31 * b11 + a32 * b21 + a33 * b31;\n      te[5] = a31 * b12 + a32 * b22 + a33 * b32;\n      te[8] = a31 * b13 + a32 * b23 + a33 * b33;\n      return this;\n    }\n    /**\n     * Multiplies every component of the matrix by the given scalar.\n     *\n     * @param {number} s - The scalar.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    multiplyScalar(s) {\n      const te = this.elements;\n      te[0] *= s;\n      te[3] *= s;\n      te[6] *= s;\n      te[1] *= s;\n      te[4] *= s;\n      te[7] *= s;\n      te[2] *= s;\n      te[5] *= s;\n      te[8] *= s;\n      return this;\n    }\n    /**\n     * Computes and returns the determinant of this matrix.\n     *\n     * @return {number} The determinant.\n     */\n    determinant() {\n      const te = this.elements;\n      const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];\n      return a * e * i2 - a * f * h - b * d * i2 + b * f * g + c * d * h - c * e * g;\n    }\n    /**\n     * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.\n     * You can not invert with a determinant of zero. If you attempt this, the method produces\n     * a zero matrix instead.\n     *\n     * @return {Matrix3} A reference to this matrix.\n     */\n    invert() {\n      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;\n      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n      const detInv = 1 / det;\n      te[0] = t11 * detInv;\n      te[1] = (n31 * n23 - n33 * n21) * detInv;\n      te[2] = (n32 * n21 - n31 * n22) * detInv;\n      te[3] = t12 * detInv;\n      te[4] = (n33 * n11 - n31 * n13) * detInv;\n      te[5] = (n31 * n12 - n32 * n11) * detInv;\n      te[6] = t13 * detInv;\n      te[7] = (n21 * n13 - n23 * n11) * detInv;\n      te[8] = (n22 * n11 - n21 * n12) * detInv;\n      return this;\n    }\n    /**\n     * Transposes this matrix in place.\n     *\n     * @return {Matrix3} A reference to this matrix.\n     */\n    transpose() {\n      let tmp;\n      const m = this.elements;\n      tmp = m[1];\n      m[1] = m[3];\n      m[3] = tmp;\n      tmp = m[2];\n      m[2] = m[6];\n      m[6] = tmp;\n      tmp = m[5];\n      m[5] = m[7];\n      m[7] = tmp;\n      return this;\n    }\n    /**\n     * Computes the normal matrix which is the inverse transpose of the upper\n     * left 3x3 portion of the given 4x4 matrix.\n     *\n     * @param {Matrix4} matrix4 - The 4x4 matrix.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    getNormalMatrix(matrix4) {\n      return this.setFromMatrix4(matrix4).invert().transpose();\n    }\n    /**\n     * Transposes this matrix into the supplied array, and returns itself unchanged.\n     *\n     * @param {Array<number>} r - An array to store the transposed matrix elements.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    transposeIntoArray(r) {\n      const m = this.elements;\n      r[0] = m[0];\n      r[1] = m[3];\n      r[2] = m[6];\n      r[3] = m[1];\n      r[4] = m[4];\n      r[5] = m[7];\n      r[6] = m[2];\n      r[7] = m[5];\n      r[8] = m[8];\n      return this;\n    }\n    /**\n     * Sets the UV transform matrix from offset, repeat, rotation, and center.\n     *\n     * @param {number} tx - Offset x.\n     * @param {number} ty - Offset y.\n     * @param {number} sx - Repeat x.\n     * @param {number} sy - Repeat y.\n     * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.\n     * @param {number} cx - Center x of rotation.\n     * @param {number} cy - Center y of rotation\n     * @return {Matrix3} A reference to this matrix.\n     */\n    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\n      const c = Math.cos(rotation);\n      const s = Math.sin(rotation);\n      this.set(\n        sx * c,\n        sx * s,\n        -sx * (c * cx + s * cy) + cx + tx,\n        -sy * s,\n        sy * c,\n        -sy * (-s * cx + c * cy) + cy + ty,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Scales this matrix with the given scalar values.\n     *\n     * @param {number} sx - The amount to scale in the X axis.\n     * @param {number} sy - The amount to scale in the Y axis.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    scale(sx, sy) {\n      this.premultiply(_m3.makeScale(sx, sy));\n      return this;\n    }\n    /**\n     * Rotates this matrix by the given angle.\n     *\n     * @param {number} theta - The rotation in radians.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    rotate(theta) {\n      this.premultiply(_m3.makeRotation(-theta));\n      return this;\n    }\n    /**\n     * Translates this matrix by the given scalar values.\n     *\n     * @param {number} tx - The amount to translate in the X axis.\n     * @param {number} ty - The amount to translate in the Y axis.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    translate(tx, ty) {\n      this.premultiply(_m3.makeTranslation(tx, ty));\n      return this;\n    }\n    // for 2D Transforms\n    /**\n     * Sets this matrix as a 2D translation transform.\n     *\n     * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.\n     * @param {number} y - The amount to translate in the Y axis.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    makeTranslation(x2, y) {\n      if (x2.isVector2) {\n        this.set(\n          1,\n          0,\n          x2.x,\n          0,\n          1,\n          x2.y,\n          0,\n          0,\n          1\n        );\n      } else {\n        this.set(\n          1,\n          0,\n          x2,\n          0,\n          1,\n          y,\n          0,\n          0,\n          1\n        );\n      }\n      return this;\n    }\n    /**\n     * Sets this matrix as a 2D rotational transformation.\n     *\n     * @param {number} theta - The rotation in radians.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    makeRotation(theta) {\n      const c = Math.cos(theta);\n      const s = Math.sin(theta);\n      this.set(\n        c,\n        -s,\n        0,\n        s,\n        c,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Sets this matrix as a 2D scale transform.\n     *\n     * @param {number} x - The amount to scale in the X axis.\n     * @param {number} y - The amount to scale in the Y axis.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    makeScale(x2, y) {\n      this.set(\n        x2,\n        0,\n        0,\n        0,\n        y,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Returns `true` if this matrix is equal with the given one.\n     *\n     * @param {Matrix3} matrix - The matrix to test for equality.\n     * @return {boolean} Whether this matrix is equal with the given one.\n     */\n    equals(matrix) {\n      const te = this.elements;\n      const me = matrix.elements;\n      for (let i2 = 0; i2 < 9; i2++) {\n        if (te[i2] !== me[i2]) return false;\n      }\n      return true;\n    }\n    /**\n     * Sets the elements of the matrix from the given array.\n     *\n     * @param {Array<number>} array - The matrix elements in column-major order.\n     * @param {number} [offset=0] - Index of the first element in the array.\n     * @return {Matrix3} A reference to this matrix.\n     */\n    fromArray(array, offset = 0) {\n      for (let i2 = 0; i2 < 9; i2++) {\n        this.elements[i2] = array[i2 + offset];\n      }\n      return this;\n    }\n    /**\n     * Writes the elements of this matrix to the given array. If no array is provided,\n     * the method returns a new instance.\n     *\n     * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.\n     * @param {number} [offset=0] - Index of the first element in the array.\n     * @return {Array<number>} The matrix elements in column-major order.\n     */\n    toArray(array = [], offset = 0) {\n      const te = this.elements;\n      array[offset] = te[0];\n      array[offset + 1] = te[1];\n      array[offset + 2] = te[2];\n      array[offset + 3] = te[3];\n      array[offset + 4] = te[4];\n      array[offset + 5] = te[5];\n      array[offset + 6] = te[6];\n      array[offset + 7] = te[7];\n      array[offset + 8] = te[8];\n      return array;\n    }\n    /**\n     * Returns a matrix with copied values from this instance.\n     *\n     * @return {Matrix3} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor().fromArray(this.elements);\n    }\n  }\n  const _m3 = /* @__PURE__ */ new Matrix3();\n  function arrayNeedsUint32(array) {\n    for (let i2 = array.length - 1; i2 >= 0; --i2) {\n      if (array[i2] >= 65535) return true;\n    }\n    return false;\n  }\n  function createElementNS(name) {\n    return document.createElementNS("http://www.w3.org/1999/xhtml", name);\n  }\n  const _cache = {};\n  function warnOnce(message) {\n    if (message in _cache) return;\n    _cache[message] = true;\n    console.warn(message);\n  }\n  const LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(\n    0.4123908,\n    0.3575843,\n    0.1804808,\n    0.212639,\n    0.7151687,\n    0.0721923,\n    0.0193308,\n    0.1191948,\n    0.9505322\n  );\n  const XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(\n    3.2409699,\n    -1.5373832,\n    -0.4986108,\n    -0.9692436,\n    1.8759675,\n    0.0415551,\n    0.0556301,\n    -0.203977,\n    1.0569715\n  );\n  function createColorManagement() {\n    const ColorManagement2 = {\n      enabled: true,\n      workingColorSpace: LinearSRGBColorSpace,\n      /**\n       * Implementations of supported color spaces.\n       *\n       * Required:\n       *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]\n       *	- whitePoint: reference white [ x y ]\n       *	- transfer: transfer function (pre-defined)\n       *	- toXYZ: Matrix3 RGB to XYZ transform\n       *	- fromXYZ: Matrix3 XYZ to RGB transform\n       *	- luminanceCoefficients: RGB luminance coefficients\n       *\n       * Optional:\n       *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace, toneMappingMode: \'extended\' | \'standard\' }\n       *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }\n       *\n       * Reference:\n       * - https://www.russellcottrell.com/photo/matrixCalculator.htm\n       */\n      spaces: {},\n      convert: function(color, sourceColorSpace, targetColorSpace) {\n        if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {\n          return color;\n        }\n        if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {\n          color.r = SRGBToLinear(color.r);\n          color.g = SRGBToLinear(color.g);\n          color.b = SRGBToLinear(color.b);\n        }\n        if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {\n          color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);\n          color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);\n        }\n        if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {\n          color.r = LinearToSRGB(color.r);\n          color.g = LinearToSRGB(color.g);\n          color.b = LinearToSRGB(color.b);\n        }\n        return color;\n      },\n      workingToColorSpace: function(color, targetColorSpace) {\n        return this.convert(color, this.workingColorSpace, targetColorSpace);\n      },\n      colorSpaceToWorking: function(color, sourceColorSpace) {\n        return this.convert(color, sourceColorSpace, this.workingColorSpace);\n      },\n      getPrimaries: function(colorSpace) {\n        return this.spaces[colorSpace].primaries;\n      },\n      getTransfer: function(colorSpace) {\n        if (colorSpace === NoColorSpace) return LinearTransfer;\n        return this.spaces[colorSpace].transfer;\n      },\n      getToneMappingMode: function(colorSpace) {\n        return this.spaces[colorSpace].outputColorSpaceConfig.toneMappingMode || "standard";\n      },\n      getLuminanceCoefficients: function(target, colorSpace = this.workingColorSpace) {\n        return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);\n      },\n      define: function(colorSpaces) {\n        Object.assign(this.spaces, colorSpaces);\n      },\n      // Internal APIs\n      _getMatrix: function(targetMatrix, sourceColorSpace, targetColorSpace) {\n        return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);\n      },\n      _getDrawingBufferColorSpace: function(colorSpace) {\n        return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;\n      },\n      _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {\n        return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;\n      },\n      // Deprecated\n      fromWorkingColorSpace: function(color, targetColorSpace) {\n        warnOnce("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace().");\n        return ColorManagement2.workingToColorSpace(color, targetColorSpace);\n      },\n      toWorkingColorSpace: function(color, sourceColorSpace) {\n        warnOnce("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking().");\n        return ColorManagement2.colorSpaceToWorking(color, sourceColorSpace);\n      }\n    };\n    const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];\n    const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];\n    const D65 = [0.3127, 0.329];\n    ColorManagement2.define({\n      [LinearSRGBColorSpace]: {\n        primaries: REC709_PRIMARIES,\n        whitePoint: D65,\n        transfer: LinearTransfer,\n        toXYZ: LINEAR_REC709_TO_XYZ,\n        fromXYZ: XYZ_TO_LINEAR_REC709,\n        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n        workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },\n        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n      },\n      [SRGBColorSpace]: {\n        primaries: REC709_PRIMARIES,\n        whitePoint: D65,\n        transfer: SRGBTransfer,\n        toXYZ: LINEAR_REC709_TO_XYZ,\n        fromXYZ: XYZ_TO_LINEAR_REC709,\n        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n      }\n    });\n    return ColorManagement2;\n  }\n  const ColorManagement = /* @__PURE__ */ createColorManagement();\n  function SRGBToLinear(c) {\n    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n  }\n  function LinearToSRGB(c) {\n    return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\n  }\n  let _canvas;\n  class ImageUtils {\n    /**\n     * Returns a data URI containing a representation of the given image.\n     *\n     * @param {(HTMLImageElement|HTMLCanvasElement)} image - The image object.\n     * @param {string} [type=\'image/png\'] - Indicates the image format.\n     * @return {string} The data URI.\n     */\n    static getDataURL(image, type = "image/png") {\n      if (/^data:/i.test(image.src)) {\n        return image.src;\n      }\n      if (typeof HTMLCanvasElement === "undefined") {\n        return image.src;\n      }\n      let canvas;\n      if (image instanceof HTMLCanvasElement) {\n        canvas = image;\n      } else {\n        if (_canvas === void 0) _canvas = createElementNS("canvas");\n        _canvas.width = image.width;\n        _canvas.height = image.height;\n        const context = _canvas.getContext("2d");\n        if (image instanceof ImageData) {\n          context.putImageData(image, 0, 0);\n        } else {\n          context.drawImage(image, 0, 0, image.width, image.height);\n        }\n        canvas = _canvas;\n      }\n      return canvas.toDataURL(type);\n    }\n    /**\n     * Converts the given sRGB image data to linear color space.\n     *\n     * @param {(HTMLImageElement|HTMLCanvasElement|ImageBitmap|Object)} image - The image object.\n     * @return {HTMLCanvasElement|Object} The converted image.\n     */\n    static sRGBToLinear(image) {\n      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {\n        const canvas = createElementNS("canvas");\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const context = canvas.getContext("2d");\n        context.drawImage(image, 0, 0, image.width, image.height);\n        const imageData = context.getImageData(0, 0, image.width, image.height);\n        const data = imageData.data;\n        for (let i2 = 0; i2 < data.length; i2++) {\n          data[i2] = SRGBToLinear(data[i2] / 255) * 255;\n        }\n        context.putImageData(imageData, 0, 0);\n        return canvas;\n      } else if (image.data) {\n        const data = image.data.slice(0);\n        for (let i2 = 0; i2 < data.length; i2++) {\n          if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {\n            data[i2] = Math.floor(SRGBToLinear(data[i2] / 255) * 255);\n          } else {\n            data[i2] = SRGBToLinear(data[i2]);\n          }\n        }\n        return {\n          data,\n          width: image.width,\n          height: image.height\n        };\n      } else {\n        console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");\n        return image;\n      }\n    }\n  }\n  let _sourceId = 0;\n  class Source {\n    /**\n     * Constructs a new video texture.\n     *\n     * @param {any} [data=null] - The data definition of a texture.\n     */\n    constructor(data = null) {\n      this.isSource = true;\n      Object.defineProperty(this, "id", { value: _sourceId++ });\n      this.uuid = generateUUID();\n      this.data = data;\n      this.dataReady = true;\n      this.version = 0;\n    }\n    /**\n     * Returns the dimensions of the source into the given target vector.\n     *\n     * @param {(Vector2|Vector3)} target - The target object the result is written into.\n     * @return {(Vector2|Vector3)} The dimensions of the source.\n     */\n    getSize(target) {\n      const data = this.data;\n      if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) {\n        target.set(data.videoWidth, data.videoHeight, 0);\n      } else if (data instanceof VideoFrame) {\n        target.set(data.displayHeight, data.displayWidth, 0);\n      } else if (data !== null) {\n        target.set(data.width, data.height, data.depth || 0);\n      } else {\n        target.set(0, 0, 0);\n      }\n      return target;\n    }\n    /**\n     * When the property is set to `true`, the engine allocates the memory\n     * for the texture (if necessary) and triggers the actual texture upload\n     * to the GPU next time the source is used.\n     *\n     * @type {boolean}\n     * @default false\n     * @param {boolean} value\n     */\n    set needsUpdate(value) {\n      if (value === true) this.version++;\n    }\n    /**\n     * Serializes the source into JSON.\n     *\n     * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.\n     * @return {Object} A JSON object representing the serialized source.\n     * @see {@link ObjectLoader#parse}\n     */\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === "string";\n      if (!isRootObject && meta.images[this.uuid] !== void 0) {\n        return meta.images[this.uuid];\n      }\n      const output = {\n        uuid: this.uuid,\n        url: ""\n      };\n      const data = this.data;\n      if (data !== null) {\n        let url;\n        if (Array.isArray(data)) {\n          url = [];\n          for (let i2 = 0, l = data.length; i2 < l; i2++) {\n            if (data[i2].isDataTexture) {\n              url.push(serializeImage(data[i2].image));\n            } else {\n              url.push(serializeImage(data[i2]));\n            }\n          }\n        } else {\n          url = serializeImage(data);\n        }\n        output.url = url;\n      }\n      if (!isRootObject) {\n        meta.images[this.uuid] = output;\n      }\n      return output;\n    }\n  }\n  function serializeImage(image) {\n    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {\n      return ImageUtils.getDataURL(image);\n    } else {\n      if (image.data) {\n        return {\n          data: Array.from(image.data),\n          width: image.width,\n          height: image.height,\n          type: image.data.constructor.name\n        };\n      } else {\n        console.warn("THREE.Texture: Unable to serialize Texture.");\n        return {};\n      }\n    }\n  }\n  let _textureId = 0;\n  const _tempVec3 = /* @__PURE__ */ new Vector3();\n  class Texture extends EventDispatcher {\n    /**\n     * Constructs a new texture.\n     *\n     * @param {?Object} [image=Texture.DEFAULT_IMAGE] - The image holding the texture data.\n     * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.\n     * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.\n     * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.\n     * @param {number} [magFilter=LinearFilter] - The mag filter value.\n     * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.\n     * @param {number} [format=RGBAFormat] - The texture format.\n     * @param {number} [type=UnsignedByteType] - The texture type.\n     * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.\n     * @param {string} [colorSpace=NoColorSpace] - The color space.\n     */\n    constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {\n      super();\n      this.isTexture = true;\n      Object.defineProperty(this, "id", { value: _textureId++ });\n      this.uuid = generateUUID();\n      this.name = "";\n      this.source = new Source(image);\n      this.mipmaps = [];\n      this.mapping = mapping;\n      this.channel = 0;\n      this.wrapS = wrapS;\n      this.wrapT = wrapT;\n      this.magFilter = magFilter;\n      this.minFilter = minFilter;\n      this.anisotropy = anisotropy;\n      this.format = format;\n      this.internalFormat = null;\n      this.type = type;\n      this.offset = new Vector2(0, 0);\n      this.repeat = new Vector2(1, 1);\n      this.center = new Vector2(0, 0);\n      this.rotation = 0;\n      this.matrixAutoUpdate = true;\n      this.matrix = new Matrix3();\n      this.generateMipmaps = true;\n      this.premultiplyAlpha = false;\n      this.flipY = true;\n      this.unpackAlignment = 4;\n      this.colorSpace = colorSpace;\n      this.userData = {};\n      this.updateRanges = [];\n      this.version = 0;\n      this.onUpdate = null;\n      this.renderTarget = null;\n      this.isRenderTargetTexture = false;\n      this.isArrayTexture = image && image.depth && image.depth > 1 ? true : false;\n      this.pmremVersion = 0;\n    }\n    /**\n     * The width of the texture in pixels.\n     */\n    get width() {\n      return this.source.getSize(_tempVec3).x;\n    }\n    /**\n     * The height of the texture in pixels.\n     */\n    get height() {\n      return this.source.getSize(_tempVec3).y;\n    }\n    /**\n     * The depth of the texture in pixels.\n     */\n    get depth() {\n      return this.source.getSize(_tempVec3).z;\n    }\n    /**\n     * The image object holding the texture data.\n     *\n     * @type {?Object}\n     */\n    get image() {\n      return this.source.data;\n    }\n    set image(value = null) {\n      this.source.data = value;\n    }\n    /**\n     * Updates the texture transformation matrix from the from the properties {@link Texture#offset},\n     * {@link Texture#repeat}, {@link Texture#rotation}, and {@link Texture#center}.\n     */\n    updateMatrix() {\n      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);\n    }\n    /**\n     * Adds a range of data in the data texture to be updated on the GPU.\n     *\n     * @param {number} start - Position at which to start update.\n     * @param {number} count - The number of components to update.\n     */\n    addUpdateRange(start, count) {\n      this.updateRanges.push({ start, count });\n    }\n    /**\n     * Clears the update ranges.\n     */\n    clearUpdateRanges() {\n      this.updateRanges.length = 0;\n    }\n    /**\n     * Returns a new texture with copied values from this instance.\n     *\n     * @return {Texture} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    /**\n     * Copies the values of the given texture to this instance.\n     *\n     * @param {Texture} source - The texture to copy.\n     * @return {Texture} A reference to this instance.\n     */\n    copy(source) {\n      this.name = source.name;\n      this.source = source.source;\n      this.mipmaps = source.mipmaps.slice(0);\n      this.mapping = source.mapping;\n      this.channel = source.channel;\n      this.wrapS = source.wrapS;\n      this.wrapT = source.wrapT;\n      this.magFilter = source.magFilter;\n      this.minFilter = source.minFilter;\n      this.anisotropy = source.anisotropy;\n      this.format = source.format;\n      this.internalFormat = source.internalFormat;\n      this.type = source.type;\n      this.offset.copy(source.offset);\n      this.repeat.copy(source.repeat);\n      this.center.copy(source.center);\n      this.rotation = source.rotation;\n      this.matrixAutoUpdate = source.matrixAutoUpdate;\n      this.matrix.copy(source.matrix);\n      this.generateMipmaps = source.generateMipmaps;\n      this.premultiplyAlpha = source.premultiplyAlpha;\n      this.flipY = source.flipY;\n      this.unpackAlignment = source.unpackAlignment;\n      this.colorSpace = source.colorSpace;\n      this.renderTarget = source.renderTarget;\n      this.isRenderTargetTexture = source.isRenderTargetTexture;\n      this.isArrayTexture = source.isArrayTexture;\n      this.userData = JSON.parse(JSON.stringify(source.userData));\n      this.needsUpdate = true;\n      return this;\n    }\n    /**\n     * Sets this texture\'s properties based on `values`.\n     * @param {Object} values - A container with texture parameters.\n     */\n    setValues(values) {\n      for (const key in values) {\n        const newValue = values[key];\n        if (newValue === void 0) {\n          console.warn(`THREE.Texture.setValues(): parameter \'${key}\' has value of undefined.`);\n          continue;\n        }\n        const currentValue = this[key];\n        if (currentValue === void 0) {\n          console.warn(`THREE.Texture.setValues(): property \'${key}\' does not exist.`);\n          continue;\n        }\n        if (currentValue && newValue && (currentValue.isVector2 && newValue.isVector2)) {\n          currentValue.copy(newValue);\n        } else if (currentValue && newValue && (currentValue.isVector3 && newValue.isVector3)) {\n          currentValue.copy(newValue);\n        } else if (currentValue && newValue && (currentValue.isMatrix3 && newValue.isMatrix3)) {\n          currentValue.copy(newValue);\n        } else {\n          this[key] = newValue;\n        }\n      }\n    }\n    /**\n     * Serializes the texture into JSON.\n     *\n     * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.\n     * @return {Object} A JSON object representing the serialized texture.\n     * @see {@link ObjectLoader#parse}\n     */\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === "string";\n      if (!isRootObject && meta.textures[this.uuid] !== void 0) {\n        return meta.textures[this.uuid];\n      }\n      const output = {\n        metadata: {\n          version: 4.7,\n          type: "Texture",\n          generator: "Texture.toJSON"\n        },\n        uuid: this.uuid,\n        name: this.name,\n        image: this.source.toJSON(meta).uuid,\n        mapping: this.mapping,\n        channel: this.channel,\n        repeat: [this.repeat.x, this.repeat.y],\n        offset: [this.offset.x, this.offset.y],\n        center: [this.center.x, this.center.y],\n        rotation: this.rotation,\n        wrap: [this.wrapS, this.wrapT],\n        format: this.format,\n        internalFormat: this.internalFormat,\n        type: this.type,\n        colorSpace: this.colorSpace,\n        minFilter: this.minFilter,\n        magFilter: this.magFilter,\n        anisotropy: this.anisotropy,\n        flipY: this.flipY,\n        generateMipmaps: this.generateMipmaps,\n        premultiplyAlpha: this.premultiplyAlpha,\n        unpackAlignment: this.unpackAlignment\n      };\n      if (Object.keys(this.userData).length > 0) output.userData = this.userData;\n      if (!isRootObject) {\n        meta.textures[this.uuid] = output;\n      }\n      return output;\n    }\n    /**\n     * Frees the GPU-related resources allocated by this instance. Call this\n     * method whenever this instance is no longer used in your app.\n     *\n     * @fires Texture#dispose\n     */\n    dispose() {\n      this.dispatchEvent({ type: "dispose" });\n    }\n    /**\n     * Transforms the given uv vector with the textures uv transformation matrix.\n     *\n     * @param {Vector2} uv - The uv vector.\n     * @return {Vector2} The transformed uv vector.\n     */\n    transformUv(uv) {\n      if (this.mapping !== UVMapping) return uv;\n      uv.applyMatrix3(this.matrix);\n      if (uv.x < 0 || uv.x > 1) {\n        switch (this.wrapS) {\n          case RepeatWrapping:\n            uv.x = uv.x - Math.floor(uv.x);\n            break;\n          case ClampToEdgeWrapping:\n            uv.x = uv.x < 0 ? 0 : 1;\n            break;\n          case MirroredRepeatWrapping:\n            if (Math.abs(Math.floor(uv.x) % 2) === 1) {\n              uv.x = Math.ceil(uv.x) - uv.x;\n            } else {\n              uv.x = uv.x - Math.floor(uv.x);\n            }\n            break;\n        }\n      }\n      if (uv.y < 0 || uv.y > 1) {\n        switch (this.wrapT) {\n          case RepeatWrapping:\n            uv.y = uv.y - Math.floor(uv.y);\n            break;\n          case ClampToEdgeWrapping:\n            uv.y = uv.y < 0 ? 0 : 1;\n            break;\n          case MirroredRepeatWrapping:\n            if (Math.abs(Math.floor(uv.y) % 2) === 1) {\n              uv.y = Math.ceil(uv.y) - uv.y;\n            } else {\n              uv.y = uv.y - Math.floor(uv.y);\n            }\n            break;\n        }\n      }\n      if (this.flipY) {\n        uv.y = 1 - uv.y;\n      }\n      return uv;\n    }\n    /**\n     * Setting this property to `true` indicates the engine the texture\n     * must be updated in the next render. This triggers a texture upload\n     * to the GPU and ensures correct texture parameter configuration.\n     *\n     * @type {boolean}\n     * @default false\n     * @param {boolean} value\n     */\n    set needsUpdate(value) {\n      if (value === true) {\n        this.version++;\n        this.source.needsUpdate = true;\n      }\n    }\n    /**\n     * Setting this property to `true` indicates the engine the PMREM\n     * must be regenerated.\n     *\n     * @type {boolean}\n     * @default false\n     * @param {boolean} value\n     */\n    set needsPMREMUpdate(value) {\n      if (value === true) {\n        this.pmremVersion++;\n      }\n    }\n  }\n  Texture.DEFAULT_IMAGE = null;\n  Texture.DEFAULT_MAPPING = UVMapping;\n  Texture.DEFAULT_ANISOTROPY = 1;\n  class Vector4 {\n    /**\n     * Constructs a new 4D vector.\n     *\n     * @param {number} [x=0] - The x value of this vector.\n     * @param {number} [y=0] - The y value of this vector.\n     * @param {number} [z=0] - The z value of this vector.\n     * @param {number} [w=1] - The w value of this vector.\n     */\n    constructor(x2 = 0, y = 0, z = 0, w = 1) {\n      Vector4.prototype.isVector4 = true;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n      this.w = w;\n    }\n    /**\n     * Alias for {@link Vector4#z}.\n     *\n     * @type {number}\n     */\n    get width() {\n      return this.z;\n    }\n    set width(value) {\n      this.z = value;\n    }\n    /**\n     * Alias for {@link Vector4#w}.\n     *\n     * @type {number}\n     */\n    get height() {\n      return this.w;\n    }\n    set height(value) {\n      this.w = value;\n    }\n    /**\n     * Sets the vector components.\n     *\n     * @param {number} x - The value of the x component.\n     * @param {number} y - The value of the y component.\n     * @param {number} z - The value of the z component.\n     * @param {number} w - The value of the w component.\n     * @return {Vector4} A reference to this vector.\n     */\n    set(x2, y, z, w) {\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n      this.w = w;\n      return this;\n    }\n    /**\n     * Sets the vector components to the same value.\n     *\n     * @param {number} scalar - The value to set for all vector components.\n     * @return {Vector4} A reference to this vector.\n     */\n    setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      this.z = scalar;\n      this.w = scalar;\n      return this;\n    }\n    /**\n     * Sets the vector\'s x component to the given value\n     *\n     * @param {number} x - The value to set.\n     * @return {Vector4} A reference to this vector.\n     */\n    setX(x2) {\n      this.x = x2;\n      return this;\n    }\n    /**\n     * Sets the vector\'s y component to the given value\n     *\n     * @param {number} y - The value to set.\n     * @return {Vector4} A reference to this vector.\n     */\n    setY(y) {\n      this.y = y;\n      return this;\n    }\n    /**\n     * Sets the vector\'s z component to the given value\n     *\n     * @param {number} z - The value to set.\n     * @return {Vector4} A reference to this vector.\n     */\n    setZ(z) {\n      this.z = z;\n      return this;\n    }\n    /**\n     * Sets the vector\'s w component to the given value\n     *\n     * @param {number} w - The value to set.\n     * @return {Vector4} A reference to this vector.\n     */\n    setW(w) {\n      this.w = w;\n      return this;\n    }\n    /**\n     * Allows to set a vector component with an index.\n     *\n     * @param {number} index - The component index. `0` equals to x, `1` equals to y,\n     * `2` equals to z, `3` equals to w.\n     * @param {number} value - The value to set.\n     * @return {Vector4} A reference to this vector.\n     */\n    setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n        case 1:\n          this.y = value;\n          break;\n        case 2:\n          this.z = value;\n          break;\n        case 3:\n          this.w = value;\n          break;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n      return this;\n    }\n    /**\n     * Returns the value of the vector component which matches the given index.\n     *\n     * @param {number} index - The component index. `0` equals to x, `1` equals to y,\n     * `2` equals to z, `3` equals to w.\n     * @return {number} A vector component value.\n     */\n    getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n        case 1:\n          return this.y;\n        case 2:\n          return this.z;\n        case 3:\n          return this.w;\n        default:\n          throw new Error("index is out of range: " + index);\n      }\n    }\n    /**\n     * Returns a new vector with copied values from this instance.\n     *\n     * @return {Vector4} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor(this.x, this.y, this.z, this.w);\n    }\n    /**\n     * Copies the values of the given vector to this instance.\n     *\n     * @param {Vector3|Vector4} v - The vector to copy.\n     * @return {Vector4} A reference to this vector.\n     */\n    copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      this.z = v.z;\n      this.w = v.w !== void 0 ? v.w : 1;\n      return this;\n    }\n    /**\n     * Adds the given vector to this instance.\n     *\n     * @param {Vector4} v - The vector to add.\n     * @return {Vector4} A reference to this vector.\n     */\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      this.z += v.z;\n      this.w += v.w;\n      return this;\n    }\n    /**\n     * Adds the given scalar value to all components of this instance.\n     *\n     * @param {number} s - The scalar to add.\n     * @return {Vector4} A reference to this vector.\n     */\n    addScalar(s) {\n      this.x += s;\n      this.y += s;\n      this.z += s;\n      this.w += s;\n      return this;\n    }\n    /**\n     * Adds the given vectors and stores the result in this instance.\n     *\n     * @param {Vector4} a - The first vector.\n     * @param {Vector4} b - The second vector.\n     * @return {Vector4} A reference to this vector.\n     */\n    addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      this.z = a.z + b.z;\n      this.w = a.w + b.w;\n      return this;\n    }\n    /**\n     * Adds the given vector scaled by the given factor to this instance.\n     *\n     * @param {Vector4} v - The vector.\n     * @param {number} s - The factor that scales `v`.\n     * @return {Vector4} A reference to this vector.\n     */\n    addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      this.z += v.z * s;\n      this.w += v.w * s;\n      return this;\n    }\n    /**\n     * Subtracts the given vector from this instance.\n     *\n     * @param {Vector4} v - The vector to subtract.\n     * @return {Vector4} A reference to this vector.\n     */\n    sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      this.z -= v.z;\n      this.w -= v.w;\n      return this;\n    }\n    /**\n     * Subtracts the given scalar value from all components of this instance.\n     *\n     * @param {number} s - The scalar to subtract.\n     * @return {Vector4} A reference to this vector.\n     */\n    subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      this.z -= s;\n      this.w -= s;\n      return this;\n    }\n    /**\n     * Subtracts the given vectors and stores the result in this instance.\n     *\n     * @param {Vector4} a - The first vector.\n     * @param {Vector4} b - The second vector.\n     * @return {Vector4} A reference to this vector.\n     */\n    subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      this.z = a.z - b.z;\n      this.w = a.w - b.w;\n      return this;\n    }\n    /**\n     * Multiplies the given vector with this instance.\n     *\n     * @param {Vector4} v - The vector to multiply.\n     * @return {Vector4} A reference to this vector.\n     */\n    multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      this.z *= v.z;\n      this.w *= v.w;\n      return this;\n    }\n    /**\n     * Multiplies the given scalar value with all components of this instance.\n     *\n     * @param {number} scalar - The scalar to multiply.\n     * @return {Vector4} A reference to this vector.\n     */\n    multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      this.z *= scalar;\n      this.w *= scalar;\n      return this;\n    }\n    /**\n     * Multiplies this vector with the given 4x4 matrix.\n     *\n     * @param {Matrix4} m - The 4x4 matrix.\n     * @return {Vector4} A reference to this vector.\n     */\n    applyMatrix4(m) {\n      const x2 = this.x, y = this.y, z = this.z, w = this.w;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[4] * y + e[8] * z + e[12] * w;\n      this.y = e[1] * x2 + e[5] * y + e[9] * z + e[13] * w;\n      this.z = e[2] * x2 + e[6] * y + e[10] * z + e[14] * w;\n      this.w = e[3] * x2 + e[7] * y + e[11] * z + e[15] * w;\n      return this;\n    }\n    /**\n     * Divides this instance by the given vector.\n     *\n     * @param {Vector4} v - The vector to divide.\n     * @return {Vector4} A reference to this vector.\n     */\n    divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      this.z /= v.z;\n      this.w /= v.w;\n      return this;\n    }\n    /**\n     * Divides this vector by the given scalar.\n     *\n     * @param {number} scalar - The scalar to divide.\n     * @return {Vector4} A reference to this vector.\n     */\n    divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n    /**\n     * Sets the x, y and z components of this\n     * vector to the quaternion\'s axis and w to the angle.\n     *\n     * @param {Quaternion} q - The Quaternion to set.\n     * @return {Vector4} A reference to this vector.\n     */\n    setAxisAngleFromQuaternion(q) {\n      this.w = 2 * Math.acos(q.w);\n      const s = Math.sqrt(1 - q.w * q.w);\n      if (s < 1e-4) {\n        this.x = 1;\n        this.y = 0;\n        this.z = 0;\n      } else {\n        this.x = q.x / s;\n        this.y = q.y / s;\n        this.z = q.z / s;\n      }\n      return this;\n    }\n    /**\n     * Sets the x, y and z components of this\n     * vector to the axis of rotation and w to the angle.\n     *\n     * @param {Matrix4} m - A 4x4 matrix of which the upper left 3x3 matrix is a pure rotation matrix.\n     * @return {Vector4} A reference to this vector.\n     */\n    setAxisAngleFromRotationMatrix(m) {\n      let angle, x2, y, z;\n      const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];\n      if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\n        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {\n          this.set(1, 0, 0, 0);\n          return this;\n        }\n        angle = Math.PI;\n        const xx = (m11 + 1) / 2;\n        const yy = (m22 + 1) / 2;\n        const zz = (m33 + 1) / 2;\n        const xy = (m12 + m21) / 4;\n        const xz = (m13 + m31) / 4;\n        const yz = (m23 + m32) / 4;\n        if (xx > yy && xx > zz) {\n          if (xx < epsilon) {\n            x2 = 0;\n            y = 0.707106781;\n            z = 0.707106781;\n          } else {\n            x2 = Math.sqrt(xx);\n            y = xy / x2;\n            z = xz / x2;\n          }\n        } else if (yy > zz) {\n          if (yy < epsilon) {\n            x2 = 0.707106781;\n            y = 0;\n            z = 0.707106781;\n          } else {\n            y = Math.sqrt(yy);\n            x2 = xy / y;\n            z = yz / y;\n          }\n        } else {\n          if (zz < epsilon) {\n            x2 = 0.707106781;\n            y = 0.707106781;\n            z = 0;\n          } else {\n            z = Math.sqrt(zz);\n            x2 = xz / z;\n            y = yz / z;\n          }\n        }\n        this.set(x2, y, z, angle);\n        return this;\n      }\n      let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));\n      if (Math.abs(s) < 1e-3) s = 1;\n      this.x = (m32 - m23) / s;\n      this.y = (m13 - m31) / s;\n      this.z = (m21 - m12) / s;\n      this.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n      return this;\n    }\n    /**\n     * Sets the vector components to the position elements of the\n     * given transformation matrix.\n     *\n     * @param {Matrix4} m - The 4x4 matrix.\n     * @return {Vector4} A reference to this vector.\n     */\n    setFromMatrixPosition(m) {\n      const e = m.elements;\n      this.x = e[12];\n      this.y = e[13];\n      this.z = e[14];\n      this.w = e[15];\n      return this;\n    }\n    /**\n     * If this vector\'s x, y, z or w value is greater than the given vector\'s x, y, z or w\n     * value, replace that value with the corresponding min value.\n     *\n     * @param {Vector4} v - The vector.\n     * @return {Vector4} A reference to this vector.\n     */\n    min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      this.z = Math.min(this.z, v.z);\n      this.w = Math.min(this.w, v.w);\n      return this;\n    }\n    /**\n     * If this vector\'s x, y, z or w value is less than the given vector\'s x, y, z or w\n     * value, replace that value with the corresponding max value.\n     *\n     * @param {Vector4} v - The vector.\n     * @return {Vector4} A reference to this vector.\n     */\n    max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      this.z = Math.max(this.z, v.z);\n      this.w = Math.max(this.w, v.w);\n      return this;\n    }\n    /**\n     * If this vector\'s x, y, z or w value is greater than the max vector\'s x, y, z or w\n     * value, it is replaced by the corresponding value.\n     * If this vector\'s x, y, z or w value is less than the min vector\'s x, y, z or w value,\n     * it is replaced by the corresponding value.\n     *\n     * @param {Vector4} min - The minimum x, y and z values.\n     * @param {Vector4} max - The maximum x, y and z values in the desired range.\n     * @return {Vector4} A reference to this vector.\n     */\n    clamp(min, max2) {\n      this.x = clamp(this.x, min.x, max2.x);\n      this.y = clamp(this.y, min.y, max2.y);\n      this.z = clamp(this.z, min.z, max2.z);\n      this.w = clamp(this.w, min.w, max2.w);\n      return this;\n    }\n    /**\n     * If this vector\'s x, y, z or w values are greater than the max value, they are\n     * replaced by the max value.\n     * If this vector\'s x, y, z or w values are less than the min value, they are\n     * replaced by the min value.\n     *\n     * @param {number} minVal - The minimum value the components will be clamped to.\n     * @param {number} maxVal - The maximum value the components will be clamped to.\n     * @return {Vector4} A reference to this vector.\n     */\n    clampScalar(minVal, maxVal) {\n      this.x = clamp(this.x, minVal, maxVal);\n      this.y = clamp(this.y, minVal, maxVal);\n      this.z = clamp(this.z, minVal, maxVal);\n      this.w = clamp(this.w, minVal, maxVal);\n      return this;\n    }\n    /**\n     * If this vector\'s length is greater than the max value, it is replaced by\n     * the max value.\n     * If this vector\'s length is less than the min value, it is replaced by the\n     * min value.\n     *\n     * @param {number} min - The minimum value the vector length will be clamped to.\n     * @param {number} max - The maximum value the vector length will be clamped to.\n     * @return {Vector4} A reference to this vector.\n     */\n    clampLength(min, max2) {\n      const length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));\n    }\n    /**\n     * The components of this vector are rounded down to the nearest integer value.\n     *\n     * @return {Vector4} A reference to this vector.\n     */\n    floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      this.z = Math.floor(this.z);\n      this.w = Math.floor(this.w);\n      return this;\n    }\n    /**\n     * The components of this vector are rounded up to the nearest integer value.\n     *\n     * @return {Vector4} A reference to this vector.\n     */\n    ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      this.z = Math.ceil(this.z);\n      this.w = Math.ceil(this.w);\n      return this;\n    }\n    /**\n     * The components of this vector are rounded to the nearest integer value\n     *\n     * @return {Vector4} A reference to this vector.\n     */\n    round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      this.z = Math.round(this.z);\n      this.w = Math.round(this.w);\n      return this;\n    }\n    /**\n     * The components of this vector are rounded towards zero (up if negative,\n     * down if positive) to an integer value.\n     *\n     * @return {Vector4} A reference to this vector.\n     */\n    roundToZero() {\n      this.x = Math.trunc(this.x);\n      this.y = Math.trunc(this.y);\n      this.z = Math.trunc(this.z);\n      this.w = Math.trunc(this.w);\n      return this;\n    }\n    /**\n     * Inverts this vector - i.e. sets x = -x, y = -y, z = -z, w = -w.\n     *\n     * @return {Vector4} A reference to this vector.\n     */\n    negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      this.z = -this.z;\n      this.w = -this.w;\n      return this;\n    }\n    /**\n     * Calculates the dot product of the given vector with this instance.\n     *\n     * @param {Vector4} v - The vector to compute the dot product with.\n     * @return {number} The result of the dot product.\n     */\n    dot(v) {\n      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n    }\n    /**\n     * Computes the square of the Euclidean length (straight-line length) from\n     * (0, 0, 0, 0) to (x, y, z, w). If you are comparing the lengths of vectors, you should\n     * compare the length squared instead as it is slightly more efficient to calculate.\n     *\n     * @return {number} The square length of this vector.\n     */\n    lengthSq() {\n      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n    }\n    /**\n     * Computes the  Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w).\n     *\n     * @return {number} The length of this vector.\n     */\n    length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n    }\n    /**\n     * Computes the Manhattan length of this vector.\n     *\n     * @return {number} The length of this vector.\n     */\n    manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n    }\n    /**\n     * Converts this vector to a unit vector - that is, sets it equal to a vector\n     * with the same direction as this one, but with a vector length of `1`.\n     *\n     * @return {Vector4} A reference to this vector.\n     */\n    normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n    /**\n     * Sets this vector to a vector with the same direction as this one, but\n     * with the specified length.\n     *\n     * @param {number} length - The new length of this vector.\n     * @return {Vector4} A reference to this vector.\n     */\n    setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n    /**\n     * Linearly interpolates between the given vector and this instance, where\n     * alpha is the percent distance along the line - alpha = 0 will be this\n     * vector, and alpha = 1 will be the given one.\n     *\n     * @param {Vector4} v - The vector to interpolate towards.\n     * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.\n     * @return {Vector4} A reference to this vector.\n     */\n    lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      this.z += (v.z - this.z) * alpha;\n      this.w += (v.w - this.w) * alpha;\n      return this;\n    }\n    /**\n     * Linearly interpolates between the given vectors, where alpha is the percent\n     * distance along the line - alpha = 0 will be first vector, and alpha = 1 will\n     * be the second one. The result is stored in this instance.\n     *\n     * @param {Vector4} v1 - The first vector.\n     * @param {Vector4} v2 - The second vector.\n     * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.\n     * @return {Vector4} A reference to this vector.\n     */\n    lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      this.z = v1.z + (v2.z - v1.z) * alpha;\n      this.w = v1.w + (v2.w - v1.w) * alpha;\n      return this;\n    }\n    /**\n     * Returns `true` if this vector is equal with the given one.\n     *\n     * @param {Vector4} v - The vector to test for equality.\n     * @return {boolean} Whether this vector is equal with the given one.\n     */\n    equals(v) {\n      return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n    }\n    /**\n     * Sets this vector\'s x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`,\n     * z value to be `array[ offset + 2 ]`, w value to be `array[ offset + 3 ]`.\n     *\n     * @param {Array<number>} array - An array holding the vector component values.\n     * @param {number} [offset=0] - The offset into the array.\n     * @return {Vector4} A reference to this vector.\n     */\n    fromArray(array, offset = 0) {\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      this.z = array[offset + 2];\n      this.w = array[offset + 3];\n      return this;\n    }\n    /**\n     * Writes the components of this vector to the given array. If no array is provided,\n     * the method returns a new instance.\n     *\n     * @param {Array<number>} [array=[]] - The target array holding the vector components.\n     * @param {number} [offset=0] - Index of the first element in the array.\n     * @return {Array<number>} The vector components.\n     */\n    toArray(array = [], offset = 0) {\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      array[offset + 2] = this.z;\n      array[offset + 3] = this.w;\n      return array;\n    }\n    /**\n     * Sets the components of this vector from the given buffer attribute.\n     *\n     * @param {BufferAttribute} attribute - The buffer attribute holding vector data.\n     * @param {number} index - The index into the attribute.\n     * @return {Vector4} A reference to this vector.\n     */\n    fromBufferAttribute(attribute, index) {\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      this.z = attribute.getZ(index);\n      this.w = attribute.getW(index);\n      return this;\n    }\n    /**\n     * Sets each component of this vector to a pseudo-random value between `0` and\n     * `1`, excluding `1`.\n     *\n     * @return {Vector4} A reference to this vector.\n     */\n    random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      this.z = Math.random();\n      this.w = Math.random();\n      return this;\n    }\n    *[Symbol.iterator]() {\n      yield this.x;\n      yield this.y;\n      yield this.z;\n      yield this.w;\n    }\n  }\n  class RenderTarget extends EventDispatcher {\n    /**\n     * Render target options.\n     *\n     * @typedef {Object} RenderTarget~Options\n     * @property {boolean} [generateMipmaps=false] - Whether to generate mipmaps or not.\n     * @property {number} [magFilter=LinearFilter] - The mag filter.\n     * @property {number} [minFilter=LinearFilter] - The min filter.\n     * @property {number} [format=RGBAFormat] - The texture format.\n     * @property {number} [type=UnsignedByteType] - The texture type.\n     * @property {?string} [internalFormat=null] - The texture\'s internal format.\n     * @property {number} [wrapS=ClampToEdgeWrapping] - The texture\'s uv wrapping mode.\n     * @property {number} [wrapT=ClampToEdgeWrapping] - The texture\'s uv wrapping mode.\n     * @property {number} [anisotropy=1] - The texture\'s anisotropy value.\n     * @property {string} [colorSpace=NoColorSpace] - The texture\'s color space.\n     * @property {boolean} [depthBuffer=true] - Whether to allocate a depth buffer or not.\n     * @property {boolean} [stencilBuffer=false] - Whether to allocate a stencil buffer or not.\n     * @property {boolean} [resolveDepthBuffer=true] - Whether to resolve the depth buffer or not.\n     * @property {boolean} [resolveStencilBuffer=true] - Whether  to resolve the stencil buffer or not.\n     * @property {?Texture} [depthTexture=null] - Reference to a depth texture.\n     * @property {number} [samples=0] - The MSAA samples count.\n     * @property {number} [count=1] - Defines the number of color attachments . Must be at least `1`.\n     * @property {number} [depth=1] - The texture depth.\n     * @property {boolean} [multiview=false] - Whether this target is used for multiview rendering.\n     */\n    /**\n     * Constructs a new render target.\n     *\n     * @param {number} [width=1] - The width of the render target.\n     * @param {number} [height=1] - The height of the render target.\n     * @param {RenderTarget~Options} [options] - The configuration object.\n     */\n    constructor(width = 1, height = 1, options = {}) {\n      super();\n      options = Object.assign({\n        generateMipmaps: false,\n        internalFormat: null,\n        minFilter: LinearFilter,\n        depthBuffer: true,\n        stencilBuffer: false,\n        resolveDepthBuffer: true,\n        resolveStencilBuffer: true,\n        depthTexture: null,\n        samples: 0,\n        count: 1,\n        depth: 1,\n        multiview: false\n      }, options);\n      this.isRenderTarget = true;\n      this.width = width;\n      this.height = height;\n      this.depth = options.depth;\n      this.scissor = new Vector4(0, 0, width, height);\n      this.scissorTest = false;\n      this.viewport = new Vector4(0, 0, width, height);\n      const image = { width, height, depth: options.depth };\n      const texture = new Texture(image);\n      this.textures = [];\n      const count = options.count;\n      for (let i2 = 0; i2 < count; i2++) {\n        this.textures[i2] = texture.clone();\n        this.textures[i2].isRenderTargetTexture = true;\n        this.textures[i2].renderTarget = this;\n      }\n      this._setTextureOptions(options);\n      this.depthBuffer = options.depthBuffer;\n      this.stencilBuffer = options.stencilBuffer;\n      this.resolveDepthBuffer = options.resolveDepthBuffer;\n      this.resolveStencilBuffer = options.resolveStencilBuffer;\n      this._depthTexture = null;\n      this.depthTexture = options.depthTexture;\n      this.samples = options.samples;\n      this.multiview = options.multiview;\n    }\n    _setTextureOptions(options = {}) {\n      const values = {\n        minFilter: LinearFilter,\n        generateMipmaps: false,\n        flipY: false,\n        internalFormat: null\n      };\n      if (options.mapping !== void 0) values.mapping = options.mapping;\n      if (options.wrapS !== void 0) values.wrapS = options.wrapS;\n      if (options.wrapT !== void 0) values.wrapT = options.wrapT;\n      if (options.wrapR !== void 0) values.wrapR = options.wrapR;\n      if (options.magFilter !== void 0) values.magFilter = options.magFilter;\n      if (options.minFilter !== void 0) values.minFilter = options.minFilter;\n      if (options.format !== void 0) values.format = options.format;\n      if (options.type !== void 0) values.type = options.type;\n      if (options.anisotropy !== void 0) values.anisotropy = options.anisotropy;\n      if (options.colorSpace !== void 0) values.colorSpace = options.colorSpace;\n      if (options.flipY !== void 0) values.flipY = options.flipY;\n      if (options.generateMipmaps !== void 0) values.generateMipmaps = options.generateMipmaps;\n      if (options.internalFormat !== void 0) values.internalFormat = options.internalFormat;\n      for (let i2 = 0; i2 < this.textures.length; i2++) {\n        const texture = this.textures[i2];\n        texture.setValues(values);\n      }\n    }\n    /**\n     * The texture representing the default color attachment.\n     *\n     * @type {Texture}\n     */\n    get texture() {\n      return this.textures[0];\n    }\n    set texture(value) {\n      this.textures[0] = value;\n    }\n    set depthTexture(current) {\n      if (this._depthTexture !== null) this._depthTexture.renderTarget = null;\n      if (current !== null) current.renderTarget = this;\n      this._depthTexture = current;\n    }\n    /**\n     * Instead of saving the depth in a renderbuffer, a texture\n     * can be used instead which is useful for further processing\n     * e.g. in context of post-processing.\n     *\n     * @type {?DepthTexture}\n     * @default null\n     */\n    get depthTexture() {\n      return this._depthTexture;\n    }\n    /**\n     * Sets the size of this render target.\n     *\n     * @param {number} width - The width.\n     * @param {number} height - The height.\n     * @param {number} [depth=1] - The depth.\n     */\n    setSize(width, height, depth = 1) {\n      if (this.width !== width || this.height !== height || this.depth !== depth) {\n        this.width = width;\n        this.height = height;\n        this.depth = depth;\n        for (let i2 = 0, il = this.textures.length; i2 < il; i2++) {\n          this.textures[i2].image.width = width;\n          this.textures[i2].image.height = height;\n          this.textures[i2].image.depth = depth;\n          this.textures[i2].isArrayTexture = this.textures[i2].image.depth > 1;\n        }\n        this.dispose();\n      }\n      this.viewport.set(0, 0, width, height);\n      this.scissor.set(0, 0, width, height);\n    }\n    /**\n     * Returns a new render target with copied values from this instance.\n     *\n     * @return {RenderTarget} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    /**\n     * Copies the settings of the given render target. This is a structural copy so\n     * no resources are shared between render targets after the copy. That includes\n     * all MRT textures and the depth texture.\n     *\n     * @param {RenderTarget} source - The render target to copy.\n     * @return {RenderTarget} A reference to this instance.\n     */\n    copy(source) {\n      this.width = source.width;\n      this.height = source.height;\n      this.depth = source.depth;\n      this.scissor.copy(source.scissor);\n      this.scissorTest = source.scissorTest;\n      this.viewport.copy(source.viewport);\n      this.textures.length = 0;\n      for (let i2 = 0, il = source.textures.length; i2 < il; i2++) {\n        this.textures[i2] = source.textures[i2].clone();\n        this.textures[i2].isRenderTargetTexture = true;\n        this.textures[i2].renderTarget = this;\n        const image = Object.assign({}, source.textures[i2].image);\n        this.textures[i2].source = new Source(image);\n      }\n      this.depthBuffer = source.depthBuffer;\n      this.stencilBuffer = source.stencilBuffer;\n      this.resolveDepthBuffer = source.resolveDepthBuffer;\n      this.resolveStencilBuffer = source.resolveStencilBuffer;\n      if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();\n      this.samples = source.samples;\n      return this;\n    }\n    /**\n     * Frees the GPU-related resources allocated by this instance. Call this\n     * method whenever this instance is no longer used in your app.\n     *\n     * @fires RenderTarget#dispose\n     */\n    dispose() {\n      this.dispatchEvent({ type: "dispose" });\n    }\n  }\n  class WebGLRenderTarget extends RenderTarget {\n    /**\n     * Constructs a new 3D render target.\n     *\n     * @param {number} [width=1] - The width of the render target.\n     * @param {number} [height=1] - The height of the render target.\n     * @param {RenderTarget~Options} [options] - The configuration object.\n     */\n    constructor(width = 1, height = 1, options = {}) {\n      super(width, height, options);\n      this.isWebGLRenderTarget = true;\n    }\n  }\n  class DataArrayTexture extends Texture {\n    /**\n     * Constructs a new data array texture.\n     *\n     * @param {?TypedArray} [data=null] - The buffer data.\n     * @param {number} [width=1] - The width of the texture.\n     * @param {number} [height=1] - The height of the texture.\n     * @param {number} [depth=1] - The depth of the texture.\n     */\n    constructor(data = null, width = 1, height = 1, depth = 1) {\n      super(null);\n      this.isDataArrayTexture = true;\n      this.image = { data, width, height, depth };\n      this.magFilter = NearestFilter;\n      this.minFilter = NearestFilter;\n      this.wrapR = ClampToEdgeWrapping;\n      this.generateMipmaps = false;\n      this.flipY = false;\n      this.unpackAlignment = 1;\n      this.layerUpdates = /* @__PURE__ */ new Set();\n    }\n    /**\n     * Describes that a specific layer of the texture needs to be updated.\n     * Normally when {@link Texture#needsUpdate} is set to `true`, the\n     * entire data texture array is sent to the GPU. Marking specific\n     * layers will only transmit subsets of all mipmaps associated with a\n     * specific depth in the array which is often much more performant.\n     *\n     * @param {number} layerIndex - The layer index that should be updated.\n     */\n    addLayerUpdate(layerIndex) {\n      this.layerUpdates.add(layerIndex);\n    }\n    /**\n     * Resets the layer updates registry.\n     */\n    clearLayerUpdates() {\n      this.layerUpdates.clear();\n    }\n  }\n  class WebGLArrayRenderTarget extends WebGLRenderTarget {\n    /**\n     * Constructs a new array render target.\n     *\n     * @param {number} [width=1] - The width of the render target.\n     * @param {number} [height=1] - The height of the render target.\n     * @param {number} [depth=1] - The height of the render target.\n     * @param {RenderTarget~Options} [options] - The configuration object.\n     */\n    constructor(width = 1, height = 1, depth = 1, options = {}) {\n      super(width, height, options);\n      this.isWebGLArrayRenderTarget = true;\n      this.depth = depth;\n      this.texture = new DataArrayTexture(null, width, height, depth);\n      this._setTextureOptions(options);\n      this.texture.isRenderTargetTexture = true;\n    }\n  }\n  class Box3 {\n    /**\n     * Constructs a new bounding box.\n     *\n     * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.\n     * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.\n     */\n    constructor(min = new Vector3(Infinity, Infinity, Infinity), max2 = new Vector3(-Infinity, -Infinity, -Infinity)) {\n      this.isBox3 = true;\n      this.min = min;\n      this.max = max2;\n    }\n    /**\n     * Sets the lower and upper boundaries of this box.\n     * Please note that this method only copies the values from the given objects.\n     *\n     * @param {Vector3} min - The lower boundary of the box.\n     * @param {Vector3} max - The upper boundary of the box.\n     * @return {Box3} A reference to this bounding box.\n     */\n    set(min, max2) {\n      this.min.copy(min);\n      this.max.copy(max2);\n      return this;\n    }\n    /**\n     * Sets the upper and lower bounds of this box so it encloses the position data\n     * in the given array.\n     *\n     * @param {Array<number>} array - An array holding 3D position data.\n     * @return {Box3} A reference to this bounding box.\n     */\n    setFromArray(array) {\n      this.makeEmpty();\n      for (let i2 = 0, il = array.length; i2 < il; i2 += 3) {\n        this.expandByPoint(_vector$b.fromArray(array, i2));\n      }\n      return this;\n    }\n    /**\n     * Sets the upper and lower bounds of this box so it encloses the position data\n     * in the given buffer attribute.\n     *\n     * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.\n     * @return {Box3} A reference to this bounding box.\n     */\n    setFromBufferAttribute(attribute) {\n      this.makeEmpty();\n      for (let i2 = 0, il = attribute.count; i2 < il; i2++) {\n        this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i2));\n      }\n      return this;\n    }\n    /**\n     * Sets the upper and lower bounds of this box so it encloses the position data\n     * in the given array.\n     *\n     * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.\n     * @return {Box3} A reference to this bounding box.\n     */\n    setFromPoints(points) {\n      this.makeEmpty();\n      for (let i2 = 0, il = points.length; i2 < il; i2++) {\n        this.expandByPoint(points[i2]);\n      }\n      return this;\n    }\n    /**\n     * Centers this box on the given center vector and sets this box\'s width, height and\n     * depth to the given size values.\n     *\n     * @param {Vector3} center - The center of the box.\n     * @param {Vector3} size - The x, y and z dimensions of the box.\n     * @return {Box3} A reference to this bounding box.\n     */\n    setFromCenterAndSize(center, size) {\n      const halfSize = _vector$b.copy(size).multiplyScalar(0.5);\n      this.min.copy(center).sub(halfSize);\n      this.max.copy(center).add(halfSize);\n      return this;\n    }\n    /**\n     * Computes the world-axis-aligned bounding box for the given 3D object\n     * (including its children), accounting for the object\'s, and children\'s,\n     * world transforms. The function may result in a larger box than strictly necessary.\n     *\n     * @param {Object3D} object - The 3D object to compute the bounding box for.\n     * @param {boolean} [precise=false] - If set to `true`, the method computes the smallest\n     * world-axis-aligned bounding box at the expense of more computation.\n     * @return {Box3} A reference to this bounding box.\n     */\n    setFromObject(object, precise = false) {\n      this.makeEmpty();\n      return this.expandByObject(object, precise);\n    }\n    /**\n     * Returns a new box with copied values from this instance.\n     *\n     * @return {Box3} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    /**\n     * Copies the values of the given box to this instance.\n     *\n     * @param {Box3} box - The box to copy.\n     * @return {Box3} A reference to this bounding box.\n     */\n    copy(box) {\n      this.min.copy(box.min);\n      this.max.copy(box.max);\n      return this;\n    }\n    /**\n     * Makes this box empty which means in encloses a zero space in 3D.\n     *\n     * @return {Box3} A reference to this bounding box.\n     */\n    makeEmpty() {\n      this.min.x = this.min.y = this.min.z = Infinity;\n      this.max.x = this.max.y = this.max.z = -Infinity;\n      return this;\n    }\n    /**\n     * Returns true if this box includes zero points within its bounds.\n     * Note that a box with equal lower and upper bounds still includes one\n     * point, the one both bounds share.\n     *\n     * @return {boolean} Whether this box is empty or not.\n     */\n    isEmpty() {\n      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n    }\n    /**\n     * Returns the center point of this box.\n     *\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {Vector3} The center point.\n     */\n    getCenter(target) {\n      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n    }\n    /**\n     * Returns the dimensions of this box.\n     *\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {Vector3} The size.\n     */\n    getSize(target) {\n      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\n    }\n    /**\n     * Expands the boundaries of this box to include the given point.\n     *\n     * @param {Vector3} point - The point that should be included by the bounding box.\n     * @return {Box3} A reference to this bounding box.\n     */\n    expandByPoint(point) {\n      this.min.min(point);\n      this.max.max(point);\n      return this;\n    }\n    /**\n     * Expands this box equilaterally by the given vector. The width of this\n     * box will be expanded by the x component of the vector in both\n     * directions. The height of this box will be expanded by the y component of\n     * the vector in both directions. The depth of this box will be\n     * expanded by the z component of the vector in both directions.\n     *\n     * @param {Vector3} vector - The vector that should expand the bounding box.\n     * @return {Box3} A reference to this bounding box.\n     */\n    expandByVector(vector) {\n      this.min.sub(vector);\n      this.max.add(vector);\n      return this;\n    }\n    /**\n     * Expands each dimension of the box by the given scalar. If negative, the\n     * dimensions of the box will be contracted.\n     *\n     * @param {number} scalar - The scalar value that should expand the bounding box.\n     * @return {Box3} A reference to this bounding box.\n     */\n    expandByScalar(scalar) {\n      this.min.addScalar(-scalar);\n      this.max.addScalar(scalar);\n      return this;\n    }\n    /**\n     * Expands the boundaries of this box to include the given 3D object and\n     * its children, accounting for the object\'s, and children\'s, world\n     * transforms. The function may result in a larger box than strictly\n     * necessary (unless the precise parameter is set to true).\n     *\n     * @param {Object3D} object - The 3D object that should expand the bounding box.\n     * @param {boolean} precise - If set to `true`, the method expands the bounding box\n     * as little as necessary at the expense of more computation.\n     * @return {Box3} A reference to this bounding box.\n     */\n    expandByObject(object, precise = false) {\n      object.updateWorldMatrix(false, false);\n      const geometry = object.geometry;\n      if (geometry !== void 0) {\n        const positionAttribute = geometry.getAttribute("position");\n        if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {\n          for (let i2 = 0, l = positionAttribute.count; i2 < l; i2++) {\n            if (object.isMesh === true) {\n              object.getVertexPosition(i2, _vector$b);\n            } else {\n              _vector$b.fromBufferAttribute(positionAttribute, i2);\n            }\n            _vector$b.applyMatrix4(object.matrixWorld);\n            this.expandByPoint(_vector$b);\n          }\n        } else {\n          if (object.boundingBox !== void 0) {\n            if (object.boundingBox === null) {\n              object.computeBoundingBox();\n            }\n            _box$4.copy(object.boundingBox);\n          } else {\n            if (geometry.boundingBox === null) {\n              geometry.computeBoundingBox();\n            }\n            _box$4.copy(geometry.boundingBox);\n          }\n          _box$4.applyMatrix4(object.matrixWorld);\n          this.union(_box$4);\n        }\n      }\n      const children = object.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        this.expandByObject(children[i2], precise);\n      }\n      return this;\n    }\n    /**\n     * Returns `true` if the given point lies within or on the boundaries of this box.\n     *\n     * @param {Vector3} point - The point to test.\n     * @return {boolean} Whether the bounding box contains the given point or not.\n     */\n    containsPoint(point) {\n      return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;\n    }\n    /**\n     * Returns `true` if this bounding box includes the entirety of the given bounding box.\n     * If this box and the given one are identical, this function also returns `true`.\n     *\n     * @param {Box3} box - The bounding box to test.\n     * @return {boolean} Whether the bounding box contains the given bounding box or not.\n     */\n    containsBox(box) {\n      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;\n    }\n    /**\n     * Returns a point as a proportion of this box\'s width, height and depth.\n     *\n     * @param {Vector3} point - A point in 3D space.\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {Vector3} A point as a proportion of this box\'s width, height and depth.\n     */\n    getParameter(point, target) {\n      return target.set(\n        (point.x - this.min.x) / (this.max.x - this.min.x),\n        (point.y - this.min.y) / (this.max.y - this.min.y),\n        (point.z - this.min.z) / (this.max.z - this.min.z)\n      );\n    }\n    /**\n     * Returns `true` if the given bounding box intersects with this bounding box.\n     *\n     * @param {Box3} box - The bounding box to test.\n     * @return {boolean} Whether the given bounding box intersects with this bounding box.\n     */\n    intersectsBox(box) {\n      return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;\n    }\n    /**\n     * Returns `true` if the given bounding sphere intersects with this bounding box.\n     *\n     * @param {Sphere} sphere - The bounding sphere to test.\n     * @return {boolean} Whether the given bounding sphere intersects with this bounding box.\n     */\n    intersectsSphere(sphere) {\n      this.clampPoint(sphere.center, _vector$b);\n      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n    }\n    /**\n     * Returns `true` if the given plane intersects with this bounding box.\n     *\n     * @param {Plane} plane - The plane to test.\n     * @return {boolean} Whether the given plane intersects with this bounding box.\n     */\n    intersectsPlane(plane) {\n      let min, max2;\n      if (plane.normal.x > 0) {\n        min = plane.normal.x * this.min.x;\n        max2 = plane.normal.x * this.max.x;\n      } else {\n        min = plane.normal.x * this.max.x;\n        max2 = plane.normal.x * this.min.x;\n      }\n      if (plane.normal.y > 0) {\n        min += plane.normal.y * this.min.y;\n        max2 += plane.normal.y * this.max.y;\n      } else {\n        min += plane.normal.y * this.max.y;\n        max2 += plane.normal.y * this.min.y;\n      }\n      if (plane.normal.z > 0) {\n        min += plane.normal.z * this.min.z;\n        max2 += plane.normal.z * this.max.z;\n      } else {\n        min += plane.normal.z * this.max.z;\n        max2 += plane.normal.z * this.min.z;\n      }\n      return min <= -plane.constant && max2 >= -plane.constant;\n    }\n    /**\n     * Returns `true` if the given triangle intersects with this bounding box.\n     *\n     * @param {Triangle} triangle - The triangle to test.\n     * @return {boolean} Whether the given triangle intersects with this bounding box.\n     */\n    intersectsTriangle(triangle) {\n      if (this.isEmpty()) {\n        return false;\n      }\n      this.getCenter(_center);\n      _extents.subVectors(this.max, _center);\n      _v0$2.subVectors(triangle.a, _center);\n      _v1$7.subVectors(triangle.b, _center);\n      _v2$4.subVectors(triangle.c, _center);\n      _f0.subVectors(_v1$7, _v0$2);\n      _f1.subVectors(_v2$4, _v1$7);\n      _f2.subVectors(_v0$2, _v2$4);\n      let axes = [\n        0,\n        -_f0.z,\n        _f0.y,\n        0,\n        -_f1.z,\n        _f1.y,\n        0,\n        -_f2.z,\n        _f2.y,\n        _f0.z,\n        0,\n        -_f0.x,\n        _f1.z,\n        0,\n        -_f1.x,\n        _f2.z,\n        0,\n        -_f2.x,\n        -_f0.y,\n        _f0.x,\n        0,\n        -_f1.y,\n        _f1.x,\n        0,\n        -_f2.y,\n        _f2.x,\n        0\n      ];\n      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {\n        return false;\n      }\n      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {\n        return false;\n      }\n      _triangleNormal.crossVectors(_f0, _f1);\n      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n      return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);\n    }\n    /**\n     * Clamps the given point within the bounds of this box.\n     *\n     * @param {Vector3} point - The point to clamp.\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {Vector3} The clamped point.\n     */\n    clampPoint(point, target) {\n      return target.copy(point).clamp(this.min, this.max);\n    }\n    /**\n     * Returns the euclidean distance from any edge of this box to the specified point. If\n     * the given point lies inside of this box, the distance will be `0`.\n     *\n     * @param {Vector3} point - The point to compute the distance to.\n     * @return {number} The euclidean distance.\n     */\n    distanceToPoint(point) {\n      return this.clampPoint(point, _vector$b).distanceTo(point);\n    }\n    /**\n     * Returns a bounding sphere that encloses this bounding box.\n     *\n     * @param {Sphere} target - The target sphere that is used to store the method\'s result.\n     * @return {Sphere} The bounding sphere that encloses this bounding box.\n     */\n    getBoundingSphere(target) {\n      if (this.isEmpty()) {\n        target.makeEmpty();\n      } else {\n        this.getCenter(target.center);\n        target.radius = this.getSize(_vector$b).length() * 0.5;\n      }\n      return target;\n    }\n    /**\n     * Computes the intersection of this bounding box and the given one, setting the upper\n     * bound of this box to the lesser of the two boxes\' upper bounds and the\n     * lower bound of this box to the greater of the two boxes\' lower bounds. If\n     * there\'s no overlap, makes this box empty.\n     *\n     * @param {Box3} box - The bounding box to intersect with.\n     * @return {Box3} A reference to this bounding box.\n     */\n    intersect(box) {\n      this.min.max(box.min);\n      this.max.min(box.max);\n      if (this.isEmpty()) this.makeEmpty();\n      return this;\n    }\n    /**\n     * Computes the union of this box and another and the given one, setting the upper\n     * bound of this box to the greater of the two boxes\' upper bounds and the\n     * lower bound of this box to the lesser of the two boxes\' lower bounds.\n     *\n     * @param {Box3} box - The bounding box that will be unioned with this instance.\n     * @return {Box3} A reference to this bounding box.\n     */\n    union(box) {\n      this.min.min(box.min);\n      this.max.max(box.max);\n      return this;\n    }\n    /**\n     * Transforms this bounding box by the given 4x4 transformation matrix.\n     *\n     * @param {Matrix4} matrix - The transformation matrix.\n     * @return {Box3} A reference to this bounding box.\n     */\n    applyMatrix4(matrix) {\n      if (this.isEmpty()) return this;\n      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);\n      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);\n      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);\n      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);\n      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);\n      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);\n      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);\n      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);\n      this.setFromPoints(_points);\n      return this;\n    }\n    /**\n     * Adds the given offset to both the upper and lower bounds of this bounding box,\n     * effectively moving it in 3D space.\n     *\n     * @param {Vector3} offset - The offset that should be used to translate the bounding box.\n     * @return {Box3} A reference to this bounding box.\n     */\n    translate(offset) {\n      this.min.add(offset);\n      this.max.add(offset);\n      return this;\n    }\n    /**\n     * Returns `true` if this bounding box is equal with the given one.\n     *\n     * @param {Box3} box - The box to test for equality.\n     * @return {boolean} Whether this bounding box is equal with the given one.\n     */\n    equals(box) {\n      return box.min.equals(this.min) && box.max.equals(this.max);\n    }\n    /**\n     * Returns a serialized structure of the bounding box.\n     *\n     * @return {Object} Serialized structure with fields representing the object state.\n     */\n    toJSON() {\n      return {\n        min: this.min.toArray(),\n        max: this.max.toArray()\n      };\n    }\n    /**\n     * Returns a serialized structure of the bounding box.\n     *\n     * @param {Object} json - The serialized json to set the box from.\n     * @return {Box3} A reference to this bounding box.\n     */\n    fromJSON(json) {\n      this.min.fromArray(json.min);\n      this.max.fromArray(json.max);\n      return this;\n    }\n  }\n  const _points = [\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3()\n  ];\n  const _vector$b = /* @__PURE__ */ new Vector3();\n  const _box$4 = /* @__PURE__ */ new Box3();\n  const _v0$2 = /* @__PURE__ */ new Vector3();\n  const _v1$7 = /* @__PURE__ */ new Vector3();\n  const _v2$4 = /* @__PURE__ */ new Vector3();\n  const _f0 = /* @__PURE__ */ new Vector3();\n  const _f1 = /* @__PURE__ */ new Vector3();\n  const _f2 = /* @__PURE__ */ new Vector3();\n  const _center = /* @__PURE__ */ new Vector3();\n  const _extents = /* @__PURE__ */ new Vector3();\n  const _triangleNormal = /* @__PURE__ */ new Vector3();\n  const _testAxis = /* @__PURE__ */ new Vector3();\n  function satForAxes(axes, v0, v1, v2, extents) {\n    for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {\n      _testAxis.fromArray(axes, i2);\n      const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);\n      const p0 = v0.dot(_testAxis);\n      const p1 = v1.dot(_testAxis);\n      const p2 = v2.dot(_testAxis);\n      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n        return false;\n      }\n    }\n    return true;\n  }\n  const _box$3 = /* @__PURE__ */ new Box3();\n  const _v1$6 = /* @__PURE__ */ new Vector3();\n  const _v2$3 = /* @__PURE__ */ new Vector3();\n  class Sphere {\n    /**\n     * Constructs a new sphere.\n     *\n     * @param {Vector3} [center=(0,0,0)] - The center of the sphere\n     * @param {number} [radius=-1] - The radius of the sphere.\n     */\n    constructor(center = new Vector3(), radius = -1) {\n      this.isSphere = true;\n      this.center = center;\n      this.radius = radius;\n    }\n    /**\n     * Sets the sphere\'s components by copying the given values.\n     *\n     * @param {Vector3} center - The center.\n     * @param {number} radius - The radius.\n     * @return {Sphere} A reference to this sphere.\n     */\n    set(center, radius) {\n      this.center.copy(center);\n      this.radius = radius;\n      return this;\n    }\n    /**\n     * Computes the minimum bounding sphere for list of points.\n     * If the optional center point is given, it is used as the sphere\'s\n     * center. Otherwise, the center of the axis-aligned bounding box\n     * encompassing the points is calculated.\n     *\n     * @param {Array<Vector3>} points - A list of points in 3D space.\n     * @param {Vector3} [optionalCenter] - The center of the sphere.\n     * @return {Sphere} A reference to this sphere.\n     */\n    setFromPoints(points, optionalCenter) {\n      const center = this.center;\n      if (optionalCenter !== void 0) {\n        center.copy(optionalCenter);\n      } else {\n        _box$3.setFromPoints(points).getCenter(center);\n      }\n      let maxRadiusSq = 0;\n      for (let i2 = 0, il = points.length; i2 < il; i2++) {\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));\n      }\n      this.radius = Math.sqrt(maxRadiusSq);\n      return this;\n    }\n    /**\n     * Copies the values of the given sphere to this instance.\n     *\n     * @param {Sphere} sphere - The sphere to copy.\n     * @return {Sphere} A reference to this sphere.\n     */\n    copy(sphere) {\n      this.center.copy(sphere.center);\n      this.radius = sphere.radius;\n      return this;\n    }\n    /**\n     * Returns `true` if the sphere is empty (the radius set to a negative number).\n     *\n     * Spheres with a radius of `0` contain only their center point and are not\n     * considered to be empty.\n     *\n     * @return {boolean} Whether this sphere is empty or not.\n     */\n    isEmpty() {\n      return this.radius < 0;\n    }\n    /**\n     * Makes this sphere empty which means in encloses a zero space in 3D.\n     *\n     * @return {Sphere} A reference to this sphere.\n     */\n    makeEmpty() {\n      this.center.set(0, 0, 0);\n      this.radius = -1;\n      return this;\n    }\n    /**\n     * Returns `true` if this sphere contains the given point inclusive of\n     * the surface of the sphere.\n     *\n     * @param {Vector3} point - The point to check.\n     * @return {boolean} Whether this sphere contains the given point or not.\n     */\n    containsPoint(point) {\n      return point.distanceToSquared(this.center) <= this.radius * this.radius;\n    }\n    /**\n     * Returns the closest distance from the boundary of the sphere to the\n     * given point. If the sphere contains the point, the distance will\n     * be negative.\n     *\n     * @param {Vector3} point - The point to compute the distance to.\n     * @return {number} The distance to the point.\n     */\n    distanceToPoint(point) {\n      return point.distanceTo(this.center) - this.radius;\n    }\n    /**\n     * Returns `true` if this sphere intersects with the given one.\n     *\n     * @param {Sphere} sphere - The sphere to test.\n     * @return {boolean} Whether this sphere intersects with the given one or not.\n     */\n    intersectsSphere(sphere) {\n      const radiusSum = this.radius + sphere.radius;\n      return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n    }\n    /**\n     * Returns `true` if this sphere intersects with the given box.\n     *\n     * @param {Box3} box - The box to test.\n     * @return {boolean} Whether this sphere intersects with the given box or not.\n     */\n    intersectsBox(box) {\n      return box.intersectsSphere(this);\n    }\n    /**\n     * Returns `true` if this sphere intersects with the given plane.\n     *\n     * @param {Plane} plane - The plane to test.\n     * @return {boolean} Whether this sphere intersects with the given plane or not.\n     */\n    intersectsPlane(plane) {\n      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n    }\n    /**\n     * Clamps a point within the sphere. If the point is outside the sphere, it\n     * will clamp it to the closest point on the edge of the sphere. Points\n     * already inside the sphere will not be affected.\n     *\n     * @param {Vector3} point - The plane to clamp.\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {Vector3} The clamped point.\n     */\n    clampPoint(point, target) {\n      const deltaLengthSq = this.center.distanceToSquared(point);\n      target.copy(point);\n      if (deltaLengthSq > this.radius * this.radius) {\n        target.sub(this.center).normalize();\n        target.multiplyScalar(this.radius).add(this.center);\n      }\n      return target;\n    }\n    /**\n     * Returns a bounding box that encloses this sphere.\n     *\n     * @param {Box3} target - The target box that is used to store the method\'s result.\n     * @return {Box3} The bounding box that encloses this sphere.\n     */\n    getBoundingBox(target) {\n      if (this.isEmpty()) {\n        target.makeEmpty();\n        return target;\n      }\n      target.set(this.center, this.center);\n      target.expandByScalar(this.radius);\n      return target;\n    }\n    /**\n     * Transforms this sphere with the given 4x4 transformation matrix.\n     *\n     * @param {Matrix4} matrix - The transformation matrix.\n     * @return {Sphere} A reference to this sphere.\n     */\n    applyMatrix4(matrix) {\n      this.center.applyMatrix4(matrix);\n      this.radius = this.radius * matrix.getMaxScaleOnAxis();\n      return this;\n    }\n    /**\n     * Translates the sphere\'s center by the given offset.\n     *\n     * @param {Vector3} offset - The offset.\n     * @return {Sphere} A reference to this sphere.\n     */\n    translate(offset) {\n      this.center.add(offset);\n      return this;\n    }\n    /**\n     * Expands the boundaries of this sphere to include the given point.\n     *\n     * @param {Vector3} point - The point to include.\n     * @return {Sphere} A reference to this sphere.\n     */\n    expandByPoint(point) {\n      if (this.isEmpty()) {\n        this.center.copy(point);\n        this.radius = 0;\n        return this;\n      }\n      _v1$6.subVectors(point, this.center);\n      const lengthSq = _v1$6.lengthSq();\n      if (lengthSq > this.radius * this.radius) {\n        const length = Math.sqrt(lengthSq);\n        const delta = (length - this.radius) * 0.5;\n        this.center.addScaledVector(_v1$6, delta / length);\n        this.radius += delta;\n      }\n      return this;\n    }\n    /**\n     * Expands this sphere to enclose both the original sphere and the given sphere.\n     *\n     * @param {Sphere} sphere - The sphere to include.\n     * @return {Sphere} A reference to this sphere.\n     */\n    union(sphere) {\n      if (sphere.isEmpty()) {\n        return this;\n      }\n      if (this.isEmpty()) {\n        this.copy(sphere);\n        return this;\n      }\n      if (this.center.equals(sphere.center) === true) {\n        this.radius = Math.max(this.radius, sphere.radius);\n      } else {\n        _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);\n        this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));\n        this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));\n      }\n      return this;\n    }\n    /**\n     * Returns `true` if this sphere is equal with the given one.\n     *\n     * @param {Sphere} sphere - The sphere to test for equality.\n     * @return {boolean} Whether this bounding sphere is equal with the given one.\n     */\n    equals(sphere) {\n      return sphere.center.equals(this.center) && sphere.radius === this.radius;\n    }\n    /**\n     * Returns a new sphere with copied values from this instance.\n     *\n     * @return {Sphere} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    /**\n     * Returns a serialized structure of the bounding sphere.\n     *\n     * @return {Object} Serialized structure with fields representing the object state.\n     */\n    toJSON() {\n      return {\n        radius: this.radius,\n        center: this.center.toArray()\n      };\n    }\n    /**\n     * Returns a serialized structure of the bounding sphere.\n     *\n     * @param {Object} json - The serialized json to set the sphere from.\n     * @return {Box3} A reference to this bounding sphere.\n     */\n    fromJSON(json) {\n      this.radius = json.radius;\n      this.center.fromArray(json.center);\n      return this;\n    }\n  }\n  const _vector$a = /* @__PURE__ */ new Vector3();\n  const _segCenter = /* @__PURE__ */ new Vector3();\n  const _segDir = /* @__PURE__ */ new Vector3();\n  const _diff = /* @__PURE__ */ new Vector3();\n  const _edge1 = /* @__PURE__ */ new Vector3();\n  const _edge2 = /* @__PURE__ */ new Vector3();\n  const _normal$1 = /* @__PURE__ */ new Vector3();\n  class Ray {\n    /**\n     * Constructs a new ray.\n     *\n     * @param {Vector3} [origin=(0,0,0)] - The origin of the ray.\n     * @param {Vector3} [direction=(0,0,-1)] - The (normalized) direction of the ray.\n     */\n    constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {\n      this.origin = origin;\n      this.direction = direction;\n    }\n    /**\n     * Sets the ray\'s components by copying the given values.\n     *\n     * @param {Vector3} origin - The origin.\n     * @param {Vector3} direction - The direction.\n     * @return {Ray} A reference to this ray.\n     */\n    set(origin, direction) {\n      this.origin.copy(origin);\n      this.direction.copy(direction);\n      return this;\n    }\n    /**\n     * Copies the values of the given ray to this instance.\n     *\n     * @param {Ray} ray - The ray to copy.\n     * @return {Ray} A reference to this ray.\n     */\n    copy(ray) {\n      this.origin.copy(ray.origin);\n      this.direction.copy(ray.direction);\n      return this;\n    }\n    /**\n     * Returns a vector that is located at a given distance along this ray.\n     *\n     * @param {number} t - The distance along the ray to retrieve a position for.\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {Vector3} A position on the ray.\n     */\n    at(t, target) {\n      return target.copy(this.origin).addScaledVector(this.direction, t);\n    }\n    /**\n     * Adjusts the direction of the ray to point at the given vector in world space.\n     *\n     * @param {Vector3} v - The target position.\n     * @return {Ray} A reference to this ray.\n     */\n    lookAt(v) {\n      this.direction.copy(v).sub(this.origin).normalize();\n      return this;\n    }\n    /**\n     * Shift the origin of this ray along its direction by the given distance.\n     *\n     * @param {number} t - The distance along the ray to interpolate.\n     * @return {Ray} A reference to this ray.\n     */\n    recast(t) {\n      this.origin.copy(this.at(t, _vector$a));\n      return this;\n    }\n    /**\n     * Returns the point along this ray that is closest to the given point.\n     *\n     * @param {Vector3} point - A point in 3D space to get the closet location on the ray for.\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {Vector3} The closest point on this ray.\n     */\n    closestPointToPoint(point, target) {\n      target.subVectors(point, this.origin);\n      const directionDistance = target.dot(this.direction);\n      if (directionDistance < 0) {\n        return target.copy(this.origin);\n      }\n      return target.copy(this.origin).addScaledVector(this.direction, directionDistance);\n    }\n    /**\n     * Returns the distance of the closest approach between this ray and the given point.\n     *\n     * @param {Vector3} point - A point in 3D space to compute the distance to.\n     * @return {number} The distance.\n     */\n    distanceToPoint(point) {\n      return Math.sqrt(this.distanceSqToPoint(point));\n    }\n    /**\n     * Returns the squared distance of the closest approach between this ray and the given point.\n     *\n     * @param {Vector3} point - A point in 3D space to compute the distance to.\n     * @return {number} The squared distance.\n     */\n    distanceSqToPoint(point) {\n      const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);\n      if (directionDistance < 0) {\n        return this.origin.distanceToSquared(point);\n      }\n      _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);\n      return _vector$a.distanceToSquared(point);\n    }\n    /**\n     * Returns the squared distance between this ray and the given line segment.\n     *\n     * @param {Vector3} v0 - The start point of the line segment.\n     * @param {Vector3} v1 - The end point of the line segment.\n     * @param {Vector3} [optionalPointOnRay] - When provided, it receives the point on this ray that is closest to the segment.\n     * @param {Vector3} [optionalPointOnSegment] - When provided, it receives the point on the line segment that is closest to this ray.\n     * @return {number} The squared distance.\n     */\n    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {\n      _segCenter.copy(v0).add(v1).multiplyScalar(0.5);\n      _segDir.copy(v1).sub(v0).normalize();\n      _diff.copy(this.origin).sub(_segCenter);\n      const segExtent = v0.distanceTo(v1) * 0.5;\n      const a01 = -this.direction.dot(_segDir);\n      const b0 = _diff.dot(this.direction);\n      const b1 = -_diff.dot(_segDir);\n      const c = _diff.lengthSq();\n      const det = Math.abs(1 - a01 * a01);\n      let s0, s1, sqrDist, extDet;\n      if (det > 0) {\n        s0 = a01 * b1 - b0;\n        s1 = a01 * b0 - b1;\n        extDet = segExtent * det;\n        if (s0 >= 0) {\n          if (s1 >= -extDet) {\n            if (s1 <= extDet) {\n              const invDet = 1 / det;\n              s0 *= invDet;\n              s1 *= invDet;\n              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;\n            } else {\n              s1 = segExtent;\n              s0 = Math.max(0, -(a01 * s1 + b0));\n              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n            }\n          } else {\n            s1 = -segExtent;\n            s0 = Math.max(0, -(a01 * s1 + b0));\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        } else {\n          if (s1 <= -extDet) {\n            s0 = Math.max(0, -(-a01 * segExtent + b0));\n            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          } else if (s1 <= extDet) {\n            s0 = 0;\n            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = s1 * (s1 + 2 * b1) + c;\n          } else {\n            s0 = Math.max(0, -(a01 * segExtent + b0));\n            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        }\n      } else {\n        s1 = a01 > 0 ? -segExtent : segExtent;\n        s0 = Math.max(0, -(a01 * s1 + b0));\n        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n      }\n      if (optionalPointOnRay) {\n        optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);\n      }\n      if (optionalPointOnSegment) {\n        optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);\n      }\n      return sqrDist;\n    }\n    /**\n     * Intersects this ray with the given sphere, returning the intersection\n     * point or `null` if there is no intersection.\n     *\n     * @param {Sphere} sphere - The sphere to intersect.\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {?Vector3} The intersection point.\n     */\n    intersectSphere(sphere, target) {\n      _vector$a.subVectors(sphere.center, this.origin);\n      const tca = _vector$a.dot(this.direction);\n      const d2 = _vector$a.dot(_vector$a) - tca * tca;\n      const radius2 = sphere.radius * sphere.radius;\n      if (d2 > radius2) return null;\n      const thc = Math.sqrt(radius2 - d2);\n      const t0 = tca - thc;\n      const t1 = tca + thc;\n      if (t1 < 0) return null;\n      if (t0 < 0) return this.at(t1, target);\n      return this.at(t0, target);\n    }\n    /**\n     * Returns `true` if this ray intersects with the given sphere.\n     *\n     * @param {Sphere} sphere - The sphere to intersect.\n     * @return {boolean} Whether this ray intersects with the given sphere or not.\n     */\n    intersectsSphere(sphere) {\n      if (sphere.radius < 0) return false;\n      return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;\n    }\n    /**\n     * Computes the distance from the ray\'s origin to the given plane. Returns `null` if the ray\n     * does not intersect with the plane.\n     *\n     * @param {Plane} plane - The plane to compute the distance to.\n     * @return {?number} Whether this ray intersects with the given sphere or not.\n     */\n    distanceToPlane(plane) {\n      const denominator = plane.normal.dot(this.direction);\n      if (denominator === 0) {\n        if (plane.distanceToPoint(this.origin) === 0) {\n          return 0;\n        }\n        return null;\n      }\n      const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;\n      return t >= 0 ? t : null;\n    }\n    /**\n     * Intersects this ray with the given plane, returning the intersection\n     * point or `null` if there is no intersection.\n     *\n     * @param {Plane} plane - The plane to intersect.\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {?Vector3} The intersection point.\n     */\n    intersectPlane(plane, target) {\n      const t = this.distanceToPlane(plane);\n      if (t === null) {\n        return null;\n      }\n      return this.at(t, target);\n    }\n    /**\n     * Returns `true` if this ray intersects with the given plane.\n     *\n     * @param {Plane} plane - The plane to intersect.\n     * @return {boolean} Whether this ray intersects with the given plane or not.\n     */\n    intersectsPlane(plane) {\n      const distToPoint = plane.distanceToPoint(this.origin);\n      if (distToPoint === 0) {\n        return true;\n      }\n      const denominator = plane.normal.dot(this.direction);\n      if (denominator * distToPoint < 0) {\n        return true;\n      }\n      return false;\n    }\n    /**\n     * Intersects this ray with the given bounding box, returning the intersection\n     * point or `null` if there is no intersection.\n     *\n     * @param {Box3} box - The box to intersect.\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {?Vector3} The intersection point.\n     */\n    intersectBox(box, target) {\n      let tmin, tmax, tymin, tymax, tzmin, tzmax;\n      const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;\n      const origin = this.origin;\n      if (invdirx >= 0) {\n        tmin = (box.min.x - origin.x) * invdirx;\n        tmax = (box.max.x - origin.x) * invdirx;\n      } else {\n        tmin = (box.max.x - origin.x) * invdirx;\n        tmax = (box.min.x - origin.x) * invdirx;\n      }\n      if (invdiry >= 0) {\n        tymin = (box.min.y - origin.y) * invdiry;\n        tymax = (box.max.y - origin.y) * invdiry;\n      } else {\n        tymin = (box.max.y - origin.y) * invdiry;\n        tymax = (box.min.y - origin.y) * invdiry;\n      }\n      if (tmin > tymax || tymin > tmax) return null;\n      if (tymin > tmin || isNaN(tmin)) tmin = tymin;\n      if (tymax < tmax || isNaN(tmax)) tmax = tymax;\n      if (invdirz >= 0) {\n        tzmin = (box.min.z - origin.z) * invdirz;\n        tzmax = (box.max.z - origin.z) * invdirz;\n      } else {\n        tzmin = (box.max.z - origin.z) * invdirz;\n        tzmax = (box.min.z - origin.z) * invdirz;\n      }\n      if (tmin > tzmax || tzmin > tmax) return null;\n      if (tzmin > tmin || tmin !== tmin) tmin = tzmin;\n      if (tzmax < tmax || tmax !== tmax) tmax = tzmax;\n      if (tmax < 0) return null;\n      return this.at(tmin >= 0 ? tmin : tmax, target);\n    }\n    /**\n     * Returns `true` if this ray intersects with the given box.\n     *\n     * @param {Box3} box - The box to intersect.\n     * @return {boolean} Whether this ray intersects with the given box or not.\n     */\n    intersectsBox(box) {\n      return this.intersectBox(box, _vector$a) !== null;\n    }\n    /**\n     * Intersects this ray with the given triangle, returning the intersection\n     * point or `null` if there is no intersection.\n     *\n     * @param {Vector3} a - The first vertex of the triangle.\n     * @param {Vector3} b - The second vertex of the triangle.\n     * @param {Vector3} c - The third vertex of the triangle.\n     * @param {boolean} backfaceCulling - Whether to use backface culling or not.\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {?Vector3} The intersection point.\n     */\n    intersectTriangle(a, b, c, backfaceCulling, target) {\n      _edge1.subVectors(b, a);\n      _edge2.subVectors(c, a);\n      _normal$1.crossVectors(_edge1, _edge2);\n      let DdN = this.direction.dot(_normal$1);\n      let sign;\n      if (DdN > 0) {\n        if (backfaceCulling) return null;\n        sign = 1;\n      } else if (DdN < 0) {\n        sign = -1;\n        DdN = -DdN;\n      } else {\n        return null;\n      }\n      _diff.subVectors(this.origin, a);\n      const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));\n      if (DdQxE2 < 0) {\n        return null;\n      }\n      const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));\n      if (DdE1xQ < 0) {\n        return null;\n      }\n      if (DdQxE2 + DdE1xQ > DdN) {\n        return null;\n      }\n      const QdN = -sign * _diff.dot(_normal$1);\n      if (QdN < 0) {\n        return null;\n      }\n      return this.at(QdN / DdN, target);\n    }\n    /**\n     * Transforms this ray with the given 4x4 transformation matrix.\n     *\n     * @param {Matrix4} matrix4 - The transformation matrix.\n     * @return {Ray} A reference to this ray.\n     */\n    applyMatrix4(matrix4) {\n      this.origin.applyMatrix4(matrix4);\n      this.direction.transformDirection(matrix4);\n      return this;\n    }\n    /**\n     * Returns `true` if this ray is equal with the given one.\n     *\n     * @param {Ray} ray - The ray to test for equality.\n     * @return {boolean} Whether this ray is equal with the given one.\n     */\n    equals(ray) {\n      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);\n    }\n    /**\n     * Returns a new ray with copied values from this instance.\n     *\n     * @return {Ray} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor().copy(this);\n    }\n  }\n  class Matrix4 {\n    /**\n     * Constructs a new 4x4 matrix. The arguments are supposed to be\n     * in row-major order. If no arguments are provided, the constructor\n     * initializes the matrix as an identity matrix.\n     *\n     * @param {number} [n11] - 1-1 matrix element.\n     * @param {number} [n12] - 1-2 matrix element.\n     * @param {number} [n13] - 1-3 matrix element.\n     * @param {number} [n14] - 1-4 matrix element.\n     * @param {number} [n21] - 2-1 matrix element.\n     * @param {number} [n22] - 2-2 matrix element.\n     * @param {number} [n23] - 2-3 matrix element.\n     * @param {number} [n24] - 2-4 matrix element.\n     * @param {number} [n31] - 3-1 matrix element.\n     * @param {number} [n32] - 3-2 matrix element.\n     * @param {number} [n33] - 3-3 matrix element.\n     * @param {number} [n34] - 3-4 matrix element.\n     * @param {number} [n41] - 4-1 matrix element.\n     * @param {number} [n42] - 4-2 matrix element.\n     * @param {number} [n43] - 4-3 matrix element.\n     * @param {number} [n44] - 4-4 matrix element.\n     */\n    constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n      Matrix4.prototype.isMatrix4 = true;\n      this.elements = [\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ];\n      if (n11 !== void 0) {\n        this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);\n      }\n    }\n    /**\n     * Sets the elements of the matrix.The arguments are supposed to be\n     * in row-major order.\n     *\n     * @param {number} [n11] - 1-1 matrix element.\n     * @param {number} [n12] - 1-2 matrix element.\n     * @param {number} [n13] - 1-3 matrix element.\n     * @param {number} [n14] - 1-4 matrix element.\n     * @param {number} [n21] - 2-1 matrix element.\n     * @param {number} [n22] - 2-2 matrix element.\n     * @param {number} [n23] - 2-3 matrix element.\n     * @param {number} [n24] - 2-4 matrix element.\n     * @param {number} [n31] - 3-1 matrix element.\n     * @param {number} [n32] - 3-2 matrix element.\n     * @param {number} [n33] - 3-3 matrix element.\n     * @param {number} [n34] - 3-4 matrix element.\n     * @param {number} [n41] - 4-1 matrix element.\n     * @param {number} [n42] - 4-2 matrix element.\n     * @param {number} [n43] - 4-3 matrix element.\n     * @param {number} [n44] - 4-4 matrix element.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n      const te = this.elements;\n      te[0] = n11;\n      te[4] = n12;\n      te[8] = n13;\n      te[12] = n14;\n      te[1] = n21;\n      te[5] = n22;\n      te[9] = n23;\n      te[13] = n24;\n      te[2] = n31;\n      te[6] = n32;\n      te[10] = n33;\n      te[14] = n34;\n      te[3] = n41;\n      te[7] = n42;\n      te[11] = n43;\n      te[15] = n44;\n      return this;\n    }\n    /**\n     * Sets this matrix to the 4x4 identity matrix.\n     *\n     * @return {Matrix4} A reference to this matrix.\n     */\n    identity() {\n      this.set(\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Returns a matrix with copied values from this instance.\n     *\n     * @return {Matrix4} A clone of this instance.\n     */\n    clone() {\n      return new Matrix4().fromArray(this.elements);\n    }\n    /**\n     * Copies the values of the given matrix to this instance.\n     *\n     * @param {Matrix4} m - The matrix to copy.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    copy(m) {\n      const te = this.elements;\n      const me = m.elements;\n      te[0] = me[0];\n      te[1] = me[1];\n      te[2] = me[2];\n      te[3] = me[3];\n      te[4] = me[4];\n      te[5] = me[5];\n      te[6] = me[6];\n      te[7] = me[7];\n      te[8] = me[8];\n      te[9] = me[9];\n      te[10] = me[10];\n      te[11] = me[11];\n      te[12] = me[12];\n      te[13] = me[13];\n      te[14] = me[14];\n      te[15] = me[15];\n      return this;\n    }\n    /**\n     * Copies the translation component of the given matrix\n     * into this matrix\'s translation component.\n     *\n     * @param {Matrix4} m - The matrix to copy the translation component.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    copyPosition(m) {\n      const te = this.elements, me = m.elements;\n      te[12] = me[12];\n      te[13] = me[13];\n      te[14] = me[14];\n      return this;\n    }\n    /**\n     * Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.\n     *\n     * @param {Matrix3} m - The 3x3 matrix.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    setFromMatrix3(m) {\n      const me = m.elements;\n      this.set(\n        me[0],\n        me[3],\n        me[6],\n        0,\n        me[1],\n        me[4],\n        me[7],\n        0,\n        me[2],\n        me[5],\n        me[8],\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Extracts the basis of this matrix into the three axis vectors provided.\n     *\n     * @param {Vector3} xAxis - The basis\'s x axis.\n     * @param {Vector3} yAxis - The basis\'s y axis.\n     * @param {Vector3} zAxis - The basis\'s z axis.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    extractBasis(xAxis, yAxis, zAxis) {\n      xAxis.setFromMatrixColumn(this, 0);\n      yAxis.setFromMatrixColumn(this, 1);\n      zAxis.setFromMatrixColumn(this, 2);\n      return this;\n    }\n    /**\n     * Sets the given basis vectors to this matrix.\n     *\n     * @param {Vector3} xAxis - The basis\'s x axis.\n     * @param {Vector3} yAxis - The basis\'s y axis.\n     * @param {Vector3} zAxis - The basis\'s z axis.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    makeBasis(xAxis, yAxis, zAxis) {\n      this.set(\n        xAxis.x,\n        yAxis.x,\n        zAxis.x,\n        0,\n        xAxis.y,\n        yAxis.y,\n        zAxis.y,\n        0,\n        xAxis.z,\n        yAxis.z,\n        zAxis.z,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Extracts the rotation component of the given matrix\n     * into this matrix\'s rotation component.\n     *\n     * Note: This method does not support reflection matrices.\n     *\n     * @param {Matrix4} m - The matrix.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    extractRotation(m) {\n      const te = this.elements;\n      const me = m.elements;\n      const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();\n      const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();\n      const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();\n      te[0] = me[0] * scaleX;\n      te[1] = me[1] * scaleX;\n      te[2] = me[2] * scaleX;\n      te[3] = 0;\n      te[4] = me[4] * scaleY;\n      te[5] = me[5] * scaleY;\n      te[6] = me[6] * scaleY;\n      te[7] = 0;\n      te[8] = me[8] * scaleZ;\n      te[9] = me[9] * scaleZ;\n      te[10] = me[10] * scaleZ;\n      te[11] = 0;\n      te[12] = 0;\n      te[13] = 0;\n      te[14] = 0;\n      te[15] = 1;\n      return this;\n    }\n    /**\n     * Sets the rotation component (the upper left 3x3 matrix) of this matrix to\n     * the rotation specified by the given Euler angles. The rest of\n     * the matrix is set to the identity. Depending on the {@link Euler#order},\n     * there are six possible outcomes. See [this page]{@link https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix}\n     * for a complete list.\n     *\n     * @param {Euler} euler - The Euler angles.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    makeRotationFromEuler(euler) {\n      const te = this.elements;\n      const x2 = euler.x, y = euler.y, z = euler.z;\n      const a = Math.cos(x2), b = Math.sin(x2);\n      const c = Math.cos(y), d = Math.sin(y);\n      const e = Math.cos(z), f = Math.sin(z);\n      if (euler.order === "XYZ") {\n        const ae = a * e, af = a * f, be = b * e, bf = b * f;\n        te[0] = c * e;\n        te[4] = -c * f;\n        te[8] = d;\n        te[1] = af + be * d;\n        te[5] = ae - bf * d;\n        te[9] = -b * c;\n        te[2] = bf - ae * d;\n        te[6] = be + af * d;\n        te[10] = a * c;\n      } else if (euler.order === "YXZ") {\n        const ce = c * e, cf = c * f, de = d * e, df = d * f;\n        te[0] = ce + df * b;\n        te[4] = de * b - cf;\n        te[8] = a * d;\n        te[1] = a * f;\n        te[5] = a * e;\n        te[9] = -b;\n        te[2] = cf * b - de;\n        te[6] = df + ce * b;\n        te[10] = a * c;\n      } else if (euler.order === "ZXY") {\n        const ce = c * e, cf = c * f, de = d * e, df = d * f;\n        te[0] = ce - df * b;\n        te[4] = -a * f;\n        te[8] = de + cf * b;\n        te[1] = cf + de * b;\n        te[5] = a * e;\n        te[9] = df - ce * b;\n        te[2] = -a * d;\n        te[6] = b;\n        te[10] = a * c;\n      } else if (euler.order === "ZYX") {\n        const ae = a * e, af = a * f, be = b * e, bf = b * f;\n        te[0] = c * e;\n        te[4] = be * d - af;\n        te[8] = ae * d + bf;\n        te[1] = c * f;\n        te[5] = bf * d + ae;\n        te[9] = af * d - be;\n        te[2] = -d;\n        te[6] = b * c;\n        te[10] = a * c;\n      } else if (euler.order === "YZX") {\n        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n        te[0] = c * e;\n        te[4] = bd - ac * f;\n        te[8] = bc * f + ad;\n        te[1] = f;\n        te[5] = a * e;\n        te[9] = -b * e;\n        te[2] = -d * e;\n        te[6] = ad * f + bc;\n        te[10] = ac - bd * f;\n      } else if (euler.order === "XZY") {\n        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n        te[0] = c * e;\n        te[4] = -f;\n        te[8] = d * e;\n        te[1] = ac * f + bd;\n        te[5] = a * e;\n        te[9] = ad * f - bc;\n        te[2] = bc * f - ad;\n        te[6] = b * e;\n        te[10] = bd * f + ac;\n      }\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = 0;\n      te[12] = 0;\n      te[13] = 0;\n      te[14] = 0;\n      te[15] = 1;\n      return this;\n    }\n    /**\n     * Sets the rotation component of this matrix to the rotation specified by\n     * the given Quaternion as outlined [here]{@link https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion}\n     * The rest of the matrix is set to the identity.\n     *\n     * @param {Quaternion} q - The Quaternion.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    makeRotationFromQuaternion(q) {\n      return this.compose(_zero, q, _one);\n    }\n    /**\n     * Sets the rotation component of the transformation matrix, looking from `eye` towards\n     * `target`, and oriented by the up-direction.\n     *\n     * @param {Vector3} eye - The eye vector.\n     * @param {Vector3} target - The target vector.\n     * @param {Vector3} up - The up vector.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    lookAt(eye, target, up) {\n      const te = this.elements;\n      _z.subVectors(eye, target);\n      if (_z.lengthSq() === 0) {\n        _z.z = 1;\n      }\n      _z.normalize();\n      _x.crossVectors(up, _z);\n      if (_x.lengthSq() === 0) {\n        if (Math.abs(up.z) === 1) {\n          _z.x += 1e-4;\n        } else {\n          _z.z += 1e-4;\n        }\n        _z.normalize();\n        _x.crossVectors(up, _z);\n      }\n      _x.normalize();\n      _y.crossVectors(_z, _x);\n      te[0] = _x.x;\n      te[4] = _y.x;\n      te[8] = _z.x;\n      te[1] = _x.y;\n      te[5] = _y.y;\n      te[9] = _z.y;\n      te[2] = _x.z;\n      te[6] = _y.z;\n      te[10] = _z.z;\n      return this;\n    }\n    /**\n     * Post-multiplies this matrix by the given 4x4 matrix.\n     *\n     * @param {Matrix4} m - The matrix to multiply with.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    multiply(m) {\n      return this.multiplyMatrices(this, m);\n    }\n    /**\n     * Pre-multiplies this matrix by the given 4x4 matrix.\n     *\n     * @param {Matrix4} m - The matrix to multiply with.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    premultiply(m) {\n      return this.multiplyMatrices(m, this);\n    }\n    /**\n     * Multiples the given 4x4 matrices and stores the result\n     * in this matrix.\n     *\n     * @param {Matrix4} a - The first matrix.\n     * @param {Matrix4} b - The second matrix.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    multiplyMatrices(a, b) {\n      const ae = a.elements;\n      const be = b.elements;\n      const te = this.elements;\n      const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];\n      const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\n      const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\n      const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\n      const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];\n      const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];\n      const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];\n      const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\n      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n      return this;\n    }\n    /**\n     * Multiplies every component of the matrix by the given scalar.\n     *\n     * @param {number} s - The scalar.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    multiplyScalar(s) {\n      const te = this.elements;\n      te[0] *= s;\n      te[4] *= s;\n      te[8] *= s;\n      te[12] *= s;\n      te[1] *= s;\n      te[5] *= s;\n      te[9] *= s;\n      te[13] *= s;\n      te[2] *= s;\n      te[6] *= s;\n      te[10] *= s;\n      te[14] *= s;\n      te[3] *= s;\n      te[7] *= s;\n      te[11] *= s;\n      te[15] *= s;\n      return this;\n    }\n    /**\n     * Computes and returns the determinant of this matrix.\n     *\n     * Based on the method outlined [here]{@link http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html}.\n     *\n     * @return {number} The determinant.\n     */\n    determinant() {\n      const te = this.elements;\n      const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];\n      const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\n      const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\n      const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\n      return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\n    }\n    /**\n     * Transposes this matrix in place.\n     *\n     * @return {Matrix4} A reference to this matrix.\n     */\n    transpose() {\n      const te = this.elements;\n      let tmp;\n      tmp = te[1];\n      te[1] = te[4];\n      te[4] = tmp;\n      tmp = te[2];\n      te[2] = te[8];\n      te[8] = tmp;\n      tmp = te[6];\n      te[6] = te[9];\n      te[9] = tmp;\n      tmp = te[3];\n      te[3] = te[12];\n      te[12] = tmp;\n      tmp = te[7];\n      te[7] = te[13];\n      te[13] = tmp;\n      tmp = te[11];\n      te[11] = te[14];\n      te[14] = tmp;\n      return this;\n    }\n    /**\n     * Sets the position component for this matrix from the given vector,\n     * without affecting the rest of the matrix.\n     *\n     * @param {number|Vector3} x - The x component of the vector or alternatively the vector object.\n     * @param {number} y - The y component of the vector.\n     * @param {number} z - The z component of the vector.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    setPosition(x2, y, z) {\n      const te = this.elements;\n      if (x2.isVector3) {\n        te[12] = x2.x;\n        te[13] = x2.y;\n        te[14] = x2.z;\n      } else {\n        te[12] = x2;\n        te[13] = y;\n        te[14] = z;\n      }\n      return this;\n    }\n    /**\n     * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.\n     * You can not invert with a determinant of zero. If you attempt this, the method produces\n     * a zero matrix instead.\n     *\n     * @return {Matrix4} A reference to this matrix.\n     */\n    invert() {\n      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n      const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n      const detInv = 1 / det;\n      te[0] = t11 * detInv;\n      te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\n      te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n      te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n      te[4] = t12 * detInv;\n      te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n      te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\n      te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\n      te[8] = t13 * detInv;\n      te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\n      te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n      te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n      te[12] = t14 * detInv;\n      te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n      te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\n      te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\n      return this;\n    }\n    /**\n     * Multiplies the columns of this matrix by the given vector.\n     *\n     * @param {Vector3} v - The scale vector.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    scale(v) {\n      const te = this.elements;\n      const x2 = v.x, y = v.y, z = v.z;\n      te[0] *= x2;\n      te[4] *= y;\n      te[8] *= z;\n      te[1] *= x2;\n      te[5] *= y;\n      te[9] *= z;\n      te[2] *= x2;\n      te[6] *= y;\n      te[10] *= z;\n      te[3] *= x2;\n      te[7] *= y;\n      te[11] *= z;\n      return this;\n    }\n    /**\n     * Gets the maximum scale value of the three axes.\n     *\n     * @return {number} The maximum scale.\n     */\n    getMaxScaleOnAxis() {\n      const te = this.elements;\n      const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n      const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n      const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n    }\n    /**\n     * Sets this matrix as a translation transform from the given vector.\n     *\n     * @param {number|Vector3} x - The amount to translate in the X axis or alternatively a translation vector.\n     * @param {number} y - The amount to translate in the Y axis.\n     * @param {number} z - The amount to translate in the z axis.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    makeTranslation(x2, y, z) {\n      if (x2.isVector3) {\n        this.set(\n          1,\n          0,\n          0,\n          x2.x,\n          0,\n          1,\n          0,\n          x2.y,\n          0,\n          0,\n          1,\n          x2.z,\n          0,\n          0,\n          0,\n          1\n        );\n      } else {\n        this.set(\n          1,\n          0,\n          0,\n          x2,\n          0,\n          1,\n          0,\n          y,\n          0,\n          0,\n          1,\n          z,\n          0,\n          0,\n          0,\n          1\n        );\n      }\n      return this;\n    }\n    /**\n     * Sets this matrix as a rotational transformation around the X axis by\n     * the given angle.\n     *\n     * @param {number} theta - The rotation in radians.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    makeRotationX(theta) {\n      const c = Math.cos(theta), s = Math.sin(theta);\n      this.set(\n        1,\n        0,\n        0,\n        0,\n        0,\n        c,\n        -s,\n        0,\n        0,\n        s,\n        c,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Sets this matrix as a rotational transformation around the Y axis by\n     * the given angle.\n     *\n     * @param {number} theta - The rotation in radians.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    makeRotationY(theta) {\n      const c = Math.cos(theta), s = Math.sin(theta);\n      this.set(\n        c,\n        0,\n        s,\n        0,\n        0,\n        1,\n        0,\n        0,\n        -s,\n        0,\n        c,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Sets this matrix as a rotational transformation around the Z axis by\n     * the given angle.\n     *\n     * @param {number} theta - The rotation in radians.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    makeRotationZ(theta) {\n      const c = Math.cos(theta), s = Math.sin(theta);\n      this.set(\n        c,\n        -s,\n        0,\n        0,\n        s,\n        c,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Sets this matrix as a rotational transformation around the given axis by\n     * the given angle.\n     *\n     * This is a somewhat controversial but mathematically sound alternative to\n     * rotating via Quaternions. See the discussion [here]{@link https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199}.\n     *\n     * @param {Vector3} axis - The normalized rotation axis.\n     * @param {number} angle - The rotation in radians.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    makeRotationAxis(axis, angle) {\n      const c = Math.cos(angle);\n      const s = Math.sin(angle);\n      const t = 1 - c;\n      const x2 = axis.x, y = axis.y, z = axis.z;\n      const tx = t * x2, ty = t * y;\n      this.set(\n        tx * x2 + c,\n        tx * y - s * z,\n        tx * z + s * y,\n        0,\n        tx * y + s * z,\n        ty * y + c,\n        ty * z - s * x2,\n        0,\n        tx * z - s * y,\n        ty * z + s * x2,\n        t * z * z + c,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Sets this matrix as a scale transformation.\n     *\n     * @param {number} x - The amount to scale in the X axis.\n     * @param {number} y - The amount to scale in the Y axis.\n     * @param {number} z - The amount to scale in the Z axis.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    makeScale(x2, y, z) {\n      this.set(\n        x2,\n        0,\n        0,\n        0,\n        0,\n        y,\n        0,\n        0,\n        0,\n        0,\n        z,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Sets this matrix as a shear transformation.\n     *\n     * @param {number} xy - The amount to shear X by Y.\n     * @param {number} xz - The amount to shear X by Z.\n     * @param {number} yx - The amount to shear Y by X.\n     * @param {number} yz - The amount to shear Y by Z.\n     * @param {number} zx - The amount to shear Z by X.\n     * @param {number} zy - The amount to shear Z by Y.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    makeShear(xy, xz, yx, yz, zx, zy) {\n      this.set(\n        1,\n        yx,\n        zx,\n        0,\n        xy,\n        1,\n        zy,\n        0,\n        xz,\n        yz,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Sets this matrix to the transformation composed of the given position,\n     * rotation (Quaternion) and scale.\n     *\n     * @param {Vector3} position - The position vector.\n     * @param {Quaternion} quaternion - The rotation as a Quaternion.\n     * @param {Vector3} scale - The scale vector.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    compose(position, quaternion, scale) {\n      const te = this.elements;\n      const x2 = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n      const x22 = x2 + x2, y2 = y + y, z2 = z + z;\n      const xx = x2 * x22, xy = x2 * y2, xz = x2 * z2;\n      const yy = y * y2, yz = y * z2, zz = z * z2;\n      const wx = w * x22, wy = w * y2, wz = w * z2;\n      const sx = scale.x, sy = scale.y, sz = scale.z;\n      te[0] = (1 - (yy + zz)) * sx;\n      te[1] = (xy + wz) * sx;\n      te[2] = (xz - wy) * sx;\n      te[3] = 0;\n      te[4] = (xy - wz) * sy;\n      te[5] = (1 - (xx + zz)) * sy;\n      te[6] = (yz + wx) * sy;\n      te[7] = 0;\n      te[8] = (xz + wy) * sz;\n      te[9] = (yz - wx) * sz;\n      te[10] = (1 - (xx + yy)) * sz;\n      te[11] = 0;\n      te[12] = position.x;\n      te[13] = position.y;\n      te[14] = position.z;\n      te[15] = 1;\n      return this;\n    }\n    /**\n     * Decomposes this matrix into its position, rotation and scale components\n     * and provides the result in the given objects.\n     *\n     * Note: Not all matrices are decomposable in this way. For example, if an\n     * object has a non-uniformly scaled parent, then the object\'s world matrix\n     * may not be decomposable, and this method may not be appropriate.\n     *\n     * @param {Vector3} position - The position vector.\n     * @param {Quaternion} quaternion - The rotation as a Quaternion.\n     * @param {Vector3} scale - The scale vector.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    decompose(position, quaternion, scale) {\n      const te = this.elements;\n      let sx = _v1$5.set(te[0], te[1], te[2]).length();\n      const sy = _v1$5.set(te[4], te[5], te[6]).length();\n      const sz = _v1$5.set(te[8], te[9], te[10]).length();\n      const det = this.determinant();\n      if (det < 0) sx = -sx;\n      position.x = te[12];\n      position.y = te[13];\n      position.z = te[14];\n      _m1$2.copy(this);\n      const invSX = 1 / sx;\n      const invSY = 1 / sy;\n      const invSZ = 1 / sz;\n      _m1$2.elements[0] *= invSX;\n      _m1$2.elements[1] *= invSX;\n      _m1$2.elements[2] *= invSX;\n      _m1$2.elements[4] *= invSY;\n      _m1$2.elements[5] *= invSY;\n      _m1$2.elements[6] *= invSY;\n      _m1$2.elements[8] *= invSZ;\n      _m1$2.elements[9] *= invSZ;\n      _m1$2.elements[10] *= invSZ;\n      quaternion.setFromRotationMatrix(_m1$2);\n      scale.x = sx;\n      scale.y = sy;\n      scale.z = sz;\n      return this;\n    }\n    /**\n        	 * Creates a perspective projection matrix. This is used internally by\n        	 * {@link PerspectiveCamera#updateProjectionMatrix}.\n    \n        	 * @param {number} left - Left boundary of the viewing frustum at the near plane.\n        	 * @param {number} right - Right boundary of the viewing frustum at the near plane.\n        	 * @param {number} top - Top boundary of the viewing frustum at the near plane.\n        	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.\n        	 * @param {number} near - The distance from the camera to the near plane.\n        	 * @param {number} far - The distance from the camera to the far plane.\n        	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.\n        	 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.\n        	 * @return {Matrix4} A reference to this matrix.\n        	 */\n    makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false) {\n      const te = this.elements;\n      const x2 = 2 * near / (right - left);\n      const y = 2 * near / (top - bottom);\n      const a = (right + left) / (right - left);\n      const b = (top + bottom) / (top - bottom);\n      let c, d;\n      if (reversedDepth) {\n        c = near / (far - near);\n        d = far * near / (far - near);\n      } else {\n        if (coordinateSystem === WebGLCoordinateSystem) {\n          c = -(far + near) / (far - near);\n          d = -2 * far * near / (far - near);\n        } else if (coordinateSystem === WebGPUCoordinateSystem) {\n          c = -far / (far - near);\n          d = -far * near / (far - near);\n        } else {\n          throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);\n        }\n      }\n      te[0] = x2;\n      te[4] = 0;\n      te[8] = a;\n      te[12] = 0;\n      te[1] = 0;\n      te[5] = y;\n      te[9] = b;\n      te[13] = 0;\n      te[2] = 0;\n      te[6] = 0;\n      te[10] = c;\n      te[14] = d;\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = -1;\n      te[15] = 0;\n      return this;\n    }\n    /**\n        	 * Creates a orthographic projection matrix. This is used internally by\n        	 * {@link OrthographicCamera#updateProjectionMatrix}.\n    \n        	 * @param {number} left - Left boundary of the viewing frustum at the near plane.\n        	 * @param {number} right - Right boundary of the viewing frustum at the near plane.\n        	 * @param {number} top - Top boundary of the viewing frustum at the near plane.\n        	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.\n        	 * @param {number} near - The distance from the camera to the near plane.\n        	 * @param {number} far - The distance from the camera to the far plane.\n        	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.\n        	 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.\n        	 * @return {Matrix4} A reference to this matrix.\n        	 */\n    makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false) {\n      const te = this.elements;\n      const x2 = 2 / (right - left);\n      const y = 2 / (top - bottom);\n      const a = -(right + left) / (right - left);\n      const b = -(top + bottom) / (top - bottom);\n      let c, d;\n      if (reversedDepth) {\n        c = 1 / (far - near);\n        d = far / (far - near);\n      } else {\n        if (coordinateSystem === WebGLCoordinateSystem) {\n          c = -2 / (far - near);\n          d = -(far + near) / (far - near);\n        } else if (coordinateSystem === WebGPUCoordinateSystem) {\n          c = -1 / (far - near);\n          d = -near / (far - near);\n        } else {\n          throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);\n        }\n      }\n      te[0] = x2;\n      te[4] = 0;\n      te[8] = 0;\n      te[12] = a;\n      te[1] = 0;\n      te[5] = y;\n      te[9] = 0;\n      te[13] = b;\n      te[2] = 0;\n      te[6] = 0;\n      te[10] = c;\n      te[14] = d;\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = 0;\n      te[15] = 1;\n      return this;\n    }\n    /**\n     * Returns `true` if this matrix is equal with the given one.\n     *\n     * @param {Matrix4} matrix - The matrix to test for equality.\n     * @return {boolean} Whether this matrix is equal with the given one.\n     */\n    equals(matrix) {\n      const te = this.elements;\n      const me = matrix.elements;\n      for (let i2 = 0; i2 < 16; i2++) {\n        if (te[i2] !== me[i2]) return false;\n      }\n      return true;\n    }\n    /**\n     * Sets the elements of the matrix from the given array.\n     *\n     * @param {Array<number>} array - The matrix elements in column-major order.\n     * @param {number} [offset=0] - Index of the first element in the array.\n     * @return {Matrix4} A reference to this matrix.\n     */\n    fromArray(array, offset = 0) {\n      for (let i2 = 0; i2 < 16; i2++) {\n        this.elements[i2] = array[i2 + offset];\n      }\n      return this;\n    }\n    /**\n     * Writes the elements of this matrix to the given array. If no array is provided,\n     * the method returns a new instance.\n     *\n     * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.\n     * @param {number} [offset=0] - Index of the first element in the array.\n     * @return {Array<number>} The matrix elements in column-major order.\n     */\n    toArray(array = [], offset = 0) {\n      const te = this.elements;\n      array[offset] = te[0];\n      array[offset + 1] = te[1];\n      array[offset + 2] = te[2];\n      array[offset + 3] = te[3];\n      array[offset + 4] = te[4];\n      array[offset + 5] = te[5];\n      array[offset + 6] = te[6];\n      array[offset + 7] = te[7];\n      array[offset + 8] = te[8];\n      array[offset + 9] = te[9];\n      array[offset + 10] = te[10];\n      array[offset + 11] = te[11];\n      array[offset + 12] = te[12];\n      array[offset + 13] = te[13];\n      array[offset + 14] = te[14];\n      array[offset + 15] = te[15];\n      return array;\n    }\n  }\n  const _v1$5 = /* @__PURE__ */ new Vector3();\n  const _m1$2 = /* @__PURE__ */ new Matrix4();\n  const _zero = /* @__PURE__ */ new Vector3(0, 0, 0);\n  const _one = /* @__PURE__ */ new Vector3(1, 1, 1);\n  const _x = /* @__PURE__ */ new Vector3();\n  const _y = /* @__PURE__ */ new Vector3();\n  const _z = /* @__PURE__ */ new Vector3();\n  const _matrix$2 = /* @__PURE__ */ new Matrix4();\n  const _quaternion$3 = /* @__PURE__ */ new Quaternion();\n  class Euler {\n    /**\n     * Constructs a new euler instance.\n     *\n     * @param {number} [x=0] - The angle of the x axis in radians.\n     * @param {number} [y=0] - The angle of the y axis in radians.\n     * @param {number} [z=0] - The angle of the z axis in radians.\n     * @param {string} [order=Euler.DEFAULT_ORDER] - A string representing the order that the rotations are applied.\n     */\n    constructor(x2 = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {\n      this.isEuler = true;\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._order = order;\n    }\n    /**\n     * The angle of the x axis in radians.\n     *\n     * @type {number}\n     * @default 0\n     */\n    get x() {\n      return this._x;\n    }\n    set x(value) {\n      this._x = value;\n      this._onChangeCallback();\n    }\n    /**\n     * The angle of the y axis in radians.\n     *\n     * @type {number}\n     * @default 0\n     */\n    get y() {\n      return this._y;\n    }\n    set y(value) {\n      this._y = value;\n      this._onChangeCallback();\n    }\n    /**\n     * The angle of the z axis in radians.\n     *\n     * @type {number}\n     * @default 0\n     */\n    get z() {\n      return this._z;\n    }\n    set z(value) {\n      this._z = value;\n      this._onChangeCallback();\n    }\n    /**\n     * A string representing the order that the rotations are applied.\n     *\n     * @type {string}\n     * @default \'XYZ\'\n     */\n    get order() {\n      return this._order;\n    }\n    set order(value) {\n      this._order = value;\n      this._onChangeCallback();\n    }\n    /**\n     * Sets the Euler components.\n     *\n     * @param {number} x - The angle of the x axis in radians.\n     * @param {number} y - The angle of the y axis in radians.\n     * @param {number} z - The angle of the z axis in radians.\n     * @param {string} [order] - A string representing the order that the rotations are applied.\n     * @return {Euler} A reference to this Euler instance.\n     */\n    set(x2, y, z, order = this._order) {\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._order = order;\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Returns a new Euler instance with copied values from this instance.\n     *\n     * @return {Euler} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor(this._x, this._y, this._z, this._order);\n    }\n    /**\n     * Copies the values of the given Euler instance to this instance.\n     *\n     * @param {Euler} euler - The Euler instance to copy.\n     * @return {Euler} A reference to this Euler instance.\n     */\n    copy(euler) {\n      this._x = euler._x;\n      this._y = euler._y;\n      this._z = euler._z;\n      this._order = euler._order;\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Sets the angles of this Euler instance from a pure rotation matrix.\n     *\n     * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).\n     * @param {string} [order] - A string representing the order that the rotations are applied.\n     * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.\n     * @return {Euler} A reference to this Euler instance.\n     */\n    setFromRotationMatrix(m, order = this._order, update = true) {\n      const te = m.elements;\n      const m11 = te[0], m12 = te[4], m13 = te[8];\n      const m21 = te[1], m22 = te[5], m23 = te[9];\n      const m31 = te[2], m32 = te[6], m33 = te[10];\n      switch (order) {\n        case "XYZ":\n          this._y = Math.asin(clamp(m13, -1, 1));\n          if (Math.abs(m13) < 0.9999999) {\n            this._x = Math.atan2(-m23, m33);\n            this._z = Math.atan2(-m12, m11);\n          } else {\n            this._x = Math.atan2(m32, m22);\n            this._z = 0;\n          }\n          break;\n        case "YXZ":\n          this._x = Math.asin(-clamp(m23, -1, 1));\n          if (Math.abs(m23) < 0.9999999) {\n            this._y = Math.atan2(m13, m33);\n            this._z = Math.atan2(m21, m22);\n          } else {\n            this._y = Math.atan2(-m31, m11);\n            this._z = 0;\n          }\n          break;\n        case "ZXY":\n          this._x = Math.asin(clamp(m32, -1, 1));\n          if (Math.abs(m32) < 0.9999999) {\n            this._y = Math.atan2(-m31, m33);\n            this._z = Math.atan2(-m12, m22);\n          } else {\n            this._y = 0;\n            this._z = Math.atan2(m21, m11);\n          }\n          break;\n        case "ZYX":\n          this._y = Math.asin(-clamp(m31, -1, 1));\n          if (Math.abs(m31) < 0.9999999) {\n            this._x = Math.atan2(m32, m33);\n            this._z = Math.atan2(m21, m11);\n          } else {\n            this._x = 0;\n            this._z = Math.atan2(-m12, m22);\n          }\n          break;\n        case "YZX":\n          this._z = Math.asin(clamp(m21, -1, 1));\n          if (Math.abs(m21) < 0.9999999) {\n            this._x = Math.atan2(-m23, m22);\n            this._y = Math.atan2(-m31, m11);\n          } else {\n            this._x = 0;\n            this._y = Math.atan2(m13, m33);\n          }\n          break;\n        case "XZY":\n          this._z = Math.asin(-clamp(m12, -1, 1));\n          if (Math.abs(m12) < 0.9999999) {\n            this._x = Math.atan2(m32, m22);\n            this._y = Math.atan2(m13, m11);\n          } else {\n            this._x = Math.atan2(-m23, m33);\n            this._y = 0;\n          }\n          break;\n        default:\n          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);\n      }\n      this._order = order;\n      if (update === true) this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Sets the angles of this Euler instance from a normalized quaternion.\n     *\n     * @param {Quaternion} q - A normalized Quaternion.\n     * @param {string} [order] - A string representing the order that the rotations are applied.\n     * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.\n     * @return {Euler} A reference to this Euler instance.\n     */\n    setFromQuaternion(q, order, update) {\n      _matrix$2.makeRotationFromQuaternion(q);\n      return this.setFromRotationMatrix(_matrix$2, order, update);\n    }\n    /**\n     * Sets the angles of this Euler instance from the given vector.\n     *\n     * @param {Vector3} v - The vector.\n     * @param {string} [order] - A string representing the order that the rotations are applied.\n     * @return {Euler} A reference to this Euler instance.\n     */\n    setFromVector3(v, order = this._order) {\n      return this.set(v.x, v.y, v.z, order);\n    }\n    /**\n     * Resets the euler angle with a new order by creating a quaternion from this\n     * euler angle and then setting this euler angle with the quaternion and the\n     * new order.\n     *\n     * Warning: This discards revolution information.\n     *\n     * @param {string} [newOrder] - A string representing the new order that the rotations are applied.\n     * @return {Euler} A reference to this Euler instance.\n     */\n    reorder(newOrder) {\n      _quaternion$3.setFromEuler(this);\n      return this.setFromQuaternion(_quaternion$3, newOrder);\n    }\n    /**\n     * Returns `true` if this Euler instance is equal with the given one.\n     *\n     * @param {Euler} euler - The Euler instance to test for equality.\n     * @return {boolean} Whether this Euler instance is equal with the given one.\n     */\n    equals(euler) {\n      return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;\n    }\n    /**\n     * Sets this Euler instance\'s components to values from the given array. The first three\n     * entries of the array are assign to the x,y and z components. An optional fourth entry\n     * defines the Euler order.\n     *\n     * @param {Array<number,number,number,?string>} array - An array holding the Euler component values.\n     * @return {Euler} A reference to this Euler instance.\n     */\n    fromArray(array) {\n      this._x = array[0];\n      this._y = array[1];\n      this._z = array[2];\n      if (array[3] !== void 0) this._order = array[3];\n      this._onChangeCallback();\n      return this;\n    }\n    /**\n     * Writes the components of this Euler instance to the given array. If no array is provided,\n     * the method returns a new instance.\n     *\n     * @param {Array<number,number,number,string>} [array=[]] - The target array holding the Euler components.\n     * @param {number} [offset=0] - Index of the first element in the array.\n     * @return {Array<number,number,number,string>} The Euler components.\n     */\n    toArray(array = [], offset = 0) {\n      array[offset] = this._x;\n      array[offset + 1] = this._y;\n      array[offset + 2] = this._z;\n      array[offset + 3] = this._order;\n      return array;\n    }\n    _onChange(callback) {\n      this._onChangeCallback = callback;\n      return this;\n    }\n    _onChangeCallback() {\n    }\n    *[Symbol.iterator]() {\n      yield this._x;\n      yield this._y;\n      yield this._z;\n      yield this._order;\n    }\n  }\n  Euler.DEFAULT_ORDER = "XYZ";\n  class Layers {\n    /**\n     * Constructs a new layers instance, with membership\n     * initially set to layer `0`.\n     */\n    constructor() {\n      this.mask = 1 | 0;\n    }\n    /**\n     * Sets membership to the given layer, and remove membership all other layers.\n     *\n     * @param {number} layer - The layer to set.\n     */\n    set(layer) {\n      this.mask = (1 << layer | 0) >>> 0;\n    }\n    /**\n     * Adds membership of the given layer.\n     *\n     * @param {number} layer - The layer to enable.\n     */\n    enable(layer) {\n      this.mask |= 1 << layer | 0;\n    }\n    /**\n     * Adds membership to all layers.\n     */\n    enableAll() {\n      this.mask = 4294967295 | 0;\n    }\n    /**\n     * Toggles the membership of the given layer.\n     *\n     * @param {number} layer - The layer to toggle.\n     */\n    toggle(layer) {\n      this.mask ^= 1 << layer | 0;\n    }\n    /**\n     * Removes membership of the given layer.\n     *\n     * @param {number} layer - The layer to enable.\n     */\n    disable(layer) {\n      this.mask &= ~(1 << layer | 0);\n    }\n    /**\n     * Removes the membership from all layers.\n     */\n    disableAll() {\n      this.mask = 0;\n    }\n    /**\n     * Returns `true` if this and the given layers object have at least one\n     * layer in common.\n     *\n     * @param {Layers} layers - The layers to test.\n     * @return {boolean } Whether this and the given layers object have at least one layer in common or not.\n     */\n    test(layers) {\n      return (this.mask & layers.mask) !== 0;\n    }\n    /**\n     * Returns `true` if the given layer is enabled.\n     *\n     * @param {number} layer - The layer to test.\n     * @return {boolean } Whether the given layer is enabled or not.\n     */\n    isEnabled(layer) {\n      return (this.mask & (1 << layer | 0)) !== 0;\n    }\n  }\n  let _object3DId = 0;\n  const _v1$4 = /* @__PURE__ */ new Vector3();\n  const _q1 = /* @__PURE__ */ new Quaternion();\n  const _m1$1 = /* @__PURE__ */ new Matrix4();\n  const _target = /* @__PURE__ */ new Vector3();\n  const _position$3 = /* @__PURE__ */ new Vector3();\n  const _scale$2 = /* @__PURE__ */ new Vector3();\n  const _quaternion$2 = /* @__PURE__ */ new Quaternion();\n  const _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);\n  const _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);\n  const _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);\n  const _addedEvent = { type: "added" };\n  const _removedEvent = { type: "removed" };\n  const _childaddedEvent = { type: "childadded", child: null };\n  const _childremovedEvent = { type: "childremoved", child: null };\n  class Object3D extends EventDispatcher {\n    /**\n     * Constructs a new 3D object.\n     */\n    constructor() {\n      super();\n      this.isObject3D = true;\n      Object.defineProperty(this, "id", { value: _object3DId++ });\n      this.uuid = generateUUID();\n      this.name = "";\n      this.type = "Object3D";\n      this.parent = null;\n      this.children = [];\n      this.up = Object3D.DEFAULT_UP.clone();\n      const position = new Vector3();\n      const rotation = new Euler();\n      const quaternion = new Quaternion();\n      const scale = new Vector3(1, 1, 1);\n      function onRotationChange() {\n        quaternion.setFromEuler(rotation, false);\n      }\n      function onQuaternionChange() {\n        rotation.setFromQuaternion(quaternion, void 0, false);\n      }\n      rotation._onChange(onRotationChange);\n      quaternion._onChange(onQuaternionChange);\n      Object.defineProperties(this, {\n        /**\n         * Represents the object\'s local position.\n         *\n         * @name Object3D#position\n         * @type {Vector3}\n         * @default (0,0,0)\n         */\n        position: {\n          configurable: true,\n          enumerable: true,\n          value: position\n        },\n        /**\n         * Represents the object\'s local rotation as Euler angles, in radians.\n         *\n         * @name Object3D#rotation\n         * @type {Euler}\n         * @default (0,0,0)\n         */\n        rotation: {\n          configurable: true,\n          enumerable: true,\n          value: rotation\n        },\n        /**\n         * Represents the object\'s local rotation as Quaternions.\n         *\n         * @name Object3D#quaternion\n         * @type {Quaternion}\n         */\n        quaternion: {\n          configurable: true,\n          enumerable: true,\n          value: quaternion\n        },\n        /**\n         * Represents the object\'s local scale.\n         *\n         * @name Object3D#scale\n         * @type {Vector3}\n         * @default (1,1,1)\n         */\n        scale: {\n          configurable: true,\n          enumerable: true,\n          value: scale\n        },\n        /**\n         * Represents the object\'s model-view matrix.\n         *\n         * @name Object3D#modelViewMatrix\n         * @type {Matrix4}\n         */\n        modelViewMatrix: {\n          value: new Matrix4()\n        },\n        /**\n         * Represents the object\'s normal matrix.\n         *\n         * @name Object3D#normalMatrix\n         * @type {Matrix3}\n         */\n        normalMatrix: {\n          value: new Matrix3()\n        }\n      });\n      this.matrix = new Matrix4();\n      this.matrixWorld = new Matrix4();\n      this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;\n      this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;\n      this.matrixWorldNeedsUpdate = false;\n      this.layers = new Layers();\n      this.visible = true;\n      this.castShadow = false;\n      this.receiveShadow = false;\n      this.frustumCulled = true;\n      this.renderOrder = 0;\n      this.animations = [];\n      this.customDepthMaterial = void 0;\n      this.customDistanceMaterial = void 0;\n      this.userData = {};\n    }\n    /**\n     * A callback that is executed immediately before a 3D object is rendered to a shadow map.\n     *\n     * @param {Renderer|WebGLRenderer} renderer - The renderer.\n     * @param {Object3D} object - The 3D object.\n     * @param {Camera} camera - The camera that is used to render the scene.\n     * @param {Camera} shadowCamera - The shadow camera.\n     * @param {BufferGeometry} geometry - The 3D object\'s geometry.\n     * @param {Material} depthMaterial - The depth material.\n     * @param {Object} group - The geometry group data.\n     */\n    onBeforeShadow() {\n    }\n    /**\n     * A callback that is executed immediately after a 3D object is rendered to a shadow map.\n     *\n     * @param {Renderer|WebGLRenderer} renderer - The renderer.\n     * @param {Object3D} object - The 3D object.\n     * @param {Camera} camera - The camera that is used to render the scene.\n     * @param {Camera} shadowCamera - The shadow camera.\n     * @param {BufferGeometry} geometry - The 3D object\'s geometry.\n     * @param {Material} depthMaterial - The depth material.\n     * @param {Object} group - The geometry group data.\n     */\n    onAfterShadow() {\n    }\n    /**\n     * A callback that is executed immediately before a 3D object is rendered.\n     *\n     * @param {Renderer|WebGLRenderer} renderer - The renderer.\n     * @param {Object3D} object - The 3D object.\n     * @param {Camera} camera - The camera that is used to render the scene.\n     * @param {BufferGeometry} geometry - The 3D object\'s geometry.\n     * @param {Material} material - The 3D object\'s material.\n     * @param {Object} group - The geometry group data.\n     */\n    onBeforeRender() {\n    }\n    /**\n     * A callback that is executed immediately after a 3D object is rendered.\n     *\n     * @param {Renderer|WebGLRenderer} renderer - The renderer.\n     * @param {Object3D} object - The 3D object.\n     * @param {Camera} camera - The camera that is used to render the scene.\n     * @param {BufferGeometry} geometry - The 3D object\'s geometry.\n     * @param {Material} material - The 3D object\'s material.\n     * @param {Object} group - The geometry group data.\n     */\n    onAfterRender() {\n    }\n    /**\n     * Applies the given transformation matrix to the object and updates the object\'s position,\n     * rotation and scale.\n     *\n     * @param {Matrix4} matrix - The transformation matrix.\n     */\n    applyMatrix4(matrix) {\n      if (this.matrixAutoUpdate) this.updateMatrix();\n      this.matrix.premultiply(matrix);\n      this.matrix.decompose(this.position, this.quaternion, this.scale);\n    }\n    /**\n     * Applies a rotation represented by given the quaternion to the 3D object.\n     *\n     * @param {Quaternion} q - The quaternion.\n     * @return {Object3D} A reference to this instance.\n     */\n    applyQuaternion(q) {\n      this.quaternion.premultiply(q);\n      return this;\n    }\n    /**\n     * Sets the given rotation represented as an axis/angle couple to the 3D object.\n     *\n     * @param {Vector3} axis - The (normalized) axis vector.\n     * @param {number} angle - The angle in radians.\n     */\n    setRotationFromAxisAngle(axis, angle) {\n      this.quaternion.setFromAxisAngle(axis, angle);\n    }\n    /**\n     * Sets the given rotation represented as Euler angles to the 3D object.\n     *\n     * @param {Euler} euler - The Euler angles.\n     */\n    setRotationFromEuler(euler) {\n      this.quaternion.setFromEuler(euler, true);\n    }\n    /**\n     * Sets the given rotation represented as rotation matrix to the 3D object.\n     *\n     * @param {Matrix4} m - Although a 4x4 matrix is expected, the upper 3x3 portion must be\n     * a pure rotation matrix (i.e, unscaled).\n     */\n    setRotationFromMatrix(m) {\n      this.quaternion.setFromRotationMatrix(m);\n    }\n    /**\n     * Sets the given rotation represented as a Quaternion to the 3D object.\n     *\n     * @param {Quaternion} q - The Quaternion\n     */\n    setRotationFromQuaternion(q) {\n      this.quaternion.copy(q);\n    }\n    /**\n     * Rotates the 3D object along an axis in local space.\n     *\n     * @param {Vector3} axis - The (normalized) axis vector.\n     * @param {number} angle - The angle in radians.\n     * @return {Object3D} A reference to this instance.\n     */\n    rotateOnAxis(axis, angle) {\n      _q1.setFromAxisAngle(axis, angle);\n      this.quaternion.multiply(_q1);\n      return this;\n    }\n    /**\n     * Rotates the 3D object along an axis in world space.\n     *\n     * @param {Vector3} axis - The (normalized) axis vector.\n     * @param {number} angle - The angle in radians.\n     * @return {Object3D} A reference to this instance.\n     */\n    rotateOnWorldAxis(axis, angle) {\n      _q1.setFromAxisAngle(axis, angle);\n      this.quaternion.premultiply(_q1);\n      return this;\n    }\n    /**\n     * Rotates the 3D object around its X axis in local space.\n     *\n     * @param {number} angle - The angle in radians.\n     * @return {Object3D} A reference to this instance.\n     */\n    rotateX(angle) {\n      return this.rotateOnAxis(_xAxis, angle);\n    }\n    /**\n     * Rotates the 3D object around its Y axis in local space.\n     *\n     * @param {number} angle - The angle in radians.\n     * @return {Object3D} A reference to this instance.\n     */\n    rotateY(angle) {\n      return this.rotateOnAxis(_yAxis, angle);\n    }\n    /**\n     * Rotates the 3D object around its Z axis in local space.\n     *\n     * @param {number} angle - The angle in radians.\n     * @return {Object3D} A reference to this instance.\n     */\n    rotateZ(angle) {\n      return this.rotateOnAxis(_zAxis, angle);\n    }\n    /**\n     * Translate the 3D object by a distance along the given axis in local space.\n     *\n     * @param {Vector3} axis - The (normalized) axis vector.\n     * @param {number} distance - The distance in world units.\n     * @return {Object3D} A reference to this instance.\n     */\n    translateOnAxis(axis, distance) {\n      _v1$4.copy(axis).applyQuaternion(this.quaternion);\n      this.position.add(_v1$4.multiplyScalar(distance));\n      return this;\n    }\n    /**\n     * Translate the 3D object by a distance along its X-axis in local space.\n     *\n     * @param {number} distance - The distance in world units.\n     * @return {Object3D} A reference to this instance.\n     */\n    translateX(distance) {\n      return this.translateOnAxis(_xAxis, distance);\n    }\n    /**\n     * Translate the 3D object by a distance along its Y-axis in local space.\n     *\n     * @param {number} distance - The distance in world units.\n     * @return {Object3D} A reference to this instance.\n     */\n    translateY(distance) {\n      return this.translateOnAxis(_yAxis, distance);\n    }\n    /**\n     * Translate the 3D object by a distance along its Z-axis in local space.\n     *\n     * @param {number} distance - The distance in world units.\n     * @return {Object3D} A reference to this instance.\n     */\n    translateZ(distance) {\n      return this.translateOnAxis(_zAxis, distance);\n    }\n    /**\n     * Converts the given vector from this 3D object\'s local space to world space.\n     *\n     * @param {Vector3} vector - The vector to convert.\n     * @return {Vector3} The converted vector.\n     */\n    localToWorld(vector) {\n      this.updateWorldMatrix(true, false);\n      return vector.applyMatrix4(this.matrixWorld);\n    }\n    /**\n     * Converts the given vector from this 3D object\'s word space to local space.\n     *\n     * @param {Vector3} vector - The vector to convert.\n     * @return {Vector3} The converted vector.\n     */\n    worldToLocal(vector) {\n      this.updateWorldMatrix(true, false);\n      return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());\n    }\n    /**\n     * Rotates the object to face a point in world space.\n     *\n     * This method does not support objects having non-uniformly-scaled parent(s).\n     *\n     * @param {number|Vector3} x - The x coordinate in world space. Alternatively, a vector representing a position in world space\n     * @param {number} [y] - The y coordinate in world space.\n     * @param {number} [z] - The z coordinate in world space.\n     */\n    lookAt(x2, y, z) {\n      if (x2.isVector3) {\n        _target.copy(x2);\n      } else {\n        _target.set(x2, y, z);\n      }\n      const parent = this.parent;\n      this.updateWorldMatrix(true, false);\n      _position$3.setFromMatrixPosition(this.matrixWorld);\n      if (this.isCamera || this.isLight) {\n        _m1$1.lookAt(_position$3, _target, this.up);\n      } else {\n        _m1$1.lookAt(_target, _position$3, this.up);\n      }\n      this.quaternion.setFromRotationMatrix(_m1$1);\n      if (parent) {\n        _m1$1.extractRotation(parent.matrixWorld);\n        _q1.setFromRotationMatrix(_m1$1);\n        this.quaternion.premultiply(_q1.invert());\n      }\n    }\n    /**\n     * Adds the given 3D object as a child to this 3D object. An arbitrary number of\n     * objects may be added. Any current parent on an object passed in here will be\n     * removed, since an object can have at most one parent.\n     *\n     * @fires Object3D#added\n     * @fires Object3D#childadded\n     * @param {Object3D} object - The 3D object to add.\n     * @return {Object3D} A reference to this instance.\n     */\n    add(object) {\n      if (arguments.length > 1) {\n        for (let i2 = 0; i2 < arguments.length; i2++) {\n          this.add(arguments[i2]);\n        }\n        return this;\n      }\n      if (object === this) {\n        console.error("THREE.Object3D.add: object can\'t be added as a child of itself.", object);\n        return this;\n      }\n      if (object && object.isObject3D) {\n        object.removeFromParent();\n        object.parent = this;\n        this.children.push(object);\n        object.dispatchEvent(_addedEvent);\n        _childaddedEvent.child = object;\n        this.dispatchEvent(_childaddedEvent);\n        _childaddedEvent.child = null;\n      } else {\n        console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);\n      }\n      return this;\n    }\n    /**\n     * Removes the given 3D object as child from this 3D object.\n     * An arbitrary number of objects may be removed.\n     *\n     * @fires Object3D#removed\n     * @fires Object3D#childremoved\n     * @param {Object3D} object - The 3D object to remove.\n     * @return {Object3D} A reference to this instance.\n     */\n    remove(object) {\n      if (arguments.length > 1) {\n        for (let i2 = 0; i2 < arguments.length; i2++) {\n          this.remove(arguments[i2]);\n        }\n        return this;\n      }\n      const index = this.children.indexOf(object);\n      if (index !== -1) {\n        object.parent = null;\n        this.children.splice(index, 1);\n        object.dispatchEvent(_removedEvent);\n        _childremovedEvent.child = object;\n        this.dispatchEvent(_childremovedEvent);\n        _childremovedEvent.child = null;\n      }\n      return this;\n    }\n    /**\n     * Removes this 3D object from its current parent.\n     *\n     * @fires Object3D#removed\n     * @fires Object3D#childremoved\n     * @return {Object3D} A reference to this instance.\n     */\n    removeFromParent() {\n      const parent = this.parent;\n      if (parent !== null) {\n        parent.remove(this);\n      }\n      return this;\n    }\n    /**\n     * Removes all child objects.\n     *\n     * @fires Object3D#removed\n     * @fires Object3D#childremoved\n     * @return {Object3D} A reference to this instance.\n     */\n    clear() {\n      return this.remove(...this.children);\n    }\n    /**\n     * Adds the given 3D object as a child of this 3D object, while maintaining the object\'s world\n     * transform. This method does not support scene graphs having non-uniformly-scaled nodes(s).\n     *\n     * @fires Object3D#added\n     * @fires Object3D#childadded\n     * @param {Object3D} object - The 3D object to attach.\n     * @return {Object3D} A reference to this instance.\n     */\n    attach(object) {\n      this.updateWorldMatrix(true, false);\n      _m1$1.copy(this.matrixWorld).invert();\n      if (object.parent !== null) {\n        object.parent.updateWorldMatrix(true, false);\n        _m1$1.multiply(object.parent.matrixWorld);\n      }\n      object.applyMatrix4(_m1$1);\n      object.removeFromParent();\n      object.parent = this;\n      this.children.push(object);\n      object.updateWorldMatrix(false, true);\n      object.dispatchEvent(_addedEvent);\n      _childaddedEvent.child = object;\n      this.dispatchEvent(_childaddedEvent);\n      _childaddedEvent.child = null;\n      return this;\n    }\n    /**\n     * Searches through the 3D object and its children, starting with the 3D object\n     * itself, and returns the first with a matching ID.\n     *\n     * @param {number} id - The id.\n     * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.\n     */\n    getObjectById(id) {\n      return this.getObjectByProperty("id", id);\n    }\n    /**\n     * Searches through the 3D object and its children, starting with the 3D object\n     * itself, and returns the first with a matching name.\n     *\n     * @param {string} name - The name.\n     * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.\n     */\n    getObjectByName(name) {\n      return this.getObjectByProperty("name", name);\n    }\n    /**\n     * Searches through the 3D object and its children, starting with the 3D object\n     * itself, and returns the first with a matching property value.\n     *\n     * @param {string} name - The name of the property.\n     * @param {any} value - The value.\n     * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.\n     */\n    getObjectByProperty(name, value) {\n      if (this[name] === value) return this;\n      for (let i2 = 0, l = this.children.length; i2 < l; i2++) {\n        const child = this.children[i2];\n        const object = child.getObjectByProperty(name, value);\n        if (object !== void 0) {\n          return object;\n        }\n      }\n      return void 0;\n    }\n    /**\n     * Searches through the 3D object and its children, starting with the 3D object\n     * itself, and returns all 3D objects with a matching property value.\n     *\n     * @param {string} name - The name of the property.\n     * @param {any} value - The value.\n     * @param {Array<Object3D>} result - The method stores the result in this array.\n     * @return {Array<Object3D>} The found 3D objects.\n     */\n    getObjectsByProperty(name, value, result = []) {\n      if (this[name] === value) result.push(this);\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        children[i2].getObjectsByProperty(name, value, result);\n      }\n      return result;\n    }\n    /**\n     * Returns a vector representing the position of the 3D object in world space.\n     *\n     * @param {Vector3} target - The target vector the result is stored to.\n     * @return {Vector3} The 3D object\'s position in world space.\n     */\n    getWorldPosition(target) {\n      this.updateWorldMatrix(true, false);\n      return target.setFromMatrixPosition(this.matrixWorld);\n    }\n    /**\n     * Returns a Quaternion representing the position of the 3D object in world space.\n     *\n     * @param {Quaternion} target - The target Quaternion the result is stored to.\n     * @return {Quaternion} The 3D object\'s rotation in world space.\n     */\n    getWorldQuaternion(target) {\n      this.updateWorldMatrix(true, false);\n      this.matrixWorld.decompose(_position$3, target, _scale$2);\n      return target;\n    }\n    /**\n     * Returns a vector representing the scale of the 3D object in world space.\n     *\n     * @param {Vector3} target - The target vector the result is stored to.\n     * @return {Vector3} The 3D object\'s scale in world space.\n     */\n    getWorldScale(target) {\n      this.updateWorldMatrix(true, false);\n      this.matrixWorld.decompose(_position$3, _quaternion$2, target);\n      return target;\n    }\n    /**\n     * Returns a vector representing the ("look") direction of the 3D object in world space.\n     *\n     * @param {Vector3} target - The target vector the result is stored to.\n     * @return {Vector3} The 3D object\'s direction in world space.\n     */\n    getWorldDirection(target) {\n      this.updateWorldMatrix(true, false);\n      const e = this.matrixWorld.elements;\n      return target.set(e[8], e[9], e[10]).normalize();\n    }\n    /**\n     * Abstract method to get intersections between a casted ray and this\n     * 3D object. Renderable 3D objects such as {@link Mesh}, {@link Line} or {@link Points}\n     * implement this method in order to use raycasting.\n     *\n     * @abstract\n     * @param {Raycaster} raycaster - The raycaster.\n     * @param {Array<Object>} intersects - An array holding the result of the method.\n     */\n    raycast() {\n    }\n    /**\n     * Executes the callback on this 3D object and all descendants.\n     *\n     * Note: Modifying the scene graph inside the callback is discouraged.\n     *\n     * @param {Function} callback - A callback function that allows to process the current 3D object.\n     */\n    traverse(callback) {\n      callback(this);\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        children[i2].traverse(callback);\n      }\n    }\n    /**\n     * Like {@link Object3D#traverse}, but the callback will only be executed for visible 3D objects.\n     * Descendants of invisible 3D objects are not traversed.\n     *\n     * Note: Modifying the scene graph inside the callback is discouraged.\n     *\n     * @param {Function} callback - A callback function that allows to process the current 3D object.\n     */\n    traverseVisible(callback) {\n      if (this.visible === false) return;\n      callback(this);\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        children[i2].traverseVisible(callback);\n      }\n    }\n    /**\n     * Like {@link Object3D#traverse}, but the callback will only be executed for all ancestors.\n     *\n     * Note: Modifying the scene graph inside the callback is discouraged.\n     *\n     * @param {Function} callback - A callback function that allows to process the current 3D object.\n     */\n    traverseAncestors(callback) {\n      const parent = this.parent;\n      if (parent !== null) {\n        callback(parent);\n        parent.traverseAncestors(callback);\n      }\n    }\n    /**\n     * Updates the transformation matrix in local space by computing it from the current\n     * position, rotation and scale values.\n     */\n    updateMatrix() {\n      this.matrix.compose(this.position, this.quaternion, this.scale);\n      this.matrixWorldNeedsUpdate = true;\n    }\n    /**\n     * Updates the transformation matrix in world space of this 3D objects and its descendants.\n     *\n     * To ensure correct results, this method also recomputes the 3D object\'s transformation matrix in\n     * local space. The computation of the local and world matrix can be controlled with the\n     * {@link Object3D#matrixAutoUpdate} and {@link Object3D#matrixWorldAutoUpdate} flags which are both\n     * `true` by default.  Set these flags to `false` if you need more control over the update matrix process.\n     *\n     * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even\n     * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.\n     */\n    updateMatrixWorld(force) {\n      if (this.matrixAutoUpdate) this.updateMatrix();\n      if (this.matrixWorldNeedsUpdate || force) {\n        if (this.matrixWorldAutoUpdate === true) {\n          if (this.parent === null) {\n            this.matrixWorld.copy(this.matrix);\n          } else {\n            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n          }\n        }\n        this.matrixWorldNeedsUpdate = false;\n        force = true;\n      }\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        const child = children[i2];\n        child.updateMatrixWorld(force);\n      }\n    }\n    /**\n     * An alternative version of {@link Object3D#updateMatrixWorld} with more control over the\n     * update of ancestor and descendant nodes.\n     *\n     * @param {boolean} [updateParents=false] Whether ancestor nodes should be updated or not.\n     * @param {boolean} [updateChildren=false] Whether descendant nodes should be updated or not.\n     */\n    updateWorldMatrix(updateParents, updateChildren) {\n      const parent = this.parent;\n      if (updateParents === true && parent !== null) {\n        parent.updateWorldMatrix(true, false);\n      }\n      if (this.matrixAutoUpdate) this.updateMatrix();\n      if (this.matrixWorldAutoUpdate === true) {\n        if (this.parent === null) {\n          this.matrixWorld.copy(this.matrix);\n        } else {\n          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n        }\n      }\n      if (updateChildren === true) {\n        const children = this.children;\n        for (let i2 = 0, l = children.length; i2 < l; i2++) {\n          const child = children[i2];\n          child.updateWorldMatrix(false, true);\n        }\n      }\n    }\n    /**\n     * Serializes the 3D object into JSON.\n     *\n     * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.\n     * @return {Object} A JSON object representing the serialized 3D object.\n     * @see {@link ObjectLoader#parse}\n     */\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === "string";\n      const output = {};\n      if (isRootObject) {\n        meta = {\n          geometries: {},\n          materials: {},\n          textures: {},\n          images: {},\n          shapes: {},\n          skeletons: {},\n          animations: {},\n          nodes: {}\n        };\n        output.metadata = {\n          version: 4.7,\n          type: "Object",\n          generator: "Object3D.toJSON"\n        };\n      }\n      const object = {};\n      object.uuid = this.uuid;\n      object.type = this.type;\n      if (this.name !== "") object.name = this.name;\n      if (this.castShadow === true) object.castShadow = true;\n      if (this.receiveShadow === true) object.receiveShadow = true;\n      if (this.visible === false) object.visible = false;\n      if (this.frustumCulled === false) object.frustumCulled = false;\n      if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;\n      if (Object.keys(this.userData).length > 0) object.userData = this.userData;\n      object.layers = this.layers.mask;\n      object.matrix = this.matrix.toArray();\n      object.up = this.up.toArray();\n      if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;\n      if (this.isInstancedMesh) {\n        object.type = "InstancedMesh";\n        object.count = this.count;\n        object.instanceMatrix = this.instanceMatrix.toJSON();\n        if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();\n      }\n      if (this.isBatchedMesh) {\n        object.type = "BatchedMesh";\n        object.perObjectFrustumCulled = this.perObjectFrustumCulled;\n        object.sortObjects = this.sortObjects;\n        object.drawRanges = this._drawRanges;\n        object.reservedRanges = this._reservedRanges;\n        object.geometryInfo = this._geometryInfo.map((info) => ({\n          ...info,\n          boundingBox: info.boundingBox ? info.boundingBox.toJSON() : void 0,\n          boundingSphere: info.boundingSphere ? info.boundingSphere.toJSON() : void 0\n        }));\n        object.instanceInfo = this._instanceInfo.map((info) => ({ ...info }));\n        object.availableInstanceIds = this._availableInstanceIds.slice();\n        object.availableGeometryIds = this._availableGeometryIds.slice();\n        object.nextIndexStart = this._nextIndexStart;\n        object.nextVertexStart = this._nextVertexStart;\n        object.geometryCount = this._geometryCount;\n        object.maxInstanceCount = this._maxInstanceCount;\n        object.maxVertexCount = this._maxVertexCount;\n        object.maxIndexCount = this._maxIndexCount;\n        object.geometryInitialized = this._geometryInitialized;\n        object.matricesTexture = this._matricesTexture.toJSON(meta);\n        object.indirectTexture = this._indirectTexture.toJSON(meta);\n        if (this._colorsTexture !== null) {\n          object.colorsTexture = this._colorsTexture.toJSON(meta);\n        }\n        if (this.boundingSphere !== null) {\n          object.boundingSphere = this.boundingSphere.toJSON();\n        }\n        if (this.boundingBox !== null) {\n          object.boundingBox = this.boundingBox.toJSON();\n        }\n      }\n      function serialize(library, element) {\n        if (library[element.uuid] === void 0) {\n          library[element.uuid] = element.toJSON(meta);\n        }\n        return element.uuid;\n      }\n      if (this.isScene) {\n        if (this.background) {\n          if (this.background.isColor) {\n            object.background = this.background.toJSON();\n          } else if (this.background.isTexture) {\n            object.background = this.background.toJSON(meta).uuid;\n          }\n        }\n        if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {\n          object.environment = this.environment.toJSON(meta).uuid;\n        }\n      } else if (this.isMesh || this.isLine || this.isPoints) {\n        object.geometry = serialize(meta.geometries, this.geometry);\n        const parameters = this.geometry.parameters;\n        if (parameters !== void 0 && parameters.shapes !== void 0) {\n          const shapes = parameters.shapes;\n          if (Array.isArray(shapes)) {\n            for (let i2 = 0, l = shapes.length; i2 < l; i2++) {\n              const shape = shapes[i2];\n              serialize(meta.shapes, shape);\n            }\n          } else {\n            serialize(meta.shapes, shapes);\n          }\n        }\n      }\n      if (this.isSkinnedMesh) {\n        object.bindMode = this.bindMode;\n        object.bindMatrix = this.bindMatrix.toArray();\n        if (this.skeleton !== void 0) {\n          serialize(meta.skeletons, this.skeleton);\n          object.skeleton = this.skeleton.uuid;\n        }\n      }\n      if (this.material !== void 0) {\n        if (Array.isArray(this.material)) {\n          const uuids = [];\n          for (let i2 = 0, l = this.material.length; i2 < l; i2++) {\n            uuids.push(serialize(meta.materials, this.material[i2]));\n          }\n          object.material = uuids;\n        } else {\n          object.material = serialize(meta.materials, this.material);\n        }\n      }\n      if (this.children.length > 0) {\n        object.children = [];\n        for (let i2 = 0; i2 < this.children.length; i2++) {\n          object.children.push(this.children[i2].toJSON(meta).object);\n        }\n      }\n      if (this.animations.length > 0) {\n        object.animations = [];\n        for (let i2 = 0; i2 < this.animations.length; i2++) {\n          const animation = this.animations[i2];\n          object.animations.push(serialize(meta.animations, animation));\n        }\n      }\n      if (isRootObject) {\n        const geometries = extractFromCache(meta.geometries);\n        const materials = extractFromCache(meta.materials);\n        const textures = extractFromCache(meta.textures);\n        const images = extractFromCache(meta.images);\n        const shapes = extractFromCache(meta.shapes);\n        const skeletons = extractFromCache(meta.skeletons);\n        const animations = extractFromCache(meta.animations);\n        const nodes = extractFromCache(meta.nodes);\n        if (geometries.length > 0) output.geometries = geometries;\n        if (materials.length > 0) output.materials = materials;\n        if (textures.length > 0) output.textures = textures;\n        if (images.length > 0) output.images = images;\n        if (shapes.length > 0) output.shapes = shapes;\n        if (skeletons.length > 0) output.skeletons = skeletons;\n        if (animations.length > 0) output.animations = animations;\n        if (nodes.length > 0) output.nodes = nodes;\n      }\n      output.object = object;\n      return output;\n      function extractFromCache(cache) {\n        const values = [];\n        for (const key in cache) {\n          const data = cache[key];\n          delete data.metadata;\n          values.push(data);\n        }\n        return values;\n      }\n    }\n    /**\n     * Returns a new 3D object with copied values from this instance.\n     *\n     * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are also cloned.\n     * @return {Object3D} A clone of this instance.\n     */\n    clone(recursive) {\n      return new this.constructor().copy(this, recursive);\n    }\n    /**\n     * Copies the values of the given 3D object to this instance.\n     *\n     * @param {Object3D} source - The 3D object to copy.\n     * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are cloned.\n     * @return {Object3D} A reference to this instance.\n     */\n    copy(source, recursive = true) {\n      this.name = source.name;\n      this.up.copy(source.up);\n      this.position.copy(source.position);\n      this.rotation.order = source.rotation.order;\n      this.quaternion.copy(source.quaternion);\n      this.scale.copy(source.scale);\n      this.matrix.copy(source.matrix);\n      this.matrixWorld.copy(source.matrixWorld);\n      this.matrixAutoUpdate = source.matrixAutoUpdate;\n      this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;\n      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n      this.layers.mask = source.layers.mask;\n      this.visible = source.visible;\n      this.castShadow = source.castShadow;\n      this.receiveShadow = source.receiveShadow;\n      this.frustumCulled = source.frustumCulled;\n      this.renderOrder = source.renderOrder;\n      this.animations = source.animations.slice();\n      this.userData = JSON.parse(JSON.stringify(source.userData));\n      if (recursive === true) {\n        for (let i2 = 0; i2 < source.children.length; i2++) {\n          const child = source.children[i2];\n          this.add(child.clone());\n        }\n      }\n      return this;\n    }\n  }\n  Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);\n  Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;\n  Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;\n  const _v0$1 = /* @__PURE__ */ new Vector3();\n  const _v1$3 = /* @__PURE__ */ new Vector3();\n  const _v2$2 = /* @__PURE__ */ new Vector3();\n  const _v3$2 = /* @__PURE__ */ new Vector3();\n  const _vab = /* @__PURE__ */ new Vector3();\n  const _vac = /* @__PURE__ */ new Vector3();\n  const _vbc = /* @__PURE__ */ new Vector3();\n  const _vap = /* @__PURE__ */ new Vector3();\n  const _vbp = /* @__PURE__ */ new Vector3();\n  const _vcp = /* @__PURE__ */ new Vector3();\n  const _v40 = /* @__PURE__ */ new Vector4();\n  const _v41 = /* @__PURE__ */ new Vector4();\n  const _v42 = /* @__PURE__ */ new Vector4();\n  class Triangle {\n    /**\n     * Constructs a new triangle.\n     *\n     * @param {Vector3} [a=(0,0,0)] - The first corner of the triangle.\n     * @param {Vector3} [b=(0,0,0)] - The second corner of the triangle.\n     * @param {Vector3} [c=(0,0,0)] - The third corner of the triangle.\n     */\n    constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n    /**\n     * Computes the normal vector of a triangle.\n     *\n     * @param {Vector3} a - The first corner of the triangle.\n     * @param {Vector3} b - The second corner of the triangle.\n     * @param {Vector3} c - The third corner of the triangle.\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {Vector3} The triangle\'s normal.\n     */\n    static getNormal(a, b, c, target) {\n      target.subVectors(c, b);\n      _v0$1.subVectors(a, b);\n      target.cross(_v0$1);\n      const targetLengthSq = target.lengthSq();\n      if (targetLengthSq > 0) {\n        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));\n      }\n      return target.set(0, 0, 0);\n    }\n    /**\n     * Computes a barycentric coordinates from the given vector.\n     * Returns `null` if the triangle is degenerate.\n     *\n     * @param {Vector3} point - A point in 3D space.\n     * @param {Vector3} a - The first corner of the triangle.\n     * @param {Vector3} b - The second corner of the triangle.\n     * @param {Vector3} c - The third corner of the triangle.\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {?Vector3} The barycentric coordinates for the given point\n     */\n    static getBarycoord(point, a, b, c, target) {\n      _v0$1.subVectors(c, a);\n      _v1$3.subVectors(b, a);\n      _v2$2.subVectors(point, a);\n      const dot00 = _v0$1.dot(_v0$1);\n      const dot01 = _v0$1.dot(_v1$3);\n      const dot02 = _v0$1.dot(_v2$2);\n      const dot11 = _v1$3.dot(_v1$3);\n      const dot12 = _v1$3.dot(_v2$2);\n      const denom = dot00 * dot11 - dot01 * dot01;\n      if (denom === 0) {\n        target.set(0, 0, 0);\n        return null;\n      }\n      const invDenom = 1 / denom;\n      const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n      const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n      return target.set(1 - u - v, v, u);\n    }\n    /**\n     * Returns `true` if the given point, when projected onto the plane of the\n     * triangle, lies within the triangle.\n     *\n     * @param {Vector3} point - The point in 3D space to test.\n     * @param {Vector3} a - The first corner of the triangle.\n     * @param {Vector3} b - The second corner of the triangle.\n     * @param {Vector3} c - The third corner of the triangle.\n     * @return {boolean} Whether the given point, when projected onto the plane of the\n     * triangle, lies within the triangle or not.\n     */\n    static containsPoint(point, a, b, c) {\n      if (this.getBarycoord(point, a, b, c, _v3$2) === null) {\n        return false;\n      }\n      return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;\n    }\n    /**\n     * Computes the value barycentrically interpolated for the given point on the\n     * triangle. Returns `null` if the triangle is degenerate.\n     *\n     * @param {Vector3} point - Position of interpolated point.\n     * @param {Vector3} p1 - The first corner of the triangle.\n     * @param {Vector3} p2 - The second corner of the triangle.\n     * @param {Vector3} p3 - The third corner of the triangle.\n     * @param {Vector3} v1 - Value to interpolate of first vertex.\n     * @param {Vector3} v2 - Value to interpolate of second vertex.\n     * @param {Vector3} v3 - Value to interpolate of third vertex.\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {?Vector3} The interpolated value.\n     */\n    static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {\n      if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {\n        target.x = 0;\n        target.y = 0;\n        if ("z" in target) target.z = 0;\n        if ("w" in target) target.w = 0;\n        return null;\n      }\n      target.setScalar(0);\n      target.addScaledVector(v1, _v3$2.x);\n      target.addScaledVector(v2, _v3$2.y);\n      target.addScaledVector(v3, _v3$2.z);\n      return target;\n    }\n    /**\n     * Computes the value barycentrically interpolated for the given attribute and indices.\n     *\n     * @param {BufferAttribute} attr - The attribute to interpolate.\n     * @param {number} i1 - Index of first vertex.\n     * @param {number} i2 - Index of second vertex.\n     * @param {number} i3 - Index of third vertex.\n     * @param {Vector3} barycoord - The barycoordinate value to use to interpolate.\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {Vector3} The interpolated attribute value.\n     */\n    static getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) {\n      _v40.setScalar(0);\n      _v41.setScalar(0);\n      _v42.setScalar(0);\n      _v40.fromBufferAttribute(attr, i1);\n      _v41.fromBufferAttribute(attr, i2);\n      _v42.fromBufferAttribute(attr, i3);\n      target.setScalar(0);\n      target.addScaledVector(_v40, barycoord.x);\n      target.addScaledVector(_v41, barycoord.y);\n      target.addScaledVector(_v42, barycoord.z);\n      return target;\n    }\n    /**\n     * Returns `true` if the triangle is oriented towards the given direction.\n     *\n     * @param {Vector3} a - The first corner of the triangle.\n     * @param {Vector3} b - The second corner of the triangle.\n     * @param {Vector3} c - The third corner of the triangle.\n     * @param {Vector3} direction - The (normalized) direction vector.\n     * @return {boolean} Whether the triangle is oriented towards the given direction or not.\n     */\n    static isFrontFacing(a, b, c, direction) {\n      _v0$1.subVectors(c, b);\n      _v1$3.subVectors(a, b);\n      return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;\n    }\n    /**\n     * Sets the triangle\'s vertices by copying the given values.\n     *\n     * @param {Vector3} a - The first corner of the triangle.\n     * @param {Vector3} b - The second corner of the triangle.\n     * @param {Vector3} c - The third corner of the triangle.\n     * @return {Triangle} A reference to this triangle.\n     */\n    set(a, b, c) {\n      this.a.copy(a);\n      this.b.copy(b);\n      this.c.copy(c);\n      return this;\n    }\n    /**\n     * Sets the triangle\'s vertices by copying the given array values.\n     *\n     * @param {Array<Vector3>} points - An array with 3D points.\n     * @param {number} i0 - The array index representing the first corner of the triangle.\n     * @param {number} i1 - The array index representing the second corner of the triangle.\n     * @param {number} i2 - The array index representing the third corner of the triangle.\n     * @return {Triangle} A reference to this triangle.\n     */\n    setFromPointsAndIndices(points, i0, i1, i2) {\n      this.a.copy(points[i0]);\n      this.b.copy(points[i1]);\n      this.c.copy(points[i2]);\n      return this;\n    }\n    /**\n     * Sets the triangle\'s vertices by copying the given attribute values.\n     *\n     * @param {BufferAttribute} attribute - A buffer attribute with 3D points data.\n     * @param {number} i0 - The attribute index representing the first corner of the triangle.\n     * @param {number} i1 - The attribute index representing the second corner of the triangle.\n     * @param {number} i2 - The attribute index representing the third corner of the triangle.\n     * @return {Triangle} A reference to this triangle.\n     */\n    setFromAttributeAndIndices(attribute, i0, i1, i2) {\n      this.a.fromBufferAttribute(attribute, i0);\n      this.b.fromBufferAttribute(attribute, i1);\n      this.c.fromBufferAttribute(attribute, i2);\n      return this;\n    }\n    /**\n     * Returns a new triangle with copied values from this instance.\n     *\n     * @return {Triangle} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    /**\n     * Copies the values of the given triangle to this instance.\n     *\n     * @param {Triangle} triangle - The triangle to copy.\n     * @return {Triangle} A reference to this triangle.\n     */\n    copy(triangle) {\n      this.a.copy(triangle.a);\n      this.b.copy(triangle.b);\n      this.c.copy(triangle.c);\n      return this;\n    }\n    /**\n     * Computes the area of the triangle.\n     *\n     * @return {number} The triangle\'s area.\n     */\n    getArea() {\n      _v0$1.subVectors(this.c, this.b);\n      _v1$3.subVectors(this.a, this.b);\n      return _v0$1.cross(_v1$3).length() * 0.5;\n    }\n    /**\n     * Computes the midpoint of the triangle.\n     *\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {Vector3} The triangle\'s midpoint.\n     */\n    getMidpoint(target) {\n      return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\n    }\n    /**\n     * Computes the normal of the triangle.\n     *\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {Vector3} The triangle\'s normal.\n     */\n    getNormal(target) {\n      return Triangle.getNormal(this.a, this.b, this.c, target);\n    }\n    /**\n     * Computes a plane the triangle lies within.\n     *\n     * @param {Plane} target - The target vector that is used to store the method\'s result.\n     * @return {Plane} The plane the triangle lies within.\n     */\n    getPlane(target) {\n      return target.setFromCoplanarPoints(this.a, this.b, this.c);\n    }\n    /**\n     * Computes a barycentric coordinates from the given vector.\n     * Returns `null` if the triangle is degenerate.\n     *\n     * @param {Vector3} point - A point in 3D space.\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {?Vector3} The barycentric coordinates for the given point\n     */\n    getBarycoord(point, target) {\n      return Triangle.getBarycoord(point, this.a, this.b, this.c, target);\n    }\n    /**\n     * Computes the value barycentrically interpolated for the given point on the\n     * triangle. Returns `null` if the triangle is degenerate.\n     *\n     * @param {Vector3} point - Position of interpolated point.\n     * @param {Vector3} v1 - Value to interpolate of first vertex.\n     * @param {Vector3} v2 - Value to interpolate of second vertex.\n     * @param {Vector3} v3 - Value to interpolate of third vertex.\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {?Vector3} The interpolated value.\n     */\n    getInterpolation(point, v1, v2, v3, target) {\n      return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);\n    }\n    /**\n     * Returns `true` if the given point, when projected onto the plane of the\n     * triangle, lies within the triangle.\n     *\n     * @param {Vector3} point - The point in 3D space to test.\n     * @return {boolean} Whether the given point, when projected onto the plane of the\n     * triangle, lies within the triangle or not.\n     */\n    containsPoint(point) {\n      return Triangle.containsPoint(point, this.a, this.b, this.c);\n    }\n    /**\n     * Returns `true` if the triangle is oriented towards the given direction.\n     *\n     * @param {Vector3} direction - The (normalized) direction vector.\n     * @return {boolean} Whether the triangle is oriented towards the given direction or not.\n     */\n    isFrontFacing(direction) {\n      return Triangle.isFrontFacing(this.a, this.b, this.c, direction);\n    }\n    /**\n     * Returns `true` if this triangle intersects with the given box.\n     *\n     * @param {Box3} box - The box to intersect.\n     * @return {boolean} Whether this triangle intersects with the given box or not.\n     */\n    intersectsBox(box) {\n      return box.intersectsTriangle(this);\n    }\n    /**\n     * Returns the closest point on the triangle to the given point.\n     *\n     * @param {Vector3} p - The point to compute the closest point for.\n     * @param {Vector3} target - The target vector that is used to store the method\'s result.\n     * @return {Vector3} The closest point on the triangle.\n     */\n    closestPointToPoint(p, target) {\n      const a = this.a, b = this.b, c = this.c;\n      let v, w;\n      _vab.subVectors(b, a);\n      _vac.subVectors(c, a);\n      _vap.subVectors(p, a);\n      const d1 = _vab.dot(_vap);\n      const d2 = _vac.dot(_vap);\n      if (d1 <= 0 && d2 <= 0) {\n        return target.copy(a);\n      }\n      _vbp.subVectors(p, b);\n      const d3 = _vab.dot(_vbp);\n      const d4 = _vac.dot(_vbp);\n      if (d3 >= 0 && d4 <= d3) {\n        return target.copy(b);\n      }\n      const vc = d1 * d4 - d3 * d2;\n      if (vc <= 0 && d1 >= 0 && d3 <= 0) {\n        v = d1 / (d1 - d3);\n        return target.copy(a).addScaledVector(_vab, v);\n      }\n      _vcp.subVectors(p, c);\n      const d5 = _vab.dot(_vcp);\n      const d6 = _vac.dot(_vcp);\n      if (d6 >= 0 && d5 <= d6) {\n        return target.copy(c);\n      }\n      const vb = d5 * d2 - d1 * d6;\n      if (vb <= 0 && d2 >= 0 && d6 <= 0) {\n        w = d2 / (d2 - d6);\n        return target.copy(a).addScaledVector(_vac, w);\n      }\n      const va = d3 * d6 - d5 * d4;\n      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {\n        _vbc.subVectors(c, b);\n        w = (d4 - d3) / (d4 - d3 + (d5 - d6));\n        return target.copy(b).addScaledVector(_vbc, w);\n      }\n      const denom = 1 / (va + vb + vc);\n      v = vb * denom;\n      w = vc * denom;\n      return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);\n    }\n    /**\n     * Returns `true` if this triangle is equal with the given one.\n     *\n     * @param {Triangle} triangle - The triangle to test for equality.\n     * @return {boolean} Whether this triangle is equal with the given one.\n     */\n    equals(triangle) {\n      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);\n    }\n  }\n  const _colorKeywords = {\n    "aliceblue": 15792383,\n    "antiquewhite": 16444375,\n    "aqua": 65535,\n    "aquamarine": 8388564,\n    "azure": 15794175,\n    "beige": 16119260,\n    "bisque": 16770244,\n    "black": 0,\n    "blanchedalmond": 16772045,\n    "blue": 255,\n    "blueviolet": 9055202,\n    "brown": 10824234,\n    "burlywood": 14596231,\n    "cadetblue": 6266528,\n    "chartreuse": 8388352,\n    "chocolate": 13789470,\n    "coral": 16744272,\n    "cornflowerblue": 6591981,\n    "cornsilk": 16775388,\n    "crimson": 14423100,\n    "cyan": 65535,\n    "darkblue": 139,\n    "darkcyan": 35723,\n    "darkgoldenrod": 12092939,\n    "darkgray": 11119017,\n    "darkgreen": 25600,\n    "darkgrey": 11119017,\n    "darkkhaki": 12433259,\n    "darkmagenta": 9109643,\n    "darkolivegreen": 5597999,\n    "darkorange": 16747520,\n    "darkorchid": 10040012,\n    "darkred": 9109504,\n    "darksalmon": 15308410,\n    "darkseagreen": 9419919,\n    "darkslateblue": 4734347,\n    "darkslategray": 3100495,\n    "darkslategrey": 3100495,\n    "darkturquoise": 52945,\n    "darkviolet": 9699539,\n    "deeppink": 16716947,\n    "deepskyblue": 49151,\n    "dimgray": 6908265,\n    "dimgrey": 6908265,\n    "dodgerblue": 2003199,\n    "firebrick": 11674146,\n    "floralwhite": 16775920,\n    "forestgreen": 2263842,\n    "fuchsia": 16711935,\n    "gainsboro": 14474460,\n    "ghostwhite": 16316671,\n    "gold": 16766720,\n    "goldenrod": 14329120,\n    "gray": 8421504,\n    "green": 32768,\n    "greenyellow": 11403055,\n    "grey": 8421504,\n    "honeydew": 15794160,\n    "hotpink": 16738740,\n    "indianred": 13458524,\n    "indigo": 4915330,\n    "ivory": 16777200,\n    "khaki": 15787660,\n    "lavender": 15132410,\n    "lavenderblush": 16773365,\n    "lawngreen": 8190976,\n    "lemonchiffon": 16775885,\n    "lightblue": 11393254,\n    "lightcoral": 15761536,\n    "lightcyan": 14745599,\n    "lightgoldenrodyellow": 16448210,\n    "lightgray": 13882323,\n    "lightgreen": 9498256,\n    "lightgrey": 13882323,\n    "lightpink": 16758465,\n    "lightsalmon": 16752762,\n    "lightseagreen": 2142890,\n    "lightskyblue": 8900346,\n    "lightslategray": 7833753,\n    "lightslategrey": 7833753,\n    "lightsteelblue": 11584734,\n    "lightyellow": 16777184,\n    "lime": 65280,\n    "limegreen": 3329330,\n    "linen": 16445670,\n    "magenta": 16711935,\n    "maroon": 8388608,\n    "mediumaquamarine": 6737322,\n    "mediumblue": 205,\n    "mediumorchid": 12211667,\n    "mediumpurple": 9662683,\n    "mediumseagreen": 3978097,\n    "mediumslateblue": 8087790,\n    "mediumspringgreen": 64154,\n    "mediumturquoise": 4772300,\n    "mediumvioletred": 13047173,\n    "midnightblue": 1644912,\n    "mintcream": 16121850,\n    "mistyrose": 16770273,\n    "moccasin": 16770229,\n    "navajowhite": 16768685,\n    "navy": 128,\n    "oldlace": 16643558,\n    "olive": 8421376,\n    "olivedrab": 7048739,\n    "orange": 16753920,\n    "orangered": 16729344,\n    "orchid": 14315734,\n    "palegoldenrod": 15657130,\n    "palegreen": 10025880,\n    "paleturquoise": 11529966,\n    "palevioletred": 14381203,\n    "papayawhip": 16773077,\n    "peachpuff": 16767673,\n    "peru": 13468991,\n    "pink": 16761035,\n    "plum": 14524637,\n    "powderblue": 11591910,\n    "purple": 8388736,\n    "rebeccapurple": 6697881,\n    "red": 16711680,\n    "rosybrown": 12357519,\n    "royalblue": 4286945,\n    "saddlebrown": 9127187,\n    "salmon": 16416882,\n    "sandybrown": 16032864,\n    "seagreen": 3050327,\n    "seashell": 16774638,\n    "sienna": 10506797,\n    "silver": 12632256,\n    "skyblue": 8900331,\n    "slateblue": 6970061,\n    "slategray": 7372944,\n    "slategrey": 7372944,\n    "snow": 16775930,\n    "springgreen": 65407,\n    "steelblue": 4620980,\n    "tan": 13808780,\n    "teal": 32896,\n    "thistle": 14204888,\n    "tomato": 16737095,\n    "turquoise": 4251856,\n    "violet": 15631086,\n    "wheat": 16113331,\n    "white": 16777215,\n    "whitesmoke": 16119285,\n    "yellow": 16776960,\n    "yellowgreen": 10145074\n  };\n  const _hslA = { h: 0, s: 0, l: 0 };\n  const _hslB = { h: 0, s: 0, l: 0 };\n  function hue2rgb(p, q, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\n    return p;\n  }\n  class Color {\n    /**\n     * Constructs a new color.\n     *\n     * Note that standard method of specifying color in three.js is with a hexadecimal triplet,\n     * and that method is used throughout the rest of the documentation.\n     *\n     * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are\n     * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.\n     * @param {number} [g] - The green component.\n     * @param {number} [b] - The blue component.\n     */\n    constructor(r, g, b) {\n      this.isColor = true;\n      this.r = 1;\n      this.g = 1;\n      this.b = 1;\n      return this.set(r, g, b);\n    }\n    /**\n     * Sets the colors\'s components from the given values.\n     *\n     * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are\n     * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.\n     * @param {number} [g] - The green component.\n     * @param {number} [b] - The blue component.\n     * @return {Color} A reference to this color.\n     */\n    set(r, g, b) {\n      if (g === void 0 && b === void 0) {\n        const value = r;\n        if (value && value.isColor) {\n          this.copy(value);\n        } else if (typeof value === "number") {\n          this.setHex(value);\n        } else if (typeof value === "string") {\n          this.setStyle(value);\n        }\n      } else {\n        this.setRGB(r, g, b);\n      }\n      return this;\n    }\n    /**\n     * Sets the colors\'s components to the given scalar value.\n     *\n     * @param {number} scalar - The scalar value.\n     * @return {Color} A reference to this color.\n     */\n    setScalar(scalar) {\n      this.r = scalar;\n      this.g = scalar;\n      this.b = scalar;\n      return this;\n    }\n    /**\n     * Sets this color from a hexadecimal value.\n     *\n     * @param {number} hex - The hexadecimal value.\n     * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n     * @return {Color} A reference to this color.\n     */\n    setHex(hex, colorSpace = SRGBColorSpace) {\n      hex = Math.floor(hex);\n      this.r = (hex >> 16 & 255) / 255;\n      this.g = (hex >> 8 & 255) / 255;\n      this.b = (hex & 255) / 255;\n      ColorManagement.colorSpaceToWorking(this, colorSpace);\n      return this;\n    }\n    /**\n     * Sets this color from RGB values.\n     *\n     * @param {number} r - Red channel value between `0.0` and `1.0`.\n     * @param {number} g - Green channel value between `0.0` and `1.0`.\n     * @param {number} b - Blue channel value between `0.0` and `1.0`.\n     * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.\n     * @return {Color} A reference to this color.\n     */\n    setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {\n      this.r = r;\n      this.g = g;\n      this.b = b;\n      ColorManagement.colorSpaceToWorking(this, colorSpace);\n      return this;\n    }\n    /**\n     * Sets this color from RGB values.\n     *\n     * @param {number} h - Hue value between `0.0` and `1.0`.\n     * @param {number} s - Saturation value between `0.0` and `1.0`.\n     * @param {number} l - Lightness value between `0.0` and `1.0`.\n     * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.\n     * @return {Color} A reference to this color.\n     */\n    setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {\n      h = euclideanModulo(h, 1);\n      s = clamp(s, 0, 1);\n      l = clamp(l, 0, 1);\n      if (s === 0) {\n        this.r = this.g = this.b = l;\n      } else {\n        const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n        const q = 2 * l - p;\n        this.r = hue2rgb(q, p, h + 1 / 3);\n        this.g = hue2rgb(q, p, h);\n        this.b = hue2rgb(q, p, h - 1 / 3);\n      }\n      ColorManagement.colorSpaceToWorking(this, colorSpace);\n      return this;\n    }\n    /**\n     * Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,\n     * `rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or\n     * any [X11 color name]{@link https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart} -\n     * all 140 color names are supported).\n     *\n     * @param {string} style - Color as a CSS-style string.\n     * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n     * @return {Color} A reference to this color.\n     */\n    setStyle(style, colorSpace = SRGBColorSpace) {\n      function handleAlpha(string) {\n        if (string === void 0) return;\n        if (parseFloat(string) < 1) {\n          console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");\n        }\n      }\n      let m;\n      if (m = /^(\\w+)\\(([^\\)]*)\\)/.exec(style)) {\n        let color;\n        const name = m[1];\n        const components = m[2];\n        switch (name) {\n          case "rgb":\n          case "rgba":\n            if (color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setRGB(\n                Math.min(255, parseInt(color[1], 10)) / 255,\n                Math.min(255, parseInt(color[2], 10)) / 255,\n                Math.min(255, parseInt(color[3], 10)) / 255,\n                colorSpace\n              );\n            }\n            if (color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setRGB(\n                Math.min(100, parseInt(color[1], 10)) / 100,\n                Math.min(100, parseInt(color[2], 10)) / 100,\n                Math.min(100, parseInt(color[3], 10)) / 100,\n                colorSpace\n              );\n            }\n            break;\n          case "hsl":\n          case "hsla":\n            if (color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setHSL(\n                parseFloat(color[1]) / 360,\n                parseFloat(color[2]) / 100,\n                parseFloat(color[3]) / 100,\n                colorSpace\n              );\n            }\n            break;\n          default:\n            console.warn("THREE.Color: Unknown color model " + style);\n        }\n      } else if (m = /^\\#([A-Fa-f\\d]+)$/.exec(style)) {\n        const hex = m[1];\n        const size = hex.length;\n        if (size === 3) {\n          return this.setRGB(\n            parseInt(hex.charAt(0), 16) / 15,\n            parseInt(hex.charAt(1), 16) / 15,\n            parseInt(hex.charAt(2), 16) / 15,\n            colorSpace\n          );\n        } else if (size === 6) {\n          return this.setHex(parseInt(hex, 16), colorSpace);\n        } else {\n          console.warn("THREE.Color: Invalid hex color " + style);\n        }\n      } else if (style && style.length > 0) {\n        return this.setColorName(style, colorSpace);\n      }\n      return this;\n    }\n    /**\n     * Sets this color from a color name. Faster than {@link Color#setStyle} if\n     * you don\'t need the other CSS-style formats.\n     *\n     * For convenience, the list of names is exposed in `Color.NAMES` as a hash.\n     * ```js\n     * Color.NAMES.aliceblue // returns 0xF0F8FF\n     * ```\n     *\n     * @param {string} style - The color name.\n     * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n     * @return {Color} A reference to this color.\n     */\n    setColorName(style, colorSpace = SRGBColorSpace) {\n      const hex = _colorKeywords[style.toLowerCase()];\n      if (hex !== void 0) {\n        this.setHex(hex, colorSpace);\n      } else {\n        console.warn("THREE.Color: Unknown color " + style);\n      }\n      return this;\n    }\n    /**\n     * Returns a new color with copied values from this instance.\n     *\n     * @return {Color} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor(this.r, this.g, this.b);\n    }\n    /**\n     * Copies the values of the given color to this instance.\n     *\n     * @param {Color} color - The color to copy.\n     * @return {Color} A reference to this color.\n     */\n    copy(color) {\n      this.r = color.r;\n      this.g = color.g;\n      this.b = color.b;\n      return this;\n    }\n    /**\n     * Copies the given color into this color, and then converts this color from\n     * `SRGBColorSpace` to `LinearSRGBColorSpace`.\n     *\n     * @param {Color} color - The color to copy/convert.\n     * @return {Color} A reference to this color.\n     */\n    copySRGBToLinear(color) {\n      this.r = SRGBToLinear(color.r);\n      this.g = SRGBToLinear(color.g);\n      this.b = SRGBToLinear(color.b);\n      return this;\n    }\n    /**\n     * Copies the given color into this color, and then converts this color from\n     * `LinearSRGBColorSpace` to `SRGBColorSpace`.\n     *\n     * @param {Color} color - The color to copy/convert.\n     * @return {Color} A reference to this color.\n     */\n    copyLinearToSRGB(color) {\n      this.r = LinearToSRGB(color.r);\n      this.g = LinearToSRGB(color.g);\n      this.b = LinearToSRGB(color.b);\n      return this;\n    }\n    /**\n     * Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.\n     *\n     * @return {Color} A reference to this color.\n     */\n    convertSRGBToLinear() {\n      this.copySRGBToLinear(this);\n      return this;\n    }\n    /**\n     * Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.\n     *\n     * @return {Color} A reference to this color.\n     */\n    convertLinearToSRGB() {\n      this.copyLinearToSRGB(this);\n      return this;\n    }\n    /**\n     * Returns the hexadecimal value of this color.\n     *\n     * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n     * @return {number} The hexadecimal value.\n     */\n    getHex(colorSpace = SRGBColorSpace) {\n      ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);\n      return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));\n    }\n    /**\n     * Returns the hexadecimal value of this color as a string (for example, \'FFFFFF\').\n     *\n     * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n     * @return {string} The hexadecimal value as a string.\n     */\n    getHexString(colorSpace = SRGBColorSpace) {\n      return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);\n    }\n    /**\n     * Converts the colors RGB values into the HSL format and stores them into the\n     * given target object.\n     *\n     * @param {{h:number,s:number,l:number}} target - The target object that is used to store the method\'s result.\n     * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.\n     * @return {{h:number,s:number,l:number}} The HSL representation of this color.\n     */\n    getHSL(target, colorSpace = ColorManagement.workingColorSpace) {\n      ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);\n      const r = _color.r, g = _color.g, b = _color.b;\n      const max2 = Math.max(r, g, b);\n      const min = Math.min(r, g, b);\n      let hue, saturation;\n      const lightness = (min + max2) / 2;\n      if (min === max2) {\n        hue = 0;\n        saturation = 0;\n      } else {\n        const delta = max2 - min;\n        saturation = lightness <= 0.5 ? delta / (max2 + min) : delta / (2 - max2 - min);\n        switch (max2) {\n          case r:\n            hue = (g - b) / delta + (g < b ? 6 : 0);\n            break;\n          case g:\n            hue = (b - r) / delta + 2;\n            break;\n          case b:\n            hue = (r - g) / delta + 4;\n            break;\n        }\n        hue /= 6;\n      }\n      target.h = hue;\n      target.s = saturation;\n      target.l = lightness;\n      return target;\n    }\n    /**\n     * Returns the RGB values of this color and stores them into the given target object.\n     *\n     * @param {Color} target - The target color that is used to store the method\'s result.\n     * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.\n     * @return {Color} The RGB representation of this color.\n     */\n    getRGB(target, colorSpace = ColorManagement.workingColorSpace) {\n      ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);\n      target.r = _color.r;\n      target.g = _color.g;\n      target.b = _color.b;\n      return target;\n    }\n    /**\n     * Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.\n     *\n     * @param {string} [colorSpace=SRGBColorSpace] - The color space.\n     * @return {string} The CSS representation of this color.\n     */\n    getStyle(colorSpace = SRGBColorSpace) {\n      ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);\n      const r = _color.r, g = _color.g, b = _color.b;\n      if (colorSpace !== SRGBColorSpace) {\n        return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;\n      }\n      return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;\n    }\n    /**\n     * Adds the given HSL values to this color\'s values.\n     * Internally, this converts the color\'s RGB values to HSL, adds HSL\n     * and then converts the color back to RGB.\n     *\n     * @param {number} h - Hue value between `0.0` and `1.0`.\n     * @param {number} s - Saturation value between `0.0` and `1.0`.\n     * @param {number} l - Lightness value between `0.0` and `1.0`.\n     * @return {Color} A reference to this color.\n     */\n    offsetHSL(h, s, l) {\n      this.getHSL(_hslA);\n      return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);\n    }\n    /**\n     * Adds the RGB values of the given color to the RGB values of this color.\n     *\n     * @param {Color} color - The color to add.\n     * @return {Color} A reference to this color.\n     */\n    add(color) {\n      this.r += color.r;\n      this.g += color.g;\n      this.b += color.b;\n      return this;\n    }\n    /**\n     * Adds the RGB values of the given colors and stores the result in this instance.\n     *\n     * @param {Color} color1 - The first color.\n     * @param {Color} color2 - The second color.\n     * @return {Color} A reference to this color.\n     */\n    addColors(color1, color2) {\n      this.r = color1.r + color2.r;\n      this.g = color1.g + color2.g;\n      this.b = color1.b + color2.b;\n      return this;\n    }\n    /**\n     * Adds the given scalar value to the RGB values of this color.\n     *\n     * @param {number} s - The scalar to add.\n     * @return {Color} A reference to this color.\n     */\n    addScalar(s) {\n      this.r += s;\n      this.g += s;\n      this.b += s;\n      return this;\n    }\n    /**\n     * Subtracts the RGB values of the given color from the RGB values of this color.\n     *\n     * @param {Color} color - The color to subtract.\n     * @return {Color} A reference to this color.\n     */\n    sub(color) {\n      this.r = Math.max(0, this.r - color.r);\n      this.g = Math.max(0, this.g - color.g);\n      this.b = Math.max(0, this.b - color.b);\n      return this;\n    }\n    /**\n     * Multiplies the RGB values of the given color with the RGB values of this color.\n     *\n     * @param {Color} color - The color to multiply.\n     * @return {Color} A reference to this color.\n     */\n    multiply(color) {\n      this.r *= color.r;\n      this.g *= color.g;\n      this.b *= color.b;\n      return this;\n    }\n    /**\n     * Multiplies the given scalar value with the RGB values of this color.\n     *\n     * @param {number} s - The scalar to multiply.\n     * @return {Color} A reference to this color.\n     */\n    multiplyScalar(s) {\n      this.r *= s;\n      this.g *= s;\n      this.b *= s;\n      return this;\n    }\n    /**\n     * Linearly interpolates this color\'s RGB values toward the RGB values of the\n     * given color. The alpha argument can be thought of as the ratio between\n     * the two colors, where `0.0` is this color and `1.0` is the first argument.\n     *\n     * @param {Color} color - The color to converge on.\n     * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.\n     * @return {Color} A reference to this color.\n     */\n    lerp(color, alpha) {\n      this.r += (color.r - this.r) * alpha;\n      this.g += (color.g - this.g) * alpha;\n      this.b += (color.b - this.b) * alpha;\n      return this;\n    }\n    /**\n     * Linearly interpolates between the given colors and stores the result in this instance.\n     * The alpha argument can be thought of as the ratio between the two colors, where `0.0`\n     * is the first and `1.0` is the second color.\n     *\n     * @param {Color} color1 - The first color.\n     * @param {Color} color2 - The second color.\n     * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.\n     * @return {Color} A reference to this color.\n     */\n    lerpColors(color1, color2, alpha) {\n      this.r = color1.r + (color2.r - color1.r) * alpha;\n      this.g = color1.g + (color2.g - color1.g) * alpha;\n      this.b = color1.b + (color2.b - color1.b) * alpha;\n      return this;\n    }\n    /**\n     * Linearly interpolates this color\'s HSL values toward the HSL values of the\n     * given color. It differs from {@link Color#lerp} by not interpolating straight\n     * from one color to the other, but instead going through all the hues in between\n     * those two colors. The alpha argument can be thought of as the ratio between\n     * the two colors, where 0.0 is this color and 1.0 is the first argument.\n     *\n     * @param {Color} color - The color to converge on.\n     * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.\n     * @return {Color} A reference to this color.\n     */\n    lerpHSL(color, alpha) {\n      this.getHSL(_hslA);\n      color.getHSL(_hslB);\n      const h = lerp(_hslA.h, _hslB.h, alpha);\n      const s = lerp(_hslA.s, _hslB.s, alpha);\n      const l = lerp(_hslA.l, _hslB.l, alpha);\n      this.setHSL(h, s, l);\n      return this;\n    }\n    /**\n     * Sets the color\'s RGB components from the given 3D vector.\n     *\n     * @param {Vector3} v - The vector to set.\n     * @return {Color} A reference to this color.\n     */\n    setFromVector3(v) {\n      this.r = v.x;\n      this.g = v.y;\n      this.b = v.z;\n      return this;\n    }\n    /**\n     * Transforms this color with the given 3x3 matrix.\n     *\n     * @param {Matrix3} m - The matrix.\n     * @return {Color} A reference to this color.\n     */\n    applyMatrix3(m) {\n      const r = this.r, g = this.g, b = this.b;\n      const e = m.elements;\n      this.r = e[0] * r + e[3] * g + e[6] * b;\n      this.g = e[1] * r + e[4] * g + e[7] * b;\n      this.b = e[2] * r + e[5] * g + e[8] * b;\n      return this;\n    }\n    /**\n     * Returns `true` if this color is equal with the given one.\n     *\n     * @param {Color} c - The color to test for equality.\n     * @return {boolean} Whether this bounding color is equal with the given one.\n     */\n    equals(c) {\n      return c.r === this.r && c.g === this.g && c.b === this.b;\n    }\n    /**\n     * Sets this color\'s RGB components from the given array.\n     *\n     * @param {Array<number>} array - An array holding the RGB values.\n     * @param {number} [offset=0] - The offset into the array.\n     * @return {Color} A reference to this color.\n     */\n    fromArray(array, offset = 0) {\n      this.r = array[offset];\n      this.g = array[offset + 1];\n      this.b = array[offset + 2];\n      return this;\n    }\n    /**\n     * Writes the RGB components of this color to the given array. If no array is provided,\n     * the method returns a new instance.\n     *\n     * @param {Array<number>} [array=[]] - The target array holding the color components.\n     * @param {number} [offset=0] - Index of the first element in the array.\n     * @return {Array<number>} The color components.\n     */\n    toArray(array = [], offset = 0) {\n      array[offset] = this.r;\n      array[offset + 1] = this.g;\n      array[offset + 2] = this.b;\n      return array;\n    }\n    /**\n     * Sets the components of this color from the given buffer attribute.\n     *\n     * @param {BufferAttribute} attribute - The buffer attribute holding color data.\n     * @param {number} index - The index into the attribute.\n     * @return {Color} A reference to this color.\n     */\n    fromBufferAttribute(attribute, index) {\n      this.r = attribute.getX(index);\n      this.g = attribute.getY(index);\n      this.b = attribute.getZ(index);\n      return this;\n    }\n    /**\n     * This methods defines the serialization result of this class. Returns the color\n     * as a hexadecimal value.\n     *\n     * @return {number} The hexadecimal value.\n     */\n    toJSON() {\n      return this.getHex();\n    }\n    *[Symbol.iterator]() {\n      yield this.r;\n      yield this.g;\n      yield this.b;\n    }\n  }\n  const _color = /* @__PURE__ */ new Color();\n  Color.NAMES = _colorKeywords;\n  let _materialId = 0;\n  class Material extends EventDispatcher {\n    /**\n     * Constructs a new material.\n     */\n    constructor() {\n      super();\n      this.isMaterial = true;\n      Object.defineProperty(this, "id", { value: _materialId++ });\n      this.uuid = generateUUID();\n      this.name = "";\n      this.type = "Material";\n      this.blending = NormalBlending;\n      this.side = FrontSide;\n      this.vertexColors = false;\n      this.opacity = 1;\n      this.transparent = false;\n      this.alphaHash = false;\n      this.blendSrc = SrcAlphaFactor;\n      this.blendDst = OneMinusSrcAlphaFactor;\n      this.blendEquation = AddEquation;\n      this.blendSrcAlpha = null;\n      this.blendDstAlpha = null;\n      this.blendEquationAlpha = null;\n      this.blendColor = new Color(0, 0, 0);\n      this.blendAlpha = 0;\n      this.depthFunc = LessEqualDepth;\n      this.depthTest = true;\n      this.depthWrite = true;\n      this.stencilWriteMask = 255;\n      this.stencilFunc = AlwaysStencilFunc;\n      this.stencilRef = 0;\n      this.stencilFuncMask = 255;\n      this.stencilFail = KeepStencilOp;\n      this.stencilZFail = KeepStencilOp;\n      this.stencilZPass = KeepStencilOp;\n      this.stencilWrite = false;\n      this.clippingPlanes = null;\n      this.clipIntersection = false;\n      this.clipShadows = false;\n      this.shadowSide = null;\n      this.colorWrite = true;\n      this.precision = null;\n      this.polygonOffset = false;\n      this.polygonOffsetFactor = 0;\n      this.polygonOffsetUnits = 0;\n      this.dithering = false;\n      this.alphaToCoverage = false;\n      this.premultipliedAlpha = false;\n      this.forceSinglePass = false;\n      this.allowOverride = true;\n      this.visible = true;\n      this.toneMapped = true;\n      this.userData = {};\n      this.version = 0;\n      this._alphaTest = 0;\n    }\n    /**\n     * Sets the alpha value to be used when running an alpha test. The material\n     * will not be rendered if the opacity is lower than this value.\n     *\n     * @type {number}\n     * @readonly\n     * @default 0\n     */\n    get alphaTest() {\n      return this._alphaTest;\n    }\n    set alphaTest(value) {\n      if (this._alphaTest > 0 !== value > 0) {\n        this.version++;\n      }\n      this._alphaTest = value;\n    }\n    /**\n     * An optional callback that is executed immediately before the material is used to render a 3D object.\n     *\n     * This method can only be used when rendering with {@link WebGLRenderer}.\n     *\n     * @param {WebGLRenderer} renderer - The renderer.\n     * @param {Scene} scene - The scene.\n     * @param {Camera} camera - The camera that is used to render the scene.\n     * @param {BufferGeometry} geometry - The 3D object\'s geometry.\n     * @param {Object3D} object - The 3D object.\n     * @param {Object} group - The geometry group data.\n     */\n    onBeforeRender() {\n    }\n    /**\n     * An optional callback that is executed immediately before the shader\n     * program is compiled. This function is called with the shader source code\n     * as a parameter. Useful for the modification of built-in materials.\n     *\n     * This method can only be used when rendering with {@link WebGLRenderer}. The\n     * recommended approach when customizing materials is to use `WebGPURenderer` with the new\n     * Node Material system and [TSL]{@link https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language}.\n     *\n     * @param {{vertexShader:string,fragmentShader:string,uniforms:Object}} shaderobject - The object holds the uniforms and the vertex and fragment shader source.\n     * @param {WebGLRenderer} renderer - A reference to the renderer.\n     */\n    onBeforeCompile() {\n    }\n    /**\n     * In case {@link Material#onBeforeCompile} is used, this callback can be used to identify\n     * values of settings used in `onBeforeCompile()`, so three.js can reuse a cached\n     * shader or recompile the shader for this material as needed.\n     *\n     * This method can only be used when rendering with {@link WebGLRenderer}.\n     *\n     * @return {string} The custom program cache key.\n     */\n    customProgramCacheKey() {\n      return this.onBeforeCompile.toString();\n    }\n    /**\n     * This method can be used to set default values from parameter objects.\n     * It is a generic implementation so it can be used with different types\n     * of materials.\n     *\n     * @param {Object} [values] - The material values to set.\n     */\n    setValues(values) {\n      if (values === void 0) return;\n      for (const key in values) {\n        const newValue = values[key];\n        if (newValue === void 0) {\n          console.warn(`THREE.Material: parameter \'${key}\' has value of undefined.`);\n          continue;\n        }\n        const currentValue = this[key];\n        if (currentValue === void 0) {\n          console.warn(`THREE.Material: \'${key}\' is not a property of THREE.${this.type}.`);\n          continue;\n        }\n        if (currentValue && currentValue.isColor) {\n          currentValue.set(newValue);\n        } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {\n          currentValue.copy(newValue);\n        } else {\n          this[key] = newValue;\n        }\n      }\n    }\n    /**\n     * Serializes the material into JSON.\n     *\n     * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.\n     * @return {Object} A JSON object representing the serialized material.\n     * @see {@link ObjectLoader#parse}\n     */\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === "string";\n      if (isRootObject) {\n        meta = {\n          textures: {},\n          images: {}\n        };\n      }\n      const data = {\n        metadata: {\n          version: 4.7,\n          type: "Material",\n          generator: "Material.toJSON"\n        }\n      };\n      data.uuid = this.uuid;\n      data.type = this.type;\n      if (this.name !== "") data.name = this.name;\n      if (this.color && this.color.isColor) data.color = this.color.getHex();\n      if (this.roughness !== void 0) data.roughness = this.roughness;\n      if (this.metalness !== void 0) data.metalness = this.metalness;\n      if (this.sheen !== void 0) data.sheen = this.sheen;\n      if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();\n      if (this.sheenRoughness !== void 0) data.sheenRoughness = this.sheenRoughness;\n      if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();\n      if (this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;\n      if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();\n      if (this.specularIntensity !== void 0) data.specularIntensity = this.specularIntensity;\n      if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();\n      if (this.shininess !== void 0) data.shininess = this.shininess;\n      if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat;\n      if (this.clearcoatRoughness !== void 0) data.clearcoatRoughness = this.clearcoatRoughness;\n      if (this.clearcoatMap && this.clearcoatMap.isTexture) {\n        data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;\n      }\n      if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {\n        data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;\n      }\n      if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {\n        data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;\n        data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n      }\n      if (this.sheenColorMap && this.sheenColorMap.isTexture) {\n        data.sheenColorMap = this.sheenColorMap.toJSON(meta).uuid;\n      }\n      if (this.sheenRoughnessMap && this.sheenRoughnessMap.isTexture) {\n        data.sheenRoughnessMap = this.sheenRoughnessMap.toJSON(meta).uuid;\n      }\n      if (this.dispersion !== void 0) data.dispersion = this.dispersion;\n      if (this.iridescence !== void 0) data.iridescence = this.iridescence;\n      if (this.iridescenceIOR !== void 0) data.iridescenceIOR = this.iridescenceIOR;\n      if (this.iridescenceThicknessRange !== void 0) data.iridescenceThicknessRange = this.iridescenceThicknessRange;\n      if (this.iridescenceMap && this.iridescenceMap.isTexture) {\n        data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;\n      }\n      if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {\n        data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;\n      }\n      if (this.anisotropy !== void 0) data.anisotropy = this.anisotropy;\n      if (this.anisotropyRotation !== void 0) data.anisotropyRotation = this.anisotropyRotation;\n      if (this.anisotropyMap && this.anisotropyMap.isTexture) {\n        data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;\n      }\n      if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;\n      if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;\n      if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;\n      if (this.lightMap && this.lightMap.isTexture) {\n        data.lightMap = this.lightMap.toJSON(meta).uuid;\n        data.lightMapIntensity = this.lightMapIntensity;\n      }\n      if (this.aoMap && this.aoMap.isTexture) {\n        data.aoMap = this.aoMap.toJSON(meta).uuid;\n        data.aoMapIntensity = this.aoMapIntensity;\n      }\n      if (this.bumpMap && this.bumpMap.isTexture) {\n        data.bumpMap = this.bumpMap.toJSON(meta).uuid;\n        data.bumpScale = this.bumpScale;\n      }\n      if (this.normalMap && this.normalMap.isTexture) {\n        data.normalMap = this.normalMap.toJSON(meta).uuid;\n        data.normalMapType = this.normalMapType;\n        data.normalScale = this.normalScale.toArray();\n      }\n      if (this.displacementMap && this.displacementMap.isTexture) {\n        data.displacementMap = this.displacementMap.toJSON(meta).uuid;\n        data.displacementScale = this.displacementScale;\n        data.displacementBias = this.displacementBias;\n      }\n      if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;\n      if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;\n      if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;\n      if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;\n      if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;\n      if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;\n      if (this.envMap && this.envMap.isTexture) {\n        data.envMap = this.envMap.toJSON(meta).uuid;\n        if (this.combine !== void 0) data.combine = this.combine;\n      }\n      if (this.envMapRotation !== void 0) data.envMapRotation = this.envMapRotation.toArray();\n      if (this.envMapIntensity !== void 0) data.envMapIntensity = this.envMapIntensity;\n      if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity;\n      if (this.refractionRatio !== void 0) data.refractionRatio = this.refractionRatio;\n      if (this.gradientMap && this.gradientMap.isTexture) {\n        data.gradientMap = this.gradientMap.toJSON(meta).uuid;\n      }\n      if (this.transmission !== void 0) data.transmission = this.transmission;\n      if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;\n      if (this.thickness !== void 0) data.thickness = this.thickness;\n      if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;\n      if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;\n      if (this.attenuationColor !== void 0) data.attenuationColor = this.attenuationColor.getHex();\n      if (this.size !== void 0) data.size = this.size;\n      if (this.shadowSide !== null) data.shadowSide = this.shadowSide;\n      if (this.sizeAttenuation !== void 0) data.sizeAttenuation = this.sizeAttenuation;\n      if (this.blending !== NormalBlending) data.blending = this.blending;\n      if (this.side !== FrontSide) data.side = this.side;\n      if (this.vertexColors === true) data.vertexColors = true;\n      if (this.opacity < 1) data.opacity = this.opacity;\n      if (this.transparent === true) data.transparent = true;\n      if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;\n      if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;\n      if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;\n      if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;\n      if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;\n      if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;\n      if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();\n      if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;\n      if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;\n      if (this.depthTest === false) data.depthTest = this.depthTest;\n      if (this.depthWrite === false) data.depthWrite = this.depthWrite;\n      if (this.colorWrite === false) data.colorWrite = this.colorWrite;\n      if (this.stencilWriteMask !== 255) data.stencilWriteMask = this.stencilWriteMask;\n      if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;\n      if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;\n      if (this.stencilFuncMask !== 255) data.stencilFuncMask = this.stencilFuncMask;\n      if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;\n      if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;\n      if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;\n      if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;\n      if (this.rotation !== void 0 && this.rotation !== 0) data.rotation = this.rotation;\n      if (this.polygonOffset === true) data.polygonOffset = true;\n      if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;\n      if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;\n      if (this.linewidth !== void 0 && this.linewidth !== 1) data.linewidth = this.linewidth;\n      if (this.dashSize !== void 0) data.dashSize = this.dashSize;\n      if (this.gapSize !== void 0) data.gapSize = this.gapSize;\n      if (this.scale !== void 0) data.scale = this.scale;\n      if (this.dithering === true) data.dithering = true;\n      if (this.alphaTest > 0) data.alphaTest = this.alphaTest;\n      if (this.alphaHash === true) data.alphaHash = true;\n      if (this.alphaToCoverage === true) data.alphaToCoverage = true;\n      if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;\n      if (this.forceSinglePass === true) data.forceSinglePass = true;\n      if (this.wireframe === true) data.wireframe = true;\n      if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;\n      if (this.wireframeLinecap !== "round") data.wireframeLinecap = this.wireframeLinecap;\n      if (this.wireframeLinejoin !== "round") data.wireframeLinejoin = this.wireframeLinejoin;\n      if (this.flatShading === true) data.flatShading = true;\n      if (this.visible === false) data.visible = false;\n      if (this.toneMapped === false) data.toneMapped = false;\n      if (this.fog === false) data.fog = false;\n      if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n      function extractFromCache(cache) {\n        const values = [];\n        for (const key in cache) {\n          const data2 = cache[key];\n          delete data2.metadata;\n          values.push(data2);\n        }\n        return values;\n      }\n      if (isRootObject) {\n        const textures = extractFromCache(meta.textures);\n        const images = extractFromCache(meta.images);\n        if (textures.length > 0) data.textures = textures;\n        if (images.length > 0) data.images = images;\n      }\n      return data;\n    }\n    /**\n     * Returns a new material with copied values from this instance.\n     *\n     * @return {Material} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    /**\n     * Copies the values of the given material to this instance.\n     *\n     * @param {Material} source - The material to copy.\n     * @return {Material} A reference to this instance.\n     */\n    copy(source) {\n      this.name = source.name;\n      this.blending = source.blending;\n      this.side = source.side;\n      this.vertexColors = source.vertexColors;\n      this.opacity = source.opacity;\n      this.transparent = source.transparent;\n      this.blendSrc = source.blendSrc;\n      this.blendDst = source.blendDst;\n      this.blendEquation = source.blendEquation;\n      this.blendSrcAlpha = source.blendSrcAlpha;\n      this.blendDstAlpha = source.blendDstAlpha;\n      this.blendEquationAlpha = source.blendEquationAlpha;\n      this.blendColor.copy(source.blendColor);\n      this.blendAlpha = source.blendAlpha;\n      this.depthFunc = source.depthFunc;\n      this.depthTest = source.depthTest;\n      this.depthWrite = source.depthWrite;\n      this.stencilWriteMask = source.stencilWriteMask;\n      this.stencilFunc = source.stencilFunc;\n      this.stencilRef = source.stencilRef;\n      this.stencilFuncMask = source.stencilFuncMask;\n      this.stencilFail = source.stencilFail;\n      this.stencilZFail = source.stencilZFail;\n      this.stencilZPass = source.stencilZPass;\n      this.stencilWrite = source.stencilWrite;\n      const srcPlanes = source.clippingPlanes;\n      let dstPlanes = null;\n      if (srcPlanes !== null) {\n        const n = srcPlanes.length;\n        dstPlanes = new Array(n);\n        for (let i2 = 0; i2 !== n; ++i2) {\n          dstPlanes[i2] = srcPlanes[i2].clone();\n        }\n      }\n      this.clippingPlanes = dstPlanes;\n      this.clipIntersection = source.clipIntersection;\n      this.clipShadows = source.clipShadows;\n      this.shadowSide = source.shadowSide;\n      this.colorWrite = source.colorWrite;\n      this.precision = source.precision;\n      this.polygonOffset = source.polygonOffset;\n      this.polygonOffsetFactor = source.polygonOffsetFactor;\n      this.polygonOffsetUnits = source.polygonOffsetUnits;\n      this.dithering = source.dithering;\n      this.alphaTest = source.alphaTest;\n      this.alphaHash = source.alphaHash;\n      this.alphaToCoverage = source.alphaToCoverage;\n      this.premultipliedAlpha = source.premultipliedAlpha;\n      this.forceSinglePass = source.forceSinglePass;\n      this.visible = source.visible;\n      this.toneMapped = source.toneMapped;\n      this.userData = JSON.parse(JSON.stringify(source.userData));\n      return this;\n    }\n    /**\n     * Frees the GPU-related resources allocated by this instance. Call this\n     * method whenever this instance is no longer used in your app.\n     *\n     * @fires Material#dispose\n     */\n    dispose() {\n      this.dispatchEvent({ type: "dispose" });\n    }\n    /**\n     * Setting this property to `true` indicates the engine the material\n     * needs to be recompiled.\n     *\n     * @type {boolean}\n     * @default false\n     * @param {boolean} value\n     */\n    set needsUpdate(value) {\n      if (value === true) this.version++;\n    }\n  }\n  class MeshBasicMaterial extends Material {\n    /**\n     * Constructs a new mesh basic material.\n     *\n     * @param {Object} [parameters] - An object with one or more properties\n     * defining the material\'s appearance. Any property of the material\n     * (including any property from inherited materials) can be passed\n     * in here. Color values can be passed any type of value accepted\n     * by {@link Color#set}.\n     */\n    constructor(parameters) {\n      super();\n      this.isMeshBasicMaterial = true;\n      this.type = "MeshBasicMaterial";\n      this.color = new Color(16777215);\n      this.map = null;\n      this.lightMap = null;\n      this.lightMapIntensity = 1;\n      this.aoMap = null;\n      this.aoMapIntensity = 1;\n      this.specularMap = null;\n      this.alphaMap = null;\n      this.envMap = null;\n      this.envMapRotation = new Euler();\n      this.combine = MultiplyOperation;\n      this.reflectivity = 1;\n      this.refractionRatio = 0.98;\n      this.wireframe = false;\n      this.wireframeLinewidth = 1;\n      this.wireframeLinecap = "round";\n      this.wireframeLinejoin = "round";\n      this.fog = true;\n      this.setValues(parameters);\n    }\n    copy(source) {\n      super.copy(source);\n      this.color.copy(source.color);\n      this.map = source.map;\n      this.lightMap = source.lightMap;\n      this.lightMapIntensity = source.lightMapIntensity;\n      this.aoMap = source.aoMap;\n      this.aoMapIntensity = source.aoMapIntensity;\n      this.specularMap = source.specularMap;\n      this.alphaMap = source.alphaMap;\n      this.envMap = source.envMap;\n      this.envMapRotation.copy(source.envMapRotation);\n      this.combine = source.combine;\n      this.reflectivity = source.reflectivity;\n      this.refractionRatio = source.refractionRatio;\n      this.wireframe = source.wireframe;\n      this.wireframeLinewidth = source.wireframeLinewidth;\n      this.wireframeLinecap = source.wireframeLinecap;\n      this.wireframeLinejoin = source.wireframeLinejoin;\n      this.fog = source.fog;\n      return this;\n    }\n  }\n  const _vector$9 = /* @__PURE__ */ new Vector3();\n  const _vector2$1 = /* @__PURE__ */ new Vector2();\n  let _id$2 = 0;\n  class BufferAttribute {\n    /**\n     * Constructs a new buffer attribute.\n     *\n     * @param {TypedArray} array - The array holding the attribute data.\n     * @param {number} itemSize - The item size.\n     * @param {boolean} [normalized=false] - Whether the data are normalized or not.\n     */\n    constructor(array, itemSize, normalized = false) {\n      if (Array.isArray(array)) {\n        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");\n      }\n      this.isBufferAttribute = true;\n      Object.defineProperty(this, "id", { value: _id$2++ });\n      this.name = "";\n      this.array = array;\n      this.itemSize = itemSize;\n      this.count = array !== void 0 ? array.length / itemSize : 0;\n      this.normalized = normalized;\n      this.usage = StaticDrawUsage;\n      this.updateRanges = [];\n      this.gpuType = FloatType;\n      this.version = 0;\n    }\n    /**\n     * A callback function that is executed after the renderer has transferred the attribute\n     * array data to the GPU.\n     */\n    onUploadCallback() {\n    }\n    /**\n     * Flag to indicate that this attribute has changed and should be re-sent to\n     * the GPU. Set this to `true` when you modify the value of the array.\n     *\n     * @type {number}\n     * @default false\n     * @param {boolean} value\n     */\n    set needsUpdate(value) {\n      if (value === true) this.version++;\n    }\n    /**\n     * Sets the usage of this buffer attribute.\n     *\n     * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.\n     * @return {BufferAttribute} A reference to this buffer attribute.\n     */\n    setUsage(value) {\n      this.usage = value;\n      return this;\n    }\n    /**\n     * Adds a range of data in the data array to be updated on the GPU.\n     *\n     * @param {number} start - Position at which to start update.\n     * @param {number} count - The number of components to update.\n     */\n    addUpdateRange(start, count) {\n      this.updateRanges.push({ start, count });\n    }\n    /**\n     * Clears the update ranges.\n     */\n    clearUpdateRanges() {\n      this.updateRanges.length = 0;\n    }\n    /**\n     * Copies the values of the given buffer attribute to this instance.\n     *\n     * @param {BufferAttribute} source - The buffer attribute to copy.\n     * @return {BufferAttribute} A reference to this instance.\n     */\n    copy(source) {\n      this.name = source.name;\n      this.array = new source.array.constructor(source.array);\n      this.itemSize = source.itemSize;\n      this.count = source.count;\n      this.normalized = source.normalized;\n      this.usage = source.usage;\n      this.gpuType = source.gpuType;\n      return this;\n    }\n    /**\n     * Copies a vector from the given buffer attribute to this one. The start\n     * and destination position in the attribute buffers are represented by the\n     * given indices.\n     *\n     * @param {number} index1 - The destination index into this buffer attribute.\n     * @param {BufferAttribute} attribute - The buffer attribute to copy from.\n     * @param {number} index2 - The source index into the given buffer attribute.\n     * @return {BufferAttribute} A reference to this instance.\n     */\n    copyAt(index1, attribute, index2) {\n      index1 *= this.itemSize;\n      index2 *= attribute.itemSize;\n      for (let i2 = 0, l = this.itemSize; i2 < l; i2++) {\n        this.array[index1 + i2] = attribute.array[index2 + i2];\n      }\n      return this;\n    }\n    /**\n     * Copies the given array data into this buffer attribute.\n     *\n     * @param {(TypedArray|Array)} array - The array to copy.\n     * @return {BufferAttribute} A reference to this instance.\n     */\n    copyArray(array) {\n      this.array.set(array);\n      return this;\n    }\n    /**\n     * Applies the given 3x3 matrix to the given attribute. Works with\n     * item size `2` and `3`.\n     *\n     * @param {Matrix3} m - The matrix to apply.\n     * @return {BufferAttribute} A reference to this instance.\n     */\n    applyMatrix3(m) {\n      if (this.itemSize === 2) {\n        for (let i2 = 0, l = this.count; i2 < l; i2++) {\n          _vector2$1.fromBufferAttribute(this, i2);\n          _vector2$1.applyMatrix3(m);\n          this.setXY(i2, _vector2$1.x, _vector2$1.y);\n        }\n      } else if (this.itemSize === 3) {\n        for (let i2 = 0, l = this.count; i2 < l; i2++) {\n          _vector$9.fromBufferAttribute(this, i2);\n          _vector$9.applyMatrix3(m);\n          this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n        }\n      }\n      return this;\n    }\n    /**\n     * Applies the given 4x4 matrix to the given attribute. Only works with\n     * item size `3`.\n     *\n     * @param {Matrix4} m - The matrix to apply.\n     * @return {BufferAttribute} A reference to this instance.\n     */\n    applyMatrix4(m) {\n      for (let i2 = 0, l = this.count; i2 < l; i2++) {\n        _vector$9.fromBufferAttribute(this, i2);\n        _vector$9.applyMatrix4(m);\n        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n      return this;\n    }\n    /**\n     * Applies the given 3x3 normal matrix to the given attribute. Only works with\n     * item size `3`.\n     *\n     * @param {Matrix3} m - The normal matrix to apply.\n     * @return {BufferAttribute} A reference to this instance.\n     */\n    applyNormalMatrix(m) {\n      for (let i2 = 0, l = this.count; i2 < l; i2++) {\n        _vector$9.fromBufferAttribute(this, i2);\n        _vector$9.applyNormalMatrix(m);\n        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n      return this;\n    }\n    /**\n     * Applies the given 4x4 matrix to the given attribute. Only works with\n     * item size `3` and with direction vectors.\n     *\n     * @param {Matrix4} m - The matrix to apply.\n     * @return {BufferAttribute} A reference to this instance.\n     */\n    transformDirection(m) {\n      for (let i2 = 0, l = this.count; i2 < l; i2++) {\n        _vector$9.fromBufferAttribute(this, i2);\n        _vector$9.transformDirection(m);\n        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n      return this;\n    }\n    /**\n     * Sets the given array data in the buffer attribute.\n     *\n     * @param {(TypedArray|Array)} value - The array data to set.\n     * @param {number} [offset=0] - The offset in this buffer attribute\'s array.\n     * @return {BufferAttribute} A reference to this instance.\n     */\n    set(value, offset = 0) {\n      this.array.set(value, offset);\n      return this;\n    }\n    /**\n     * Returns the given component of the vector at the given index.\n     *\n     * @param {number} index - The index into the buffer attribute.\n     * @param {number} component - The component index.\n     * @return {number} The returned value.\n     */\n    getComponent(index, component) {\n      let value = this.array[index * this.itemSize + component];\n      if (this.normalized) value = denormalize(value, this.array);\n      return value;\n    }\n    /**\n     * Sets the given value to the given component of the vector at the given index.\n     *\n     * @param {number} index - The index into the buffer attribute.\n     * @param {number} component - The component index.\n     * @param {number} value - The value to set.\n     * @return {BufferAttribute} A reference to this instance.\n     */\n    setComponent(index, component, value) {\n      if (this.normalized) value = normalize$2(value, this.array);\n      this.array[index * this.itemSize + component] = value;\n      return this;\n    }\n    /**\n     * Returns the x component of the vector at the given index.\n     *\n     * @param {number} index - The index into the buffer attribute.\n     * @return {number} The x component.\n     */\n    getX(index) {\n      let x2 = this.array[index * this.itemSize];\n      if (this.normalized) x2 = denormalize(x2, this.array);\n      return x2;\n    }\n    /**\n     * Sets the x component of the vector at the given index.\n     *\n     * @param {number} index - The index into the buffer attribute.\n     * @param {number} x - The value to set.\n     * @return {BufferAttribute} A reference to this instance.\n     */\n    setX(index, x2) {\n      if (this.normalized) x2 = normalize$2(x2, this.array);\n      this.array[index * this.itemSize] = x2;\n      return this;\n    }\n    /**\n     * Returns the y component of the vector at the given index.\n     *\n     * @param {number} index - The index into the buffer attribute.\n     * @return {number} The y component.\n     */\n    getY(index) {\n      let y = this.array[index * this.itemSize + 1];\n      if (this.normalized) y = denormalize(y, this.array);\n      return y;\n    }\n    /**\n     * Sets the y component of the vector at the given index.\n     *\n     * @param {number} index - The index into the buffer attribute.\n     * @param {number} y - The value to set.\n     * @return {BufferAttribute} A reference to this instance.\n     */\n    setY(index, y) {\n      if (this.normalized) y = normalize$2(y, this.array);\n      this.array[index * this.itemSize + 1] = y;\n      return this;\n    }\n    /**\n     * Returns the z component of the vector at the given index.\n     *\n     * @param {number} index - The index into the buffer attribute.\n     * @return {number} The z component.\n     */\n    getZ(index) {\n      let z = this.array[index * this.itemSize + 2];\n      if (this.normalized) z = denormalize(z, this.array);\n      return z;\n    }\n    /**\n     * Sets the z component of the vector at the given index.\n     *\n     * @param {number} index - The index into the buffer attribute.\n     * @param {number} z - The value to set.\n     * @return {BufferAttribute} A reference to this instance.\n     */\n    setZ(index, z) {\n      if (this.normalized) z = normalize$2(z, this.array);\n      this.array[index * this.itemSize + 2] = z;\n      return this;\n    }\n    /**\n     * Returns the w component of the vector at the given index.\n     *\n     * @param {number} index - The index into the buffer attribute.\n     * @return {number} The w component.\n     */\n    getW(index) {\n      let w = this.array[index * this.itemSize + 3];\n      if (this.normalized) w = denormalize(w, this.array);\n      return w;\n    }\n    /**\n     * Sets the w component of the vector at the given index.\n     *\n     * @param {number} index - The index into the buffer attribute.\n     * @param {number} w - The value to set.\n     * @return {BufferAttribute} A reference to this instance.\n     */\n    setW(index, w) {\n      if (this.normalized) w = normalize$2(w, this.array);\n      this.array[index * this.itemSize + 3] = w;\n      return this;\n    }\n    /**\n     * Sets the x and y component of the vector at the given index.\n     *\n     * @param {number} index - The index into the buffer attribute.\n     * @param {number} x - The value for the x component to set.\n     * @param {number} y - The value for the y component to set.\n     * @return {BufferAttribute} A reference to this instance.\n     */\n    setXY(index, x2, y) {\n      index *= this.itemSize;\n      if (this.normalized) {\n        x2 = normalize$2(x2, this.array);\n        y = normalize$2(y, this.array);\n      }\n      this.array[index + 0] = x2;\n      this.array[index + 1] = y;\n      return this;\n    }\n    /**\n     * Sets the x, y and z component of the vector at the given index.\n     *\n     * @param {number} index - The index into the buffer attribute.\n     * @param {number} x - The value for the x component to set.\n     * @param {number} y - The value for the y component to set.\n     * @param {number} z - The value for the z component to set.\n     * @return {BufferAttribute} A reference to this instance.\n     */\n    setXYZ(index, x2, y, z) {\n      index *= this.itemSize;\n      if (this.normalized) {\n        x2 = normalize$2(x2, this.array);\n        y = normalize$2(y, this.array);\n        z = normalize$2(z, this.array);\n      }\n      this.array[index + 0] = x2;\n      this.array[index + 1] = y;\n      this.array[index + 2] = z;\n      return this;\n    }\n    /**\n     * Sets the x, y, z and w component of the vector at the given index.\n     *\n     * @param {number} index - The index into the buffer attribute.\n     * @param {number} x - The value for the x component to set.\n     * @param {number} y - The value for the y component to set.\n     * @param {number} z - The value for the z component to set.\n     * @param {number} w - The value for the w component to set.\n     * @return {BufferAttribute} A reference to this instance.\n     */\n    setXYZW(index, x2, y, z, w) {\n      index *= this.itemSize;\n      if (this.normalized) {\n        x2 = normalize$2(x2, this.array);\n        y = normalize$2(y, this.array);\n        z = normalize$2(z, this.array);\n        w = normalize$2(w, this.array);\n      }\n      this.array[index + 0] = x2;\n      this.array[index + 1] = y;\n      this.array[index + 2] = z;\n      this.array[index + 3] = w;\n      return this;\n    }\n    /**\n     * Sets the given callback function that is executed after the Renderer has transferred\n     * the attribute array data to the GPU. Can be used to perform clean-up operations after\n     * the upload when attribute data are not needed anymore on the CPU side.\n     *\n     * @param {Function} callback - The `onUpload()` callback.\n     * @return {BufferAttribute} A reference to this instance.\n     */\n    onUpload(callback) {\n      this.onUploadCallback = callback;\n      return this;\n    }\n    /**\n     * Returns a new buffer attribute with copied values from this instance.\n     *\n     * @return {BufferAttribute} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor(this.array, this.itemSize).copy(this);\n    }\n    /**\n     * Serializes the buffer attribute into JSON.\n     *\n     * @return {Object} A JSON object representing the serialized buffer attribute.\n     */\n    toJSON() {\n      const data = {\n        itemSize: this.itemSize,\n        type: this.array.constructor.name,\n        array: Array.from(this.array),\n        normalized: this.normalized\n      };\n      if (this.name !== "") data.name = this.name;\n      if (this.usage !== StaticDrawUsage) data.usage = this.usage;\n      return data;\n    }\n  }\n  class Uint16BufferAttribute extends BufferAttribute {\n    /**\n     * Constructs a new buffer attribute.\n     *\n     * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.\n     * @param {number} itemSize - The item size.\n     * @param {boolean} [normalized=false] - Whether the data are normalized or not.\n     */\n    constructor(array, itemSize, normalized) {\n      super(new Uint16Array(array), itemSize, normalized);\n    }\n  }\n  class Uint32BufferAttribute extends BufferAttribute {\n    /**\n     * Constructs a new buffer attribute.\n     *\n     * @param {(Array<number>|Uint32Array)} array - The array holding the attribute data.\n     * @param {number} itemSize - The item size.\n     * @param {boolean} [normalized=false] - Whether the data are normalized or not.\n     */\n    constructor(array, itemSize, normalized) {\n      super(new Uint32Array(array), itemSize, normalized);\n    }\n  }\n  class Float32BufferAttribute extends BufferAttribute {\n    /**\n     * Constructs a new buffer attribute.\n     *\n     * @param {(Array<number>|Float32Array)} array - The array holding the attribute data.\n     * @param {number} itemSize - The item size.\n     * @param {boolean} [normalized=false] - Whether the data are normalized or not.\n     */\n    constructor(array, itemSize, normalized) {\n      super(new Float32Array(array), itemSize, normalized);\n    }\n  }\n  let _id$1 = 0;\n  const _m1 = /* @__PURE__ */ new Matrix4();\n  const _obj = /* @__PURE__ */ new Object3D();\n  const _offset = /* @__PURE__ */ new Vector3();\n  const _box$2 = /* @__PURE__ */ new Box3();\n  const _boxMorphTargets = /* @__PURE__ */ new Box3();\n  const _vector$8 = /* @__PURE__ */ new Vector3();\n  class BufferGeometry extends EventDispatcher {\n    /**\n     * Constructs a new geometry.\n     */\n    constructor() {\n      super();\n      this.isBufferGeometry = true;\n      Object.defineProperty(this, "id", { value: _id$1++ });\n      this.uuid = generateUUID();\n      this.name = "";\n      this.type = "BufferGeometry";\n      this.index = null;\n      this.indirect = null;\n      this.attributes = {};\n      this.morphAttributes = {};\n      this.morphTargetsRelative = false;\n      this.groups = [];\n      this.boundingBox = null;\n      this.boundingSphere = null;\n      this.drawRange = { start: 0, count: Infinity };\n      this.userData = {};\n    }\n    /**\n     * Returns the index of this geometry.\n     *\n     * @return {?BufferAttribute} The index. Returns `null` if no index is defined.\n     */\n    getIndex() {\n      return this.index;\n    }\n    /**\n     * Sets the given index to this geometry.\n     *\n     * @param {Array<number>|BufferAttribute} index - The index to set.\n     * @return {BufferGeometry} A reference to this instance.\n     */\n    setIndex(index) {\n      if (Array.isArray(index)) {\n        this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n      } else {\n        this.index = index;\n      }\n      return this;\n    }\n    /**\n     * Sets the given indirect attribute to this geometry.\n     *\n     * @param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n     * @return {BufferGeometry} A reference to this instance.\n     */\n    setIndirect(indirect) {\n      this.indirect = indirect;\n      return this;\n    }\n    /**\n     * Returns the indirect attribute of this geometry.\n     *\n     * @return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n     */\n    getIndirect() {\n      return this.indirect;\n    }\n    /**\n     * Returns the buffer attribute for the given name.\n     *\n     * @param {string} name - The attribute name.\n     * @return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\n     * Returns `undefined` if not attribute has been found.\n     */\n    getAttribute(name) {\n      return this.attributes[name];\n    }\n    /**\n     * Sets the given attribute for the given name.\n     *\n     * @param {string} name - The attribute name.\n     * @param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n     * @return {BufferGeometry} A reference to this instance.\n     */\n    setAttribute(name, attribute) {\n      this.attributes[name] = attribute;\n      return this;\n    }\n    /**\n     * Deletes the attribute for the given name.\n     *\n     * @param {string} name - The attribute name to delete.\n     * @return {BufferGeometry} A reference to this instance.\n     */\n    deleteAttribute(name) {\n      delete this.attributes[name];\n      return this;\n    }\n    /**\n     * Returns `true` if this geometry has an attribute for the given name.\n     *\n     * @param {string} name - The attribute name.\n     * @return {boolean} Whether this geometry has an attribute for the given name or not.\n     */\n    hasAttribute(name) {\n      return this.attributes[name] !== void 0;\n    }\n    /**\n     * Adds a group to this geometry.\n     *\n     * @param {number} start - The first element in this draw call. That is the first\n     * vertex for non-indexed geometry, otherwise the first triangle index.\n     * @param {number} count - Specifies how many vertices (or indices) are part of this group.\n     * @param {number} [materialIndex=0] - The material array index to use.\n     */\n    addGroup(start, count, materialIndex = 0) {\n      this.groups.push({\n        start,\n        count,\n        materialIndex\n      });\n    }\n    /**\n     * Clears all groups.\n     */\n    clearGroups() {\n      this.groups = [];\n    }\n    /**\n     * Sets the draw range for this geometry.\n     *\n     * @param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n     * @param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\n     * For indexed BufferGeometry, `count` is the number of indices to render.\n     */\n    setDrawRange(start, count) {\n      this.drawRange.start = start;\n      this.drawRange.count = count;\n    }\n    /**\n     * Applies the given 4x4 transformation matrix to the geometry.\n     *\n     * @param {Matrix4} matrix - The matrix to apply.\n     * @return {BufferGeometry} A reference to this instance.\n     */\n    applyMatrix4(matrix) {\n      const position = this.attributes.position;\n      if (position !== void 0) {\n        position.applyMatrix4(matrix);\n        position.needsUpdate = true;\n      }\n      const normal = this.attributes.normal;\n      if (normal !== void 0) {\n        const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n        normal.applyNormalMatrix(normalMatrix);\n        normal.needsUpdate = true;\n      }\n      const tangent = this.attributes.tangent;\n      if (tangent !== void 0) {\n        tangent.transformDirection(matrix);\n        tangent.needsUpdate = true;\n      }\n      if (this.boundingBox !== null) {\n        this.computeBoundingBox();\n      }\n      if (this.boundingSphere !== null) {\n        this.computeBoundingSphere();\n      }\n      return this;\n    }\n    /**\n     * Applies the rotation represented by the Quaternion to the geometry.\n     *\n     * @param {Quaternion} q - The Quaternion to apply.\n     * @return {BufferGeometry} A reference to this instance.\n     */\n    applyQuaternion(q) {\n      _m1.makeRotationFromQuaternion(q);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    /**\n     * Rotates the geometry about the X axis. This is typically done as a one time\n     * operation, and not during a loop. Use {@link Object3D#rotation} for typical\n     * real-time mesh rotation.\n     *\n     * @param {number} angle - The angle in radians.\n     * @return {BufferGeometry} A reference to this instance.\n     */\n    rotateX(angle) {\n      _m1.makeRotationX(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    /**\n     * Rotates the geometry about the Y axis. This is typically done as a one time\n     * operation, and not during a loop. Use {@link Object3D#rotation} for typical\n     * real-time mesh rotation.\n     *\n     * @param {number} angle - The angle in radians.\n     * @return {BufferGeometry} A reference to this instance.\n     */\n    rotateY(angle) {\n      _m1.makeRotationY(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    /**\n     * Rotates the geometry about the Z axis. This is typically done as a one time\n     * operation, and not during a loop. Use {@link Object3D#rotation} for typical\n     * real-time mesh rotation.\n     *\n     * @param {number} angle - The angle in radians.\n     * @return {BufferGeometry} A reference to this instance.\n     */\n    rotateZ(angle) {\n      _m1.makeRotationZ(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    /**\n     * Translates the geometry. This is typically done as a one time\n     * operation, and not during a loop. Use {@link Object3D#position} for typical\n     * real-time mesh rotation.\n     *\n     * @param {number} x - The x offset.\n     * @param {number} y - The y offset.\n     * @param {number} z - The z offset.\n     * @return {BufferGeometry} A reference to this instance.\n     */\n    translate(x2, y, z) {\n      _m1.makeTranslation(x2, y, z);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    /**\n     * Scales the geometry. This is typically done as a one time\n     * operation, and not during a loop. Use {@link Object3D#scale} for typical\n     * real-time mesh rotation.\n     *\n     * @param {number} x - The x scale.\n     * @param {number} y - The y scale.\n     * @param {number} z - The z scale.\n     * @return {BufferGeometry} A reference to this instance.\n     */\n    scale(x2, y, z) {\n      _m1.makeScale(x2, y, z);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    /**\n     * Rotates the geometry to face a point in 3D space. This is typically done as a one time\n     * operation, and not during a loop. Use {@link Object3D#lookAt} for typical\n     * real-time mesh rotation.\n     *\n     * @param {Vector3} vector - The target point.\n     * @return {BufferGeometry} A reference to this instance.\n     */\n    lookAt(vector) {\n      _obj.lookAt(vector);\n      _obj.updateMatrix();\n      this.applyMatrix4(_obj.matrix);\n      return this;\n    }\n    /**\n     * Center the geometry based on its bounding box.\n     *\n     * @return {BufferGeometry} A reference to this instance.\n     */\n    center() {\n      this.computeBoundingBox();\n      this.boundingBox.getCenter(_offset).negate();\n      this.translate(_offset.x, _offset.y, _offset.z);\n      return this;\n    }\n    /**\n     * Defines a geometry by creating a `position` attribute based on the given array of points. The array\n     * can hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is\n     * set to `0`.\n     *\n     * If the method is used with an existing `position` attribute, the vertex data are overwritten with the\n     * data from the array. The length of the array must match the vertex count.\n     *\n     * @param {Array<Vector2>|Array<Vector3>} points - The points.\n     * @return {BufferGeometry} A reference to this instance.\n     */\n    setFromPoints(points) {\n      const positionAttribute = this.getAttribute("position");\n      if (positionAttribute === void 0) {\n        const position = [];\n        for (let i2 = 0, l = points.length; i2 < l; i2++) {\n          const point = points[i2];\n          position.push(point.x, point.y, point.z || 0);\n        }\n        this.setAttribute("position", new Float32BufferAttribute(position, 3));\n      } else {\n        const l = Math.min(points.length, positionAttribute.count);\n        for (let i2 = 0; i2 < l; i2++) {\n          const point = points[i2];\n          positionAttribute.setXYZ(i2, point.x, point.y, point.z || 0);\n        }\n        if (points.length > positionAttribute.count) {\n          console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.");\n        }\n        positionAttribute.needsUpdate = true;\n      }\n      return this;\n    }\n    /**\n     * Computes the bounding box of the geometry, and updates the `boundingBox` member.\n     * The bounding box is not computed by the engine; it must be computed by your app.\n     * You may need to recompute the bounding box if the geometry vertices are modified.\n     */\n    computeBoundingBox() {\n      if (this.boundingBox === null) {\n        this.boundingBox = new Box3();\n      }\n      const position = this.attributes.position;\n      const morphAttributesPosition = this.morphAttributes.position;\n      if (position && position.isGLBufferAttribute) {\n        console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this);\n        this.boundingBox.set(\n          new Vector3(-Infinity, -Infinity, -Infinity),\n          new Vector3(Infinity, Infinity, Infinity)\n        );\n        return;\n      }\n      if (position !== void 0) {\n        this.boundingBox.setFromBufferAttribute(position);\n        if (morphAttributesPosition) {\n          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {\n            const morphAttribute = morphAttributesPosition[i2];\n            _box$2.setFromBufferAttribute(morphAttribute);\n            if (this.morphTargetsRelative) {\n              _vector$8.addVectors(this.boundingBox.min, _box$2.min);\n              this.boundingBox.expandByPoint(_vector$8);\n              _vector$8.addVectors(this.boundingBox.max, _box$2.max);\n              this.boundingBox.expandByPoint(_vector$8);\n            } else {\n              this.boundingBox.expandByPoint(_box$2.min);\n              this.boundingBox.expandByPoint(_box$2.max);\n            }\n          }\n        }\n      } else {\n        this.boundingBox.makeEmpty();\n      }\n      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n        console.error(\'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.\', this);\n      }\n    }\n    /**\n     * Computes the bounding sphere of the geometry, and updates the `boundingSphere` member.\n     * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.\n     * You may need to recompute the bounding sphere if the geometry vertices are modified.\n     */\n    computeBoundingSphere() {\n      if (this.boundingSphere === null) {\n        this.boundingSphere = new Sphere();\n      }\n      const position = this.attributes.position;\n      const morphAttributesPosition = this.morphAttributes.position;\n      if (position && position.isGLBufferAttribute) {\n        console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this);\n        this.boundingSphere.set(new Vector3(), Infinity);\n        return;\n      }\n      if (position) {\n        const center = this.boundingSphere.center;\n        _box$2.setFromBufferAttribute(position);\n        if (morphAttributesPosition) {\n          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {\n            const morphAttribute = morphAttributesPosition[i2];\n            _boxMorphTargets.setFromBufferAttribute(morphAttribute);\n            if (this.morphTargetsRelative) {\n              _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);\n              _box$2.expandByPoint(_vector$8);\n              _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);\n              _box$2.expandByPoint(_vector$8);\n            } else {\n              _box$2.expandByPoint(_boxMorphTargets.min);\n              _box$2.expandByPoint(_boxMorphTargets.max);\n            }\n          }\n        }\n        _box$2.getCenter(center);\n        let maxRadiusSq = 0;\n        for (let i2 = 0, il = position.count; i2 < il; i2++) {\n          _vector$8.fromBufferAttribute(position, i2);\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n        }\n        if (morphAttributesPosition) {\n          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {\n            const morphAttribute = morphAttributesPosition[i2];\n            const morphTargetsRelative = this.morphTargetsRelative;\n            for (let j = 0, jl = morphAttribute.count; j < jl; j++) {\n              _vector$8.fromBufferAttribute(morphAttribute, j);\n              if (morphTargetsRelative) {\n                _offset.fromBufferAttribute(position, j);\n                _vector$8.add(_offset);\n              }\n              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n            }\n          }\n        }\n        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n        if (isNaN(this.boundingSphere.radius)) {\n          console.error(\'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.\', this);\n        }\n      }\n    }\n    /**\n     * Calculates and adds a tangent attribute to this geometry.\n     *\n     * The computation is only supported for indexed geometries and if position, normal, and uv attributes\n     * are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by\n     * {@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.\n     */\n    computeTangents() {\n      const index = this.index;\n      const attributes = this.attributes;\n      if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {\n        console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");\n        return;\n      }\n      const positionAttribute = attributes.position;\n      const normalAttribute = attributes.normal;\n      const uvAttribute = attributes.uv;\n      if (this.hasAttribute("tangent") === false) {\n        this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));\n      }\n      const tangentAttribute = this.getAttribute("tangent");\n      const tan1 = [], tan2 = [];\n      for (let i2 = 0; i2 < positionAttribute.count; i2++) {\n        tan1[i2] = new Vector3();\n        tan2[i2] = new Vector3();\n      }\n      const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();\n      function handleTriangle(a, b, c) {\n        vA.fromBufferAttribute(positionAttribute, a);\n        vB.fromBufferAttribute(positionAttribute, b);\n        vC.fromBufferAttribute(positionAttribute, c);\n        uvA.fromBufferAttribute(uvAttribute, a);\n        uvB.fromBufferAttribute(uvAttribute, b);\n        uvC.fromBufferAttribute(uvAttribute, c);\n        vB.sub(vA);\n        vC.sub(vA);\n        uvB.sub(uvA);\n        uvC.sub(uvA);\n        const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);\n        if (!isFinite(r)) return;\n        sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n        tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n        tan1[a].add(sdir);\n        tan1[b].add(sdir);\n        tan1[c].add(sdir);\n        tan2[a].add(tdir);\n        tan2[b].add(tdir);\n        tan2[c].add(tdir);\n      }\n      let groups = this.groups;\n      if (groups.length === 0) {\n        groups = [{\n          start: 0,\n          count: index.count\n        }];\n      }\n      for (let i2 = 0, il = groups.length; i2 < il; ++i2) {\n        const group = groups[i2];\n        const start = group.start;\n        const count = group.count;\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          handleTriangle(\n            index.getX(j + 0),\n            index.getX(j + 1),\n            index.getX(j + 2)\n          );\n        }\n      }\n      const tmp = new Vector3(), tmp2 = new Vector3();\n      const n = new Vector3(), n2 = new Vector3();\n      function handleVertex(v) {\n        n.fromBufferAttribute(normalAttribute, v);\n        n2.copy(n);\n        const t = tan1[v];\n        tmp.copy(t);\n        tmp.sub(n.multiplyScalar(n.dot(t))).normalize();\n        tmp2.crossVectors(n2, t);\n        const test = tmp2.dot(tan2[v]);\n        const w = test < 0 ? -1 : 1;\n        tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w);\n      }\n      for (let i2 = 0, il = groups.length; i2 < il; ++i2) {\n        const group = groups[i2];\n        const start = group.start;\n        const count = group.count;\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          handleVertex(index.getX(j + 0));\n          handleVertex(index.getX(j + 1));\n          handleVertex(index.getX(j + 2));\n        }\n      }\n    }\n    /**\n     * Computes vertex normals for the given vertex data. For indexed geometries, the method sets\n     * each vertex normal to be the average of the face normals of the faces that share that vertex.\n     * For non-indexed geometries, vertices are not shared, and the method sets each vertex normal\n     * to be the same as the face normal.\n     */\n    computeVertexNormals() {\n      const index = this.index;\n      const positionAttribute = this.getAttribute("position");\n      if (positionAttribute !== void 0) {\n        let normalAttribute = this.getAttribute("normal");\n        if (normalAttribute === void 0) {\n          normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);\n          this.setAttribute("normal", normalAttribute);\n        } else {\n          for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {\n            normalAttribute.setXYZ(i2, 0, 0, 0);\n          }\n        }\n        const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n        const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n        const cb = new Vector3(), ab = new Vector3();\n        if (index) {\n          for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {\n            const vA = index.getX(i2 + 0);\n            const vB = index.getX(i2 + 1);\n            const vC = index.getX(i2 + 2);\n            pA.fromBufferAttribute(positionAttribute, vA);\n            pB.fromBufferAttribute(positionAttribute, vB);\n            pC.fromBufferAttribute(positionAttribute, vC);\n            cb.subVectors(pC, pB);\n            ab.subVectors(pA, pB);\n            cb.cross(ab);\n            nA.fromBufferAttribute(normalAttribute, vA);\n            nB.fromBufferAttribute(normalAttribute, vB);\n            nC.fromBufferAttribute(normalAttribute, vC);\n            nA.add(cb);\n            nB.add(cb);\n            nC.add(cb);\n            normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);\n            normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n            normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n          }\n        } else {\n          for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {\n            pA.fromBufferAttribute(positionAttribute, i2 + 0);\n            pB.fromBufferAttribute(positionAttribute, i2 + 1);\n            pC.fromBufferAttribute(positionAttribute, i2 + 2);\n            cb.subVectors(pC, pB);\n            ab.subVectors(pA, pB);\n            cb.cross(ab);\n            normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);\n            normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);\n            normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);\n          }\n        }\n        this.normalizeNormals();\n        normalAttribute.needsUpdate = true;\n      }\n    }\n    /**\n     * Ensures every normal vector in a geometry will have a magnitude of `1`. This will\n     * correct lighting on the geometry surfaces.\n     */\n    normalizeNormals() {\n      const normals = this.attributes.normal;\n      for (let i2 = 0, il = normals.count; i2 < il; i2++) {\n        _vector$8.fromBufferAttribute(normals, i2);\n        _vector$8.normalize();\n        normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);\n      }\n    }\n    /**\n     * Return a new non-index version of this indexed geometry. If the geometry\n     * is already non-indexed, the method is a NOOP.\n     *\n     * @return {BufferGeometry} The non-indexed version of this indexed geometry.\n     */\n    toNonIndexed() {\n      function convertBufferAttribute(attribute, indices2) {\n        const array = attribute.array;\n        const itemSize = attribute.itemSize;\n        const normalized = attribute.normalized;\n        const array2 = new array.constructor(indices2.length * itemSize);\n        let index = 0, index2 = 0;\n        for (let i2 = 0, l = indices2.length; i2 < l; i2++) {\n          if (attribute.isInterleavedBufferAttribute) {\n            index = indices2[i2] * attribute.data.stride + attribute.offset;\n          } else {\n            index = indices2[i2] * itemSize;\n          }\n          for (let j = 0; j < itemSize; j++) {\n            array2[index2++] = array[index++];\n          }\n        }\n        return new BufferAttribute(array2, itemSize, normalized);\n      }\n      if (this.index === null) {\n        console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");\n        return this;\n      }\n      const geometry2 = new BufferGeometry();\n      const indices = this.index.array;\n      const attributes = this.attributes;\n      for (const name in attributes) {\n        const attribute = attributes[name];\n        const newAttribute = convertBufferAttribute(attribute, indices);\n        geometry2.setAttribute(name, newAttribute);\n      }\n      const morphAttributes = this.morphAttributes;\n      for (const name in morphAttributes) {\n        const morphArray = [];\n        const morphAttribute = morphAttributes[name];\n        for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {\n          const attribute = morphAttribute[i2];\n          const newAttribute = convertBufferAttribute(attribute, indices);\n          morphArray.push(newAttribute);\n        }\n        geometry2.morphAttributes[name] = morphArray;\n      }\n      geometry2.morphTargetsRelative = this.morphTargetsRelative;\n      const groups = this.groups;\n      for (let i2 = 0, l = groups.length; i2 < l; i2++) {\n        const group = groups[i2];\n        geometry2.addGroup(group.start, group.count, group.materialIndex);\n      }\n      return geometry2;\n    }\n    /**\n     * Serializes the geometry into JSON.\n     *\n     * @return {Object} A JSON object representing the serialized geometry.\n     */\n    toJSON() {\n      const data = {\n        metadata: {\n          version: 4.7,\n          type: "BufferGeometry",\n          generator: "BufferGeometry.toJSON"\n        }\n      };\n      data.uuid = this.uuid;\n      data.type = this.type;\n      if (this.name !== "") data.name = this.name;\n      if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n      if (this.parameters !== void 0) {\n        const parameters = this.parameters;\n        for (const key in parameters) {\n          if (parameters[key] !== void 0) data[key] = parameters[key];\n        }\n        return data;\n      }\n      data.data = { attributes: {} };\n      const index = this.index;\n      if (index !== null) {\n        data.data.index = {\n          type: index.array.constructor.name,\n          array: Array.prototype.slice.call(index.array)\n        };\n      }\n      const attributes = this.attributes;\n      for (const key in attributes) {\n        const attribute = attributes[key];\n        data.data.attributes[key] = attribute.toJSON(data.data);\n      }\n      const morphAttributes = {};\n      let hasMorphAttributes = false;\n      for (const key in this.morphAttributes) {\n        const attributeArray = this.morphAttributes[key];\n        const array = [];\n        for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {\n          const attribute = attributeArray[i2];\n          array.push(attribute.toJSON(data.data));\n        }\n        if (array.length > 0) {\n          morphAttributes[key] = array;\n          hasMorphAttributes = true;\n        }\n      }\n      if (hasMorphAttributes) {\n        data.data.morphAttributes = morphAttributes;\n        data.data.morphTargetsRelative = this.morphTargetsRelative;\n      }\n      const groups = this.groups;\n      if (groups.length > 0) {\n        data.data.groups = JSON.parse(JSON.stringify(groups));\n      }\n      const boundingSphere = this.boundingSphere;\n      if (boundingSphere !== null) {\n        data.data.boundingSphere = boundingSphere.toJSON();\n      }\n      return data;\n    }\n    /**\n     * Returns a new geometry with copied values from this instance.\n     *\n     * @return {BufferGeometry} A clone of this instance.\n     */\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    /**\n     * Copies the values of the given geometry to this instance.\n     *\n     * @param {BufferGeometry} source - The geometry to copy.\n     * @return {BufferGeometry} A reference to this instance.\n     */\n    copy(source) {\n      this.index = null;\n      this.attributes = {};\n      this.morphAttributes = {};\n      this.groups = [];\n      this.boundingBox = null;\n      this.boundingSphere = null;\n      const data = {};\n      this.name = source.name;\n      const index = source.index;\n      if (index !== null) {\n        this.setIndex(index.clone());\n      }\n      const attributes = source.attributes;\n      for (const name in attributes) {\n        const attribute = attributes[name];\n        this.setAttribute(name, attribute.clone(data));\n      }\n      const morphAttributes = source.morphAttributes;\n      for (const name in morphAttributes) {\n        const array = [];\n        const morphAttribute = morphAttributes[name];\n        for (let i2 = 0, l = morphAttribute.length; i2 < l; i2++) {\n          array.push(morphAttribute[i2].clone(data));\n        }\n        this.morphAttributes[name] = array;\n      }\n      this.morphTargetsRelative = source.morphTargetsRelative;\n      const groups = source.groups;\n      for (let i2 = 0, l = groups.length; i2 < l; i2++) {\n        const group = groups[i2];\n        this.addGroup(group.start, group.count, group.materialIndex);\n      }\n      const boundingBox = source.boundingBox;\n      if (boundingBox !== null) {\n        this.boundingBox = boundingBox.clone();\n      }\n      const boundingSphere = source.boundingSphere;\n      if (boundingSphere !== null) {\n        this.boundingSphere = boundingSphere.clone();\n      }\n      this.drawRange.start = source.drawRange.start;\n      this.drawRange.count = source.drawRange.count;\n      this.userData = source.userData;\n      return this;\n    }\n    /**\n     * Frees the GPU-related resources allocated by this instance. Call this\n     * method whenever this instance is no longer used in your app.\n     *\n     * @fires BufferGeometry#dispose\n     */\n    dispose() {\n      this.dispatchEvent({ type: "dispose" });\n    }\n  }\n  const _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();\n  const _ray$3 = /* @__PURE__ */ new Ray();\n  const _sphere$6 = /* @__PURE__ */ new Sphere();\n  const _sphereHitAt = /* @__PURE__ */ new Vector3();\n  const _vA$1 = /* @__PURE__ */ new Vector3();\n  const _vB$1 = /* @__PURE__ */ new Vector3();\n  const _vC$1 = /* @__PURE__ */ new Vector3();\n  const _tempA = /* @__PURE__ */ new Vector3();\n  const _morphA = /* @__PURE__ */ new Vector3();\n  const _intersectionPoint = /* @__PURE__ */ new Vector3();\n  const _intersectionPointWorld = /* @__PURE__ */ new Vector3();\n  class Mesh extends Object3D {\n    /**\n     * Constructs a new mesh.\n     *\n     * @param {BufferGeometry} [geometry] - The mesh geometry.\n     * @param {Material|Array<Material>} [material] - The mesh material.\n     */\n    constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {\n      super();\n      this.isMesh = true;\n      this.type = "Mesh";\n      this.geometry = geometry;\n      this.material = material;\n      this.morphTargetDictionary = void 0;\n      this.morphTargetInfluences = void 0;\n      this.count = 1;\n      this.updateMorphTargets();\n    }\n    copy(source, recursive) {\n      super.copy(source, recursive);\n      if (source.morphTargetInfluences !== void 0) {\n        this.morphTargetInfluences = source.morphTargetInfluences.slice();\n      }\n      if (source.morphTargetDictionary !== void 0) {\n        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);\n      }\n      this.material = Array.isArray(source.material) ? source.material.slice() : source.material;\n      this.geometry = source.geometry;\n      return this;\n    }\n    /**\n     * Sets the values of {@link Mesh#morphTargetDictionary} and {@link Mesh#morphTargetInfluences}\n     * to make sure existing morph targets can influence this 3D object.\n     */\n    updateMorphTargets() {\n      const geometry = this.geometry;\n      const morphAttributes = geometry.morphAttributes;\n      const keys = Object.keys(morphAttributes);\n      if (keys.length > 0) {\n        const morphAttribute = morphAttributes[keys[0]];\n        if (morphAttribute !== void 0) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n            const name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    }\n    /**\n     * Returns the local-space position of the vertex at the given index, taking into\n     * account the current animation state of both morph targets and skinning.\n     *\n     * @param {number} index - The vertex index.\n     * @param {Vector3} target - The target object that is used to store the method\'s result.\n     * @return {Vector3} The vertex position in local space.\n     */\n    getVertexPosition(index, target) {\n      const geometry = this.geometry;\n      const position = geometry.attributes.position;\n      const morphPosition = geometry.morphAttributes.position;\n      const morphTargetsRelative = geometry.morphTargetsRelative;\n      target.fromBufferAttribute(position, index);\n      const morphInfluences = this.morphTargetInfluences;\n      if (morphPosition && morphInfluences) {\n        _morphA.set(0, 0, 0);\n        for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {\n          const influence = morphInfluences[i2];\n          const morphAttribute = morphPosition[i2];\n          if (influence === 0) continue;\n          _tempA.fromBufferAttribute(morphAttribute, index);\n          if (morphTargetsRelative) {\n            _morphA.addScaledVector(_tempA, influence);\n          } else {\n            _morphA.addScaledVector(_tempA.sub(target), influence);\n          }\n        }\n        target.add(_morphA);\n      }\n      return target;\n    }\n    /**\n     * Computes intersection points between a casted ray and this line.\n     *\n     * @param {Raycaster} raycaster - The raycaster.\n     * @param {Array<Object>} intersects - The target array that holds the intersection points.\n     */\n    raycast(raycaster, intersects) {\n      const geometry = this.geometry;\n      const material = this.material;\n      const matrixWorld = this.matrixWorld;\n      if (material === void 0) return;\n      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n      _sphere$6.copy(geometry.boundingSphere);\n      _sphere$6.applyMatrix4(matrixWorld);\n      _ray$3.copy(raycaster.ray).recast(raycaster.near);\n      if (_sphere$6.containsPoint(_ray$3.origin) === false) {\n        if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;\n        if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return;\n      }\n      _inverseMatrix$3.copy(matrixWorld).invert();\n      _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);\n      if (geometry.boundingBox !== null) {\n        if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;\n      }\n      this._computeIntersections(raycaster, intersects, _ray$3);\n    }\n    _computeIntersections(raycaster, intersects, rayLocalSpace) {\n      let intersection;\n      const geometry = this.geometry;\n      const material = this.material;\n      const index = geometry.index;\n      const position = geometry.attributes.position;\n      const uv = geometry.attributes.uv;\n      const uv1 = geometry.attributes.uv1;\n      const normal = geometry.attributes.normal;\n      const groups = geometry.groups;\n      const drawRange = geometry.drawRange;\n      if (index !== null) {\n        if (Array.isArray(material)) {\n          for (let i2 = 0, il = groups.length; i2 < il; i2++) {\n            const group = groups[i2];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = index.getX(j);\n              const b = index.getX(j + 1);\n              const c = index.getX(j + 2);\n              intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3);\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(index.count, drawRange.start + drawRange.count);\n          for (let i2 = start, il = end; i2 < il; i2 += 3) {\n            const a = index.getX(i2);\n            const b = index.getX(i2 + 1);\n            const c = index.getX(i2 + 2);\n            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i2 / 3);\n              intersects.push(intersection);\n            }\n          }\n        }\n      } else if (position !== void 0) {\n        if (Array.isArray(material)) {\n          for (let i2 = 0, il = groups.length; i2 < il; i2++) {\n            const group = groups[i2];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = j;\n              const b = j + 1;\n              const c = j + 2;\n              intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3);\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(position.count, drawRange.start + drawRange.count);\n          for (let i2 = start, il = end; i2 < il; i2 += 3) {\n            const a = i2;\n            const b = i2 + 1;\n            const c = i2 + 2;\n            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i2 / 3);\n              intersects.push(intersection);\n            }\n          }\n        }\n      }\n    }\n  }\n  function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {\n    let intersect;\n    if (material.side === BackSide) {\n      intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n    } else {\n      intersect = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);\n    }\n    if (intersect === null) return null;\n    _intersectionPointWorld.copy(point);\n    _intersectionPointWorld.applyMatrix4(object.matrixWorld);\n    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n    if (distance < raycaster.near || distance > raycaster.far) return null;\n    return {\n      distance,\n      point: _intersectionPointWorld.clone(),\n      object\n    };\n  }\n  function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {\n    object.getVertexPosition(a, _vA$1);\n    object.getVertexPosition(b, _vB$1);\n    object.getVertexPosition(c, _vC$1);\n    const intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);\n    if (intersection) {\n      const barycoord = new Vector3();\n      Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord);\n      if (uv) {\n        intersection.uv = Triangle.getInterpolatedAttribute(uv, a, b, c, barycoord, new Vector2());\n      }\n      if (uv1) {\n        intersection.uv1 = Triangle.getInterpolatedAttribute(uv1, a, b, c, barycoord, new Vector2());\n      }\n      if (normal) {\n        intersection.normal = Triangle.getInterpolatedAttribute(normal, a, b, c, barycoord, new Vector3());\n        if (intersection.normal.dot(ray.direction) > 0) {\n          intersection.normal.multiplyScalar(-1);\n        }\n      }\n      const face = {\n        a,\n        b,\n        c,\n        normal: new Vector3(),\n        materialIndex: 0\n      };\n      Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);\n      intersection.face = face;\n      intersection.barycoord = barycoord;\n    }\n    return intersection;\n  }\n  function cloneUniforms(src) {\n    const dst = {};\n    for (const u in src) {\n      dst[u] = {};\n      for (const p in src[u]) {\n        const property = src[u][p];\n        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {\n          if (property.isRenderTargetTexture) {\n            console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().");\n            dst[u][p] = null;\n          } else {\n            dst[u][p] = property.clone();\n          }\n        } else if (Array.isArray(property)) {\n          dst[u][p] = property.slice();\n        } else {\n          dst[u][p] = property;\n        }\n      }\n    }\n    return dst;\n  }\n  function cloneUniformsGroups(src) {\n    const dst = [];\n    for (let u = 0; u < src.length; u++) {\n      dst.push(src[u].clone());\n    }\n    return dst;\n  }\n  var default_vertex = "void main() {\\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}";\n  var default_fragment = "void main() {\\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}";\n  class ShaderMaterial extends Material {\n    /**\n     * Constructs a new shader material.\n     *\n     * @param {Object} [parameters] - An object with one or more properties\n     * defining the material\'s appearance. Any property of the material\n     * (including any property from inherited materials) can be passed\n     * in here. Color values can be passed any type of value accepted\n     * by {@link Color#set}.\n     */\n    constructor(parameters) {\n      super();\n      this.isShaderMaterial = true;\n      this.type = "ShaderMaterial";\n      this.defines = {};\n      this.uniforms = {};\n      this.uniformsGroups = [];\n      this.vertexShader = default_vertex;\n      this.fragmentShader = default_fragment;\n      this.linewidth = 1;\n      this.wireframe = false;\n      this.wireframeLinewidth = 1;\n      this.fog = false;\n      this.lights = false;\n      this.clipping = false;\n      this.forceSinglePass = true;\n      this.extensions = {\n        clipCullDistance: false,\n        // set to use vertex shader clipping\n        multiDraw: false\n        // set to use vertex shader multi_draw / enable gl_DrawID\n      };\n      this.defaultAttributeValues = {\n        "color": [1, 1, 1],\n        "uv": [0, 0],\n        "uv1": [0, 0]\n      };\n      this.index0AttributeName = void 0;\n      this.uniformsNeedUpdate = false;\n      this.glslVersion = null;\n      if (parameters !== void 0) {\n        this.setValues(parameters);\n      }\n    }\n    copy(source) {\n      super.copy(source);\n      this.fragmentShader = source.fragmentShader;\n      this.vertexShader = source.vertexShader;\n      this.uniforms = cloneUniforms(source.uniforms);\n      this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);\n      this.defines = Object.assign({}, source.defines);\n      this.wireframe = source.wireframe;\n      this.wireframeLinewidth = source.wireframeLinewidth;\n      this.fog = source.fog;\n      this.lights = source.lights;\n      this.clipping = source.clipping;\n      this.extensions = Object.assign({}, source.extensions);\n      this.glslVersion = source.glslVersion;\n      return this;\n    }\n    toJSON(meta) {\n      const data = super.toJSON(meta);\n      data.glslVersion = this.glslVersion;\n      data.uniforms = {};\n      for (const name in this.uniforms) {\n        const uniform = this.uniforms[name];\n        const value = uniform.value;\n        if (value && value.isTexture) {\n          data.uniforms[name] = {\n            type: "t",\n            value: value.toJSON(meta).uuid\n          };\n        } else if (value && value.isColor) {\n          data.uniforms[name] = {\n            type: "c",\n            value: value.getHex()\n          };\n        } else if (value && value.isVector2) {\n          data.uniforms[name] = {\n            type: "v2",\n            value: value.toArray()\n          };\n        } else if (value && value.isVector3) {\n          data.uniforms[name] = {\n            type: "v3",\n            value: value.toArray()\n          };\n        } else if (value && value.isVector4) {\n          data.uniforms[name] = {\n            type: "v4",\n            value: value.toArray()\n          };\n        } else if (value && value.isMatrix3) {\n          data.uniforms[name] = {\n            type: "m3",\n            value: value.toArray()\n          };\n        } else if (value && value.isMatrix4) {\n          data.uniforms[name] = {\n            type: "m4",\n            value: value.toArray()\n          };\n        } else {\n          data.uniforms[name] = {\n            value\n          };\n        }\n      }\n      if (Object.keys(this.defines).length > 0) data.defines = this.defines;\n      data.vertexShader = this.vertexShader;\n      data.fragmentShader = this.fragmentShader;\n      data.lights = this.lights;\n      data.clipping = this.clipping;\n      const extensions = {};\n      for (const key in this.extensions) {\n        if (this.extensions[key] === true) extensions[key] = true;\n      }\n      if (Object.keys(extensions).length > 0) data.extensions = extensions;\n      return data;\n    }\n  }\n  class Camera extends Object3D {\n    /**\n     * Constructs a new camera.\n     */\n    constructor() {\n      super();\n      this.isCamera = true;\n      this.type = "Camera";\n      this.matrixWorldInverse = new Matrix4();\n      this.projectionMatrix = new Matrix4();\n      this.projectionMatrixInverse = new Matrix4();\n      this.coordinateSystem = WebGLCoordinateSystem;\n      this._reversedDepth = false;\n    }\n    /**\n     * The flag that indicates whether the camera uses a reversed depth buffer.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get reversedDepth() {\n      return this._reversedDepth;\n    }\n    copy(source, recursive) {\n      super.copy(source, recursive);\n      this.matrixWorldInverse.copy(source.matrixWorldInverse);\n      this.projectionMatrix.copy(source.projectionMatrix);\n      this.projectionMatrixInverse.copy(source.projectionMatrixInverse);\n      this.coordinateSystem = source.coordinateSystem;\n      return this;\n    }\n    /**\n     * Returns a vector representing the ("look") direction of the 3D object in world space.\n     *\n     * This method is overwritten since cameras have a different forward vector compared to other\n     * 3D objects. A camera looks down its local, negative z-axis by default.\n     *\n     * @param {Vector3} target - The target vector the result is stored to.\n     * @return {Vector3} The 3D object\'s direction in world space.\n     */\n    getWorldDirection(target) {\n      return super.getWorldDirection(target).negate();\n    }\n    updateMatrixWorld(force) {\n      super.updateMatrixWorld(force);\n      this.matrixWorldInverse.copy(this.matrixWorld).invert();\n    }\n    updateWorldMatrix(updateParents, updateChildren) {\n      super.updateWorldMatrix(updateParents, updateChildren);\n      this.matrixWorldInverse.copy(this.matrixWorld).invert();\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n  }\n  class DataTexture extends Texture {\n    /**\n     * Constructs a new data texture.\n     *\n     * @param {?TypedArray} [data=null] - The buffer data.\n     * @param {number} [width=1] - The width of the texture.\n     * @param {number} [height=1] - The height of the texture.\n     * @param {number} [format=RGBAFormat] - The texture format.\n     * @param {number} [type=UnsignedByteType] - The texture type.\n     * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.\n     * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.\n     * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.\n     * @param {number} [magFilter=NearestFilter] - The mag filter value.\n     * @param {number} [minFilter=NearestFilter] - The min filter value.\n     * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.\n     * @param {string} [colorSpace=NoColorSpace] - The color space.\n     */\n    constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {\n      super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);\n      this.isDataTexture = true;\n      this.image = { data, width, height };\n      this.generateMipmaps = false;\n      this.flipY = false;\n      this.unpackAlignment = 1;\n    }\n  }\n  class RawShaderMaterial extends ShaderMaterial {\n    /**\n     * Constructs a new raw shader material.\n     *\n     * @param {Object} [parameters] - An object with one or more properties\n     * defining the material\'s appearance. Any property of the material\n     * (including any property from inherited materials) can be passed\n     * in here. Color values can be passed any type of value accepted\n     * by {@link Color#set}.\n     */\n    constructor(parameters) {\n      super(parameters);\n      this.isRawShaderMaterial = true;\n      this.type = "RawShaderMaterial";\n    }\n  }\n  const Cache = {\n    /**\n     * Whether caching is enabled or not.\n     *\n     * @static\n     * @type {boolean}\n     * @default false\n     */\n    enabled: false,\n    /**\n     * A dictionary that holds cached files.\n     *\n     * @static\n     * @type {Object<string,Object>}\n     */\n    files: {},\n    /**\n     * Adds a cache entry with a key to reference the file. If this key already\n     * holds a file, it is overwritten.\n     *\n     * @static\n     * @param {string} key - The key to reference the cached file.\n     * @param {Object} file -  The file to be cached.\n     */\n    add: function(key, file) {\n      if (this.enabled === false) return;\n      this.files[key] = file;\n    },\n    /**\n     * Gets the cached value for the given key.\n     *\n     * @static\n     * @param {string} key - The key to reference the cached file.\n     * @return {Object|undefined} The cached file. If the key does not exist `undefined` is returned.\n     */\n    get: function(key) {\n      if (this.enabled === false) return;\n      return this.files[key];\n    },\n    /**\n     * Removes the cached file associated with the given key.\n     *\n     * @static\n     * @param {string} key - The key to reference the cached file.\n     */\n    remove: function(key) {\n      delete this.files[key];\n    },\n    /**\n     * Remove all values from the cache.\n     *\n     * @static\n     */\n    clear: function() {\n      this.files = {};\n    }\n  };\n  class LoadingManager {\n    /**\n     * Constructs a new loading manager.\n     *\n     * @param {Function} [onLoad] - Executes when all items have been loaded.\n     * @param {Function} [onProgress] - Executes when single items have been loaded.\n     * @param {Function} [onError] - Executes when an error occurs.\n     */\n    constructor(onLoad, onProgress, onError) {\n      const scope = this;\n      let isLoading = false;\n      let itemsLoaded = 0;\n      let itemsTotal = 0;\n      let urlModifier = void 0;\n      const handlers = [];\n      this.onStart = void 0;\n      this.onLoad = onLoad;\n      this.onProgress = onProgress;\n      this.onError = onError;\n      this.abortController = new AbortController();\n      this.itemStart = function(url) {\n        itemsTotal++;\n        if (isLoading === false) {\n          if (scope.onStart !== void 0) {\n            scope.onStart(url, itemsLoaded, itemsTotal);\n          }\n        }\n        isLoading = true;\n      };\n      this.itemEnd = function(url) {\n        itemsLoaded++;\n        if (scope.onProgress !== void 0) {\n          scope.onProgress(url, itemsLoaded, itemsTotal);\n        }\n        if (itemsLoaded === itemsTotal) {\n          isLoading = false;\n          if (scope.onLoad !== void 0) {\n            scope.onLoad();\n          }\n        }\n      };\n      this.itemError = function(url) {\n        if (scope.onError !== void 0) {\n          scope.onError(url);\n        }\n      };\n      this.resolveURL = function(url) {\n        if (urlModifier) {\n          return urlModifier(url);\n        }\n        return url;\n      };\n      this.setURLModifier = function(transform) {\n        urlModifier = transform;\n        return this;\n      };\n      this.addHandler = function(regex, loader) {\n        handlers.push(regex, loader);\n        return this;\n      };\n      this.removeHandler = function(regex) {\n        const index = handlers.indexOf(regex);\n        if (index !== -1) {\n          handlers.splice(index, 2);\n        }\n        return this;\n      };\n      this.getHandler = function(file) {\n        for (let i2 = 0, l = handlers.length; i2 < l; i2 += 2) {\n          const regex = handlers[i2];\n          const loader = handlers[i2 + 1];\n          if (regex.global) regex.lastIndex = 0;\n          if (regex.test(file)) {\n            return loader;\n          }\n        }\n        return null;\n      };\n      this.abort = function() {\n        this.abortController.abort();\n        this.abortController = new AbortController();\n        return this;\n      };\n    }\n  }\n  const DefaultLoadingManager = /* @__PURE__ */ new LoadingManager();\n  class Loader {\n    /**\n     * Constructs a new loader.\n     *\n     * @param {LoadingManager} [manager] - The loading manager.\n     */\n    constructor(manager) {\n      this.manager = manager !== void 0 ? manager : DefaultLoadingManager;\n      this.crossOrigin = "anonymous";\n      this.withCredentials = false;\n      this.path = "";\n      this.resourcePath = "";\n      this.requestHeader = {};\n    }\n    /**\n     * This method needs to be implemented by all concrete loaders. It holds the\n     * logic for loading assets from the backend.\n     *\n     * @abstract\n     * @param {string} url - The path/URL of the file to be loaded.\n     * @param {Function} onLoad - Executed when the loading process has been finished.\n     * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.\n     * @param {onErrorCallback} [onError] - Executed when errors occur.\n     */\n    load() {\n    }\n    /**\n     * A async version of {@link Loader#load}.\n     *\n     * @param {string} url - The path/URL of the file to be loaded.\n     * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.\n     * @return {Promise} A Promise that resolves when the asset has been loaded.\n     */\n    loadAsync(url, onProgress) {\n      const scope = this;\n      return new Promise(function(resolve, reject) {\n        scope.load(url, resolve, onProgress, reject);\n      });\n    }\n    /**\n     * This method needs to be implemented by all concrete loaders. It holds the\n     * logic for parsing the asset into three.js entities.\n     *\n     * @abstract\n     * @param {any} data - The data to parse.\n     */\n    parse() {\n    }\n    /**\n     * Sets the `crossOrigin` String to implement CORS for loading the URL\n     * from a different domain that allows CORS.\n     *\n     * @param {string} crossOrigin - The `crossOrigin` value.\n     * @return {Loader} A reference to this instance.\n     */\n    setCrossOrigin(crossOrigin) {\n      this.crossOrigin = crossOrigin;\n      return this;\n    }\n    /**\n     * Whether the XMLHttpRequest uses credentials such as cookies, authorization\n     * headers or TLS client certificates, see [XMLHttpRequest.withCredentials]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials}.\n     *\n     * Note: This setting has no effect if you are loading files locally or from the same domain.\n     *\n     * @param {boolean} value - The `withCredentials` value.\n     * @return {Loader} A reference to this instance.\n     */\n    setWithCredentials(value) {\n      this.withCredentials = value;\n      return this;\n    }\n    /**\n     * Sets the base path for the asset.\n     *\n     * @param {string} path - The base path.\n     * @return {Loader} A reference to this instance.\n     */\n    setPath(path) {\n      this.path = path;\n      return this;\n    }\n    /**\n     * Sets the base path for dependent resources like textures.\n     *\n     * @param {string} resourcePath - The resource path.\n     * @return {Loader} A reference to this instance.\n     */\n    setResourcePath(resourcePath) {\n      this.resourcePath = resourcePath;\n      return this;\n    }\n    /**\n     * Sets the given request header.\n     *\n     * @param {Object} requestHeader - A [request header]{@link https://developer.mozilla.org/en-US/docs/Glossary/Request_header}\n     * for configuring the HTTP request.\n     * @return {Loader} A reference to this instance.\n     */\n    setRequestHeader(requestHeader) {\n      this.requestHeader = requestHeader;\n      return this;\n    }\n    /**\n     * This method can be implemented in loaders for aborting ongoing requests.\n     *\n     * @abstract\n     * @return {Loader} A reference to this instance.\n     */\n    abort() {\n      return this;\n    }\n  }\n  Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";\n  const loading = {};\n  class HttpError extends Error {\n    constructor(message, response) {\n      super(message);\n      this.response = response;\n    }\n  }\n  class FileLoader extends Loader {\n    /**\n     * Constructs a new file loader.\n     *\n     * @param {LoadingManager} [manager] - The loading manager.\n     */\n    constructor(manager) {\n      super(manager);\n      this.mimeType = "";\n      this.responseType = "";\n      this._abortController = new AbortController();\n    }\n    /**\n     * Starts loading from the given URL and pass the loaded response to the `onLoad()` callback.\n     *\n     * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n     * @param {function(any)} onLoad - Executed when the loading process has been finished.\n     * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.\n     * @param {onErrorCallback} [onError] - Executed when errors occur.\n     * @return {any|undefined} The cached resource if available.\n     */\n    load(url, onLoad, onProgress, onError) {\n      if (url === void 0) url = "";\n      if (this.path !== void 0) url = this.path + url;\n      url = this.manager.resolveURL(url);\n      const cached = Cache.get(`file:${url}`);\n      if (cached !== void 0) {\n        this.manager.itemStart(url);\n        setTimeout(() => {\n          if (onLoad) onLoad(cached);\n          this.manager.itemEnd(url);\n        }, 0);\n        return cached;\n      }\n      if (loading[url] !== void 0) {\n        loading[url].push({\n          onLoad,\n          onProgress,\n          onError\n        });\n        return;\n      }\n      loading[url] = [];\n      loading[url].push({\n        onLoad,\n        onProgress,\n        onError\n      });\n      const req = new Request(url, {\n        headers: new Headers(this.requestHeader),\n        credentials: this.withCredentials ? "include" : "same-origin",\n        signal: typeof AbortSignal.any === "function" ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal\n      });\n      const mimeType = this.mimeType;\n      const responseType = this.responseType;\n      fetch(req).then((response) => {\n        if (response.status === 200 || response.status === 0) {\n          if (response.status === 0) {\n            console.warn("THREE.FileLoader: HTTP Status 0 received.");\n          }\n          if (typeof ReadableStream === "undefined" || response.body === void 0 || response.body.getReader === void 0) {\n            return response;\n          }\n          const callbacks = loading[url];\n          const reader = response.body.getReader();\n          const contentLength = response.headers.get("X-File-Size") || response.headers.get("Content-Length");\n          const total = contentLength ? parseInt(contentLength) : 0;\n          const lengthComputable = total !== 0;\n          let loaded = 0;\n          const stream = new ReadableStream({\n            start(controller) {\n              readData();\n              function readData() {\n                reader.read().then(({ done, value }) => {\n                  if (done) {\n                    controller.close();\n                  } else {\n                    loaded += value.byteLength;\n                    const event = new ProgressEvent("progress", { lengthComputable, loaded, total });\n                    for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {\n                      const callback = callbacks[i2];\n                      if (callback.onProgress) callback.onProgress(event);\n                    }\n                    controller.enqueue(value);\n                    readData();\n                  }\n                }, (e) => {\n                  controller.error(e);\n                });\n              }\n            }\n          });\n          return new Response(stream);\n        } else {\n          throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response);\n        }\n      }).then((response) => {\n        switch (responseType) {\n          case "arraybuffer":\n            return response.arrayBuffer();\n          case "blob":\n            return response.blob();\n          case "document":\n            return response.text().then((text) => {\n              const parser = new DOMParser();\n              return parser.parseFromString(text, mimeType);\n            });\n          case "json":\n            return response.json();\n          default:\n            if (mimeType === "") {\n              return response.text();\n            } else {\n              const re = /charset="?([^;"\\s]*)"?/i;\n              const exec = re.exec(mimeType);\n              const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;\n              const decoder = new TextDecoder(label);\n              return response.arrayBuffer().then((ab) => decoder.decode(ab));\n            }\n        }\n      }).then((data) => {\n        Cache.add(`file:${url}`, data);\n        const callbacks = loading[url];\n        delete loading[url];\n        for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {\n          const callback = callbacks[i2];\n          if (callback.onLoad) callback.onLoad(data);\n        }\n      }).catch((err2) => {\n        const callbacks = loading[url];\n        if (callbacks === void 0) {\n          this.manager.itemError(url);\n          throw err2;\n        }\n        delete loading[url];\n        for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {\n          const callback = callbacks[i2];\n          if (callback.onError) callback.onError(err2);\n        }\n        this.manager.itemError(url);\n      }).finally(() => {\n        this.manager.itemEnd(url);\n      });\n      this.manager.itemStart(url);\n    }\n    /**\n     * Sets the expected response type.\n     *\n     * @param {(\'arraybuffer\'|\'blob\'|\'document\'|\'json\'|\'\')} value - The response type.\n     * @return {FileLoader} A reference to this file loader.\n     */\n    setResponseType(value) {\n      this.responseType = value;\n      return this;\n    }\n    /**\n     * Sets the expected mime type of the loaded file.\n     *\n     * @param {string} value - The mime type.\n     * @return {FileLoader} A reference to this file loader.\n     */\n    setMimeType(value) {\n      this.mimeType = value;\n      return this;\n    }\n    /**\n     * Aborts ongoing fetch requests.\n     *\n     * @return {FileLoader} A reference to this instance.\n     */\n    abort() {\n      this._abortController.abort();\n      this._abortController = new AbortController();\n      return this;\n    }\n  }\n  class OrthographicCamera extends Camera {\n    /**\n     * Constructs a new orthographic camera.\n     *\n     * @param {number} [left=-1] - The left plane of the camera\'s frustum.\n     * @param {number} [right=1] - The right plane of the camera\'s frustum.\n     * @param {number} [top=1] - The top plane of the camera\'s frustum.\n     * @param {number} [bottom=-1] - The bottom plane of the camera\'s frustum.\n     * @param {number} [near=0.1] - The camera\'s near plane.\n     * @param {number} [far=2000] - The camera\'s far plane.\n     */\n    constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {\n      super();\n      this.isOrthographicCamera = true;\n      this.type = "OrthographicCamera";\n      this.zoom = 1;\n      this.view = null;\n      this.left = left;\n      this.right = right;\n      this.top = top;\n      this.bottom = bottom;\n      this.near = near;\n      this.far = far;\n      this.updateProjectionMatrix();\n    }\n    copy(source, recursive) {\n      super.copy(source, recursive);\n      this.left = source.left;\n      this.right = source.right;\n      this.top = source.top;\n      this.bottom = source.bottom;\n      this.near = source.near;\n      this.far = source.far;\n      this.zoom = source.zoom;\n      this.view = source.view === null ? null : Object.assign({}, source.view);\n      return this;\n    }\n    /**\n     * Sets an offset in a larger frustum. This is useful for multi-window or\n     * multi-monitor/multi-machine setups.\n     *\n     * @param {number} fullWidth - The full width of multiview setup.\n     * @param {number} fullHeight - The full height of multiview setup.\n     * @param {number} x - The horizontal offset of the subcamera.\n     * @param {number} y - The vertical offset of the subcamera.\n     * @param {number} width - The width of subcamera.\n     * @param {number} height - The height of subcamera.\n     * @see {@link PerspectiveCamera#setViewOffset}\n     */\n    setViewOffset(fullWidth, fullHeight, x2, y, width, height) {\n      if (this.view === null) {\n        this.view = {\n          enabled: true,\n          fullWidth: 1,\n          fullHeight: 1,\n          offsetX: 0,\n          offsetY: 0,\n          width: 1,\n          height: 1\n        };\n      }\n      this.view.enabled = true;\n      this.view.fullWidth = fullWidth;\n      this.view.fullHeight = fullHeight;\n      this.view.offsetX = x2;\n      this.view.offsetY = y;\n      this.view.width = width;\n      this.view.height = height;\n      this.updateProjectionMatrix();\n    }\n    /**\n     * Removes the view offset from the projection matrix.\n     */\n    clearViewOffset() {\n      if (this.view !== null) {\n        this.view.enabled = false;\n      }\n      this.updateProjectionMatrix();\n    }\n    /**\n     * Updates the camera\'s projection matrix. Must be called after any change of\n     * camera properties.\n     */\n    updateProjectionMatrix() {\n      const dx = (this.right - this.left) / (2 * this.zoom);\n      const dy = (this.top - this.bottom) / (2 * this.zoom);\n      const cx = (this.right + this.left) / 2;\n      const cy = (this.top + this.bottom) / 2;\n      let left = cx - dx;\n      let right = cx + dx;\n      let top = cy + dy;\n      let bottom = cy - dy;\n      if (this.view !== null && this.view.enabled) {\n        const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;\n        const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;\n        left += scaleW * this.view.offsetX;\n        right = left + scaleW * this.view.width;\n        top -= scaleH * this.view.offsetY;\n        bottom = top - scaleH * this.view.height;\n      }\n      this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem, this.reversedDepth);\n      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n    }\n    toJSON(meta) {\n      const data = super.toJSON(meta);\n      data.object.zoom = this.zoom;\n      data.object.left = this.left;\n      data.object.right = this.right;\n      data.object.top = this.top;\n      data.object.bottom = this.bottom;\n      data.object.near = this.near;\n      data.object.far = this.far;\n      if (this.view !== null) data.object.view = Object.assign({}, this.view);\n      return data;\n    }\n  }\n  class Matrix2 {\n    /**\n     * Constructs a new 2x2 matrix. The arguments are supposed to be\n     * in row-major order. If no arguments are provided, the constructor\n     * initializes the matrix as an identity matrix.\n     *\n     * @param {number} [n11] - 1-1 matrix element.\n     * @param {number} [n12] - 1-2 matrix element.\n     * @param {number} [n21] - 2-1 matrix element.\n     * @param {number} [n22] - 2-2 matrix element.\n     */\n    constructor(n11, n12, n21, n22) {\n      Matrix2.prototype.isMatrix2 = true;\n      this.elements = [\n        1,\n        0,\n        0,\n        1\n      ];\n      if (n11 !== void 0) {\n        this.set(n11, n12, n21, n22);\n      }\n    }\n    /**\n     * Sets this matrix to the 2x2 identity matrix.\n     *\n     * @return {Matrix2} A reference to this matrix.\n     */\n    identity() {\n      this.set(\n        1,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    /**\n     * Sets the elements of the matrix from the given array.\n     *\n     * @param {Array<number>} array - The matrix elements in column-major order.\n     * @param {number} [offset=0] - Index of the first element in the array.\n     * @return {Matrix2} A reference to this matrix.\n     */\n    fromArray(array, offset = 0) {\n      for (let i2 = 0; i2 < 4; i2++) {\n        this.elements[i2] = array[i2 + offset];\n      }\n      return this;\n    }\n    /**\n     * Sets the elements of the matrix.The arguments are supposed to be\n     * in row-major order.\n     *\n     * @param {number} n11 - 1-1 matrix element.\n     * @param {number} n12 - 1-2 matrix element.\n     * @param {number} n21 - 2-1 matrix element.\n     * @param {number} n22 - 2-2 matrix element.\n     * @return {Matrix2} A reference to this matrix.\n     */\n    set(n11, n12, n21, n22) {\n      const te = this.elements;\n      te[0] = n11;\n      te[2] = n12;\n      te[1] = n21;\n      te[3] = n22;\n      return this;\n    }\n  }\n  if (typeof __THREE_DEVTOOLS__ !== "undefined") {\n    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {\n      revision: REVISION\n    } }));\n  }\n  if (typeof window !== "undefined") {\n    if (window.__THREE__) {\n      console.warn("WARNING: Multiple instances of Three.js being imported.");\n    } else {\n      window.__THREE__ = REVISION;\n    }\n  }\n  const LN_SCALE_MIN = -12;\n  const LN_SCALE_MAX = 9;\n  const LN_SCALE_ZERO = -30;\n  const SCALE_ZERO = Math.exp(LN_SCALE_ZERO);\n  const SPLAT_TEX_WIDTH_BITS = 11;\n  const SPLAT_TEX_HEIGHT_BITS = 11;\n  const SPLAT_TEX_WIDTH = 1 << SPLAT_TEX_WIDTH_BITS;\n  const SPLAT_TEX_HEIGHT = 1 << SPLAT_TEX_HEIGHT_BITS;\n  const SPLAT_TEX_MIN_HEIGHT = 1;\n  const SPLAT_PAGED_WIDTH_BITS = 12;\n  const SPLAT_PAGED_HEIGHT_BITS = 12;\n  const SPLAT_PAGED_WIDTH = 1 << SPLAT_PAGED_WIDTH_BITS;\n  const SPLAT_PAGED_HEIGHT = 1 << SPLAT_PAGED_HEIGHT_BITS;\n  function isIntType(type) {\n    return type === "int" || type === "ivec2" || type === "ivec3" || type === "ivec4";\n  }\n  function isUintType(type) {\n    return type === "uint" || type === "uvec2" || type === "uvec3" || type === "uvec4";\n  }\n  function isFloatType(type) {\n    return type === "float" || type === "vec2" || type === "vec3" || type === "vec4";\n  }\n  function isMatFloatType(type) {\n    return type === "mat2" || type === "mat2x2" || type === "mat2x3" || type === "mat2x4" || type === "mat3" || type === "mat3x2" || type === "mat3x3" || type === "mat3x4" || type === "mat4" || type === "mat4x2" || type === "mat4x3" || type === "mat4x4";\n  }\n  function isAllFloatType(type) {\n    return isFloatType(type) || isMatFloatType(type);\n  }\n  function isMat2(type) {\n    return type === "mat2" || type === "mat2x2";\n  }\n  function isMat3(type) {\n    return type === "mat3" || type === "mat3x3";\n  }\n  function isMat4(type) {\n    return type === "mat4" || type === "mat4x4";\n  }\n  function numberAsInt(value) {\n    return Math.trunc(value).toString();\n  }\n  function numberAsUint(value) {\n    const v = Math.max(0, Math.trunc(value));\n    return `${v.toString()}u`;\n  }\n  function numberAsFloat(value) {\n    return value === Number.POSITIVE_INFINITY ? "INFINITY" : value === Number.NEGATIVE_INFINITY ? "-INFINITY" : Number.isInteger(value) ? value.toFixed(1) : value.toString();\n  }\n  function valType(val) {\n    if (val instanceof DynoValue) {\n      return val.type;\n    }\n    const value = val.dynoOut();\n    return value.type;\n  }\n  class DynoValue {\n    constructor(type) {\n      this.__isDynoValue = true;\n      this.type = type;\n    }\n  }\n  class DynoOutput extends DynoValue {\n    constructor(dyno2, key) {\n      super(dyno2.outTypes[key]);\n      this.dyno = dyno2;\n      this.key = key;\n    }\n  }\n  class DynoLiteral extends DynoValue {\n    constructor(type, literal) {\n      super(type);\n      this.literal = literal;\n    }\n    getLiteral() {\n      return this.literal;\n    }\n  }\n  class DynoConst extends DynoLiteral {\n    constructor(type, value) {\n      super(type, "");\n      this.value = value;\n    }\n    getLiteral() {\n      const { type, value } = this;\n      switch (type) {\n        case "bool":\n          return value ? "true" : "false";\n        case "uint":\n          return numberAsUint(value);\n        case "int":\n          return numberAsInt(value);\n        case "float":\n          return numberAsFloat(value);\n        case "bvec2": {\n          const v = value;\n          return `bvec2(${v[0]}, ${v[1]})`;\n        }\n        case "uvec2": {\n          if (value instanceof Vector2) {\n            return `uvec2(${numberAsUint(value.x)}, ${numberAsUint(value.y)})`;\n          }\n          const v = value;\n          return `uvec2(${numberAsUint(v[0])}, ${numberAsUint(v[1])})`;\n        }\n        case "ivec2": {\n          if (value instanceof Vector2) {\n            return `ivec2(${numberAsInt(value.x)}, ${numberAsInt(value.y)})`;\n          }\n          const v = value;\n          return `ivec2(${numberAsInt(v[0])}, ${numberAsInt(v[1])})`;\n        }\n        case "vec2": {\n          if (value instanceof Vector2) {\n            return `vec2(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)})`;\n          }\n          const v = value;\n          return `vec2(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])})`;\n        }\n        case "bvec3": {\n          const v = value;\n          return `bvec3(${v[0]}, ${v[1]}, ${v[2]})`;\n        }\n        case "uvec3": {\n          if (value instanceof Vector3) {\n            return `uvec3(${numberAsUint(value.x)}, ${numberAsUint(value.y)}, ${numberAsUint(value.z)})`;\n          }\n          const v = value;\n          return `uvec3(${numberAsUint(v[0])}, ${numberAsUint(v[1])}, ${numberAsUint(v[2])})`;\n        }\n        case "ivec3": {\n          if (value instanceof Vector3) {\n            return `ivec3(${numberAsInt(value.x)}, ${numberAsInt(value.y)}, ${numberAsInt(value.z)})`;\n          }\n          const v = value;\n          return `ivec3(${numberAsInt(v[0])}, ${numberAsInt(v[1])}, ${numberAsInt(v[2])})`;\n        }\n        case "vec3": {\n          if (value instanceof Vector3) {\n            return `vec3(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)})`;\n          }\n          const v = value;\n          return `vec3(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])}, ${numberAsFloat(v[2])})`;\n        }\n        case "bvec4": {\n          const v = value;\n          return `bvec4(${v[0]}, ${v[1]}, ${v[2]}, ${v[3]})`;\n        }\n        case "uvec4": {\n          if (value instanceof Vector4) {\n            return `uvec4(${numberAsUint(value.x)}, ${numberAsUint(value.y)}, ${numberAsUint(value.z)}, ${numberAsUint(value.w)})`;\n          }\n          const v = value;\n          return `uvec4(${numberAsUint(v[0])}, ${numberAsUint(v[1])}, ${numberAsUint(v[2])}, ${numberAsUint(v[3])})`;\n        }\n        case "ivec4": {\n          if (value instanceof Vector4) {\n            return `ivec4(${numberAsInt(value.x)}, ${numberAsInt(value.y)}, ${numberAsInt(value.z)}, ${numberAsInt(value.w)})`;\n          }\n          const v = value;\n          return `ivec4(${numberAsInt(v[0])}, ${numberAsInt(v[1])}, ${numberAsInt(v[2])}, ${numberAsInt(v[3])})`;\n        }\n        case "vec4": {\n          if (value instanceof Vector4) {\n            return `vec4(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)}, ${numberAsFloat(value.w)})`;\n          }\n          if (value instanceof Quaternion) {\n            return `vec4(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)}, ${numberAsFloat(value.w)})`;\n          }\n          const v = value;\n          return `vec4(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])}, ${numberAsFloat(v[2])}, ${numberAsFloat(v[3])})`;\n        }\n        case "mat2":\n        case "mat2x2": {\n          const m = value;\n          const e = m instanceof Matrix2 ? m.elements : value;\n          const arg = new Array(4).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat2x3": {\n          const e = value;\n          const arg = new Array(6).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat2x4": {\n          const e = value;\n          const arg = new Array(8).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat3":\n        case "mat3x3": {\n          const m = value;\n          const e = m instanceof Matrix3 ? m.elements : value;\n          const arg = new Array(9).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat3x2": {\n          const e = value;\n          const arg = new Array(6).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat3x4": {\n          const e = value;\n          const arg = new Array(12).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat4":\n        case "mat4x4": {\n          const m = value;\n          const e = m instanceof Matrix4 ? m.elements : value;\n          const arg = new Array(16).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat4x2": {\n          const e = value;\n          const arg = new Array(8).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        case "mat4x3": {\n          const e = value;\n          const arg = new Array(12).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return `${type}(${arg.join(", ")})`;\n        }\n        default:\n          throw new Error(`Type not implemented: ${String(type)}`);\n      }\n    }\n  }\n  function dynoConst(type, value) {\n    return new DynoConst(type, value);\n  }\n  const DEFAULT_INDENT = "    ";\n  class Compilation {\n    constructor({ indent } = {}) {\n      this.globals = /* @__PURE__ */ new Set();\n      this.statements = [];\n      this.uniforms = {};\n      this.declares = /* @__PURE__ */ new Set();\n      this.updaters = [];\n      this.sequence = 0;\n      this.indent = DEFAULT_INDENT;\n      this.indent = indent ?? DEFAULT_INDENT;\n    }\n    nextSequence() {\n      return this.sequence++;\n    }\n  }\n  class Dyno {\n    constructor({\n      inTypes,\n      outTypes,\n      inputs,\n      update,\n      globals,\n      statements,\n      generate\n    }) {\n      this.inTypes = inTypes ?? {};\n      this.outTypes = outTypes ?? {};\n      this.inputs = inputs ?? {};\n      this.update = update;\n      this.globals = globals;\n      this.statements = statements;\n      this.generate = generate ?? (({ inputs: inputs2, outputs, compile }) => {\n        var _a2, _b2;\n        return {\n          globals: (_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs: inputs2, outputs, compile }),\n          statements: (_b2 = this.statements) == null ? void 0 : _b2.call(this, { inputs: inputs2, outputs, compile })\n        };\n      });\n    }\n    get outputs() {\n      const outputs = {};\n      for (const key in this.outTypes) {\n        outputs[key] = new DynoOutput(this, key);\n      }\n      return outputs;\n    }\n    apply(inputs) {\n      Object.assign(this.inputs, inputs);\n      return this.outputs;\n    }\n    compile({\n      inputs,\n      outputs,\n      compile\n    }) {\n      const result = [\n        `// ${this.constructor.name}(${Object.values(inputs).join(", ")}) => (${Object.values(outputs).join(", ")})`\n      ];\n      const declares = [];\n      for (const key in outputs) {\n        const name = outputs[key];\n        if (name && !compile.declares.has(name)) {\n          compile.declares.add(name);\n          declares.push(key);\n        }\n      }\n      const { globals, statements, uniforms } = this.generate({\n        inputs,\n        outputs,\n        compile\n      });\n      for (const global of globals ?? []) {\n        compile.globals.add(global);\n      }\n      for (const key in uniforms) {\n        compile.uniforms[key] = uniforms[key];\n      }\n      if (this.update) {\n        compile.updaters.push(this.update);\n      }\n      for (const key of declares) {\n        const name = outputs[key];\n        if (name) {\n          if (!compile.uniforms[name]) {\n            result.push(`${dynoDeclare(name, this.outTypes[key])};`);\n          }\n        }\n      }\n      if (statements == null ? void 0 : statements.length) {\n        result.push("{");\n        result.push(...statements.map((line) => compile.indent + line));\n        result.push("}");\n      }\n      return result;\n    }\n  }\n  class DynoBlock extends Dyno {\n    constructor({\n      inTypes,\n      outTypes,\n      inputs,\n      update,\n      globals,\n      construct\n    }) {\n      super({\n        inTypes,\n        outTypes,\n        inputs,\n        update,\n        globals,\n        generate: (args) => this.generateBlock(args)\n      });\n      this.construct = construct;\n    }\n    generateBlock({\n      inputs,\n      outputs,\n      compile\n    }) {\n      var _a2, _b2;\n      const blockInputs = {};\n      const blockOutputs = {};\n      for (const key in inputs) {\n        if (inputs[key] != null) {\n          blockInputs[key] = new DynoLiteral(this.inTypes[key], inputs[key]);\n        }\n      }\n      for (const key in outputs) {\n        if (outputs[key] != null) {\n          blockOutputs[key] = new DynoValue(this.outTypes[key]);\n        }\n      }\n      const options = { roots: [] };\n      const returned = this.construct(blockInputs, blockOutputs, options);\n      for (const global of ((_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs, outputs, compile })) ?? []) {\n        compile.globals.add(global);\n      }\n      const ordering = [];\n      const nodeOuts = /* @__PURE__ */ new Map();\n      function visit(node, outKey, outName) {\n        let outs = nodeOuts.get(node);\n        if (!outs) {\n          outs = {\n            sequence: compile.nextSequence(),\n            outNames: /* @__PURE__ */ new Map(),\n            newOuts: /* @__PURE__ */ new Set()\n          };\n          nodeOuts.set(node, outs);\n          for (const key in node.inputs) {\n            let input = node.inputs[key];\n            while (input) {\n              if (input instanceof DynoValue) {\n                if (input instanceof DynoOutput) {\n                  visit(input.dyno, input.key);\n                }\n                break;\n              }\n              input = input.dynoOut();\n            }\n          }\n          ordering.push(node);\n        }\n        if (outKey) {\n          if (!outName) {\n            outs.newOuts.add(outKey);\n          }\n          outs.outNames.set(outKey, outName ?? `${outKey}_${outs.sequence}`);\n        }\n      }\n      for (const root of options.roots) {\n        visit(root);\n      }\n      for (const key in blockOutputs) {\n        let value = (returned == null ? void 0 : returned[key]) ?? blockOutputs[key];\n        while (value) {\n          if (value instanceof DynoValue) {\n            if (value instanceof DynoOutput) {\n              visit(value.dyno, value.key, outputs[key]);\n            }\n            break;\n          }\n          value = value.dynoOut();\n        }\n        blockOutputs[key] = value;\n      }\n      const steps = [];\n      for (const dyno2 of ordering) {\n        const inputs2 = {};\n        const outputs2 = {};\n        for (const key in dyno2.inputs) {\n          let value = dyno2.inputs[key];\n          while (value) {\n            if (value instanceof DynoValue) {\n              if (value instanceof DynoLiteral) {\n                inputs2[key] = value.getLiteral();\n              } else if (value instanceof DynoOutput) {\n                const source = (_b2 = nodeOuts.get(value.dyno)) == null ? void 0 : _b2.outNames.get(value.key);\n                if (!source) {\n                  throw new Error(\n                    `Source not found for ${value.dyno.constructor.name}.${value.key}`\n                  );\n                }\n                inputs2[key] = source;\n              }\n              break;\n            }\n            value = value.dynoOut();\n          }\n        }\n        const outs = nodeOuts.get(dyno2) ?? { outNames: /* @__PURE__ */ new Map() };\n        for (const [key, name] of outs.outNames.entries()) {\n          outputs2[key] = name;\n        }\n        const newSteps = dyno2.compile({ inputs: inputs2, outputs: outputs2, compile });\n        steps.push(newSteps);\n      }\n      const literalOutputs = [];\n      for (const key in outputs) {\n        if (blockOutputs[key] instanceof DynoLiteral) {\n          literalOutputs.push(\n            `${outputs[key]} = ${blockOutputs[key].getLiteral()};`\n          );\n        }\n      }\n      if (literalOutputs.length > 0) {\n        steps.push(literalOutputs);\n      }\n      const statements = steps.flatMap((step, index) => {\n        return index === 0 ? step : ["", ...step];\n      });\n      return { statements };\n    }\n  }\n  function dynoBlock(inTypes, outTypes, construct, { update, globals } = {}) {\n    return new DynoBlock({ inTypes, outTypes, construct, update, globals });\n  }\n  function dyno({\n    inTypes,\n    outTypes,\n    inputs,\n    update,\n    globals,\n    statements,\n    generate\n  }) {\n    return new Dyno({\n      inTypes,\n      outTypes,\n      inputs,\n      update,\n      globals,\n      statements,\n      generate\n    });\n  }\n  function dynoDeclare(name, type, count) {\n    const typeStr = typeof type === "string" ? type : type.type;\n    if (!typeStr) {\n      throw new Error(`Invalid DynoType: ${String(type)}`);\n    }\n    return `${typeStr} ${name}${count != null ? `[${count}]` : ""}`;\n  }\n  function unindentLines(s) {\n    var _a2;\n    let seenNonEmpty = false;\n    const lines = s.split("\\n").map((line) => {\n      const trimmedLine = line.trimEnd();\n      if (seenNonEmpty) {\n        return trimmedLine;\n      }\n      if (trimmedLine.length > 0) {\n        seenNonEmpty = true;\n        return trimmedLine;\n      }\n      return null;\n    }).filter((line) => line != null);\n    while (lines.length > 0 && lines[lines.length - 1].length === 0) {\n      lines.pop();\n    }\n    if (lines.length === 0) {\n      return [];\n    }\n    const indent = (_a2 = lines[0].match(/^\\s*/)) == null ? void 0 : _a2[0];\n    if (!indent) {\n      return lines;\n    }\n    const regex = new RegExp(`^${indent}`);\n    return lines.map((line) => line.replace(regex, ""));\n  }\n  function unindent(s) {\n    return unindentLines(s).join("\\n");\n  }\n  class UnaryOp extends Dyno {\n    constructor({\n      a,\n      outKey,\n      outTypeFunc\n    }) {\n      const inTypes = { a: valType(a) };\n      const outType = outTypeFunc(valType(a));\n      const outTypes = { [outKey]: outType };\n      super({ inTypes, outTypes, inputs: { a } });\n      this.outKey = outKey;\n    }\n    dynoOut() {\n      return new DynoOutput(this, this.outKey);\n    }\n  }\n  class BinaryOp extends Dyno {\n    constructor({\n      a,\n      b,\n      outKey,\n      outTypeFunc\n    }) {\n      const inTypes = { a: valType(a), b: valType(b) };\n      const outType = outTypeFunc(valType(a), valType(b));\n      const outTypes = { [outKey]: outType };\n      super({ inTypes, outTypes, inputs: { a, b } });\n      this.outKey = outKey;\n    }\n    dynoOut() {\n      return new DynoOutput(this, this.outKey);\n    }\n  }\n  const f32buffer = new Float32Array(1);\n  const u32buffer = new Uint32Array(f32buffer.buffer);\n  const supportsFloat16Array = "Float16Array" in globalThis;\n  const f16buffer = supportsFloat16Array ? new globalThis["Float16Array"](1) : null;\n  const u16buffer = new Uint16Array(f16buffer == null ? void 0 : f16buffer.buffer);\n  function normalize$1(vec) {\n    const norm = Math.sqrt(vec.reduce((acc, v) => acc + v * v, 0));\n    return vec.map((v) => v / norm);\n  }\n  const toHalf = supportsFloat16Array ? toHalfNative : toHalfJS;\n  const fromHalf = supportsFloat16Array ? fromHalfNative : fromHalfJS;\n  function toHalfNative(f) {\n    f16buffer[0] = f;\n    return u16buffer[0];\n  }\n  function toHalfJS(f) {\n    f32buffer[0] = f;\n    const bits2 = u32buffer[0];\n    const sign = bits2 >> 31 & 1;\n    const exp = bits2 >> 23 & 255;\n    const frac = bits2 & 8388607;\n    const halfSign = sign << 15;\n    if (exp === 255) {\n      if (frac !== 0) {\n        return halfSign | 32767;\n      }\n      return halfSign | 31744;\n    }\n    const newExp = exp - 127 + 15;\n    if (newExp >= 31) {\n      return halfSign | 31744;\n    }\n    if (newExp <= 0) {\n      if (newExp < -10) {\n        return halfSign;\n      }\n      const subFrac = (frac | 8388608) >> 1 - newExp + 13;\n      return halfSign | subFrac;\n    }\n    const halfFrac = frac >> 13;\n    return halfSign | newExp << 10 | halfFrac;\n  }\n  function fromHalfNative(u) {\n    u16buffer[0] = u;\n    return f16buffer[0];\n  }\n  function fromHalfJS(h) {\n    const sign = h >> 15 & 1;\n    const exp = h >> 10 & 31;\n    const frac = h & 1023;\n    let f32bits;\n    if (exp === 0) {\n      if (frac === 0) {\n        f32bits = sign << 31;\n      } else {\n        let mant = frac;\n        let e = -14;\n        while ((mant & 1024) === 0) {\n          mant <<= 1;\n          e--;\n        }\n        mant &= 1023;\n        const newExp = e + 127;\n        const newFrac = mant << 13;\n        f32bits = sign << 31 | newExp << 23 | newFrac;\n      }\n    } else if (exp === 31) {\n      if (frac === 0) {\n        f32bits = sign << 31 | 2139095040;\n      } else {\n        f32bits = sign << 31 | 2143289344;\n      }\n    } else {\n      const newExp = exp - 15 + 127;\n      const newFrac = frac << 13;\n      f32bits = sign << 31 | newExp << 23 | newFrac;\n    }\n    u32buffer[0] = f32bits;\n    return f32buffer[0];\n  }\n  function floatToUint8(v) {\n    return Math.max(0, Math.min(255, Math.round(v * 255)));\n  }\n  function getArrayBuffers(ctx) {\n    const buffers = [];\n    const seen = /* @__PURE__ */ new Set();\n    function traverse(obj) {\n      if (obj && typeof obj === "object" && !seen.has(obj)) {\n        seen.add(obj);\n        if (obj instanceof ArrayBuffer) {\n          buffers.push(obj);\n        } else if (ArrayBuffer.isView(obj)) {\n          buffers.push(obj.buffer);\n        } else if (Array.isArray(obj)) {\n          obj.forEach(traverse);\n        } else {\n          Object.values(obj).forEach(traverse);\n        }\n      }\n    }\n    traverse(ctx);\n    return buffers;\n  }\n  function setPackedSplat(packedSplats, index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b, encoding) {\n    const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n    const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n    const rgbRange = rgbMax - rgbMin;\n    const uR = floatToUint8((r - rgbMin) / rgbRange);\n    const uG = floatToUint8((g - rgbMin) / rgbRange);\n    const uB = floatToUint8((b - rgbMin) / rgbRange);\n    const uA = floatToUint8((encoding == null ? void 0 : encoding.lodOpacity) ? 0.5 * opacity : opacity);\n    const uQuat = encodeQuatOctXy88R8(\n      tempQuaternion.set(quatX, quatY, quatZ, quatW)\n    );\n    const uQuatX = uQuat & 255;\n    const uQuatY = uQuat >>> 8 & 255;\n    const uQuatZ = uQuat >>> 16 & 255;\n    const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;\n    const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;\n    const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);\n    const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1\n      )\n    );\n    const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1\n      )\n    );\n    const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1\n      )\n    );\n    const uCenterX = toHalf(x2);\n    const uCenterY = toHalf(y);\n    const uCenterZ = toHalf(z);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\n    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n    packedSplats[i4 + 2] = uCenterZ | uQuatX << 16 | uQuatY << 24;\n    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | uQuatZ << 24;\n  }\n  function setPackedSplatCenter(packedSplats, index, x2, y, z) {\n    const uCenterX = toHalf(x2);\n    const uCenterY = toHalf(y);\n    const uCenterZ = toHalf(z);\n    const i4 = index * 4;\n    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n    packedSplats[i4 + 2] = uCenterZ | packedSplats[i4 + 2] & 4294901760;\n  }\n  function setPackedSplatScales(packedSplats, index, scaleX, scaleY, scaleZ, encoding) {\n    const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;\n    const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;\n    const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);\n    const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1\n      )\n    );\n    const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1\n      )\n    );\n    const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(\n      255,\n      Math.max(\n        1,\n        Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1\n      )\n    );\n    const i4 = index * 4;\n    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | packedSplats[i4 + 3] & 4278190080;\n  }\n  const tempQuaternion = new Quaternion();\n  function setPackedSplatQuat(packedSplats, index, quatX, quatY, quatZ, quatW) {\n    const uQuat = encodeQuatOctXy88R8(\n      tempQuaternion.set(quatX, quatY, quatZ, quatW)\n    );\n    const uQuatX = uQuat & 255;\n    const uQuatY = uQuat >>> 8 & 255;\n    const uQuatZ = uQuat >>> 16 & 255;\n    const i4 = index * 4;\n    packedSplats[i4 + 2] = packedSplats[i4 + 2] & 65535 | uQuatX << 16 | uQuatY << 24;\n    packedSplats[i4 + 3] = packedSplats[i4 + 3] & 16777215 | uQuatZ << 24;\n  }\n  function setPackedSplatRgba(packedSplats, index, r, g, b, a, encoding) {\n    const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n    const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n    const rgbRange = rgbMax - rgbMin;\n    const uR = floatToUint8((r - rgbMin) / rgbRange);\n    const uG = floatToUint8((g - rgbMin) / rgbRange);\n    const uB = floatToUint8((b - rgbMin) / rgbRange);\n    const uA = floatToUint8((encoding == null ? void 0 : encoding.lodOpacity) ? 0.5 * a : a);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\n  }\n  function setPackedSplatRgb(packedSplats, index, r, g, b, encoding) {\n    const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n    const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n    const rgbRange = rgbMax - rgbMin;\n    const uR = floatToUint8((r - rgbMin) / rgbRange);\n    const uG = floatToUint8((g - rgbMin) / rgbRange);\n    const uB = floatToUint8((b - rgbMin) / rgbRange);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | packedSplats[i4] & 4278190080;\n  }\n  function setPackedSplatOpacity(packedSplats, index, opacity) {\n    const uA = floatToUint8(opacity);\n    const i4 = index * 4;\n    packedSplats[i4] = packedSplats[i4] & 16777215 | uA << 24;\n  }\n  const packedCenter = new Vector3();\n  const packedScales = new Vector3();\n  const packedQuaternion = new Quaternion();\n  const packedColor = new Color();\n  const packedFields = {\n    center: packedCenter,\n    scales: packedScales,\n    quaternion: packedQuaternion,\n    color: packedColor,\n    opacity: 0\n  };\n  function unpackSplat(packedSplats, index, encoding) {\n    const result = packedFields;\n    const i4 = index * 4;\n    const word0 = packedSplats[i4];\n    const word1 = packedSplats[i4 + 1];\n    const word2 = packedSplats[i4 + 2];\n    const word3 = packedSplats[i4 + 3];\n    const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n    const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n    const rgbRange = rgbMax - rgbMin;\n    result.color.set(\n      rgbMin + (word0 & 255) / 255 * rgbRange,\n      rgbMin + (word0 >>> 8 & 255) / 255 * rgbRange,\n      rgbMin + (word0 >>> 16 & 255) / 255 * rgbRange\n    );\n    result.opacity = (word0 >>> 24 & 255) / 255;\n    if (encoding == null ? void 0 : encoding.lodOpacity) {\n      result.opacity = 2 * result.opacity;\n    }\n    result.center.set(\n      fromHalf(word1 & 65535),\n      fromHalf(word1 >>> 16 & 65535),\n      fromHalf(word2 & 65535)\n    );\n    const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;\n    const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;\n    const lnScaleScale = (lnScaleMax - lnScaleMin) / 254;\n    const uScalesX = word3 & 255;\n    result.scales.x = uScalesX === 0 ? 0 : Math.exp(lnScaleMin + (uScalesX - 1) * lnScaleScale);\n    const uScalesY = word3 >>> 8 & 255;\n    result.scales.y = uScalesY === 0 ? 0 : Math.exp(lnScaleMin + (uScalesY - 1) * lnScaleScale);\n    const uScalesZ = word3 >>> 16 & 255;\n    result.scales.z = uScalesZ === 0 ? 0 : Math.exp(lnScaleMin + (uScalesZ - 1) * lnScaleScale);\n    const uQuat = word2 >>> 16 & 65535 | word3 >>> 8 & 16711680;\n    decodeQuatOctXy88R8(uQuat, result.quaternion);\n    return result;\n  }\n  function getTextureSize(numSplats) {\n    const width = SPLAT_TEX_WIDTH;\n    const height = Math.max(\n      SPLAT_TEX_MIN_HEIGHT,\n      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\n    );\n    const depth = Math.ceil(numSplats / (width * height));\n    const maxSplats = width * height * depth;\n    return { width, height, depth, maxSplats };\n  }\n  function computeMaxSplats(numSplats) {\n    const width = SPLAT_TEX_WIDTH;\n    const height = Math.max(\n      SPLAT_TEX_MIN_HEIGHT,\n      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\n    );\n    const depth = Math.ceil(numSplats / (width * height));\n    return width * height * depth;\n  }\n  const IDENT_VERTEX_SHADER = unindent(`\n  precision highp float;\n\n  in vec3 position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n  }\n`);\n  const tempNormalizedQuaternion = new Quaternion();\n  const tempAxis = new Vector3();\n  function encodeQuatOctXy88R8(q) {\n    const qnorm = tempNormalizedQuaternion.copy(q).normalize();\n    if (qnorm.w < 0) {\n      qnorm.set(-qnorm.x, -qnorm.y, -qnorm.z, -qnorm.w);\n    }\n    const theta = 2 * Math.acos(qnorm.w);\n    const xyz_norm = Math.sqrt(\n      qnorm.x * qnorm.x + qnorm.y * qnorm.y + qnorm.z * qnorm.z\n    );\n    const axis = xyz_norm < 1e-6 ? tempAxis.set(1, 0, 0) : tempAxis.set(qnorm.x, qnorm.y, qnorm.z).divideScalar(xyz_norm);\n    const sum = Math.abs(axis.x) + Math.abs(axis.y) + Math.abs(axis.z);\n    let p_x = axis.x / sum;\n    let p_y = axis.y / sum;\n    if (axis.z < 0) {\n      const tmp = p_x;\n      p_x = (1 - Math.abs(p_y)) * (p_x >= 0 ? 1 : -1);\n      p_y = (1 - Math.abs(tmp)) * (p_y >= 0 ? 1 : -1);\n    }\n    const u_f = p_x * 0.5 + 0.5;\n    const v_f = p_y * 0.5 + 0.5;\n    const quantU = Math.round(u_f * 255);\n    const quantV = Math.round(v_f * 255);\n    const angleInt = Math.round(theta * (255 / Math.PI));\n    return angleInt << 16 | quantV << 8 | quantU;\n  }\n  function decodeQuatOctXy88R8(encoded, out) {\n    const quantU = encoded & 255;\n    const quantV = encoded >>> 8 & 255;\n    const angleInt = encoded >>> 16 & 255;\n    const u_f = quantU / 255;\n    const v_f = quantV / 255;\n    let f_x = (u_f - 0.5) * 2;\n    let f_y = (v_f - 0.5) * 2;\n    const f_z = 1 - (Math.abs(f_x) + Math.abs(f_y));\n    const t = Math.max(-f_z, 0);\n    f_x += f_x >= 0 ? -t : t;\n    f_y += f_y >= 0 ? -t : t;\n    const axis = tempAxis.set(f_x, f_y, f_z).normalize();\n    const theta = angleInt / 255 * Math.PI;\n    const halfTheta = theta * 0.5;\n    const s = Math.sin(halfTheta);\n    const w = Math.cos(halfTheta);\n    out.set(axis.x * s, axis.y * s, axis.z * s, w);\n    return out;\n  }\n  function packSint8Bytes(b0, b1, b22, b3) {\n    const clampedB0 = Math.round(Math.max(-127, Math.min(127, b0 * 127)));\n    const clampedB1 = Math.round(Math.max(-127, Math.min(127, b1 * 127)));\n    const clampedB2 = Math.round(Math.max(-127, Math.min(127, b22 * 127)));\n    const clampedB3 = Math.round(Math.max(-127, Math.min(127, b3 * 127)));\n    return clampedB0 & 255 | (clampedB1 & 255) << 8 | (clampedB2 & 255) << 16 | (clampedB3 & 255) << 24;\n  }\n  function encodeSh1Rgb(sh1Array, index, sh1Rgb, encoding) {\n    const sh1Min = (encoding == null ? void 0 : encoding.sh1Min) ?? -1;\n    const sh1Max = (encoding == null ? void 0 : encoding.sh1Max) ?? 1;\n    const sh1Mid = 0.5 * (sh1Min + sh1Max);\n    const sh1Scale = 126 / (sh1Max - sh1Min);\n    const base = index * 2;\n    for (let i2 = 0; i2 < 9; ++i2) {\n      const s = (sh1Rgb[i2] - sh1Mid) * sh1Scale;\n      const value = Math.round(Math.max(-63, Math.min(63, s))) & 127;\n      const bitStart = i2 * 7;\n      const bitEnd = bitStart + 7;\n      const wordStart = Math.floor(bitStart / 32);\n      const bitOffset = bitStart - wordStart * 32;\n      const firstWord = value << bitOffset & 4294967295;\n      sh1Array[base + wordStart] |= firstWord;\n      if (bitEnd > wordStart * 32 + 32) {\n        const secondWord = value >>> 32 - bitOffset & 4294967295;\n        sh1Array[base + wordStart + 1] |= secondWord;\n      }\n    }\n  }\n  function encodeSh2Rgb(sh2Array, index, sh2Rgb, encoding) {\n    const sh2Min = (encoding == null ? void 0 : encoding.sh2Min) ?? -1;\n    const sh2Max = (encoding == null ? void 0 : encoding.sh2Max) ?? 1;\n    const sh2Mid = 0.5 * (sh2Min + sh2Max);\n    const sh2Scale = 2 / (sh2Max - sh2Min);\n    sh2Array[index * 4 + 0] = packSint8Bytes(\n      (sh2Rgb[0] - sh2Mid) * sh2Scale,\n      (sh2Rgb[1] - sh2Mid) * sh2Scale,\n      (sh2Rgb[2] - sh2Mid) * sh2Scale,\n      (sh2Rgb[3] - sh2Mid) * sh2Scale\n    );\n    sh2Array[index * 4 + 1] = packSint8Bytes(\n      (sh2Rgb[4] - sh2Mid) * sh2Scale,\n      (sh2Rgb[5] - sh2Mid) * sh2Scale,\n      (sh2Rgb[6] - sh2Mid) * sh2Scale,\n      (sh2Rgb[7] - sh2Mid) * sh2Scale\n    );\n    sh2Array[index * 4 + 2] = packSint8Bytes(\n      (sh2Rgb[8] - sh2Mid) * sh2Scale,\n      (sh2Rgb[9] - sh2Mid) * sh2Scale,\n      (sh2Rgb[10] - sh2Mid) * sh2Scale,\n      (sh2Rgb[11] - sh2Mid) * sh2Scale\n    );\n    sh2Array[index * 4 + 3] = packSint8Bytes(\n      (sh2Rgb[12] - sh2Mid) * sh2Scale,\n      (sh2Rgb[13] - sh2Mid) * sh2Scale,\n      (sh2Rgb[14] - sh2Mid) * sh2Scale,\n      0\n    );\n  }\n  function encodeSh3Rgb(sh3Array, index, sh3Rgb, encoding) {\n    const sh3Min = (encoding == null ? void 0 : encoding.sh3Min) ?? -1;\n    const sh3Max = (encoding == null ? void 0 : encoding.sh3Max) ?? 1;\n    const sh3Mid = 0.5 * (sh3Min + sh3Max);\n    const sh3Scale = 62 / (sh3Max - sh3Min);\n    const base = index * 4;\n    for (let i2 = 0; i2 < 21; ++i2) {\n      const s = (sh3Rgb[i2] - sh3Mid) * sh3Scale;\n      const value = Math.round(Math.max(-31, Math.min(31, s))) & 63;\n      const bitStart = i2 * 6;\n      const bitEnd = bitStart + 6;\n      const wordStart = Math.floor(bitStart / 32);\n      const bitOffset = bitStart - wordStart * 32;\n      const firstWord = value << bitOffset & 4294967295;\n      sh3Array[base + wordStart] |= firstWord;\n      if (bitEnd > wordStart * 32 + 32) {\n        const secondWord = value >>> 32 - bitOffset & 4294967295;\n        sh3Array[base + wordStart + 1] |= secondWord;\n      }\n    }\n  }\n  function decompressPartialGzip(fileBytes, numBytes) {\n    const chunks = [];\n    let totalBytes = 0;\n    let result = null;\n    const gunzip = new Gunzip((data, final) => {\n      chunks.push(data);\n      totalBytes += data.length;\n      if (final || totalBytes >= numBytes) {\n        const allBytes = new Uint8Array(totalBytes);\n        let offset2 = 0;\n        for (const chunk of chunks) {\n          allBytes.set(chunk, offset2);\n          offset2 += chunk.length;\n        }\n        result = allBytes.slice(0, numBytes);\n      }\n    });\n    const CHUNK_SIZE = 1024;\n    let offset = 0;\n    while (result == null && offset < fileBytes.length) {\n      const chunk = fileBytes.slice(offset, offset + CHUNK_SIZE);\n      gunzip.push(chunk, false);\n      offset += CHUNK_SIZE;\n    }\n    if (result == null) {\n      gunzip.push(new Uint8Array(), true);\n      if (result == null) {\n        throw new Error("Failed to decompress partial gzip");\n      }\n    }\n    return result;\n  }\n  class GunzipReader {\n    constructor({\n      fileBytes,\n      chunkBytes = 64 * 1024\n    }) {\n      this.fileBytes = fileBytes;\n      this.chunkBytes = chunkBytes;\n      this.chunks = [];\n      this.totalBytes = 0;\n      const ds = new DecompressionStream("gzip");\n      const decompressionStream = new Blob([fileBytes]).stream().pipeThrough(ds);\n      this.reader = decompressionStream.getReader();\n    }\n    async read(numBytes) {\n      while (this.totalBytes < numBytes) {\n        const { value: chunk, done: readerDone } = await this.reader.read();\n        if (readerDone) {\n          break;\n        }\n        this.chunks.push(chunk);\n        this.totalBytes += chunk.length;\n      }\n      if (this.totalBytes < numBytes) {\n        throw new Error(\n          `Unexpected EOF: needed ${numBytes}, got ${this.totalBytes}`\n        );\n      }\n      const allBytes = new Uint8Array(this.totalBytes);\n      let outOffset = 0;\n      for (const chunk of this.chunks) {\n        allBytes.set(chunk, outOffset);\n        outOffset += chunk.length;\n      }\n      const result = allBytes.subarray(0, numBytes);\n      this.chunks = [allBytes.subarray(numBytes)];\n      this.totalBytes -= numBytes;\n      return result;\n    }\n  }\n  function decodeAntiSplat(fileBytes, initNumSplats, splatCallback) {\n    const numSplats = Math.floor(fileBytes.length / 32);\n    if (numSplats * 32 !== fileBytes.length) {\n      throw new Error("Invalid .splat file size");\n    }\n    initNumSplats(numSplats);\n    const f32 = new Float32Array(fileBytes.buffer);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const i322 = i2 * 32;\n      const i8 = i2 * 8;\n      const x2 = f32[i8 + 0];\n      const y = f32[i8 + 1];\n      const z = f32[i8 + 2];\n      const scaleX = f32[i8 + 3];\n      const scaleY = f32[i8 + 4];\n      const scaleZ = f32[i8 + 5];\n      const r = fileBytes[i322 + 24] / 255;\n      const g = fileBytes[i322 + 25] / 255;\n      const b = fileBytes[i322 + 26] / 255;\n      const opacity = fileBytes[i322 + 27] / 255;\n      const quatW = (fileBytes[i322 + 28] - 128) / 128;\n      const quatX = (fileBytes[i322 + 29] - 128) / 128;\n      const quatY = (fileBytes[i322 + 30] - 128) / 128;\n      const quatZ = (fileBytes[i322 + 31] - 128) / 128;\n      splatCallback(\n        i2,\n        x2,\n        y,\n        z,\n        scaleX,\n        scaleY,\n        scaleZ,\n        quatX,\n        quatY,\n        quatZ,\n        quatW,\n        opacity,\n        r,\n        g,\n        b\n      );\n    }\n  }\n  function unpackAntiSplat(fileBytes, splatEncoding) {\n    let numSplats = 0;\n    let maxSplats = 0;\n    let packedArray = new Uint32Array(0);\n    decodeAntiSplat(\n      fileBytes,\n      (cbNumSplats) => {\n        numSplats = cbNumSplats;\n        maxSplats = computeMaxSplats(numSplats);\n        packedArray = new Uint32Array(maxSplats * 4);\n      },\n      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n        setPackedSplat(\n          packedArray,\n          index,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b,\n          splatEncoding\n        );\n      }\n    );\n    return { packedArray, numSplats };\n  }\n  const KSPLAT_COMPRESSION = {\n    0: {\n      bytesPerCenter: 12,\n      bytesPerScale: 12,\n      bytesPerRotation: 16,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 4,\n      scaleOffsetBytes: 12,\n      rotationOffsetBytes: 24,\n      colorOffsetBytes: 40,\n      sphericalHarmonicsOffsetBytes: 44,\n      scaleRange: 1\n    },\n    1: {\n      bytesPerCenter: 6,\n      bytesPerScale: 6,\n      bytesPerRotation: 8,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 2,\n      scaleOffsetBytes: 6,\n      rotationOffsetBytes: 12,\n      colorOffsetBytes: 20,\n      sphericalHarmonicsOffsetBytes: 24,\n      scaleRange: 32767\n    },\n    2: {\n      bytesPerCenter: 6,\n      bytesPerScale: 6,\n      bytesPerRotation: 8,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 1,\n      scaleOffsetBytes: 6,\n      rotationOffsetBytes: 12,\n      colorOffsetBytes: 20,\n      sphericalHarmonicsOffsetBytes: 24,\n      scaleRange: 32767\n    }\n  };\n  const KSPLAT_SH_DEGREE_TO_COMPONENTS = {\n    0: 0,\n    1: 9,\n    2: 24,\n    3: 45\n  };\n  function decodeKsplat(fileBytes, initNumSplats, splatCallback, shCallback) {\n    var _a2;\n    const HEADER_BYTES = 4096;\n    const SECTION_BYTES = 1024;\n    let headerOffset = 0;\n    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\n    headerOffset += HEADER_BYTES;\n    const versionMajor = header.getUint8(0);\n    const versionMinor = header.getUint8(1);\n    if (versionMajor !== 0 || versionMinor < 1) {\n      throw new Error(\n        `Unsupported .ksplat version: ${versionMajor}.${versionMinor}`\n      );\n    }\n    const maxSectionCount = header.getUint32(4, true);\n    header.getUint32(16, true);\n    const compressionLevel = header.getUint16(20, true);\n    if (compressionLevel < 0 || compressionLevel > 2) {\n      throw new Error(`Invalid .ksplat compression level: ${compressionLevel}`);\n    }\n    const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;\n    const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;\n    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;\n    for (let section = 0; section < maxSectionCount; ++section) {\n      let getSh = function(splatOffset, component) {\n        if (compressionLevel === 0) {\n          return data.getFloat32(\n            splatOffset + sphericalHarmonicsOffsetBytes + component * 4,\n            true\n          );\n        }\n        if (compressionLevel === 1) {\n          return fromHalf(\n            data.getUint16(\n              splatOffset + sphericalHarmonicsOffsetBytes + component * 2,\n              true\n            )\n          );\n        }\n        const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;\n        return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);\n      };\n      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\n      headerOffset += SECTION_BYTES;\n      const sectionSplatCount = section2.getUint32(0, true);\n      const sectionMaxSplatCount = section2.getUint32(4, true);\n      const bucketSize = section2.getUint32(8, true);\n      const bucketCount = section2.getUint32(12, true);\n      const bucketBlockSize = section2.getFloat32(16, true);\n      const bucketStorageSizeBytes = section2.getUint16(20, true);\n      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;\n      const fullBucketCount = section2.getUint32(32, true);\n      const fullBucketSplats = fullBucketCount * bucketSize;\n      const partiallyFilledBucketCount = section2.getUint32(36, true);\n      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\n      const sphericalHarmonicsDegree = section2.getUint16(40, true);\n      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\n      const {\n        bytesPerCenter,\n        bytesPerScale,\n        bytesPerRotation,\n        bytesPerColor,\n        bytesPerSphericalHarmonicsComponent,\n        scaleOffsetBytes,\n        rotationOffsetBytes,\n        colorOffsetBytes,\n        sphericalHarmonicsOffsetBytes\n      } = KSPLAT_COMPRESSION[compressionLevel];\n      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;\n      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\n      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\n      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];\n      const sh2Index = [\n        9,\n        14,\n        19,\n        10,\n        15,\n        20,\n        11,\n        16,\n        21,\n        12,\n        17,\n        22,\n        13,\n        18,\n        23\n      ];\n      const sh3Index = [\n        24,\n        31,\n        38,\n        25,\n        32,\n        39,\n        26,\n        33,\n        40,\n        27,\n        34,\n        41,\n        28,\n        35,\n        42,\n        29,\n        36,\n        43,\n        30,\n        37,\n        44\n      ];\n      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\n      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;\n      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;\n      const dataBase = sectionBase + bucketsStorageSizeBytes;\n      const data = new DataView(\n        fileBytes.buffer,\n        dataBase,\n        splatDataStorageSizeBytes\n      );\n      const bucketArray = new Float32Array(\n        fileBytes.buffer,\n        bucketsBase,\n        bucketCount * 3\n      );\n      const partiallyFilledBucketLengths = new Uint32Array(\n        fileBytes.buffer,\n        sectionBase,\n        partiallyFilledBucketCount\n      );\n      let partialBucketIndex = fullBucketCount;\n      let partialBucketBase = fullBucketSplats;\n      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\n        const splatOffset = i2 * bytesPerSplat;\n        let bucketIndex;\n        if (i2 < fullBucketSplats) {\n          bucketIndex = Math.floor(i2 / bucketSize);\n        } else {\n          const bucketLength = partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\n          if (i2 >= partialBucketBase + bucketLength) {\n            partialBucketIndex += 1;\n            partialBucketBase += bucketLength;\n          }\n          bucketIndex = partialBucketIndex;\n        }\n        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\n        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\n        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\n        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\n        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\n        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\n        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\n        );\n        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\n        );\n        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\n        );\n        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\n        );\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\n        splatCallback(\n          i2,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n        if (sphericalHarmonicsDegree >= 1 && sh1) {\n          for (const [i22, key] of sh1Index.entries()) {\n            sh1[i22] = getSh(splatOffset, key);\n          }\n          if (sh2) {\n            for (const [i22, key] of sh2Index.entries()) {\n              sh2[i22] = getSh(splatOffset, key);\n            }\n          }\n          if (sh3) {\n            for (const [i22, key] of sh3Index.entries()) {\n              sh3[i22] = getSh(splatOffset, key);\n            }\n          }\n          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);\n        }\n      }\n      sectionBase += storageSizeBytes;\n    }\n  }\n  function unpackKsplat(fileBytes, splatEncoding) {\n    var _a2;\n    const HEADER_BYTES = 4096;\n    const SECTION_BYTES = 1024;\n    let headerOffset = 0;\n    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\n    headerOffset += HEADER_BYTES;\n    const versionMajor = header.getUint8(0);\n    const versionMinor = header.getUint8(1);\n    if (versionMajor !== 0 || versionMinor < 1) {\n      throw new Error(\n        `Unsupported .ksplat version: ${versionMajor}.${versionMinor}`\n      );\n    }\n    const maxSectionCount = header.getUint32(4, true);\n    const splatCount = header.getUint32(16, true);\n    const compressionLevel = header.getUint16(20, true);\n    if (compressionLevel < 0 || compressionLevel > 2) {\n      throw new Error(`Invalid .ksplat compression level: ${compressionLevel}`);\n    }\n    const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;\n    const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;\n    const numSplats = splatCount;\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;\n    for (let section = 0; section < maxSectionCount; ++section) {\n      let getSh = function(splatOffset, component) {\n        if (compressionLevel === 0) {\n          return data.getFloat32(\n            splatOffset + sphericalHarmonicsOffsetBytes + component * 4,\n            true\n          );\n        }\n        if (compressionLevel === 1) {\n          return fromHalf(\n            data.getUint16(\n              splatOffset + sphericalHarmonicsOffsetBytes + component * 2,\n              true\n            )\n          );\n        }\n        const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;\n        return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);\n      };\n      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\n      headerOffset += SECTION_BYTES;\n      const sectionSplatCount = section2.getUint32(0, true);\n      const sectionMaxSplatCount = section2.getUint32(4, true);\n      const bucketSize = section2.getUint32(8, true);\n      const bucketCount = section2.getUint32(12, true);\n      const bucketBlockSize = section2.getFloat32(16, true);\n      const bucketStorageSizeBytes = section2.getUint16(20, true);\n      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;\n      const fullBucketCount = section2.getUint32(32, true);\n      const fullBucketSplats = fullBucketCount * bucketSize;\n      const partiallyFilledBucketCount = section2.getUint32(36, true);\n      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\n      const sphericalHarmonicsDegree = section2.getUint16(40, true);\n      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\n      const {\n        bytesPerCenter,\n        bytesPerScale,\n        bytesPerRotation,\n        bytesPerColor,\n        bytesPerSphericalHarmonicsComponent,\n        scaleOffsetBytes,\n        rotationOffsetBytes,\n        colorOffsetBytes,\n        sphericalHarmonicsOffsetBytes\n      } = KSPLAT_COMPRESSION[compressionLevel];\n      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;\n      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\n      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\n      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];\n      const sh2Index = [\n        9,\n        14,\n        19,\n        10,\n        15,\n        20,\n        11,\n        16,\n        21,\n        12,\n        17,\n        22,\n        13,\n        18,\n        23\n      ];\n      const sh3Index = [\n        24,\n        31,\n        38,\n        25,\n        32,\n        39,\n        26,\n        33,\n        40,\n        27,\n        34,\n        41,\n        28,\n        35,\n        42,\n        29,\n        36,\n        43,\n        30,\n        37,\n        44\n      ];\n      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\n      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;\n      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;\n      const dataBase = sectionBase + bucketsStorageSizeBytes;\n      const data = new DataView(\n        fileBytes.buffer,\n        dataBase,\n        splatDataStorageSizeBytes\n      );\n      const bucketArray = new Float32Array(\n        fileBytes.buffer,\n        bucketsBase,\n        bucketCount * 3\n      );\n      const partiallyFilledBucketLengths = new Uint32Array(\n        fileBytes.buffer,\n        sectionBase,\n        partiallyFilledBucketCount\n      );\n      let partialBucketIndex = fullBucketCount;\n      let partialBucketBase = fullBucketSplats;\n      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\n        const splatOffset = i2 * bytesPerSplat;\n        let bucketIndex;\n        if (i2 < fullBucketSplats) {\n          bucketIndex = Math.floor(i2 / bucketSize);\n        } else {\n          const bucketLength = partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\n          if (i2 >= partialBucketBase + bucketLength) {\n            partialBucketIndex += 1;\n            partialBucketBase += bucketLength;\n          }\n          bucketIndex = partialBucketIndex;\n        }\n        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\n        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\n        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\n        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\n        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\n        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\n        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\n        );\n        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\n        );\n        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\n        );\n        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\n        );\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\n        setPackedSplat(\n          packedArray,\n          i2,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b,\n          splatEncoding\n        );\n        if (sphericalHarmonicsDegree >= 1) {\n          if (sh1) {\n            if (!extra.sh1) {\n              extra.sh1 = new Uint32Array(numSplats * 2);\n            }\n            for (const [i22, key] of sh1Index.entries()) {\n              sh1[i22] = getSh(splatOffset, key);\n            }\n            encodeSh1Rgb(extra.sh1, i2, sh1, splatEncoding);\n          }\n          if (sh2) {\n            if (!extra.sh2) {\n              extra.sh2 = new Uint32Array(numSplats * 4);\n            }\n            for (const [i22, key] of sh2Index.entries()) {\n              sh2[i22] = getSh(splatOffset, key);\n            }\n            encodeSh2Rgb(extra.sh2, i2, sh2, splatEncoding);\n          }\n          if (sh3) {\n            if (!extra.sh3) {\n              extra.sh3 = new Uint32Array(numSplats * 4);\n            }\n            for (const [i22, key] of sh3Index.entries()) {\n              sh3[i22] = getSh(splatOffset, key);\n            }\n            encodeSh3Rgb(extra.sh3, i2, sh3, splatEncoding);\n          }\n        }\n      }\n      sectionBase += storageSizeBytes;\n    }\n    return { packedArray, numSplats, extra };\n  }\n  const jsContent = \'(function() {\\n  "use strict";\\n  let wasm;\\n  function addToExternrefTable0(obj) {\\n    const idx = wasm.__externref_table_alloc();\\n    wasm.__wbindgen_export_2.set(idx, obj);\\n    return idx;\\n  }\\n  function handleError(f, args) {\\n    try {\\n      return f.apply(this, args);\\n    } catch (e) {\\n      const idx = addToExternrefTable0(e);\\n      wasm.__wbindgen_exn_store(idx);\\n    }\\n  }\\n  function debugString(val) {\\n    const type = typeof val;\\n    if (type == "number" || type == "boolean" || val == null) {\\n      return `${val}`;\\n    }\\n    if (type == "string") {\\n      return `"${val}"`;\\n    }\\n    if (type == "symbol") {\\n      const description = val.description;\\n      if (description == null) {\\n        return "Symbol";\\n      } else {\\n        return `Symbol(${description})`;\\n      }\\n    }\\n    if (type == "function") {\\n      const name = val.name;\\n      if (typeof name == "string" && name.length > 0) {\\n        return `Function(${name})`;\\n      } else {\\n        return "Function";\\n      }\\n    }\\n    if (Array.isArray(val)) {\\n      const length = val.length;\\n      let debug = "[";\\n      if (length > 0) {\\n        debug += debugString(val[0]);\\n      }\\n      for (let i = 1; i < length; i++) {\\n        debug += ", " + debugString(val[i]);\\n      }\\n      debug += "]";\\n      return debug;\\n    }\\n    const builtInMatches = /\\\\[object ([^\\\\]]+)\\\\]/.exec(toString.call(val));\\n    let className;\\n    if (builtInMatches && builtInMatches.length > 1) {\\n      className = builtInMatches[1];\\n    } else {\\n      return toString.call(val);\\n    }\\n    if (className == "Object") {\\n      try {\\n        return "Object(" + JSON.stringify(val) + ")";\\n      } catch (_) {\\n        return "Object";\\n      }\\n    }\\n    if (val instanceof Error) {\\n      return `${val.name}: ${val.message}\\n${val.stack}`;\\n    }\\n    return className;\\n  }\\n  let WASM_VECTOR_LEN = 0;\\n  let cachedUint8ArrayMemory0 = null;\\n  function getUint8ArrayMemory0() {\\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\\n      cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\\n    }\\n    return cachedUint8ArrayMemory0;\\n  }\\n  const cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: () => {\\n    throw Error("TextEncoder not available");\\n  } };\\n  const encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {\\n    return cachedTextEncoder.encodeInto(arg, view);\\n  } : function(arg, view) {\\n    const buf = cachedTextEncoder.encode(arg);\\n    view.set(buf);\\n    return {\\n      read: arg.length,\\n      written: buf.length\\n    };\\n  };\\n  function passStringToWasm0(arg, malloc, realloc) {\\n    if (realloc === void 0) {\\n      const buf = cachedTextEncoder.encode(arg);\\n      const ptr2 = malloc(buf.length, 1) >>> 0;\\n      getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);\\n      WASM_VECTOR_LEN = buf.length;\\n      return ptr2;\\n    }\\n    let len = arg.length;\\n    let ptr = malloc(len, 1) >>> 0;\\n    const mem = getUint8ArrayMemory0();\\n    let offset = 0;\\n    for (; offset < len; offset++) {\\n      const code = arg.charCodeAt(offset);\\n      if (code > 127) break;\\n      mem[ptr + offset] = code;\\n    }\\n    if (offset !== len) {\\n      if (offset !== 0) {\\n        arg = arg.slice(offset);\\n      }\\n      ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\\n      const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\\n      const ret = encodeString(arg, view);\\n      offset += ret.written;\\n      ptr = realloc(ptr, len, offset, 1) >>> 0;\\n    }\\n    WASM_VECTOR_LEN = offset;\\n    return ptr;\\n  }\\n  let cachedDataViewMemory0 = null;\\n  function getDataViewMemory0() {\\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {\\n      cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\\n    }\\n    return cachedDataViewMemory0;\\n  }\\n  const cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {\\n    throw Error("TextDecoder not available");\\n  } };\\n  if (typeof TextDecoder !== "undefined") {\\n    cachedTextDecoder.decode();\\n  }\\n  function getStringFromWasm0(ptr, len) {\\n    ptr = ptr >>> 0;\\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\\n  }\\n  function takeFromExternrefTable0(idx) {\\n    const value = wasm.__wbindgen_export_2.get(idx);\\n    wasm.__externref_table_dealloc(idx);\\n    return value;\\n  }\\n  function init_lod_tree(num_splats, lod_tree) {\\n    const ret = wasm.init_lod_tree(num_splats, lod_tree);\\n    if (ret[2]) {\\n      throw takeFromExternrefTable0(ret[1]);\\n    }\\n    return takeFromExternrefTable0(ret[0]);\\n  }\\n  function dispose_lod_tree(lod_id) {\\n    wasm.dispose_lod_tree(lod_id);\\n  }\\n  let cachedUint32ArrayMemory0 = null;\\n  function getUint32ArrayMemory0() {\\n    if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {\\n      cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);\\n    }\\n    return cachedUint32ArrayMemory0;\\n  }\\n  function passArray32ToWasm0(arg, malloc) {\\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\\n    getUint32ArrayMemory0().set(arg, ptr / 4);\\n    WASM_VECTOR_LEN = arg.length;\\n    return ptr;\\n  }\\n  function insert_lod_trees(lod_ids, page_bases, chunk_bases, counts, lod_trees) {\\n    const ptr0 = passArray32ToWasm0(lod_ids, wasm.__wbindgen_malloc);\\n    const len0 = WASM_VECTOR_LEN;\\n    const ptr1 = passArray32ToWasm0(page_bases, wasm.__wbindgen_malloc);\\n    const len1 = WASM_VECTOR_LEN;\\n    const ptr2 = passArray32ToWasm0(chunk_bases, wasm.__wbindgen_malloc);\\n    const len2 = WASM_VECTOR_LEN;\\n    const ptr3 = passArray32ToWasm0(counts, wasm.__wbindgen_malloc);\\n    const len3 = WASM_VECTOR_LEN;\\n    const ret = wasm.insert_lod_trees(ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, lod_trees);\\n    if (ret[2]) {\\n      throw takeFromExternrefTable0(ret[1]);\\n    }\\n    return takeFromExternrefTable0(ret[0]);\\n  }\\n  function clear_lod_trees(lod_ids, page_bases, chunk_bases, counts) {\\n    const ptr0 = passArray32ToWasm0(lod_ids, wasm.__wbindgen_malloc);\\n    const len0 = WASM_VECTOR_LEN;\\n    const ptr1 = passArray32ToWasm0(page_bases, wasm.__wbindgen_malloc);\\n    const len1 = WASM_VECTOR_LEN;\\n    const ptr2 = passArray32ToWasm0(chunk_bases, wasm.__wbindgen_malloc);\\n    const len2 = WASM_VECTOR_LEN;\\n    const ptr3 = passArray32ToWasm0(counts, wasm.__wbindgen_malloc);\\n    const len3 = WASM_VECTOR_LEN;\\n    const ret = wasm.clear_lod_trees(ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);\\n    if (ret[2]) {\\n      throw takeFromExternrefTable0(ret[1]);\\n    }\\n    return takeFromExternrefTable0(ret[0]);\\n  }\\n  let cachedFloat32ArrayMemory0 = null;\\n  function getFloat32ArrayMemory0() {\\n    if (cachedFloat32ArrayMemory0 === null || cachedFloat32ArrayMemory0.byteLength === 0) {\\n      cachedFloat32ArrayMemory0 = new Float32Array(wasm.memory.buffer);\\n    }\\n    return cachedFloat32ArrayMemory0;\\n  }\\n  function passArrayF32ToWasm0(arg, malloc) {\\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\\n    getFloat32ArrayMemory0().set(arg, ptr / 4);\\n    WASM_VECTOR_LEN = arg.length;\\n    return ptr;\\n  }\\n  function traverse_lod_trees(max_splats, pixel_scale_limit, fov_x_degrees, fov_y_degrees, lod_ids, view_to_objects, lod_scales, outside_foveates, behind_foveates) {\\n    const ptr0 = passArray32ToWasm0(lod_ids, wasm.__wbindgen_malloc);\\n    const len0 = WASM_VECTOR_LEN;\\n    const ptr1 = passArrayF32ToWasm0(view_to_objects, wasm.__wbindgen_malloc);\\n    const len1 = WASM_VECTOR_LEN;\\n    const ptr2 = passArrayF32ToWasm0(lod_scales, wasm.__wbindgen_malloc);\\n    const len2 = WASM_VECTOR_LEN;\\n    const ptr3 = passArrayF32ToWasm0(outside_foveates, wasm.__wbindgen_malloc);\\n    const len3 = WASM_VECTOR_LEN;\\n    const ptr4 = passArrayF32ToWasm0(behind_foveates, wasm.__wbindgen_malloc);\\n    const len4 = WASM_VECTOR_LEN;\\n    const ret = wasm.traverse_lod_trees(max_splats, pixel_scale_limit, fov_x_degrees, fov_y_degrees, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, ptr4, len4);\\n    if (ret[2]) {\\n      throw takeFromExternrefTable0(ret[1]);\\n    }\\n    return takeFromExternrefTable0(ret[0]);\\n  }\\n  function sort_splats(num_splats, readback, ordering) {\\n    const ret = wasm.sort_splats(num_splats, readback, ordering);\\n    return ret >>> 0;\\n  }\\n  function sort32_splats(num_splats, readback, ordering) {\\n    const ret = wasm.sort32_splats(num_splats, readback, ordering);\\n    return ret >>> 0;\\n  }\\n  function isLikeNone(x) {\\n    return x === void 0 || x === null;\\n  }\\n  function decode_to_packedsplats(file_type, path_name) {\\n    var ptr0 = isLikeNone(file_type) ? 0 : passStringToWasm0(file_type, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\\n    var len0 = WASM_VECTOR_LEN;\\n    var ptr1 = isLikeNone(path_name) ? 0 : passStringToWasm0(path_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\\n    var len1 = WASM_VECTOR_LEN;\\n    const ret = wasm.decode_to_packedsplats(ptr0, len0, ptr1, len1);\\n    if (ret[2]) {\\n      throw takeFromExternrefTable0(ret[1]);\\n    }\\n    return ChunkDecoder.__wrap(ret[0]);\\n  }\\n  function decode_to_gsplatarray(file_type, path_name) {\\n    var ptr0 = isLikeNone(file_type) ? 0 : passStringToWasm0(file_type, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\\n    var len0 = WASM_VECTOR_LEN;\\n    var ptr1 = isLikeNone(path_name) ? 0 : passStringToWasm0(path_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\\n    var len1 = WASM_VECTOR_LEN;\\n    const ret = wasm.decode_to_gsplatarray(ptr0, len0, ptr1, len1);\\n    if (ret[2]) {\\n      throw takeFromExternrefTable0(ret[1]);\\n    }\\n    return ChunkDecoder.__wrap(ret[0]);\\n  }\\n  function quick_lod_packedsplats(num_splats, packed, extra, lod_base) {\\n    const ret = wasm.quick_lod_packedsplats(num_splats, packed, isLikeNone(extra) ? 0 : addToExternrefTable0(extra), lod_base);\\n    if (ret[2]) {\\n      throw takeFromExternrefTable0(ret[1]);\\n    }\\n    return takeFromExternrefTable0(ret[0]);\\n  }\\n  const ChunkDecoderFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {\\n  }, unregister: () => {\\n  } } : new FinalizationRegistry((ptr) => wasm.__wbg_chunkdecoder_free(ptr >>> 0, 1));\\n  class ChunkDecoder {\\n    static __wrap(ptr) {\\n      ptr = ptr >>> 0;\\n      const obj = Object.create(ChunkDecoder.prototype);\\n      obj.__wbg_ptr = ptr;\\n      ChunkDecoderFinalization.register(obj, obj.__wbg_ptr, obj);\\n      return obj;\\n    }\\n    __destroy_into_raw() {\\n      const ptr = this.__wbg_ptr;\\n      this.__wbg_ptr = 0;\\n      ChunkDecoderFinalization.unregister(this);\\n      return ptr;\\n    }\\n    free() {\\n      const ptr = this.__destroy_into_raw();\\n      wasm.__wbg_chunkdecoder_free(ptr, 0);\\n    }\\n    /**\\n     * @param {Uint8Array} bytes\\n     */\\n    push(bytes) {\\n      const ret = wasm.chunkdecoder_push(this.__wbg_ptr, bytes);\\n      if (ret[1]) {\\n        throw takeFromExternrefTable0(ret[0]);\\n      }\\n    }\\n    /**\\n     * @returns {any}\\n     */\\n    finish() {\\n      const ptr = this.__destroy_into_raw();\\n      const ret = wasm.chunkdecoder_finish(ptr);\\n      if (ret[2]) {\\n        throw takeFromExternrefTable0(ret[1]);\\n      }\\n      return takeFromExternrefTable0(ret[0]);\\n    }\\n  }\\n  const GsplatArrayFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {\\n  }, unregister: () => {\\n  } } : new FinalizationRegistry((ptr) => wasm.__wbg_gsplatarray_free(ptr >>> 0, 1));\\n  class GsplatArray {\\n    static __wrap(ptr) {\\n      ptr = ptr >>> 0;\\n      const obj = Object.create(GsplatArray.prototype);\\n      obj.__wbg_ptr = ptr;\\n      GsplatArrayFinalization.register(obj, obj.__wbg_ptr, obj);\\n      return obj;\\n    }\\n    __destroy_into_raw() {\\n      const ptr = this.__wbg_ptr;\\n      this.__wbg_ptr = 0;\\n      GsplatArrayFinalization.unregister(this);\\n      return ptr;\\n    }\\n    free() {\\n      const ptr = this.__destroy_into_raw();\\n      wasm.__wbg_gsplatarray_free(ptr, 0);\\n    }\\n    /**\\n     * @returns {number}\\n     */\\n    get numSplats() {\\n      const ret = wasm.__wbg_get_gsplatarray_numSplats(this.__wbg_ptr);\\n      return ret >>> 0;\\n    }\\n    /**\\n     * @param {number} arg0\\n     */\\n    set numSplats(arg0) {\\n      wasm.__wbg_set_gsplatarray_numSplats(this.__wbg_ptr, arg0);\\n    }\\n    /**\\n     * @returns {number}\\n     */\\n    get maxShDegree() {\\n      const ret = wasm.__wbg_get_gsplatarray_maxShDegree(this.__wbg_ptr);\\n      return ret >>> 0;\\n    }\\n    /**\\n     * @param {number} arg0\\n     */\\n    set maxShDegree(arg0) {\\n      wasm.__wbg_set_gsplatarray_maxShDegree(this.__wbg_ptr, arg0);\\n    }\\n    /**\\n     * @returns {number}\\n     */\\n    len() {\\n      const ret = wasm.gsplatarray_len(this.__wbg_ptr);\\n      return ret >>> 0;\\n    }\\n    /**\\n     * @returns {boolean}\\n     */\\n    has_lod() {\\n      const ret = wasm.gsplatarray_has_lod(this.__wbg_ptr);\\n      return ret !== 0;\\n    }\\n    /**\\n     * @param {number} lod_base\\n     */\\n    quick_lod(lod_base) {\\n      wasm.gsplatarray_quick_lod(this.__wbg_ptr, lod_base);\\n    }\\n    /**\\n     * @returns {object}\\n     */\\n    to_packedsplats() {\\n      const ret = wasm.gsplatarray_to_packedsplats(this.__wbg_ptr);\\n      if (ret[2]) {\\n        throw takeFromExternrefTable0(ret[1]);\\n      }\\n      return takeFromExternrefTable0(ret[0]);\\n    }\\n    /**\\n     * @returns {object}\\n     */\\n    to_packedsplats_lod() {\\n      const ret = wasm.gsplatarray_to_packedsplats_lod(this.__wbg_ptr);\\n      if (ret[2]) {\\n        throw takeFromExternrefTable0(ret[1]);\\n      }\\n      return takeFromExternrefTable0(ret[0]);\\n    }\\n  }\\n  async function __wbg_load(module, imports) {\\n    if (typeof Response === "function" && module instanceof Response) {\\n      if (typeof WebAssembly.instantiateStreaming === "function") {\\n        try {\\n          return await WebAssembly.instantiateStreaming(module, imports);\\n        } catch (e) {\\n          if (module.headers.get("Content-Type") != "application/wasm") {\\n            console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\\\n", e);\\n          } else {\\n            throw e;\\n          }\\n        }\\n      }\\n      const bytes = await module.arrayBuffer();\\n      return await WebAssembly.instantiate(bytes, imports);\\n    } else {\\n      const instance = await WebAssembly.instantiate(module, imports);\\n      if (instance instanceof WebAssembly.Instance) {\\n        return { instance, module };\\n      } else {\\n        return instance;\\n      }\\n    }\\n  }\\n  function __wbg_get_imports() {\\n    const imports = {};\\n    imports.wbg = {};\\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\\n      const ret = arg0.buffer;\\n      return ret;\\n    };\\n    imports.wbg.__wbg_get_67b2ba62fc30de12 = function() {\\n      return handleError(function(arg0, arg1) {\\n        const ret = Reflect.get(arg0, arg1);\\n        return ret;\\n      }, arguments);\\n    };\\n    imports.wbg.__wbg_get_b9b93047fe3cf45b = function(arg0, arg1) {\\n      const ret = arg0[arg1 >>> 0];\\n      return ret;\\n    };\\n    imports.wbg.__wbg_gsplatarray_new = function(arg0) {\\n      const ret = GsplatArray.__wrap(arg0);\\n      return ret;\\n    };\\n    imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {\\n      const ret = arg0.length;\\n      return ret;\\n    };\\n    imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {\\n      const ret = arg0.length;\\n      return ret;\\n    };\\n    imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {\\n      const ret = arg0.length;\\n      return ret;\\n    };\\n    imports.wbg.__wbg_length_a446193dc22c12f8 = function(arg0) {\\n      const ret = arg0.length;\\n      return ret;\\n    };\\n    imports.wbg.__wbg_length_e2d2a49132c1b256 = function(arg0) {\\n      const ret = arg0.length;\\n      return ret;\\n    };\\n    imports.wbg.__wbg_new_405e22f390576ce2 = function() {\\n      const ret = new Object();\\n      return ret;\\n    };\\n    imports.wbg.__wbg_new_78feb108b6472713 = function() {\\n      const ret = new Array();\\n      return ret;\\n    };\\n    imports.wbg.__wbg_new_9fee97a409b32b68 = function(arg0) {\\n      const ret = new Uint16Array(arg0);\\n      return ret;\\n    };\\n    imports.wbg.__wbg_new_a12002a7f91c75be = function(arg0) {\\n      const ret = new Uint8Array(arg0);\\n      return ret;\\n    };\\n    imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {\\n      const ret = new Uint32Array(arg0);\\n      return ret;\\n    };\\n    imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(arg0, arg1, arg2) {\\n      const ret = new Float32Array(arg0, arg1 >>> 0, arg2 >>> 0);\\n      return ret;\\n    };\\n    imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(arg0, arg1, arg2) {\\n      const ret = new Uint32Array(arg0, arg1 >>> 0, arg2 >>> 0);\\n      return ret;\\n    };\\n    imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {\\n      const ret = new Float32Array(arg0 >>> 0);\\n      return ret;\\n    };\\n    imports.wbg.__wbg_newwithlength_bd3de93688d68fbc = function(arg0) {\\n      const ret = new Uint32Array(arg0 >>> 0);\\n      return ret;\\n    };\\n    imports.wbg.__wbg_push_737cfc8c1432c2c6 = function(arg0, arg1) {\\n      const ret = arg0.push(arg1);\\n      return ret;\\n    };\\n    imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {\\n      arg0.set(arg1, arg2 >>> 0);\\n    };\\n    imports.wbg.__wbg_set_3f1d0b984ed272ed = function(arg0, arg1, arg2) {\\n      arg0[arg1] = arg2;\\n    };\\n    imports.wbg.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {\\n      arg0.set(arg1, arg2 >>> 0);\\n    };\\n    imports.wbg.__wbg_set_bb8cecf6a62b9f46 = function() {\\n      return handleError(function(arg0, arg1, arg2) {\\n        const ret = Reflect.set(arg0, arg1, arg2);\\n        return ret;\\n      }, arguments);\\n    };\\n    imports.wbg.__wbg_set_d23661d19148b229 = function(arg0, arg1, arg2) {\\n      arg0.set(arg1, arg2 >>> 0);\\n    };\\n    imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {\\n      arg0.set(arg1, arg2 >>> 0);\\n    };\\n    imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {\\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\\n      return ret;\\n    };\\n    imports.wbg.__wbg_subarray_769e1e0f81bb259b = function(arg0, arg1, arg2) {\\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\\n      return ret;\\n    };\\n    imports.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(arg0, arg1, arg2) {\\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\\n      return ret;\\n    };\\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\\n      const ret = debugString(arg1);\\n      const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\\n      const len1 = WASM_VECTOR_LEN;\\n      getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\\n      getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\\n    };\\n    imports.wbg.__wbindgen_init_externref_table = function() {\\n      const table = wasm.__wbindgen_export_2;\\n      const offset = table.grow(4);\\n      table.set(0, void 0);\\n      table.set(offset + 0, void 0);\\n      table.set(offset + 1, null);\\n      table.set(offset + 2, true);\\n      table.set(offset + 3, false);\\n    };\\n    imports.wbg.__wbindgen_is_falsy = function(arg0) {\\n      const ret = !arg0;\\n      return ret;\\n    };\\n    imports.wbg.__wbindgen_memory = function() {\\n      const ret = wasm.memory;\\n      return ret;\\n    };\\n    imports.wbg.__wbindgen_number_new = function(arg0) {\\n      const ret = arg0;\\n      return ret;\\n    };\\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\\n      const ret = getStringFromWasm0(arg0, arg1);\\n      return ret;\\n    };\\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\\n      throw new Error(getStringFromWasm0(arg0, arg1));\\n    };\\n    return imports;\\n  }\\n  function __wbg_finalize_init(instance, module) {\\n    wasm = instance.exports;\\n    __wbg_init.__wbindgen_wasm_module = module;\\n    cachedDataViewMemory0 = null;\\n    cachedFloat32ArrayMemory0 = null;\\n    cachedUint32ArrayMemory0 = null;\\n    cachedUint8ArrayMemory0 = null;\\n    wasm.__wbindgen_start();\\n    return wasm;\\n  }\\n  async function __wbg_init(module_or_path) {\\n    if (wasm !== void 0) return wasm;\\n    if (typeof module_or_path !== "undefined") {\\n      if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\\n        ({ module_or_path } = module_or_path);\\n      } else {\\n        console.warn("using deprecated parameters for the initialization function; pass a single object instead");\\n      }\\n    }\\n    if (typeof module_or_path === "undefined") {\\n      module_or_path = new URL("data:application/wasm;base64,AGFzbQEAAAAB+ANEYAN/f38Bf2ACf38Bf2ACf38AYAF/AGABfwF/YAN/f38AYAADf39/YAR/f39/AGAFf39/f38AYAF9AX1gAABgAW8Bf2AGf39/f39/AGAAAX9gA29/fwFvYAV/f39/fwF/YAFvAW9gA29vfwBgBH9/f38Bf2ADf35+AGADf35+AX9gAX8Bb2AAAW9gB39/f39/f38AYAF/A39/f2ACf30AYAR/fX9/AX9gB39/f39/f38Bf2AGf39/f39/AX9gBH9/f38Df39/YAN/b28Bf2ACfX0BfWAAAn9/YAJ/fwFvYANvb28Bf2ABfAFvYANvb28AYAJvfwFvYAJvbwF/YAJvbwFvYAJ/bwBgCX9/f39/f39/fwBgBn9/fX9/fwBgBH9/fX0BfWACf34AYAN/fX8Bf2AEfn5/fwF+YAF/AX1gCX9/f39/f35+fgBgA39+fwBgAn9+AX9gA319fQF9YAF+AX9gDn99fX1/f39/f39/f39/A39/f2AJf39/f39/f39vA39/f2AIf39/f39/f38Df39/YA19fX19fX19fX9vf319AW9gBH9vf30Df39/YAN/b38Df39/YAJ/bwN/f39gAn9vAn9/YAV/f31/fwBgBH99f38AYAV/f3x/fwBgBH98f38AYAV/f35/fwBgBH9+f38AYAF8AX8CwQkjA3diZxVfX3diZ19nc3BsYXRhcnJheV9uZXcAFQN3YmcVX193YmluZGdlbl9zdHJpbmdfbmV3ACEDd2JnGl9fd2JnX3NldF9iYjhjZWNmNmE2MmI5ZjQ2ACIDd2JnH19fd2JnX3N1YmFycmF5XzNhYWVlYzg5YmIyNTQ0ZjAADgN3YmcaX193YmdfbmV3XzQwNWUyMmYzOTA1NzZjZTIAFgN3YmcVX193YmluZGdlbl9udW1iZXJfbmV3ACMDd2JnGl9fd2JnX3NldF8zZjFkMGI5ODRlZDI3MmVkACQDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfYmQzZGU5MzY4OGQ2OGZiYwAVA3diZx1fX3diZ19sZW5ndGhfYTQ0NjE5M2RjMjJjMTJmOAALA3diZx9fX3diZ19zdWJhcnJheV9hYTkwNjVmYTlkYzVkZjk2AA4Dd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABYDd2JnHV9fd2JnX2J1ZmZlcl82MDljYzNlZWU1MWVkMTU4ABADd2JnGl9fd2JnX25ld19hMTIwMDJhN2Y5MWM3NWJlABADd2JnGl9fd2JnX3NldF82NTU5NWJkZDg2OGIzMDA5ABEDd2JnHV9fd2JnX2xlbmd0aF9lMmQyYTQ5MTMyYzFiMjU2AAsDd2JnGl9fd2JnX2dldF9iOWI5MzA0N2ZlM2NmNDViACUDd2JnGl9fd2JnX25ld183OGZlYjEwOGI2NDcyNzEzABYDd2JnG19fd2JnX3B1c2hfNzM3Y2ZjOGMxNDMyYzJjNgAmA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAALA3diZx9fX3diZ19zdWJhcnJheV83NjllMWUwZjgxYmIyNTliAA4Dd2JnGl9fd2JnX25ld185ZmVlOTdhNDA5YjMyYjY4ABADd2JnGl9fd2JnX3NldF9mNGYxZjBkYWEzMDY5NmZjABEDd2JnHV9fd2JnX2xlbmd0aF82Y2E1Mjc2NjVkODk2OTRkAAsDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfNWE1ZWZlMzEzY2ZkNTlmMQAVA3diZx1fX3diZ19sZW5ndGhfM2I0ZjAyMjE4OGFlOGRiNgALA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9lNmI3ZTY5YWNkNGM3MzU0AA4Dd2JnGl9fd2JnX3NldF8xMGJhZDliZWUwZTljNThiABEDd2JnGl9fd2JnX2dldF82N2IyYmE2MmZjMzBkZTEyACcDd2JnE19fd2JpbmRnZW5faXNfZmFsc3kACwN3YmcaX193YmdfbmV3X2UzYjMyMWRjZmVmODlmYzcAEAN3YmcaX193Ymdfc2V0X2QyMzY2MWQxOTE0OGIyMjkAEQN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZjFkZWFkNDRkMWZjNzIxMgAOA3diZxBfX3diaW5kZ2VuX3Rocm93AAIDd2JnF19fd2JpbmRnZW5fZGVidWdfc3RyaW5nACgDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFibGUACgOxA68DBRkIAAQXAwMaBQIEAAoHASkBFwcEBAoHBAcFBwUIAQUBDAIIAgQEBQMCAwgBBwECBCoCKwkICQcDBAEH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g0IIhoSEICFCCIhCgICA+A+DICFCGIhCgID8B4OEICFCKIhCgP4DgyAhQjiIhISEICBC2KLR78Kp5b8tfoUiIEI4hiAgQoD+A4NCKIaEICBCgID8B4NCGIYgIEKAgID4D4NCCIaEhCAgQgiIQoCAgPgPgyAgQhiIQoCA/AeDhCAgQiiIQoD+A4MgIEI4iISEhEKOip+43Pep+HF+IiFCOIYgIUKA/gODQiiGhCAhQoCA/AeDQhiGICFCgICA+A+DQgiGhIQgIUIIiEKAgID4D4MgIUIYiEKAgPwHg4QgIUIoiEKA/gODICFCOIiEhIQgIEKOnuCShIe+nXF+hSAgiTcDcAJAIAMoAlgiBCADKAJUTwRAQv///////////wAhLUKAgICAgICAgIB/IS5CgICAgICAgICAfyEvQoCAgICAgICAgH8hMEL///////////8AITFC////////////ACEyDAELQoCAgICAgICAgH8hMEL///////////8AITJC////////////ACExQv///////////wAhLUKAgICAgICAgIB/IS9CgICAgICAgICAfyEuAkADQCAAKAIUIgIgBEsEQCAAKAIQIARB0ABsai4BTCADLgFSSg0DIAQgACgCCCICTw0CIAMpA3ghIyADKQNwISUgAyAAKAIEIARBMGxq/QAEACAD/QkCXP3nAf1oIjf9HwH8BCIqNwOIAiADKQOAASEgIAMgN/0fAvwEIis3A5ACIAMpA4gBISEgAyA3/R8A/AQiJzcDgAIgJSAlICNCA4UiIkI4hiAiQoD+A4NCKIaEICJCgID8B4NCGIYgIkKAgID4D4NCCIaEhCAjQgiIQoCAgPgPgyAjQhiIQoCA/AeDhCAjQiiIQoD+A4MgI0I4iISEhELSgaqbq/qC16d/fiIjQjiGICNCgP4Dg0IohoQgI0KAgPwHg0IYhiAjQoCAgPgPg0IIhoSEICNCCIhCgICA+A+DICNCGIhCgID8B4OEICNCKIhCgP4DgyAjQjiIhISEICJC2KLR78Kp5b8tfoVCrf7V5NSF/ajYAH58QrjYj/Dyh7nXxwB8ICAgKoUiKEI4hiAoQoD+A4NCKIaEIChCgID8B4NCGIYgKEKAgID4D4NCCIaEhCAoQgiIQoCAgPgPgyAoQhiIQoCA/AeDhCAoQiiIQoD+A4MgKEI4iISE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ASIGQQlPBEAgAygCZCEFIAMoAmghByAIDAELIAYhBSAIIQdBCCEGIAsLIQIgBCgCACEKIAUgBkYEQCADQeAAahCNAiADKAJkIQUgAygCaCEHIAghAgsgByAFQQJ0aiAKNgIAIAIgAigCAEEBajYCACATIARBBGoiBEcNAAsMAQsgDyACNgIACyADQcgCaiADQYABaikCADcDACADQbgCaiADQfAAav0AAgD9CwMAIAMgA/0AAmD9CwOoAgJAAkACQAJ/An8CQCADKALMAiIGQQlJIgxFBEAgAygCrAIiAg0BQQEMAwsgDiAGIgINARpBAQwCCyADKAKwAgsiBCgCACIFIAAoAhQiD08NASAAKAIQIgogBUHQAGxqLwFMIQUgAkEBRwRAIARBBGohBCACQQFrQf////8DcSECA0AgBCgCACIHIA9PDQQgCiAHQdAAbGouAUwiByAFwSIFIAUgB0gbIQUgBEEEaiEEIAJBAWsiAg0ACwsgBcEgAy8BUkECa8FKBEAgAyADKAK8ASIFIAMoArABIgJGBH8gA0GwAWpBuJ/CABD7ASADKAK8ASEFIAMoArABBSACCyADKAK4AUEBayIEaiICIAQgAiAESRsiAjYCuAEgAygCtAEgAkEsbGoiAiAWNgIAIAIgAykDqAI3AgQgAkEMaiADQbACav0AAwD9CwIAIAJBHGogA0HAAmr9AAMA/QsCACADIAVBAWo2ArwBQQAMAQsgAygCrAEiAiADKAKgASIERgRAIANBoAFqQcifwgAQ+wEgAygCoAEhBCADKAKsASECCyADKAKkASADKAKoASACaiIFIARBACAEIAVNG2tBLGxqIgUgFjYCACAFIAMpA6gCNwIEIAVBDGogA0GwAmr9AAMA/QsCACAFQRxqIANBwAJq/QADAP0LAgAgAyACQQFqNgKsAUEACyADKAKcASIKIAMoApQBRgRAQQAhByMAQSBrIhIkAAJAAkAgA0GUAWoiEygCACIPQf////8BSw0AQQQgD0EBdCICIAJBBE0bIgVBAnQiAkH8////B0sNACASIA8EfyASIA9BAnQ2AhwgEiATKAIENgIUQQQFQQALNgIYIBJBCGpBBCACIBJBFGoQiAIgEigCCEEBRw0BIBIoAhAaIBIoAgwhBwsgB0HYn8IAEIMDAAsgEigCDCECIBMgBTYCACATIAI2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yMIAIAQ2AgBBpMjCAEGkyMIAKAIAIAVqIgA2AgAgBCAAQQFyNgIEDAULQajIwgAgBDYCAEGgyMIAQaDIwgAoAgAgBWoiADYCACAEIABBAXI2AgQgACAEaiAANgIADAQLQQAhA0GkyMIAKAIAIgAgBU0NAEGkyMIAIAAgBWsiATYCAEGsyMIAQazIwgAoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQgAEEIag8LIAMPC0GcyMIAQZzIwgAoAgBBfiACKAIcd3E2AgALAkAgA0EQTwRAIAIgBUEDcjYCBCACIAVqIgEgA0EBcjYCBCABIANqIAM2AgAgA0GAAk8EQCABIAMQywEMAgsgA0H4AXFBkMbCAGohAAJ/QZjIwgAoAgAiBEEBIANBA3Z0IgNxRQRAQZjIwgAgAyAEcjYCACAADAELIAAoAggLIQMgACABNgIIIAMgATYCDCABIAA2AgwgASADNgIIDAELIAIgAyAFaiIAQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIECyACQQhqDwsgAUEIagvuFwIbfwJ8IwBBsARrIgMkACADQgA3A5gBIANCADcDkAEgA0IANwOIASADQgA3A4ABIANCADcDeCADQgA3A3AgA0IANwNoIANCADcDYCADQgA3A1ggA0IANwNQIANCADcDSCADQgA3A0AgA0IANwM4IANCADcDMCADQgA3AyggA0IANwMgIANCADcDGCADQgA3AxAgA0IANwMIIANCADcDACADQgA3A7gCIANCADcDsAIgA0IANwOoAiADQgA3A6ACIANCADcDmAIgA0IANwOQAiADQgA3A4gCIANCADcDgAIgA0IANwP4ASADQgA3A/ABIANCADcD6AEgA0IANwPgASADQgA3A9gBIANCADcD0AEgA0IANwPIASADQgA3A8ABIANCADcDuAEgA0IANwOwASADQgA3A6gBIANCADcDoAEgA0IANwPYAyADQgA3A9ADIANCADcDyAMgA0IANwPAAyADQgA3A7gDIANCADcDsAMgA0IANwOoAyADQgA3A6ADIANCADcDmAMgA0IANwOQAyADQgA3A4gDIANCADcDgAMgA0IANwP4AiADQgA3A/ACIANCADcD6AIgA0IANwPgAiADQgA3A9gCIANCADcD0AIgA0IANwPIAiADQgA3A8ACIANB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IgMgASABoqIgAUSnRjuMh83GPqJEdOfK4vkAKr+goiACIAMgAUSy+26JEBGBP6JEd6zLVFVVxb+goqCgtgwECyABRBgtRFT7Ifk/oCICIAIgAqIiAaIiAyABIAGioiABRKdGO4yHzcY+okR058ri+QAqv6CiIAIgAyABRLL7bokQEYE/okR3rMtUVVXFv6CioKC2DAMLIARBgICAzANPBEAgASABoiIBRIFeDP3//9+/okQAAAAAAADwP6AgASABoiICREI6BeFTVaU/oqAgASACoiABRGlQ7uBCk/k+okQnHg/oh8BWv6CioLYMAwsgBSAAQwAAgHuSOAIIIAUqAggaQwAAgD8MAgtEGC1EVPshGcBEGC1EVPshGUAgBkEAThsgAaAiASABoiIBRIFeDP3//9+/okQAAAAAAADwP6AgASABoiICREI6BeFTVaU/oqAgASACoiABRGlQ7uBCk/k+okQnHg/oh8BWv6CioLYMAQtEGC1EVPshCcBEGC1EVPshCUAgBkEAThsgAaAiASABoiIBRIFeDP3//9+/okQAAAAAAADwP6AgASABoiICREI6BeFTVaU/oqAgASACoiABRGlQ7uBCk/k+okQnHg/oh8BWv6CioLaMCyAFQRBqJAALvQcBCn8jAEEgayIIJAACQAJAIAEoAhBFBEAgAUF/NgIQIAMgAyACQQNqQXxxIAJrIgprQQdxQQAgAyAKTxsiBGshCSADIARJDQECQAJAAkACfwJAIARFDQACfyAEQQFrIAIgA2oiBUEBayIGLQAAQQpGDQAaIAYgAiAJaiIGRg0BIARBAmsgBUECayIHLQAAQQpGDQAaIAYgB0YNASAEQQNrIAVBA2siBy0AAEEKRg0AGiAGIAdGDQEgBEEEayAFQQRrIgctAABBCkYNABogBiAHRg0BIARBBWsgBUEFayIHLQAAQQpGDQAaIAYgB0YNASAEQQZrIAVBBmsiBy0AAEEKRg0AGiAGIAdGDQEgBEEHayAFQQdrIgUtAABBCkYNABogBSAGRg0BIARBeHILIAlqQQFqDAELIAogAyADIApLGyEMQQAgBGshCiACQQRrIQ0gBEF/cyACaiEHA0ACQCAHIQUgCiEEIAkiBiAMTQ0AIARBCGshCiAFQQhrIQdBgIKECCACIAZBCGsiCWooAgAiC0GKlKjQAHNrIAtyQYCC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BSAGaiwAAEG/f0wNAQsgAiAGaiEEIAcNASAAQgE3AgggACADNgIEIAAgBDYCAA8LIAYgBCACIAVBxIjCABCVAwALIAIgBmpBAWshBiADIQECfwNAIAEiAkUEQEEAIQEgBCEFQQEMAgsgAkEBayEBIAIgBmotAABB3wBHDQALAkACQCABRQ0AAkAgASADTwRAIAEgA0cNASACDQJBACEGDAMLIAEgBGosAABBv39KDQELIAQgA0EAIAFB1IjCABCVAwALAkAgAiADTwRAIAMhBiACIANHDQEMAgsgAiAEaiwAAEG/f0wNACACIQYMAQsgBCADIAIgA0HkiMIAEJUDAAsgBCAGaiEFIAMgBmshAyAECyECIANFBEAMAQsgACADNgIMIAAgBTYCCCAAIAE2AgQgACACNgIADwsgAEEANgIAIABBADoABAuWBgEDfyMAQSBrIgMkACAAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEOKAIBAQEBAQEBAQMFAQEEAQEBAQEBAQEBAQEBAQEBAQEBAQEIAQEBAQcACyABQdwARg0FCyACQQFxRSABQf8FTXINByABELcBRQ0HIANBDmpBADoAACADQQA7AQwgAyABQRR2QfCAwgBqLQAAOgAPIAMgAUEEdkEPcUHwgMIAai0AADoAEyADIAFBCHZBD3FB8IDCAGotAAA6ABIgAyABQQx2QQ9xQfCAwgBqLQAAOgARIAMgAUEQdkEPcUHwgMIAai0AADoAECABQQFyZ0ECdiICIANBDGoiBWoiBEH7ADoAACAEQQFrQfUAOgAAIAUgAkECayICakHcADoAACADQRRqIgQgAUEPcUHwgMIAai0AADoAACAAIAMpAQw3AAAgA0H9ADoAFQwICyAAQgA3AQIgAEHc4AA7AQAMCgsgAEIANwECIABB3OgBOwEADAkLIABCADcBAiAAQdzkATsBAAwICyAAQgA3AQIgAEHc3AE7AQAMBwsgAEIANwECIABB3LgBOwEADAYLIAJBgAJxRQ0BIABCADcBAiAAQdzOADsBAAwFCyACQf///wdxQYCABE8NAwsgARD6AQ0BIANBGGpBADoAACADQQA7ARYgAyABQRR2QfCAwgBqLQAAOgAZIAMgAUEEdkEPcUHwgMIAai0AADoAHSADIAFBCHZBD3FB8IDCAGotAAA6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QYCAgNgDciADQRd0a3ILIQUgAS8BJCEBAn8gAkH//wFxBEAgAkH/B3EhAyACQYCAAnEhBCACQYD4AXEiAkGA+AFHBEAgBEEQdCIEIAJBDXRBgICA/ABxIANBDXRyQYCAgMADanIgAg0CGiADIANnQRBrIgJB//8DcUEIanRB////A3EgBEGAgIDYA3IgAkEXdGtyDAILIARBEHQiAiADQQ10ckGAgID+B3IgAw0BGiACQYCAgPwHcgwBCyACQRB0CyEDIAACfyABQf//AXEEQCABQf8HcSEAIAFBgIACcSECIAFBgPgBcSIBQYD4AUcEQCACQRB0IgIgAUENdEGAgID8AHEgAEENdHJBgICAwANqciABDQIaIAAgAGdBEGsiAEH//wNxQQhqdEH///8DcSACQYCAgNgDciAAQRd0a3IMAgsgAkEQdCIBIABBDXRyQYCAgP4HciAADQEaIAFBgICA/AdyDAELIAFBEHQLvhCcAf0TIAW+EJwB/SAAIAO+EJwB/SAB/QsEAAu2BAEEfyABLwEcIQQCfyABLwEaIgJB//8BcUUEQCACQRB0DAELIAJB/wdxIQUgAkGAgAJxIQMgAkGA+AFxIgJBgPgBRgRAIANBEHQhAiACQYCAgPwHciAFRQ0BGiACIAVBDXRyQYCAgP4HcgwBCyADQRB0IQMgAkENdEGAgID8AHEgBUENdHJBgICAwANqIANyIAINABogBSAFZ0EQayIFQf//A3FBCGp0Qf///wNxIANBgICA2ANyIAVBF3RrcgshBSABLwEeIQECfyAEQf//AXEEQCAEQf8HcSECIARBgIACcSEDIARBgPgBcSIEQYD4AUcEQCADQRB0IQMgBEENdEGAgID8AHEgAkENdHJBgICAwANqIANyIAQNAhogAiACZ0EQayIEQf//A3FBCGp0Qf///wNxIANBgICA2ANyIARBF3RrcgwCCyADQRB0IQQgBCACQQ10ckGAgID+B3IgAg0BGiAEQYCAgPwHcgwBCyAEQRB0CyEEIAACfyABQf//AXEEQCABQf8HcSECIAFBgIACcSEDIAFBgPgBcSIBQYD4AUcEQCADQRB0IQMgAUENdEGAgID8AHEgAkENdHJBgICAwANqIANyIAENAhogAiACZ0EQayIBQf//A3FBCGp0Qf///wNxIANBgICA2ANyIAFBF3RrcgwC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IAEoAhwhAQwBCyABKAIgIgIgASgCHCIBRg0BCyABIAdqIQggAiABayEDCyAAIAM2AgQgACAINgIAIAZBEGokAAuWAwEDfyMAQYABayIEJAACfwJAIAEoAggiAkGAgIAQcUUEQCACQYCAgCBxDQFBAyECIAAtAAAiACEDIABBCk8EQCAEIAAgAEHkAG4iA0HkAGxrQf8BcUEBdCICQbX6wABqLQAAOgACIAQgAkG0+sAAai0AADoAAUEBIQILQQAgACADG0UEQCAEIAJBAWsiAmogA0EBdEH+AXFBtfrAAGotAAA6AAALIAFBAUEBQQAgAiAEakEDIAJrEI4BDAILIAAtAAAhAkGBASEAA0AgACAEakECayACQQ9xIgNBMHIgA0HXAGogA0EKSRs6AAAgAkH/AXEiA0EEdiECIABBAWshACADQQ9LDQALIAFBAUGbisIAQQIgACAEakEBa0GBASAAaxCOAQwBCyAALQAAIQJBgQEhAANAIAAgBGpBAmsgAkEPcSIDQTByIANBN2ogA0EKSRs6AAAgAkH/AXEiA0EEdiECIABBAWshACADQQ9LDQALIAFBAUGbisIAQQIgACAEakEBa0GBASAAaxCOAQsgBEGAAWokAAu8AwIGfwF+IwBB0ABrIgIkACACQSBqIAAgACgCACgCBBECACACIAJByABqrUKAgICAwAGENwMoQQEhAyACQQE2AjQgAkHcq8IANgIwIAJCATcCPCACIAIpAyA3AkggAiACQShqNgI4AkAgASgCACIGIAEoAgQiByACQTBqEIwBDQAgAS0ACkGAAXFFBEBBACEDDAELIAJBGGogACAAKAIAKAIEEQIAIAJBEGogAigCGCACKAIcKAIYEQIAIAIoAhAiBEUEQEEAIQMMAQsgAkEIaiAEIAIoAhQiBSgCGBECACACKAIMIQAgAigCCCEBIAIgBTYCLCACIAQ2AiggAkEBNgI0IAJBoM/AADYCMCACQgE3AjwgAiACQShqrUKAgICAwAGEIgg3A0ggAiACQcgAajYCOCAGIAcgAkEwahCKAw0AA0AgAUUEQEEAIQMMAgsgAiABIAAoAhgRAgAgAigCBCACKAIAIAIgADYCLCACIAE2AiggAkEBNgI0IAJBoM/AADYCMCACQgE3AjwgAiAINwNIIAIgAkHIAGo2AjghASEAIAYgByACQTBq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A0F4cSIEQQRBCCADQQNxIgMbIAJqSQ0BIANBACAEIAJBJ2pLGw0CIAEQWwsgACgCFCEBIAAoAhgiAigCACIDBEAgASADEQMACyACKAIEIgIEQCABQQRrKAIAIgNBeHEiBEEEQQggA0EDcSIDGyACakkNASADQQAgBCACQSdqSxsNAiABEFsLAkAgAEF/Rg0AIAAgACgCBEEBayIBNgIEIAENACAAQQRrKAIAIgFBeHEiAkEgQSQgAUEDcSIBG0kNASABQQAgAkHEAE8bDQIgABBbCw8LQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIAC9cCAQV/QRFBACAAQa+wBE8bIgIgAkEIciIBIABBC3QiAiABQQJ0QYSUwQBqKAIAQQt0SRsiASABQQRyIgEgAUECdEGElMEAaigCAEELdCACSxsiASABQQJyIgEgAUECdEGElMEAaigCAEELdCACSxsiASABQQFqIgEgAUECdEGElMEAaigCAEELdCACSxsiASABQQFqIgEgAUECdEGElMEAaigCAEELdCACSxsiAUECdEGElMEAaigCAEELdCIEIAJGIAIgBEtqIAFqIgRBAnRBhJTBAGoiBSgCAEEVdiECQe8FIQECQCAEQSBNBEAgBSgCBEEVdiEBIARFDQELIAVBBGsoAgBB////AHEhAwsCQCABIAJBf3NqRQ0AIAAgA2shAyABQQFrIQFBACEAA0AgACACQe/ZwABqLQAAaiIAIANLDQEgASACQQFqIgJHDQALCyACQQFxC9cCAQV/QRJBACAAQbC4BE8bIgIgAkEJciIBIABBC3QiAiABQQJ0QZiSwQBqKAIAQQt0SRsiASABQQVqIgEgAUECdEGYksEAaigCAEELdCACSxsiASABQQJqIgEgAUECdEGYksEAaigCAEELdCACSxsiASABQQFqIgEgAUECdEGYksEAaigCAEELdCACSxsiASABQQFqIgEgAUECdEGYksEAaigCAEELdCACSxsiAUECdEGYksEAaigCAEELdCIEIAJGIAIgBEtqIAFqIgRBAnRBmJLBAGoiBSgCAEEVdiECQYkHIQECQCAEQSNNBEAgBSgCBEEVdiEBIARFDQELIAVBBGsoAgBB////AHEhAwsCQCABIAJBf3NqRQ0AIAAgA2shAyABQQFrIQFBACEAA0AgACAC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AiAGaiADIAQQ9gEhAgsgBCgCAEEEaigCACAAKAIAIAEoAgAQigEiAyAEKAIAQQRqKAIAIAAoAgAgAigCABCKAUYEfyACIAEgBCgCAEEEaigCACABKAIAIAIoAgAQigEgA3MbBSAACwu9AQEEfyMAQRBrIgIkACACQQhqIgMgAUEkaigCADYCACACIAEpAhw3AwACQAJAQQwQLiIEBEAgBCACKQMANwIAIARBCGogAygCADYCACABQQRqEHEgAUEEaygCACIDQXhxQSxBMCADQQNxIgUbSQ0BIAVBACADQdAATxsNAiABEFsgAEHMjsIANgIEIAAgBDYCACACQRBqJAAPCwALQdiowgBBLkGIqcIAEMQCAAtBmKnCAEEuQcipwgAQxAIAC6gBAQN/IwBBEGsiAyQAQQMhAiAALQAAIgAhBCAAQQpPBEAgAyAAIABB5ABuIgRB5ABsa0H/AXFBAXQiAkG1+sAAai0AADoADyADIAJBtPrAAGotAAA6AA5BASECC0EAIAAgBBtFBEAgAkEBayICIANBDWpqIARBAXRB/gFxQbX6wABqLQAAOgAACyABQQFBAUEAIANBDWogAmpBAyACaxCOASADQRBqJAALqgMBCH8jAEEQayIDJAAgACgCBCEFIAAoAgAhAEEBIQcgASgCAEG3icIAQQEgASgCBCgCDBEAACECIANBADoACSADIAI6AAggAyABNgIEAkACQCAFBEADQCADIAA2AgwgA0EMaiEIIwBBIGsiASQAQQEhBgJAIANBBGoiBC0ABA0AIAQtAAUhCQJAIAQoAgAiAi0ACkGAAXFFBEAgCUEBcUUNASACKAIAQbWJwgBBAiACKAIEKAIMEQAARQ0BDAILIAlBAXFFBEAgAigCAEHstMIAQQEgAigCBCgCDBEAAA0CCyABQQE6AA8gAUHk+MAANgIUIAEgAikCADcCACABIAIpAgg3AhggASABQQ9qNgIIIAEgATYCECAIIAFBEGoQxgINASABKAIQQYP5wABBAiABKAIUKAIMEQAAIQYMAQsgCCACEMYCIQYLIARBAToABSAEIAY6AAQgAUEgaiQAIABBAWohACAFQQFrIgUNAAsgAy0ACEEBcUUNAQwCCyACDQELIAMoAgQiACgCAEG4icIAQQEgACgCBCgCDBEAACEHCyADQRBqJAAgBwvhAQAgAEEg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DygCEBEAACIJRQ0ACyACQQA2AhAgAkKAgICAEDcCCCACQdydwAA2AhwgAkKggICADjcCICACIAJBCGo2AhggCSACQRhqEKwBDQggAigCCCEAIAIoAgwiBCACKAIQEIADIQMgAARAIARBBGsoAgAiBUF4cSIIQQRBCCAFQQNxIgUbIABqSQ0KIAVBACAIIABBJ2pLGw0LIAQQWwsgCSAJKAIAKAIAEQMAQQEhAEGUwsIAQZTCwgAoAgBBAWo2AgAgBkGDAUsNAQwCC0EAIQBBlMLCAEGUwsIAKAIAQQFqNgIAIAZBhAFJDQELIAcgEUkhACAGELUCCyALQQA2AgAgDCAMKAIAQQFrIgY2AgAgBkUEQCAMELYBCyAKIAA2AgQgCiADQQAgABs2AgAgAkEwaiQADAgLELMDCwALELUDAAtBzJ3AABC4AgALIAJBADYCGCACQRRqIAJBCGogAkEYakHc78EAEM8CAAtBvM3AAEE3IAJBFGpB9J3AAEH0zcAAEJMCAAtB2KjCAEEuQYipwgAQxAIAC0GYqcIAQS5ByKnCABDEAgALIAooAgAgCigCBCAKQRBqJAALKgAgACABLQAAQQJ0IgFBpMvAAGooAgA2AgQgACABQbjLwABqKAIANgIACyEAAkAgAARAIAAoAgBFDQEQtQMACxCzAwALIAAgATYCRAshAAJAIAAEQCAAKAIARQ0BELUDAAsQswMACyAAIAE2AkgLJQAgAEUEQEGo78EAQTIQtAMACyAAIAIgAyAEIAUgASgCEBEPAAslACABIAAtAABBAnQiAEGAucIAaigCACAAQey4wgBqKAIAEIQBCyMAIABFBEBBqO/BAEEyELQDAAsgACACIAMgBCABKAIQERIACyMAIABFBEBBqO/BAEEyELQDAAsgACACIAMgBCABKAIQEQcACyMAIABFBEBBqO/BAEEyELQDAAsgACACIAMgBCABKAIQET4ACyMAIABFBEBBqO/BAEEyELQDAAsgACACIAMgBCABKAIQEUAACyMAIABFBEBBqO/BAEEyELQDAAsgACACIAMgBCABKAIQEUIACycAIAAoAgAtAABFBEAgAUGMisIAQQUQhAEPCyABQZGKwgBBBBCEAQsnACAAQRxqQQAgAkKtoMydv86x+lJRG0EAIAFCucS3xZeH/65OURsLKAAgAEEcakEAIAJC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ZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2NvcmUvc3JjL3NsaWNlL2luZGV4LnJzAGxpYnJhcnkvY29yZS9zcmMvbnVtL2ZsdDJkZWMvc3RyYXRlZ3kvZ3Jpc3UucnMAc3BhcmstaW50ZXJuYWwtcnMvc3JjL3JheWNhc3QucnMAbGlicmFyeS9jb3JlL3NyYy9zbGljZS9zb3J0L3NoYXJlZC9zbWFsbHNvcnQucnMAL1VzZXJzL2FzdW5kcXVpLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9zb3J0L3N0YWJsZS9xdWlja3NvcnQucnMAc3BhcmstaW50ZXJuYWwtcnMvc3JjL3NvcnQucnMAbGlicmFyeS9hbGxvYy9zcmMvZm10LnJzAC9Vc2Vycy9hc3VuZHF1aS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2FueWhvdy0xLjAuOTgvc3JjL2ZtdC5ycwBsaWJyYXJ5L2NvcmUvc3JjL251bS9kaXlfZmxvYXQucnMAc3BhcmstbGliL3NyYy9nc3BsYXQucnMAc3BhcmstaW50ZXJuYWwtcnMvc3JjL3BhY2tlZF9zcGxhdHMucnMAbGlicmFyeS9jb3JlL3NyYy9mbXQvYnVpbGRlcnMucnMAbGlicmFyeS9zdGQvc3JjL3N5cy9zeW5jL211dGV4L25vX3RocmVhZHMucnMAL1VzZXJzL2FzdW5kcXVpLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9zdGQvc3JjL3N5cy9zeW5jL29uY2Uvbm9fdGhyZWFkcy5ycwBsaWJyYXJ5L2FsbG9jL3NyYy9zdHIucnMAL1VzZXJzL2FzdW5kcXVpLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9jb3JlL3NyYy9pdGVyL3RyYWl0cy9pdGVyYXRvci5ycwAvVXNlcnMvYXN1bmRxdWkvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9hbnlob3ctMS4wLjk4L3NyYy9lcnJvci5ycwBsaWJyYXJ5L2NvcmUvc3JjL3NsaWNlL21lbWNoci5ycwAvVXNlcnMvYXN1bmRxdWkvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9taW5pel9veGlkZS0wLjguOS9zcmMvaW5mbGF0ZS9vdXRwdXRfYnVmZmVyLnJzAC9Vc2Vycy9hc3VuZHF1aS9zcGFyazMvcnVzdC9zcGFyay1saWIvc3JjL2RlY29kZXIucnMAbGlicmFyeS9zdGQvc3JjL2lvL3N0ZGlvLnJzAC9Vc2Vycy9hc3VuZHF1aS8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvY29yZS9zcmMvc3RyL3BhdHRlcm4ucnMAL3J1c3RjLzI5NDgzODgzZWVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9jb3JlL3NyYy9zdHIvcGF0dGVybi5ycwAvcnVzdGMvMjk0ODM4ODNlZWQ2OWQ1ZmI0ZGIwMTk2NGNkZjJhZjRkODZlOWNiMi9saWJyYXJ5L2NvcmUvc3JjL29wcy9mdW5jdGlvbi5ycwBsaWJyYXJ5L2NvcmUvc3JjL251bS9mbHQyZGVjL3N0cmF0ZWd5L2RyYWdvbi5ycwBsaWJyYXJ5L2NvcmUvc3JjL251bS9iaWdudW0ucnMAbGlicmFyeS9zdGQvc3JjL2lvL2J1ZmZlcmVkL2xpbmV3cml0ZXJzaGltLnJzAC9Vc2Vycy9hc3VuZHF1aS8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvc3RkL3NyYy90aHJlYWQvbG9jYWwucnMAbGlicmFyeS9zdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzAGxpYnJhcnkvc3RkL3NyYy9zeW5jL3JlZW50cmFudF9sb2NrLnJzAC9Vc2Vycy9hc3VuZHF1aS8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAvVXNlcnMvYXN1bmRxdWkvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9taW5pel9veGlkZS0wLjguOS9zcmMvaW5mbGF0ZS9jb3JlLnJzAGxpYnJhcnkvY29yZS9zcmMvdW5pY29kZS9wcmludGFibGUucnMAc3BhcmstaW50ZXJuYWwtcnMvc3JjL2xvZF90cmVlLnJzAHNwYXJrLWxpYi9zcmMvc3BsYXRfZW5jb2RlLnJzAGxpYnJhcnkvc3RkL3NyYy9zeW5jL3BvaXNvbi9vbmNlLnJzAC9Vc2Vycy9hc3VuZHF1aS8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJzAGxpYnJhcnkvc3RkL3NyYy9iYWNrdHJhY2UucnMAL3J1c3QvZGVwcy9oYXNoYnJvd24tMC4xNS40L3NyYy9yYXcvbW9kLnJzAGxpYnJhcnkvY29yZS9zcmMvZm10L21vZC5ycwBsaWJyYXJ5L2NvcmUvc3JjL3N0ci9tb2QucnMAL1VzZXJzL2FzdW5kcXVpLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvYmluYXJ5X2hlYXAvbW9kLnJzAGxpYnJhcnkvc3RkL3NyYy9pby9tb2QucnMAbGlicmFyeS9zdGQvc3JjLy4uLy4uL2JhY2t0cmFjZS9zcmMvc3ltYm9saXplL21vZC5ycwBsaWJyYXJ5L3N0ZC9zcmMvdGhyZWFkL21vZC5ycwAvVXNlcnMvYXN1bmRxdWkvLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjL21vZC5ycwAvVXNlcnMvYXN1bmRxdWkvLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy92ZWMvbW9kLnJzAGxpYnJhcnkvY29yZS9zcmMvbnVtL2ZsdDJkZWMvbW9kLnJzAHNwYXJrLWxpYi9zcmMvcXVpY2tfbG9kLnJzAC9ydXN0L2RlcHMvZGxtYWxsb2MtMC4yLjkvc3JjL2RsbWFsbG9jLnJzAHNwYXJrLWludGVybmFsLXJzL3NyYy9saWIucnMAL1VzZXJzL2FzdW5kcXVpLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvanMtc3lzLTAuMy43Ny9zcmMvbGliLnJzAC9ydXN0L2RlcHMvcnVzdGMtZGVtYW5nbGUtMC4xLjI1L3NyYy9saWIucnMAL1VzZXJzL2FzdW5kcXVpLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvc2VyZGUtd2FzbS1iaW5kZ2VuLTAuNi41L3NyYy9saWIucnMAL1VzZXJzL2FzdW5kcXVpLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvb25jZV9jZWxsLTEuMjEuMy9zcmMvbGliLnJzAC9Vc2Vycy9hc3VuZHF1aS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3NtYWxsdmVjLTEuMTUuMS9zcmMvbGliLnJzAGxpYnJhcnkvY29yZS9zcmMvdW5pY29kZS91bmljb2RlX2RhdGEucnMAc3BhcmstbGliL3NyYy9zeW1tYXQzLnJzAC9ydXN0L2RlcHMvcnVzdGMtZGVtYW5nbGUtMC4xLjI1L3NyYy92MC5y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AgYBAWUBAQECBAEFAAkBAgACAQEEAZAEAgIEASAKKAYCBAgBCQYCAy4NAQIABwEGAQFSFgIHAQIBAnoGAwEBAgEHAQFIAgMBAQEAAgsCNAUFAQEBFwEAEQYPAAwDAwAFOwcJBAADKAIAAT8RQAIBAgAEAQcBAgACAQQALgIXAAMJEAIHHgSUAwA3BDIIAQ4BFgUBDwAHARECBwECAQUFPiEBoA4AAT0EAAX+AgAHbQgABQABHmCA8ABBGgYaLwEKAQQBBRcBHwHDAQQE0AEkBwIeBWABKgQCAgIEAQEGAQEDAQEBFAFTAYsIpgEmCSkAJgEBBQECKwEEAFYCBgALBSsCA0DAQAACBgImAgYCCAEBAQEBAQEfAjUBBwEBAwMBBwMEAgYEDQUDAQd0AQ0BEA1lAQQBAgoBAQMFBgEBAQEBAQQBBgQBAgQFBQQBESADAgA0AOUGBAMCDCYBAQUBAC4SHoRmAwQBPgICAQEBCBUFAQMAKwEOBlAABwwFABoGGgBQYCQEJHQLAQ8BBwECAQsBDwEHAQIAAQIDASoBCQAzDTNdFgoWAEAAQABVAUcBAgIBAgICBAEMAQEBBwFBAQQCCAEHARwBBAEFAQEDBwEAAhkBGQEfARkBHwEZAR8BGQEfARkBCAAKARQGBgA+AEQAGgYaBhoAAHAABwAtAQEBAgECAQFICzAVEAFlBwIGAgIBBCMBHhtbCzoJCQEYBAEJAQMBBSsDOwkqGAEgNwEBAQQIBAEDBwoCHQE6AQEBAgQIAQkBCgIaAQICOQEEAgQCAgMDAR4CAwELAjkBBAUBAgQBFAIWBgEBOgEBAgEECAEHAwoCHgE7AQEBDAEJASgBAwE3AQEDBQMBBAcCCwIdAToBAgIBAQMDAQQHAgsCHAI5AgEBAgQIAQkBCgIdAUgBBAECAwEBCAFRAQIHDAhiAQIJCwdJAhsBAQEBATcOAQUBAgULASQJAWYEAQYBAgICGQIEAxAEDQECAgYBDwEAAwAEHAMdAh4CQAIBBwgBAgsJAS0DAQF1AiIBdgMEAgkBBgPbAgIBOgEBBwEBAQECCAYKAgEwHzEEMAoEAyYJDAIgBAIGOAEBAgMBAQU4CAICmAMBDQEHBAEGAQMCxkAAAcMhAAONAWAgAAZpAgAEAQogAlACAAEDAQQBGQIFAZcCGhINASYIGQsBASwDMAECBAIC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AQAAAgEAAAMBAAAEAQAABQEAAAYBAAAHAQAACAEAAAkBAAAKAQAACwEAAAwBAAANAQAADgEAAA8BAAAQAQAAEQEAABIBAAATAQAAFAEAABUBAAAWAQAAFwEAABgBAAAZAQAAGgEAABsBAAAcAQAAHQEAAB4BAAAfAQAAIAEAACEBAAAiAQAAIwEAACQBAAAlAQAAJgEAACcBAAAoAQAAKQEAACoBAAArAQAALAEAAC0BAAAuAQAALwEAADABAAAAAEAAMgEAADMBAAA0AQAANQEAADYBAAA3AQAAOQEAADoBAAA7AQAAPAEAAD0BAAA+AQAAPwEAAEABAABBAQAAQgEAAEMBAABEAQAARQEAAEYBAABHAQAASAEAAEoBAABLAQAATAEAAE0BAABOAQAATwEAAFABAABRAQAAUgEAAFMBAABUAQAAVQEAAFYBAABXAQAAWAEAAFkBAABaAQAAWwEAAFwBAABdAQAAXgEAAF8BAABgAQAAYQEAAGIBAABjAQAAZAEAAGUBAABmAQAAZwEAAGgBAABpAQAAagEAAGsBAABsAQAAbQEAAG4BAABvAQAAcAEAAHEBAAByAQAAcwEAAHQBAAB1AQAAdgEAAHcBAAB4AQAA/wAAAHkBAAB6AQAAewEAAHwBAAB9AQAAfgEAAIEBAABTAgAAggEAAIMBAACEAQAAhQEAAIYBAABUAgAAhwEAAIgBAACJAQAAVgIAAIoBAABXAgAAiwEAAIwBAACOAQAA3QEAAI8BAABZAgAAkAEAAFsCAACRAQAAkgEAAJMBAABgAgAAlAEAAGMCAACWAQAAaQIAAJcBAABoAgAAmAEAAJkBAACcAQAAbwIAAJ0BAAByAgAAnwEAAHUCAACgAQAAoQEAAKIBAACjAQAApAEAAKUBAACmAQAAgAIAAKcBAACoAQAAqQEAAIMCAACsAQAArQEAAK4BAACIAgAArwEAALABAACxAQAAigIAALIBAACLAgAAswEAALQBAAC1AQAAtgEAALcBAACSAgAAuAEAALkBAAC8AQAAvQEAAMQBAADGAQAAxQEAAMYBAADHAQAAyQEAAMgBAADJAQAAygEAAMwBAADLAQAAzAEAAM0BAADOAQAAzwEAANABAADRAQAA0gEAANMBAADUAQAA1QEAANYBAADXAQAA2AEAANkBAADaAQAA2wEAANwBAADeAQAA3wEAAOABAADhAQAA4gEAAOMBAADkAQAA5QEAAOYBAADnAQAA6AEAAOkBAADqAQAA6wEAAOwBAADtAQAA7gEAAO8BAADxAQAA8wEAAPIBAADzAQAA9AEAAPUBAAD2AQAAlQEAAPcBAAC/AQAA+AEAAPkBAAD6AQAA+wEAAPwBAAD9AQAA/gEAAP8BAAAAAgAAAQIAAAICAAADAgAABAIAAAUCAAAGAgAABwIAAAgCAAAJAgAACgIAAAsCAAAMAgAADQIAAA4CAAAPAgAAEAIAABECAAASAgAAEwIAABQCAAAVAgAAFgIAABcCAAAYAgAAGQIAABoCAAAbAgAAHAIAAB0CAAAeAgAAHwIAACACAACeAQAAIgIAACMCAAAkAgAAJQIAACYCAAAnAgAAKAIAACkCAAAqAgAAKwIAACwCAAAtAgAALgIAAC8CAAAwAgAAMQIAADICAAAzAgAAOgIAAGUsAAA7AgAAPAIAAD0CAACaAQAAPgIAAGYsAABBAgAAQgIAAEMCAACAAQAARAIAAIkCAABFAgAAjAIAAEYCAABHAgAASAIAAEkCAABKAgAASwIAAEwCAABNAgAATgIAAE8CAABwAwAAcQMAAHIDAABzAwAAdgMAAHcDAAB/AwAA8wMAAIYDAACsAwAAiAMAAK0DAACJAwAArgMAAIoDAACvAwAAjAMAAMwDAACOAwAAzQMAAI8DAADOAwAAkQMAALEDAACSAwAAsgMAAJMDAACzAwAAlAMAALQDAACVAwAAtQMAAJYDAAC2AwAAlwMAALcDAACYAwAAuAMAAJkDAAC5AwAAmgMAALoDAACbAwAAuwMAAJwDAAC8AwAAnQMAAL0DAACeAwAAvgMAAJ8DAAC/AwAAoAMAAMADAAChAwAAwQMAAKMDAADDAwAApAMAAMQDAAClAwAAxQMAAKYDAADGAwAApwMAAMcDAACoAwAAyAMAAKkDAADJAwAAqgMAAMoDAACrAwAAywMAAM8DAADXAwAA2AMAANkDAADaAwAA2wMAANwDAADdAwAA3gMAAN8DAADgAwAA4QMAAOIDAADjAwAA5AMAAOUDAADmAwAA5wMAAOgDAADpAwAA6gMAAOsDAADsAwAA7QMAAO4DAADvAwAA9AMAALgDAAD3AwAA+AMAAPkDAADyAwAA+gMAAPsDAAD9AwAAewMAAP4DAAB8AwAA/wMAAH0DAAAABAAAUAQAAAEEAABRBAAAAgQAAFIEAAADBAAAUwQAAAQEAABUBAAABQQAAFUEAAAGBAAAVgQAAAcEAABXBAAACAQAAFgEAAAJBAAAWQQAAAoEAABaBAAACwQAAFsEAAAMBAAAXAQAAA0EAABdBAAADgQAAF4EAAAPBAAAXwQAABAEAAAwBAAAEQQAADEEAAASBAAAMgQAABMEAAAzBAAAFAQAADQEAAAVBAAANQQAABYEAAA2BAAAFwQAADcEAAAYBAAAOAQAABkEAAA5BAAAGgQAADoEAAAbBAAAOwQAABwEAAA8BAAAHQQAAD0EAAAeBAAAPgQAAB8EAAA/BAAAIAQAAEAEAAAhBAAAQQQAACIEAABCBAAAIwQAAEMEAAAkBAAARAQAACUEAABFBAAAJgQAAEYEAAAnBAAARwQAACgEAABIBAAAKQQAAEkEAAAqBAAASgQAACsEAABLBAAALAQAAEwEAAAtBAAATQQAAC4EAABOBAAALwQAAE8EAABgBAAAYQQAAGIEAABjBAAAZAQAAGUEAABmBAAAZwQAAGgEAABpBAAAagQAAGsEAABsBAAAbQQAAG4EAABvBAAAcAQAAHEEAAByBAAAcwQAAHQEAAB1BAAAdgQAAHcEAAB4BAAAeQQAAHoEAAB7BAAAfAQAAH0EAAB+BAAAfwQAAIAEAACBBAAAigQAAIsEAACMBAAAjQQAAI4EAACPBAAAkAQAAJEEAACSBAAAkwQAAJQEAACVBAAAlgQAAJcEAACYBAAAmQQAAJoEAACbBAAAnAQAAJ0EAACeBAAAnwQAAKAEAAChBAAAogQAAKMEAACkBAAApQQAAKYEAACnBAAAqAQAAKkEAACqBAAAqwQAAKwEAACtBAAArgQAAK8EAACwBAAAsQQAALIEAACzBAAAtAQAALUEAAC2BAAAtwQAALgEAAC5BAAAugQAALsEAAC8BAAAvQQAAL4EAAC/BAAAwAQAAM8EAADBBAAAwgQAAMMEAADEBAAAxQQAAMYEAADHBAAAyAQAAMkEAADKBAAAywQAAMwEAADNBAAAzgQAANAEAADRBAAA0gQAANMEAADUBAAA1QQAANYEAADXBAAA2AQAANkEAADaBAAA2wQAANwEAADdBAAA3gQAAN8EAADgBAAA4QQAAOIEAADjBAAA5AQAAOUEAADmBAAA5wQAAOgEAADpBAAA6gQAAOsEAADsBAAA7QQAAO4EAADvBAAA8AQAAPEEAADyBAAA8wQAAPQEAAD1BAAA9gQAAPcEAAD4BAAA+QQAAPoEAAD7BAAA/AQAAP0EAAD+BAAA/wQAAAAFAAABBQAAAgUAAAMFAAAEBQAABQUAAAYFAAAHBQAACAUAAAkFAAAKBQAACwUAAAwFAAANBQAADgUAAA8FAAAQBQAAEQUAABIFAAATBQAAFAUAABUFAAAWBQAAFwUAABgFAAAZBQAAGgUAABsFAAAcBQAAHQUAAB4FAAAfBQAAIAUAACEFAAAiBQAAIwUAACQFAAAlBQAAJgUAACcFAAAoBQAAKQUAACoFAAArBQAALAUAAC0FAAAuBQAALwUAADEFAABhBQAAMgUAAGIFAAAzBQAAYwUAADQFAABkBQAANQUAAGUFAAA2BQAAZgUAADcFAABnBQAAOAUAAGgFAAA5BQAAaQUAADoFAABqBQAAOwUAAGsFAAA8BQAAbAUAAD0FAABtBQAAPgUAAG4FAAA/BQAAbwUAAEAFAABwBQAAQQUAAHEFAABCBQAAcgUAAEMFAABzBQAARAUAAHQFAABFBQAAdQUAAEYFAAB2BQAARwUAAHcFAABIBQAAeAUAAEkFAAB5BQAASgUAAHoFAABLBQAAewUAAEwFAAB8BQAATQUAAH0FAABOBQAAfgUAAE8FAAB/BQAAUAUAAIAFAABRBQAAgQUAAFIFAACCBQAAUwUAAIMFAABUBQAAhAUAAFUFAACFBQAAVgUAAIYFAACgEAAAAC0AAKEQAAABLQAAohAAAAItAACjEAAAAy0AAKQQAAAELQAApRAAAAUtAACmEAAABi0AAKcQAAAHLQAAqBAAAAgtAACpEAAACS0AAKoQAAAKLQAAqxAAAAstAACsEAAADC0AAK0QAAANLQAArhAAAA4tAACvEAAADy0AALAQAAAQLQAAsRAAABEtAACyEAAAEi0AALMQAAATLQAAtBAAABQtAAC1EAAAFS0AALYQAAAWLQAAtxAAABctAAC4EAAAGC0AALkQAAAZLQAAuhAAABotAAC7EAAAGy0AALwQAAAcLQAAvRAAAB0tAAC+EAAAHi0AAL8QAAAfLQAAwBAAACAtAADBEAAAIS0AAMIQAAAiLQAAwxAAACMtAADEEAAAJC0AAMUQAAAlLQAAxxAAACctAADNEAAALS0AAKATAABwqwAAoRMAAHGrAACiEwAAcqsAAKMTAABzqwAApBMAAHSrAAClEwAAdasAAKYTAAB2qwAApxMAAHerAACoEwAAeKsAAKkTAAB5qwAAqhMAAHqrAACrEwAAe6sAAKwTAAB8qwAArRMAAH2rAACuEwAAfqsAAK8TAAB/qwAAsBMAAICrAACxEwAAgasAALITAACCqwAAsxMAAIOrAAC0EwAAhKsAALUTAACFqwAAthMAAIarAAC3EwAAh6sAALgTAACIqwAAuRMAAImrAAC6EwAAiqsAALsTAACLqwAAvBMAAIyrAAC9EwAAjasAAL4TAACOqwAAvxMAAI+rAADAEwAAkKsAAMETAACRqwAAwhMAAJKrAADDEwAAk6sAAMQTAACUqwAAxRMAAJWrAADGEwAAlqsAAMcTAACXqwAAyBMAAJirAADJEwAAmasAAMoTAACaqwAAyxMAAJurAADMEwAAnKsAAM0TAACdqwAAzhMAAJ6rAADPEwAAn6sAANATAACgqwAA0RMAAKGrAADSEwAAoqsAANMTAACjqwAA1BMAAKSrAADVEwAApasAANYTAACmqwAA1xMAAKerAADYEwAAqKsAANkTAACpqwAA2hMAAKqrAADbEwAAq6sAANwTAACsqwAA3RMAAK2rAADeEwAArqsAAN8TAACvqwAA4BMAALCrAADhEwAAsasAAOITAACyqwAA4xMAALOrAADkEwAAtKsAAOUTAAC1qwAA5hMAALarAADnEwAAt6sAAOgTAAC4qwAA6RMAALmrAADqEwAAuqsAAOsTAAC7qwAA7BMAALyrAADtEwAAvasAAO4TAAC+qwAA7xMAAL+rAADwEwAA+BMAAPETAAD5EwAA8hMAAPoTAADzEwAA+xMAAPQTAAD8EwAA9RMAAP0TAACJHAAAihwAAJAcAADQEAAAkRwAANEQAACSHAAA0hAAAJMcAADTEAAAlBwAANQQAACVHAAA1RAAAJYcAADWEAAAlxwAANcQAACYHAAA2BAAAJkcAADZEAAAmhwAANoQAACbHAAA2xAAAJwcAADcEAAAnRwAAN0QAACeHAAA3hAAAJ8cAADfEAAAoBwAAOAQAAChHAAA4RAAAKIcAADiEAAAoxwAAOMQAACkHAAA5BAAAKUcAADlEAAAphwAAOYQAACnHAAA5xAAAKgcAADoEAAAqRwAAOkQAACqHAAA6hAAAKscAADrEAAArBwAAOwQAACtHAAA7RAAAK4cAADuEAAArxwAAO8QAACwHAAA8BAAALEcAADxEAAAshwAAPIQAACzHAAA8xAAALQcAAD0EAAAtRwAAPUQAAC2HAAA9hAAALccAAD3EAAAuBwAAPgQAAC5HAAA+RAAALocAAD6EAAAvRwAAP0QAAC+HAAA/hAAAL8cAAD/EAAAAB4AAAEeAAACHgAAAx4AAAQeAAAFHgAABh4AAAceAAAIHgAACR4AAAoeAAALHgAADB4AAA0eAAAOHgAADx4AABAeAAARHgAAEh4AABMeAAAUHgAAFR4AABYeAAAXHgAAGB4AABkeAAAaHgAAGx4AABweAAAdHgAAHh4AAB8eAAAgHgAAIR4AACIeAAAjHgAAJB4AACUeAAAmHgAAJx4AACgeAAApHgAAKh4AACseAAAsHgAALR4AAC4eAAAvHgAAMB4AADEeAAAyHgAAMx4AADQeAAA1HgAANh4AADceAAA4HgAAOR4AADoeAAA7HgAAPB4AAD0eAAA+HgAAPx4AAEAeAABBHgAAQh4AAEMeAABEHgAARR4AAEYeAABHHgAASB4AAEkeAABKHgAASx4AAEweAABNHgAATh4AAE8eAABQHgAAUR4AAFIeAABTHgAAVB4AAFUeAABWHgAAVx4AAFgeAABZHgAAWh4AAFseAABcHgAAXR4AAF4eAABfHgAAYB4AAGEeAABiHgAAYx4AAGQeAABlHgAAZh4AAGceAABoHgAAaR4AAGoeAABrHgAAbB4AAG0eAABuHgAAbx4AAHAeAABxHgAAch4AAHMeAAB0HgAAdR4AAHYeAAB3HgAAeB4AAHkeAAB6HgAAex4AAHweAAB9HgAAfh4AAH8eAACAHgAAgR4AAIIeAACDHgAAhB4AAIUeAACGHgAAhx4AAIgeAACJHgAAih4AAIseAACMHgAAjR4AAI4eAACPHgAAkB4AAJEeAACSHgAAkx4AAJQeAACVHgAAnh4AAN8AAACgHgAAoR4AAKIeAACjHgAApB4AAKUeAACmHgAApx4AAKgeAACpHgAAqh4AAKseAACsHgAArR4AAK4eAACvHgAAsB4AALEeAACyHgAAsx4AALQeAAC1HgAAth4AALceAAC4HgAAuR4AALoeAAC7HgAAvB4AAL0eAAC+HgAAvx4AAMAeAADBHgAAwh4AAMMeAADEHgAAxR4AAMYeAADHHgAAyB4AAMkeAADKHgAAyx4AAMweAADNHgAAzh4AAM8eAADQHgAA0R4AANIeAADTHgAA1B4AANUeAADWHgAA1x4AANgeAADZHgAA2h4AANseAADcHgAA3R4AAN4eAADfHgAA4B4AAOEeAADiHgAA4x4AAOQeAADlHgAA5h4AAOceAADoHgAA6R4AAOoeAADrHgAA7B4AAO0eAADuHgAA7x4AAPAeAADxHgAA8h4AAPMeAAD0HgAA9R4AAPYeAAD3HgAA+B4AAPkeAAD6HgAA+x4AAPweAAD9HgAA/h4AAP8eAAAIHwAAAB8AAAkfAAABHwAACh8AAAIfAAALHwAAAx8AAAwfAAAEHwAADR8AAAUfAAAOHwAABh8AAA8fAAAHHwAAGB8AABAfAAAZHwAAER8AABofAAASHwAAGx8AABMfAAAcHwAAFB8AAB0fAAAVHwAAKB8AACAfAAApHwAAIR8AACofAAAiHwAAKx8AACMfAAAsHwAAJB8AAC0fAAAlHwAALh8AACYfAAAvHwAAJx8AADgfAAAwHwAAOR8AADEfAAA6HwAAMh8AADsfAAAzHwAAPB8AADQfAAA9HwAANR8AAD4fAAA2HwAAPx8AADcfAABIHwAAQB8AAEkfAABBHwAASh8AAEIfAABLHwAAQx8AAEwfAABEHwAATR8AAEUfAABZHwAAUR8AAFsfAABTHwAAXR8AAFUfAABfHwAAVx8AAGgfAABgHwAAaR8AAGEfAABqHwAAYh8AAGsfAABjHwAAbB8AAGQfAABtHwAAZR8AAG4fAABmHwAAbx8AAGcfAACIHwAAgB8AAIkfAACBHwAAih8AAIIfAACLHwAAgx8AAIwfAACEHwAAjR8AAIUfAACOHwAAhh8AAI8fAACHHwAAmB8AAJAfAACZHwAAkR8AAJofAACSHwAAmx8AAJMfAACcHwAAlB8AAJ0fAACVHwAAnh8AAJYfAACfHwAAlx8AAKgfAACgHwAAqR8AAKEfAACqHwAAoh8AAKsfAACjHwAArB8AAKQfAACtHwAApR8AAK4fAACmHwAArx8AAKcfAAC4HwAAsB8AALkfAACxHwAAuh8AAHAfAAC7HwAAcR8AALwfAACzHwAAyB8AAHIfAADJHwAAcx8AAMofAAB0HwAAyx8AAHUfAADMHwAAwx8AANgfAADQHwAA2R8AANEfAADaHwAAdh8AANsfAAB3HwAA6B8AAOAfAADpHwAA4R8AAOofAAB6HwAA6x8AAHsfAADsHwAA5R8AAPgfAAB4HwAA+R8AAHkfAAD6HwAAfB8AAPsfAAB9HwAA/B8AAPMfAAAmIQAAyQMAACohAABrAAAAKyEAAOUAAAAyIQAATiEAAGAhAABwIQAAYSEAAHEhAABiIQAAciEAAGMhAABzIQAAZCEAAHQhAABlIQAAdSEAAGYhAAB2IQAAZyEAAHchAABoIQAAeCEAAGkhAAB5IQAAaiEAAHohAABrIQAAeyEAAGwhAAB8IQAAbSEAAH0hAABuIQAAfiEAAG8hAAB/IQAAgyEAAIQhAAC2JAAA0CQAALckAADRJAAAuCQAANIkAAC5JAAA0yQAALokAADUJAAAuyQAANUkAAC8JAAA1iQAAL0kAADXJAAAviQAANgkAAC/JAAA2SQAAMAkAADaJAAAwSQAANskAADCJAAA3CQAAMMkAADdJAAAxCQAAN4kAADFJAAA3yQAAMYkAADgJAAAxyQAAOEkAADIJAAA4iQAAMkkAADjJAAAyiQAAOQkAADLJAAA5SQAAMwkAADmJAAAzSQAAOckAADOJAAA6CQAAM8kAADpJAAAACwAADAsAAABLAAAMSwAAAIsAAAyLAAAAywAADMsAAAELAAANCwAAAUsAAA1LAAABiwAADYsAAAHLAAANywAAAgsAAA4LAAACSwAADksAAAKLAAAOiwAAAssAAA7LAAADCwAADwsAAANLAAAPSwAAA4sAAA+LAAADywAAD8sAAAQLAAAQCwAABEsAABBLAAAEiwAAEIsAAATLAAAQywAABQsAABELAAAFSwAAEUsAAAWLAAARiwAABcsAABHLAAAGCwAAEgsAAAZLAAASSwAABosAABKLAAAGywAAEssAAAcLAAATCwAAB0sAABNLAAAHiwAAE4sAAAfLAAATywAACAsAABQLAAAISwAAFEsAAAiLAAAUiwAACMsAABTLAAAJCwAAFQsAAAlLAAAVSwAACYsAABWLAAAJywAAFcsAAAoLAAAWCwAACksAABZLAAAKiwAAFosAAArLAAAWywAACwsAABcLAAALSwAAF0sAAAuLAAAXiwAAC8sAABfLAAAYCwAAGEsAABiLAAAawIAAGMsAAB9HQAAZCwAAH0CAABnLAAAaCwAAGksAABqLAAAaywAAGwsAABtLAAAUQIAAG4sAABxAgAAbywAAFACAABwLAAAUgIAAHIsAABzLAAAdSwAAHYsAAB+LAAAPwIAAH8sAABAAgAAgCwAAIEsAACCLAAAgywAAIQsAACFLAAAhiwAAIcsAACILAAAiSwAAIosAACLLAAAjCwAAI0sAACOLAAAjywAAJAsAACRLAAAkiwAAJMsAACULAAAlSwAAJYsAACXLAAAmCwAAJksAACaLAAAmywAAJwsAACdLAAAniwAAJ8sAACgLAAAoSwAAKIsAACjLAAApCwAAKUsAACmLAAApywAAKgsAACpLAAAqiwAAKssAACsLAAArSwAAK4sAACvLAAAsCwAALEsAACyLAAAsywAALQsAAC1LAAAtiwAALcsAAC4LAAAuSwAALosAAC7LAAAvCwAAL0sAAC+LAAAvywAAMAsAADBLAAAwiwAAMMsAADELAAAxSwAAMYsAADHLAAAyCwAAMksAADKLAAAyywAAMwsAADNLAAAziwAAM8sAADQLAAA0SwAANIsAADTLAAA1CwAANUsAADWLAAA1ywAANgsAADZLAAA2iwAANssAADcLAAA3SwAAN4sAADfLAAA4CwAAOEsAADiLAAA4ywAAOssAADsLAAA7SwAAO4sAADyLAAA8ywAAECmAABBpgAAQqYAAEOmAABEpgAARaYAAEamAABHpgAASKYAAEmmAABKpgAAS6YAAEymAABNpgAATqYAAE+mAABQpgAAUaYAAFKmAABTpgAAVKYAAFWmAABWpgAAV6YAAFimAABZpgAAWqYAAFumAABcpgAAXaYAAF6mAABfpgAAYKYAAGGmAABipgAAY6YAAGSmAABlpgAAZqYAAGemAABopgAAaaYAAGqmAABrpgAAbKYAAG2mAACApgAAgaYAAIKmAACDpgAAhKYAAIWmAACGpgAAh6YAAIimAACJpgAAiqYAAIumAACMpgAAjaYAAI6mAACPpgAAkKYAAJGmAACSpgAAk6YAAJSmAACVpgAAlqYAAJemAACYpgAAmaYAAJqmAACbpgAAIqcAACOnAAAkpwAAJacAACanAAAnpwAAKKcAACmnAAAqpwAAK6cAACynAAAtpwAALqcAAC+nAAAypwAAM6cAADSnAAA1pwAANqcAADenAAA4pwAAOacAADqnAAA7pwAAPKcAAD2nAAA+pwAAP6cAAECnAABBpwAAQqcAAEOnAABEpwAARacAAEanAABHpwAASKcAAEmnAABKpwAAS6cAAEynAABNpwAATqcAAE+nAABQpwAAUacAAFKnAABTpwAAVKcAAFWnAABWpwAAV6cAAFinAABZpwAAWqcAAFunAABcpwAAXacAAF6nAABfpwAAYKcAAGGnAABipwAAY6cAAGSnAABlpwAAZqcAAGenAABopwAAaacAAGqnAABrpwAAbKcAAG2nAABupwAAb6cAAHmnAAB6pwAAe6cAAHynAAB9pwAAeR0AAH6nAAB/pwAAgKcAAIGnAACCpwAAg6cAAISnAACFpwAAhqcAAIenAACLpwAAjKcAAI2nAABlAgAAkKcAAJGnAACSpwAAk6cAAJanAACXpwAAmKcAAJmnAACapwAAm6cAAJynAACdpwAAnqcAAJ+nAACgpwAAoacAAKKnAACjpwAApKcAAKWnAACmpwAAp6cAAKinAACppwAAqqcAAGYCAACrpwAAXAIAAKynAABhAgAAracAAGwCAACupwAAagIAALCnAACeAgAAsacAAIcCAACypwAAnQIAALOnAABTqwAAtKcAALWnAAC2pwAAt6cAALinAAC5pwAAuqcAALunAAC8pwAAvacAAL6nAAC/pwAAwKcAAMGnAADCpwAAw6cAAMSnAACUpwAAxacAAIICAADGpwAAjh0AAMenAADIpwAAyacAAMqnAADLpwAAZAIAAMynAADNpwAA0KcAANGnAADWpwAA16cAANinAADZpwAA2qcAANunAADcpwAAmwEAAPWnAAD2pwAAIf8AAEH/AAAi/wAAQv8AACP/AABD/wAAJP8AAET/AAAl/wAARf8AACb/AABG/wAAJ/8AAEf/AAAo/wAASP8AACn/AABJ/wAAKv8AAEr/AAAr/wAAS/8AACz/AABM/wAALf8AAE3/AAAu/wAATv8AAC//AABP/wAAMP8AAFD/AAAx/wAAUf8AADL/AABS/wAAM/8AAFP/AAA0/wAAVP8AADX/AABV/wAANv8AAFb/AAA3/wAAV/8AADj/AABY/wAAOf8AAFn/AAA6/wAAWv8AAAAEAQAoBAEAAQQBACkEAQACBAEAKgQBAAMEAQArBAEABAQBACwEAQAFBAEALQQBAAYEAQAuBAEABwQBAC8EAQAIBAEAMAQBAAkEAQAxBAEACgQBADIEAQALBAEAMwQBAAwEAQA0BAEADQQBADUEAQAOBAEANgQBAA8EAQA3BAEAEAQBADgEAQARBAEAOQQBABIEAQA6BAEAEwQBADsEAQAUBAEAPAQBABUEAQA9BAEAFgQBAD4EAQAXBAEAPwQBABgEAQBABAEAGQQBAEEEAQAaBAEAQgQBABsEAQBDBAEAHAQBAEQEAQAdBAEARQQBAB4EAQBGBAEAHwQBAEcEAQAgBAEASAQBACEEAQBJBAEAIgQBAEoEAQAjBAEASwQBACQEAQBMBAEAJQQBAE0EAQAmBAEATgQBACcEAQBPBAEAsAQBANgEAQCxBAEA2QQBALIEAQDaBAEAswQBANsEAQC0BAEA3AQBALUEAQDdBAEAtgQBAN4EAQC3BAEA3wQBALgEAQDgBAEAuQQBAOEEAQC6BAEA4gQBALsEAQDjBAEAvAQBAOQEAQC9BAEA5QQBAL4EAQDmBAEAvwQBAOcEAQDABAEA6AQBAMEEAQDpBAEAwgQBAOoEAQDDBAEA6wQBAMQEAQDsBAEAxQQBAO0EAQDGBAEA7gQBAMcEAQDvBAEAyAQBAPAEAQDJBAEA8QQBAMoEAQDyBAEAywQBAPMEAQDMBAEA9AQBAM0EAQD1BAEAzgQBAPYEAQDPBAEA9wQBANAEAQD4BAEA0QQBAPkEAQDSBAEA+gQBANMEAQD7BAEAcAUBAJcFAQBxBQEAmAUBAHIFAQCZBQEAcwUBAJoFAQB0BQEAmwUBAHUFAQCcBQEAdgUBAJ0FAQB3BQEAngUBAHgFAQCfBQEAeQUBAKAFAQB6BQEAoQUBAHwFAQCjBQEAfQUBAKQFAQB+BQEApQUBAH8FAQCmBQEAgAUBAKcFAQCBBQEAqAUBAIIFAQCpBQEAgwUBAKoFAQCEBQEAqwUBAIUFAQCsBQEAhgUBAK0FAQCHBQEArgUBAIgFAQCvBQEAiQUBALAFAQCKBQEAsQUBAIwFAQCzBQEAjQUBALQFAQCOBQEAtQUBAI8FAQC2BQEAkAUBALcFAQCRBQEAuAUBAJIFAQC5BQEAlAUBALsFAQCVBQEAvAUBAIAMAQDADAEAgQwBAMEMAQCCDAEAwgwBAIMMAQDDDAEAhAwBAMQMAQCFDAEAxQwBAIYMAQDGDAEAhwwBAMcMAQCIDAEAyAwBAIkMAQDJDAEAigwBAMoMAQCLDAEAywwBAIwMAQDMDAEAjQwBAM0MAQCODAEAzgwBAI8MAQDPDAEAkAwBANAMAQCRDAEA0QwBAJIMAQDSDAEAkwwBANMMAQCUDAEA1AwBAJUMAQDVDAEAlgwBANYMAQCXDAEA1wwBAJgMAQDYDAEAmQwBANkMAQCaDAEA2gwBAJsMAQDbDAEAnAwBANwMAQCdDAEA3QwBAJ4MAQDeDAEAnwwBAN8MAQCgDAEA4AwBAKEMAQDhDAEAogwBAOIMAQCjDAEA4wwBAKQMAQDkDAEApQwBAOUMAQCmDAEA5gwBAKcMAQDnDAEAqAwBAOgMAQCpDAEA6QwBAKoMAQDqDAEAqwwBAOsMAQCsDAEA7AwBAK0MAQDtDAEArgwBAO4MAQCvDAEA7wwBALAMAQDwDAEAsQwBAPEMAQCyDAEA8gwBAFANAQBwDQEAUQ0BAHENAQBSDQEAcg0BAFMNAQBzDQEAVA0BAHQNAQBVDQEAdQ0BAFYNAQB2DQEAVw0BAHcNAQBYDQEAeA0BAFkNAQB5DQEAWg0BAHoNAQBbDQEAew0BAFwNAQB8DQEAXQ0BAH0NAQBeDQEAfg0BAF8NAQB/DQEAYA0BAIANAQBhDQEAgQ0BAGINAQCCDQEAYw0BAIMNAQBkDQEAhA0BAGUNAQCFDQEAoBgBAMAYAQChGAEAwRgBAKIYAQDCGAEAoxgBAMMYAQCkGAEAxBgBAKUYAQDFGAEAphgBAMYYAQCnGAEAxxgBAKgYAQDIGAEAqRgBAMkYAQCqGAEAyhgBAKsYAQDLGAEArBgBAMwYAQCtGAEAzRgBAK4YAQDOGAEArxgBAM8YAQCwGAEA0BgBALEYAQDRGAEAshgBANIYAQCzGAEA0xgBALQYAQDUGAEAtRgBANUYAQC2GAEA1hgBALcYAQDXGAEAuBgBANgYAQC5GAEA2RgBALoYAQDaGAEAuxgBANsYAQC8GAEA3BgBAL0YAQDdGAEAvhgBAN4YAQC/GAEA3xgBAEBuAQBgbgEAQW4BAGFuAQBCbgEAYm4BAENuAQBjbgEARG4BAGRuAQBFbgEAZW4BAEZuAQBmbgEAR24BAGduAQBIbgEAaG4BAEluAQBpbgEASm4BAGpuAQBLbgEAa24BAExuAQBsbgEATW4BAG1uAQBObgEAbm4BAE9uAQBvbgEAUG4BAHBuAQBRbgEAcW4BAFJuAQBybgEAU24BAHNuAQBUbgEAdG4BAFVuAQB1bgEAVm4BAHZuAQBXbgEAd24BAFhuAQB4bgEAWW4BAHluAQBabgEAem4BAFtuAQB7bgEAXG4BAHxuAQBdbgEAfW4BAF5uAQB+bgEAX24BAH9uAQAA6QEAIukBAAHpAQAj6QEAAukBACTpAQAD6QEAJekBAATpAQAm6QEABekBACfpAQAG6QEAKOkBAAfpAQAp6QEACOkBACrpAQAJ6QEAK+kBAArpAQAs6QEAC+kBAC3pAQAM6QEALukBAA3pAQAv6QEADukBADDpAQAP6QEAMekBABDpAQAy6QEAEekBADPpAQAS6QEANOkBABPpAQA16QEAFOkBADbpAQAV6QEAN+kBABbpAQA46QEAF+kBADnpAQAY6QEAOukBABnpAQA76QEAGukBADzpAQAb6QEAPekBABzpAQA+6QEAHekBAD/pAQAe6QEAQOkBAB/pAQBB6QEAIOkBAELpAQAh6QEAQ+kBAFZlYzNBSGFzaCB0YWJsZSBjYXBhY2l0eSBvdmVyZmxvdwAAAHF3EAAcAAAA6QkQACsAAAAlAAAAKAAAAGNsb3N1cmUgaW52b2tlZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkAACqDBAAXgAAAPsYAAABAAAAZGVzdCBpcyBvdXQgb2YgYm91bmRzAAAA7HcQABUAAACRABAAdAAAAFIDAAAyAAAAEBESAAgHCQYKBQsEDAMNAg4BDwBoCBAAawAAABECAAAoAAAAaAgQAGsAAACGAgAAHQAAAAAAAIAAQADAACAAoABgAOAAEACQAFAA0AAwALAAcADwAAgAiABIAMgAKACoAGgA6AAYAJgAWADYADgAuAB4APgABACEAEQAxAAkAKQAZADkABQAlABUANQANAC0AHQA9AAMAIwATADMACwArABsAOwAHACcAFwA3AA8ALwAfAD8AAIAggBCAMIAIgCiAGIA4gASAJIAUgDSADIAsgByAPIACgCKAEoAygAqAKoAagDqABoAmgBaANoAOgC6AHoA+gAGAIYARgDGACYApgBmAOYAFgCWAFYA1gA2ALYAdgD2AA4AjgBOAM4ALgCuAG4A7gAeAJ4AXgDeAD4AvgB+AP4AAQCBAEEAwQAhAKEAYQDhABEAkQBRANEAMQCxAHEA8QAJAIkASQDJACkAqQBpAOkAGQCZAFkA2QA5ALkAeQD5AAUAhQBFAMUAJQClAGUA5QAVAJUAVQDVADUAtQB1APUADQCNAE0AzQAtAK0AbQDtAB0AnQBdAN0APQC9AH0A/QADAIMAQwDDACMAowBjAOMAEwCTAFMA0wAzALMAcwDzAAsAiwBLAMsAKwCrAGsA6wAbAJsAWwDbADsAuwB7APsABwCHAEcAxwAnAKcAZwDnABcAlwBXANcANwC3AHcA9wAPAI8ATwDPAC8ArwBvAO8AHwCfAF8A3wA/AL8AfwD/gACAgIBAgMCAIICggGCA4IAQgJCAUIDQgDCAsIBwgPCACICIgEiAyIAogKiAaIDogBiAmIBYgNiAOIC4gHiA+IAEgISARIDEgCSApIBkgOSAFICUgFSA1IA0gLSAdID0gAyAjIBMgMyALICsgGyA7IAcgJyAXIDcgDyAvIB8gPyAAoCCgEKAwoAigKKAYoDigBKAkoBSgNKAMoCygHKA8oAKgIqASoDKgCqAqoBqgOqAGoCagFqA2oA6gLqAeoD6gAaAhoBGgMaAJoCmgGaA5oAWgJaAVoDWgDaAtoB2gPaADoCOgE6AzoAugK6AboDugB6AnoBegN6APoC+gH6A/oABgIGAQYDBgCGAoYBhgOGAEYCRgFGA0YAxgLGAcYDxgAmAiYBJgMmAKYCpgGmA6YAZgJmAWYDZgDmAuYB5gPmABYCFgEWAxYAlgKWAZYDlgBWAlYBVgNWANYC1gHWA9YANgI2ATYDNgC2ArYBtgO2AHYCdgF2A3YA9gL2AfYD9gAOAg4BDgMOAI4CjgGOA44ATgJOAU4DTgDOAs4BzgPOAC4CLgEuAy4ArgKuAa4DrgBuAm4BbgNuAO4C7gHuA+4AHgIeAR4DHgCeAp4BngOeAF4CXgFeA14A3gLeAd4D3gA+Aj4BPgM+AL4CvgG+A74AfgJ+AX4DfgD+Av4B/gP9oCBAAawAAACIEAAAUAAAAaAgQAGsAAAAjBAAAEgAAAGFzc2VydGlvbiBmYWlsZWQ6IG91dF9wb3MgKyAzIDwgb3V0X3NsaWNlLmxlbigpAGgIEABrAAAANgQAAA0AAABhc3NlcnRpb24gZmFpbGVkOiAoc291cmNl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IHBsYXRmb3JtUJUQACgAAAAkAAAAAAAAAAIAAAB4lRAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAMwJEAAdAAAAigEAAB0AAAC5AAAAEAAAAAQAAAC6AAAAuwAAAAEAAAAAAAAAbWlkID4gbGVuAAAA5JUQAAkAAAANBxAALgAAABYBAAApAAAAZW50aXR5IG5vdCBmb3VuZHBlcm1pc3Npb24gZGVuaWVkY29ubmVjdGlvbiByZWZ1c2VkY29ubmVjdGlvbiByZXNldGhvc3QgdW5yZWFjaGFibGVuZXR3b3JrIHVucmVhY2hhYmxlY29ubmVjdGlvbiBhYm9ydGVkbm90IGNvbm5lY3RlZGFkZHJlc3MgaW4gdXNlYWRkcmVzcyBub3QgYXZhaWxhYmxlbmV0d29yayBkb3duYnJva2VuIHBpcGVlbnRpdHkgYWxyZWFkeSBleGlzdHNvcGVyYXRpb24gd291bGQgYmxvY2tub3QgYSBkaXJlY3RvcnlpcyBhIGRpcmVjdG9yeWRpcmVjdG9yeSBub3QgZW1wdHlyZWFkLW9ubHkgZmlsZXN5c3RlbSBvciBzdG9yYWdlIG1lZGl1bWZpbGVzeXN0ZW0gbG9vcCBvciBpbmRpcmVjdGlvbiBsaW1pdCAoZS5nLiBzeW1saW5rIGxvb3Apc3RhbGUgbmV0d29yayBmaWxlIGhhbmRsZWludmFsaWQgaW5wdXQgcGFyYW1ldGVyaW52YWxpZCBkYXRhdGltZWQgb3V0d3JpdGUgemVyb25vIHN0b3JhZ2Ugc3BhY2VzZWVrIG9uIHVuc2Vla2FibGUgZmlsZXF1b3RhIGV4Y2VlZGVkZmlsZSB0b28gbGFyZ2VyZXNvdXJjZSBidXN5ZXhlY3V0YWJsZSBmaWxlIGJ1c3lkZWFkbG9ja2Nyb3NzLWRldmljZSBsaW5rIG9yIHJlbmFtZXRvbyBtYW55IGxpbmtzaW52YWxpZCBmaWxlbmFtZWFyZ3VtZW50IGxpc3QgdG9vIGxvbmdvcGVyYXRpb24gaW50ZXJydXB0ZWR1bnN1cHBvcnRlZHVuZXhwZWN0ZWQgZW5kIG9mIGZpbGVvdXQgb2YgbWVtb3J5aW4gcHJvZ3Jlc3NvdGhlciBlcnJvcnVuY2F0ZWdvcml6ZWQgZXJy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", self.location.href);\\n    }\\n    const imports = __wbg_get_imports();\\n    if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {\\n      module_or_path = fetch(module_or_path);\\n    }\\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\\n    return __wbg_finalize_init(instance, module);\\n  }\\n  const rpcHandlers = {\\n    sortSplats16,\\n    sortSplats32,\\n    loadSplats,\\n    quickLod,\\n    initLodTree,\\n    disposeLodTree,\\n    insertLodTrees,\\n    clearLodTrees,\\n    traverseLodTrees\\n  };\\n  async function onMessage(event) {\\n    const {\\n      id,\\n      name,\\n      args\\n    } = event.data;\\n    try {\\n      const handler = rpcHandlers[name];\\n      if (!handler) {\\n        throw new Error(`Unknown worker RPC: ${name}`);\\n      }\\n      const sendStatus = (data) => {\\n        self.postMessage(\\n          { id, status: data },\\n          { transfer: getArrayBuffers(data) }\\n        );\\n      };\\n      const result = await handler(args, { sendStatus });\\n      self.postMessage({ id, result }, { transfer: getArrayBuffers(result) });\\n    } catch (error) {\\n      console.warn(`Worker error: ${error}`);\\n      self.postMessage({ id, error }, { transfer: getArrayBuffers(error) });\\n    }\\n  }\\n  function sortSplats16({\\n    numSplats,\\n    readback,\\n    ordering\\n  }) {\\n    const activeSplats = sort_splats(numSplats, readback, ordering);\\n    return { activeSplats, readback, ordering };\\n  }\\n  function sortSplats32({\\n    numSplats,\\n    readback,\\n    ordering\\n  }) {\\n    const activeSplats = sort32_splats(numSplats, readback, ordering);\\n    return { activeSplats, readback, ordering };\\n  }\\n  async function decodeBytesUrl({\\n    decoder,\\n    fileBytes,\\n    url,\\n    // baseUri,\\n    requestHeader,\\n    withCredentials,\\n    sendStatus\\n  }) {\\n    let decodeDuration = 0;\\n    if (fileBytes) {\\n      const start = performance.now();\\n      decoder.push(fileBytes);\\n      decodeDuration += performance.now() - start;\\n    } else if (url) {\\n      const request = new Request(url, {\\n        headers: requestHeader ? new Headers(requestHeader) : void 0,\\n        credentials: withCredentials ? "include" : "same-origin"\\n      });\\n      const response = await fetch(request);\\n      if (!response.ok || !response.body) {\\n        throw new Error(\\n          `Failed to fetch: ${response.status} ${response.statusText}`\\n        );\\n      }\\n      const reader = response.body.getReader();\\n      const contentLength = Number.parseInt(\\n        response.headers.get("Content-Length") || "0"\\n      );\\n      const total = Number.isNaN(contentLength) ? 0 : contentLength;\\n      let loaded = 0;\\n      while (true) {\\n        const { done, value } = await reader.read();\\n        if (done) {\\n          break;\\n        }\\n        loaded += value.length;\\n        sendStatus({ loaded, total });\\n        const start = performance.now();\\n        decoder.push(value);\\n        decodeDuration += performance.now() - start;\\n      }\\n    } else {\\n      throw new Error("No url or fileBytes provided");\\n    }\\n    const decoded = decoder.finish();\\n    return decoded;\\n  }\\n  function toPackedResult(packed) {\\n    return {\\n      numSplats: packed.numSplats,\\n      packedArray: packed.packed,\\n      extra: {\\n        sh1: packed.sh1,\\n        sh2: packed.sh2,\\n        sh3: packed.sh3,\\n        lodTree: packed.lodTree\\n      },\\n      splatEncoding: packed.splatEncoding\\n    };\\n  }\\n  async function loadSplats({\\n    url,\\n    // baseUri,\\n    requestHeader,\\n    withCredentials,\\n    fileBytes,\\n    fileType,\\n    pathName,\\n    lod,\\n    lodBase,\\n    encoding,\\n    nonLod\\n  }, {\\n    sendStatus\\n  }) {\\n    if (!lod) {\\n      const decoder2 = decode_to_packedsplats(fileType, pathName ?? url);\\n      const decoded2 = await decodeBytesUrl({\\n        decoder: decoder2,\\n        fileBytes,\\n        url,\\n        // baseUri,\\n        requestHeader,\\n        withCredentials,\\n        sendStatus\\n      });\\n      const result = toPackedResult(decoded2);\\n      if (result.splatEncoding.lodOpacity) {\\n        return { lodSplats: result };\\n      }\\n      return result;\\n    }\\n    const decoder = decode_to_gsplatarray(fileType, pathName ?? url);\\n    const decoded = await decodeBytesUrl({\\n      decoder,\\n      fileBytes,\\n      url,\\n      // baseUri,\\n      requestHeader,\\n      withCredentials,\\n      sendStatus\\n    });\\n    if (decoded.has_lod()) {\\n      return {\\n        lodSplats: toPackedResult(decoded.to_packedsplats_lod())\\n      };\\n    }\\n    if (nonLod) {\\n      const initialConvertStart = performance.now();\\n      const packed = decoded.to_packedsplats();\\n      performance.now() - initialConvertStart;\\n      sendStatus({ orig: toPackedResult(packed) });\\n    }\\n    const initialSplats = decoded.len();\\n    const base = Math.max(1.1, Math.min(2, lodBase ?? 1.5));\\n    const lodStart = performance.now();\\n    decoded.quick_lod(base);\\n    const lodDuration = performance.now() - lodStart;\\n    console.log(\\n      `Quick LoD: ${initialSplats} -> ${decoded.len()} (${lodDuration} ms)`\\n    );\\n    const convertStart = performance.now();\\n    const lodPacked = decoded.to_packedsplats_lod();\\n    const convertDuration = performance.now() - convertStart;\\n    console.log(`Convert to packedsplats in ${convertDuration} ms`);\\n    return { lodSplats: toPackedResult(lodPacked) };\\n  }\\n  async function quickLod({\\n    numSplats,\\n    packedArray,\\n    extra,\\n    lodBase\\n  }) {\\n    const base = Math.max(1.1, Math.min(2, lodBase ?? 1.5));\\n    const lodStart = performance.now();\\n    const decoded = quick_lod_packedsplats(numSplats, packedArray, extra, base);\\n    const lodDuration = performance.now() - lodStart;\\n    const result = toPackedResult(decoded);\\n    console.log(\\n      `Quick LoD: ${numSplats} -> ${result.numSplats} (${lodDuration} ms)`\\n    );\\n    return result;\\n  }\\n  function initLodTree({\\n    numSplats,\\n    lodTree\\n  }) {\\n    const { lodId, chunkToPage } = init_lod_tree(numSplats, lodTree);\\n    return { lodId, chunkToPage };\\n  }\\n  function disposeLodTree({ lodId }) {\\n    dispose_lod_tree(lodId);\\n  }\\n  function insertLodTrees({ ranges }) {\\n    console.log("insertLodTrees", ranges);\\n    const lodIds = new Uint32Array(ranges.map(({ lodId }) => lodId));\\n    const pageBases = new Uint32Array(ranges.map(({ pageBase }) => pageBase));\\n    const chunkBases = new Uint32Array(ranges.map(({ chunkBase }) => chunkBase));\\n    const counts = new Uint32Array(ranges.map(({ count }) => count));\\n    const lodTreeData = ranges.map(({ lodTreeData: lodTreeData2 }) => lodTreeData2);\\n    const lodIdToChunkToPages = insert_lod_trees(lodIds, pageBases, chunkBases, counts, lodTreeData);\\n    console.log("=> done insertLodTrees", lodIdToChunkToPages);\\n    return lodIdToChunkToPages;\\n  }\\n  function clearLodTrees({ ranges }) {\\n    const lodIds = new Uint32Array(ranges.map(({ lodId }) => lodId));\\n    const pageBases = new Uint32Array(ranges.map(({ pageBase }) => pageBase));\\n    const chunkBases = new Uint32Array(ranges.map(({ chunkBase }) => chunkBase));\\n    const counts = new Uint32Array(ranges.map(({ count }) => count));\\n    const lodIdToChunkToPages = clear_lod_trees(lodIds, pageBases, chunkBases, counts);\\n    return lodIdToChunkToPages;\\n  }\\n  function traverseLodTrees({\\n    maxSplats,\\n    pixelScaleLimit,\\n    fovXdegrees,\\n    fovYdegrees,\\n    instances\\n  }) {\\n    const keyInstances = Object.entries(instances);\\n    const lodIds = new Uint32Array(\\n      keyInstances.map(([_key, instance]) => instance.lodId)\\n    );\\n    const viewToObjects = new Float32Array(\\n      keyInstances.flatMap(([_key, instance]) => {\\n        if (instance.viewToObjectCols.length !== 16) {\\n          throw new Error("Incorrect array size for viewToObjectCols");\\n        }\\n        return instance.viewToObjectCols;\\n      })\\n    );\\n    const lodScales = new Float32Array(\\n      keyInstances.map(([_key, instance]) => instance.lodScale)\\n    );\\n    const outsideFoveates = new Float32Array(\\n      keyInstances.map(([_key, instance]) => instance.outsideFoveate)\\n    );\\n    const behindFoveates = new Float32Array(\\n      keyInstances.map(([_key, instance]) => instance.behindFoveate)\\n    );\\n    const { instanceIndices, chunks } = traverse_lod_trees(\\n      maxSplats,\\n      pixelScaleLimit,\\n      fovXdegrees,\\n      fovYdegrees,\\n      lodIds,\\n      viewToObjects,\\n      lodScales,\\n      outsideFoveates,\\n      behindFoveates\\n    );\\n    const indices = keyInstances.reduce(\\n      (indices2, [key, _instance], index) => {\\n        indices2[key] = instanceIndices[index];\\n        return indices2;\\n      },\\n      {}\\n    );\\n    return {\\n      keyIndices: indices,\\n      // chunks: chunks.map(([instIndex, chunk]) => [keyInstances[instIndex][0], chunk]),\\n      chunks\\n    };\\n  }\\n  function getArrayBuffers(ctx) {\\n    const buffers = [];\\n    const seen = /* @__PURE__ */ new Set();\\n    function traverse(obj) {\\n      if (obj && typeof obj === "object" && !seen.has(obj)) {\\n        seen.add(obj);\\n        if (obj instanceof ArrayBuffer) {\\n          buffers.push(obj);\\n        } else if (ArrayBuffer.isView(obj)) {\\n          buffers.push(obj.buffer);\\n        } else if (Array.isArray(obj)) {\\n          obj.forEach(traverse);\\n        } else {\\n          Object.values(obj).forEach(traverse);\\n        }\\n      }\\n    }\\n    traverse(ctx);\\n    return buffers;\\n  }\\n  async function initialize() {\\n    const pending = [];\\n    const bufferMessage = (event) => {\\n      pending.push(event);\\n    };\\n    self.addEventListener("message", bufferMessage);\\n    await __wbg_init();\\n    self.removeEventListener("message", bufferMessage);\\n    self.addEventListener("message", onMessage);\\n    for (const event of pending) {\\n      onMessage(event);\\n    }\\n    pending.length = 0;\\n  }\\n  initialize().catch(console.error);\\n})();\\n//# sourceMappingURL=newWorker-kJP9WzNa.js.map\\n\';\n  const blob = typeof self !== "undefined" && self.Blob && new Blob([jsContent], { type: "text/javascript;charset=utf-8" });\n  function WorkerWrapper(options) {\n    let objURL;\n    try {\n      objURL = blob && (self.URL || self.webkitURL).createObjectURL(blob);\n      if (!objURL) throw "";\n      const worker = new Worker(objURL, {\n        name: options == null ? void 0 : options.name\n      });\n      worker.addEventListener("error", () => {\n        (self.URL || self.webkitURL).revokeObjectURL(objURL);\n      });\n      return worker;\n    } catch (e) {\n      return new Worker(\n        "data:text/javascript;charset=utf-8," + encodeURIComponent(jsContent),\n        {\n          name: options == null ? void 0 : options.name\n        }\n      );\n    } finally {\n      objURL && (self.URL || self.webkitURL).revokeObjectURL(objURL);\n    }\n  }\n  const _NewSplatWorker = class _NewSplatWorker {\n    constructor() {\n      this.queue = null;\n      this.messages = {};\n      this.worker = new WorkerWrapper();\n      this.worker.onmessage = (event) => this.onMessage(event);\n    }\n    onMessage(event) {\n      var _a2;\n      const { id, result, error, status } = event.data;\n      const promise = this.messages[id];\n      if (promise) {\n        if (error !== void 0) {\n          delete this.messages[id];\n          promise.reject(error);\n        } else if (status !== void 0) {\n          (_a2 = promise.onStatus) == null ? void 0 : _a2.call(promise, status);\n        } else {\n          delete this.messages[id];\n          promise.resolve(result);\n        }\n      }\n    }\n    tryExclusive(callback) {\n      return this.queue == null ? this.exclusive(callback) : null;\n    }\n    async exclusive(callback) {\n      const queue = this.queue;\n      if (queue != null) {\n        await new Promise((resolve) => {\n          queue.push(() => resolve(void 0));\n        });\n      } else {\n        this.queue = [];\n      }\n      try {\n        return await callback(this);\n      } finally {\n        if (this.queue != null) {\n          if (this.queue.length === 0) {\n            this.queue = null;\n          } else {\n            const waiter = this.queue.shift();\n            waiter();\n          }\n        }\n      }\n    }\n    async call(name, args, options = {}) {\n      const id = ++_NewSplatWorker.currentId;\n      const promise = new Promise((resolve, reject) => {\n        this.messages[id] = { resolve, reject, onStatus: options.onStatus };\n      });\n      this.worker.postMessage(\n        { id, name, args },\n        { transfer: getArrayBuffers(args) }\n      );\n      return await promise;\n    }\n  };\n  _NewSplatWorker.currentId = 0;\n  let NewSplatWorker = _NewSplatWorker;\n  class NewSplatWorkerPool {\n    constructor(maxWorkers = 4) {\n      this.numWorkers = 0;\n      this.freelist = [];\n      this.queue = [];\n      this.maxWorkers = maxWorkers;\n    }\n    async withWorker(callback) {\n      const worker = await this.allocWorker();\n      try {\n        return await callback(worker);\n      } finally {\n        this.freeWorker(worker);\n      }\n    }\n    async allocWorker() {\n      const worker = this.freelist.pop();\n      if (worker) {\n        return worker;\n      }\n      if (this.numWorkers < this.maxWorkers) {\n        const worker2 = new NewSplatWorker();\n        this.numWorkers += 1;\n        return worker2;\n      }\n      return new Promise((resolve) => {\n        this.queue.push(resolve);\n      });\n    }\n    freeWorker(worker) {\n      if (this.numWorkers > this.maxWorkers) {\n        this.numWorkers -= 1;\n        return;\n      }\n      const waiter = this.queue.shift();\n      if (waiter) {\n        waiter(worker);\n        return;\n      }\n      this.freelist.push(worker);\n    }\n  }\n  const workerPool = new NewSplatWorkerPool();\n  const _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n  class FullscreenTriangleGeometry extends BufferGeometry {\n    constructor() {\n      super();\n      this.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));\n      this.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));\n    }\n  }\n  const _geometry = new FullscreenTriangleGeometry();\n  class FullScreenQuad {\n    /**\n     * Constructs a new full screen quad.\n     *\n     * @param {?Material} material - The material to render te full screen quad with.\n     */\n    constructor(material) {\n      this._mesh = new Mesh(_geometry, material);\n    }\n    /**\n     * Frees the GPU-related resources allocated by this instance. Call this\n     * method whenever the instance is no longer used in your app.\n     */\n    dispose() {\n      this._mesh.geometry.dispose();\n    }\n    /**\n     * Renders the full screen quad.\n     *\n     * @param {WebGLRenderer} renderer - The renderer.\n     */\n    render(renderer) {\n      renderer.render(this._mesh, _camera);\n    }\n    /**\n     * The quad\'s material.\n     *\n     * @type {?Material}\n     */\n    get material() {\n      return this._mesh.material;\n    }\n    set material(value) {\n      this._mesh.material = value;\n    }\n  }\n  const Gsplat = { type: "Gsplat" };\n  const TPackedSplats = { type: "PackedSplats" };\n  const readPackedSplat = (packedSplats, index) => new ReadPackedSplat({ packedSplats, index });\n  const readPackedSplatRange = (packedSplats, index, base, count) => new ReadPackedSplatRange({ packedSplats, index, base, count });\n  const splitGsplat = (gsplat) => new SplitGsplat({ gsplat });\n  const combineGsplat = ({\n    gsplat,\n    flags,\n    index,\n    center,\n    scales,\n    quaternion,\n    rgba,\n    rgb,\n    opacity,\n    x: x2,\n    y,\n    z,\n    r,\n    g,\n    b\n  }) => {\n    return new CombineGsplat({\n      gsplat,\n      flags,\n      index,\n      center,\n      scales,\n      quaternion,\n      rgba,\n      rgb,\n      opacity,\n      x: x2,\n      y,\n      z,\n      r,\n      g,\n      b\n    });\n  };\n  const transformGsplat = (gsplat, {\n    scale,\n    rotate,\n    translate,\n    recolor\n  }) => {\n    return new TransformGsplat({ gsplat, scale, rotate, translate, recolor });\n  };\n  const defineGsplat = unindent(`\n  struct Gsplat {\n    vec3 center;\n    uint flags;\n    vec3 scales;\n    int index;\n    vec4 quaternion;\n    vec4 rgba;\n  };\n  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;\n\n  bool isGsplatActive(uint flags) {\n    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;\n  }\n`);\n  const definePackedSplats = unindent(`\n  struct PackedSplats {\n    usampler2DArray textureArray;\n    usampler2D texture;\n    int numSplats;\n    vec4 rgbMinMaxLnScaleMinMax;\n    int flagsFlatLodOpacity;\n  };\n`);\n  const defineReadPackedArray = unindent(`\n  bool readPackedArray(usampler2DArray texture, int numSplats, vec4 rgbMinMaxLnScaleMinMax, int index, out Gsplat gsplat) {\n    if ((index >= 0) && (index < numSplats)) {\n      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);\n      unpackSplatEncoding(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba, rgbMinMaxLnScaleMinMax);\n      return true;\n    } else {\n      return false;\n    }\n  }\n`);\n  const defineReadPackedFlat = unindent(`\n  bool readPackedFlat(usampler2D texture, int numSplats, vec4 rgbMinMaxLnScaleMinMax, int index, out Gsplat gsplat) {\n    if ((index >= 0) && (index < numSplats)) {\n      ivec2 coord = ivec2(index & 4095, index >> 12);\n      uvec4 packed = texelFetch(texture, coord, 0);\n      unpackSplatEncoding(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba, rgbMinMaxLnScaleMinMax);\n      return true;\n    } else {\n      return false;\n    }\n  }\n`);\n  class ReadPackedSplat extends Dyno {\n    constructor({\n      packedSplats,\n      index\n    }) {\n      super({\n        inTypes: { packedSplats: TPackedSplats, index: "int" },\n        outTypes: { gsplat: Gsplat },\n        inputs: { packedSplats, index },\n        globals: () => [defineGsplat, definePackedSplats, defineReadPackedArray, defineReadPackedFlat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat } = outputs;\n          if (!gsplat) {\n            return [];\n          }\n          const { packedSplats: packedSplats2, index: index2 } = inputs;\n          let statements;\n          if (packedSplats2 && index2) {\n            statements = unindentLines(`\n            ${gsplat}.flags = 0u;\n            if ((${packedSplats2}.flagsFlatLodOpacity & 0x1) != 0) {\n              if (readPackedFlat(${packedSplats2}.texture, ${packedSplats2}.numSplats, ${packedSplats2}.rgbMinMaxLnScaleMinMax, ${index2}, ${gsplat})) {\n                if ((${packedSplats2}.flagsFlatLodOpacity & 0x2) != 0) {\n                  ${gsplat}.rgba.a = 2.0 * ${gsplat}.rgba.a;\n                }\n                bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\n                ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n              }\n            } else {\n              if (readPackedArray(${packedSplats2}.textureArray, ${packedSplats2}.numSplats, ${packedSplats2}.rgbMinMaxLnScaleMinMax, ${index2}, ${gsplat})) {\n                if ((${packedSplats2}.flagsFlatLodOpacity & 0x2) != 0) {\n                  ${gsplat}.rgba.a = 2.0 * ${gsplat}.rgba.a;\n                }\n                bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\n                ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n              }\n            }\n          `);\n          } else {\n            statements = [`${gsplat}.flags = 0u;`];\n          }\n          statements.push(`${gsplat}.index = ${index2 ?? "0"};`);\n          return statements;\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "gsplat");\n    }\n  }\n  class ReadPackedSplatRange extends Dyno {\n    constructor({\n      packedSplats,\n      index,\n      base,\n      count\n    }) {\n      super({\n        inTypes: {\n          packedSplats: TPackedSplats,\n          index: "int",\n          base: "int",\n          count: "int"\n        },\n        outTypes: { gsplat: Gsplat },\n        inputs: { packedSplats, index, base, count },\n        globals: () => [defineGsplat, definePackedSplats, defineReadPackedArray, defineReadPackedFlat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat } = outputs;\n          if (!gsplat) {\n            return [];\n          }\n          const { packedSplats: packedSplats2, index: index2, base: base2, count: count2 } = inputs;\n          let statements;\n          if (packedSplats2 && index2 && base2 && count2) {\n            statements = unindentLines(`\n            ${gsplat}.flags = 0u;\n            if ((${packedSplats2}.flagsFlatLodOpacity & 0x1) != 0) {\n              if (readPackedFlat(${packedSplats2}.texture, ${packedSplats2}.numSplats, ${packedSplats2}.rgbMinMaxLnScaleMinMax, ${index2}, ${gsplat})) {\n                if ((${packedSplats2}.flagsFlatLodOpacity & 0x2) != 0) {\n                  ${gsplat}.rgba.a = 2.0 * ${gsplat}.rgba.a;\n                }\n                bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\n                ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n              }\n            } else {\n              if (readPackedArray(${packedSplats2}.textureArray, ${packedSplats2}.numSplats, ${packedSplats2}.rgbMinMaxLnScaleMinMax, ${index2}, ${gsplat})) {\n                if ((${packedSplats2}.flagsFlatLodOpacity & 0x2) != 0) {\n                  ${gsplat}.rgba.a = 2.0 * ${gsplat}.rgba.a;\n                }\n                bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\n                ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n              }\n            }\n          `);\n          } else {\n            statements = [`${gsplat}.flags = 0u;`];\n          }\n          statements.push(`${gsplat}.index = ${index2 ?? "0"};`);\n          return statements;\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "gsplat");\n    }\n  }\n  class SplitGsplat extends Dyno {\n    constructor({ gsplat }) {\n      super({\n        inTypes: { gsplat: Gsplat },\n        outTypes: {\n          flags: "uint",\n          active: "bool",\n          index: "int",\n          center: "vec3",\n          scales: "vec3",\n          quaternion: "vec4",\n          rgba: "vec4",\n          rgb: "vec3",\n          opacity: "float",\n          x: "float",\n          y: "float",\n          z: "float",\n          r: "float",\n          g: "float",\n          b: "float"\n        },\n        inputs: { gsplat },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat: gsplat2 } = inputs;\n          const {\n            flags,\n            active,\n            index,\n            center,\n            scales,\n            quaternion,\n            rgba,\n            rgb,\n            opacity,\n            x: x2,\n            y,\n            z,\n            r,\n            g,\n            b\n          } = outputs;\n          return [\n            !flags ? null : `${flags} = ${gsplat2 ? `${gsplat2}.flags` : "0u"};`,\n            !active ? null : `${active} = isGsplatActive(${gsplat2 ? `${gsplat2}.flags` : "0u"});`,\n            !index ? null : `${index} = ${gsplat2 ? `${gsplat2}.index` : "0"};`,\n            !center ? null : `${center} = ${gsplat2 ? `${gsplat2}.center` : "vec3(0.0, 0.0, 0.0)"};`,\n            !scales ? null : `${scales} = ${gsplat2 ? `${gsplat2}.scales` : "vec3(0.0, 0.0, 0.0)"};`,\n            !quaternion ? null : `${quaternion} = ${gsplat2 ? `${gsplat2}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)"};`,\n            !rgba ? null : `${rgba} = ${gsplat2 ? `${gsplat2}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)"};`,\n            !rgb ? null : `${rgb} = ${gsplat2 ? `${gsplat2}.rgba.rgb` : "vec3(0.0, 0.0, 0.0)"};`,\n            !opacity ? null : `${opacity} = ${gsplat2 ? `${gsplat2}.rgba.a` : "0.0"};`,\n            !x2 ? null : `${x2} = ${gsplat2 ? `${gsplat2}.center.x` : "0.0"};`,\n            !y ? null : `${y} = ${gsplat2 ? `${gsplat2}.center.y` : "0.0"};`,\n            !z ? null : `${z} = ${gsplat2 ? `${gsplat2}.center.z` : "0.0"};`,\n            !r ? null : `${r} = ${gsplat2 ? `${gsplat2}.rgba.r` : "0.0"};`,\n            !g ? null : `${g} = ${gsplat2 ? `${gsplat2}.rgba.g` : "0.0"};`,\n            !b ? null : `${b} = ${gsplat2 ? `${gsplat2}.rgba.b` : "0.0"};`\n          ].filter(Boolean);\n        }\n      });\n    }\n  }\n  class CombineGsplat extends Dyno {\n    constructor({\n      gsplat,\n      flags,\n      index,\n      center,\n      scales,\n      quaternion,\n      rgba,\n      rgb,\n      opacity,\n      x: x2,\n      y,\n      z,\n      r,\n      g,\n      b\n    }) {\n      super({\n        inTypes: {\n          gsplat: Gsplat,\n          flags: "uint",\n          index: "int",\n          center: "vec3",\n          scales: "vec3",\n          quaternion: "vec4",\n          rgba: "vec4",\n          rgb: "vec3",\n          opacity: "float",\n          x: "float",\n          y: "float",\n          z: "float",\n          r: "float",\n          g: "float",\n          b: "float"\n        },\n        outTypes: { gsplat: Gsplat },\n        inputs: {\n          gsplat,\n          flags,\n          index,\n          center,\n          scales,\n          quaternion,\n          rgba,\n          rgb,\n          opacity,\n          x: x2,\n          y,\n          z,\n          r,\n          g,\n          b\n        },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat: outGsplat } = outputs;\n          if (!outGsplat) {\n            return [];\n          }\n          const {\n            gsplat: gsplat2,\n            flags: flags2,\n            index: index2,\n            center: center2,\n            scales: scales2,\n            quaternion: quaternion2,\n            rgba: rgba2,\n            rgb: rgb2,\n            opacity: opacity2,\n            x: x22,\n            y: y2,\n            z: z2,\n            r: r2,\n            g: g2,\n            b: b22\n          } = inputs;\n          return [\n            `${outGsplat}.flags = ${flags2 ?? (gsplat2 ? `${gsplat2}.flags` : "0u")};`,\n            `${outGsplat}.index = ${index2 ?? (gsplat2 ? `${gsplat2}.index` : "0")};`,\n            `${outGsplat}.center = ${center2 ?? (gsplat2 ? `${gsplat2}.center` : "vec3(0.0, 0.0, 0.0)")};`,\n            `${outGsplat}.scales = ${scales2 ?? (gsplat2 ? `${gsplat2}.scales` : "vec3(0.0, 0.0, 0.0)")};`,\n            `${outGsplat}.quaternion = ${quaternion2 ?? (gsplat2 ? `${gsplat2}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)")};`,\n            `${outGsplat}.rgba = ${rgba2 ?? (gsplat2 ? `${gsplat2}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)")};`,\n            !rgb2 ? null : `${outGsplat}.rgba.rgb = ${rgb2};`,\n            !opacity2 ? null : `${outGsplat}.rgba.a = ${opacity2};`,\n            !x22 ? null : `${outGsplat}.center.x = ${x22};`,\n            !y2 ? null : `${outGsplat}.center.y = ${y2};`,\n            !z2 ? null : `${outGsplat}.center.z = ${z2};`,\n            !r2 ? null : `${outGsplat}.rgba.r = ${r2};`,\n            !g2 ? null : `${outGsplat}.rgba.g = ${g2};`,\n            !b22 ? null : `${outGsplat}.rgba.b = ${b22};`\n          ].filter(Boolean);\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "gsplat");\n    }\n  }\n  unindent(`\n  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {\n    float minScale = min(scales.x, min(scales.y, scales.z));\n    vec3 normal;\n    if (scales.z == minScale) {\n      normal = vec3(0.0, 0.0, 1.0);\n    } else if (scales.y == minScale) {\n      normal = vec3(0.0, 1.0, 0.0);\n    } else {\n      normal = vec3(1.0, 0.0, 0.0);\n    }\n    return quatVec(quaternion, normal);\n  }\n`);\n  class TransformGsplat extends Dyno {\n    constructor({\n      gsplat,\n      scale,\n      rotate,\n      translate,\n      recolor\n    }) {\n      super({\n        inTypes: {\n          gsplat: Gsplat,\n          scale: "float",\n          rotate: "vec4",\n          translate: "vec3",\n          recolor: "vec4"\n        },\n        outTypes: { gsplat: Gsplat },\n        inputs: { gsplat, scale, rotate, translate, recolor },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs, compile }) => {\n          const { gsplat: gsplat2 } = outputs;\n          if (!gsplat2 || !inputs.gsplat) {\n            return [];\n          }\n          const { scale: scale2, rotate: rotate2, translate: translate2, recolor: recolor2 } = inputs;\n          const indent = compile.indent;\n          const statements = [\n            `${gsplat2} = ${inputs.gsplat};`,\n            `if (isGsplatActive(${gsplat2}.flags)) {`,\n            scale2 ? `${indent}${gsplat2}.center *= ${scale2};` : null,\n            rotate2 ? `${indent}${gsplat2}.center = quatVec(${rotate2}, ${gsplat2}.center);` : null,\n            translate2 ? `${indent}${gsplat2}.center += ${translate2};` : null,\n            scale2 ? `${indent}${gsplat2}.scales *= ${scale2};` : null,\n            rotate2 ? `${indent}${gsplat2}.quaternion = quatQuat(${rotate2}, ${gsplat2}.quaternion);` : null,\n            recolor2 ? `${indent}${gsplat2}.rgba *= ${recolor2};` : null,\n            "}"\n          ].filter(Boolean);\n          return statements;\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "gsplat");\n    }\n  }\n  const outputPackedSplat = (gsplat, rgbMinMaxLnScaleMinMax) => new OutputPackedSplat({ gsplat, rgbMinMaxLnScaleMinMax });\n  class OutputPackedSplat extends Dyno {\n    constructor({\n      gsplat,\n      rgbMinMaxLnScaleMinMax\n    }) {\n      super({\n        inTypes: { gsplat: Gsplat, rgbMinMaxLnScaleMinMax: "vec4" },\n        inputs: { gsplat, rgbMinMaxLnScaleMinMax },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs }) => {\n          const { output } = outputs;\n          if (!output) {\n            return [];\n          }\n          const { gsplat: gsplat2, rgbMinMaxLnScaleMinMax: rgbMinMaxLnScaleMinMax2 } = inputs;\n          if (gsplat2) {\n            return unindentLines(`\n            if (isGsplatActive(${gsplat2}.flags)) {\n              ${output} = packSplatEncoding(${gsplat2}.center, ${gsplat2}.scales, ${gsplat2}.quaternion, ${gsplat2}.rgba, ${rgbMinMaxLnScaleMinMax2});\n            } else {\n              ${output} = uvec4(0u, 0u, 0u, 0u);\n            }\n          `);\n          }\n          return [`${output} = uvec4(0u, 0u, 0u, 0u);`];\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "output");\n    }\n  }\n  class OutputRgba8 extends Dyno {\n    constructor({ rgba8 }) {\n      super({\n        inTypes: { rgba8: "vec4" },\n        inputs: { rgba8 },\n        statements: ({ inputs, outputs }) => [\n          `target = ${inputs.rgba8 ?? "vec4(0.0, 0.0, 0.0, 0.0)"};`\n        ]\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, "rgba8");\n    }\n  }\n  class DynoUniform extends Dyno {\n    constructor({\n      key,\n      type,\n      count,\n      value,\n      update,\n      globals\n    }) {\n      key = key ?? "value";\n      super({\n        outTypes: { [key]: type },\n        update: () => {\n          if (update) {\n            const value2 = update(this.value);\n            if (value2 !== void 0) {\n              this.value = value2;\n            }\n          }\n          this.uniform.value = this.value;\n        },\n        generate: ({ inputs, outputs }) => {\n          const allGlobals = (globals == null ? void 0 : globals({ inputs, outputs })) ?? [];\n          const uniforms = {};\n          const name = outputs[key];\n          if (name) {\n            allGlobals.push(`uniform ${dynoDeclare(name, type, count)};`);\n            uniforms[name] = this.uniform;\n          }\n          return { globals: allGlobals, uniforms };\n        }\n      });\n      this.type = type;\n      this.count = count;\n      this.value = value;\n      this.uniform = { value };\n      this.outKey = key;\n    }\n    dynoOut() {\n      return new DynoOutput(this, this.outKey);\n    }\n  }\n  class DynoBool extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "bool", value, update });\n    }\n  }\n  class DynoInt extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "int", value, update });\n    }\n  }\n  class DynoFloat extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "float", value, update });\n    }\n  }\n  class DynoVec2 extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "vec2", value, update });\n    }\n  }\n  class DynoVec3 extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "vec3", value, update });\n    }\n  }\n  class DynoVec4 extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "vec4", value, update });\n    }\n  }\n  class DynoUsampler2D extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "usampler2D", value, update });\n    }\n  }\n  class DynoUsampler2DArray extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: "usampler2DArray", value, update });\n    }\n  }\n  class DynoProgram {\n    constructor({\n      graph,\n      inputs,\n      outputs,\n      template\n    }) {\n      this.graph = graph;\n      this.template = template;\n      this.inputs = inputs ?? {};\n      this.outputs = outputs ?? {};\n      const compile = new Compilation({ indent: this.template.indent });\n      for (const key in this.outputs) {\n        if (this.outputs[key]) {\n          compile.declares.add(this.outputs[key]);\n        }\n      }\n      const statements = graph.compile({\n        inputs: this.inputs,\n        outputs: this.outputs,\n        compile\n      });\n      this.shader = template.generate({ globals: compile.globals, statements });\n      this.uniforms = compile.uniforms;\n      this.updaters = compile.updaters;\n    }\n    prepareMaterial() {\n      return getMaterial(this);\n    }\n    update() {\n      for (const updater of this.updaters) {\n        updater();\n      }\n    }\n  }\n  class DynoProgramTemplate {\n    constructor(template) {\n      const globals = template.match(/^([ \\t]*)\\{\\{\\s*GLOBALS\\s*\\}\\}/m);\n      const statements = template.match(/^([ \\t]*)\\{\\{\\s*STATEMENTS\\s*\\}\\}/m);\n      if (!globals || !statements) {\n        throw new Error(\n          "Template must contain {{ GLOBALS }} and {{ STATEMENTS }}"\n        );\n      }\n      this.before = template.substring(0, globals.index);\n      this.between = template.substring(\n        globals.index + globals[0].length,\n        statements.index\n      );\n      this.after = template.substring(\n        statements.index + statements[0].length\n      );\n      this.indent = statements[1];\n    }\n    generate({\n      globals,\n      statements\n    }) {\n      return this.before + Array.from(globals).join("\\n\\n") + this.between + statements.map((s) => this.indent + s).join("\\n") + this.after;\n    }\n  }\n  const programMaterial = /* @__PURE__ */ new Map();\n  function getMaterial(program) {\n    let material = programMaterial.get(program);\n    if (material) {\n      return material;\n    }\n    material = new RawShaderMaterial({\n      glslVersion: GLSL3,\n      vertexShader: IDENT_VERTEX_SHADER,\n      fragmentShader: program.shader,\n      uniforms: program.uniforms\n    });\n    programMaterial.set(program, material);\n    return material;\n  }\n  function addOutputType(a, b, operation = "add") {\n    const error = () => {\n      throw new Error(`Invalid ${operation} types: ${a}, ${b}`);\n    };\n    if (a === b) return a;\n    if (a === "int") {\n      if (isIntType(b)) return b;\n      error();\n    }\n    if (b === "int") {\n      if (isIntType(a)) return a;\n      error();\n    }\n    if (a === "uint") {\n      if (isUintType(b)) return b;\n      error();\n    }\n    if (b === "uint") {\n      if (isUintType(a)) return a;\n      error();\n    }\n    if (a === "float") {\n      if (isAllFloatType(b)) return b;\n      error();\n    }\n    if (b === "float") {\n      if (isAllFloatType(a)) return a;\n      error();\n    }\n    throw new Error(`Invalid ${operation} types: ${a}, ${b}`);\n  }\n  function subOutputType(a, b) {\n    return addOutputType(a, b, "sub");\n  }\n  function mulOutputType(a, b) {\n    const error = () => {\n      throw new Error(`Invalid mul types: ${a}, ${b}`);\n    };\n    const result = (value) => value;\n    if (a === "int") {\n      if (isIntType(b)) return result(b);\n      error();\n    }\n    if (b === "int") {\n      if (isIntType(a)) return result(a);\n      error();\n    }\n    if (a === "uint") {\n      if (isUintType(b)) return result(b);\n      error();\n    }\n    if (b === "uint") {\n      if (isUintType(a)) return result(a);\n      error();\n    }\n    if (a === "float") {\n      if (isAllFloatType(b)) return result(b);\n      error();\n    }\n    if (b === "float") {\n      if (isAllFloatType(a)) return result(a);\n      error();\n    }\n    if (isIntType(a) || isUintType(a) || isIntType(b) || isUintType(b)) {\n      if (a === b) return result(a);\n      error();\n    }\n    if (a === "vec2") {\n      if (b === "vec2" || isMat2(b)) return result("vec2");\n      if (b === "mat3x2") return result("vec3");\n      if (b === "mat4x2") return result("vec4");\n      error();\n    }\n    if (a === "vec3") {\n      if (b === "mat2x3") return result("vec2");\n      if (b === "vec3" || isMat3(b)) return result("vec3");\n      if (b === "mat4x3") return result("vec4");\n      error();\n    }\n    if (a === "vec4") {\n      if (b === "mat2x4") return result("vec2");\n      if (b === "mat3x4") return result("vec3");\n      if (b === "vec4" || isMat4(b)) return result("vec4");\n      error();\n    }\n    if (b === "vec2") {\n      if (isMat2(a)) return result("vec2");\n      if (a === "mat2x3") return result("vec3");\n      if (a === "mat2x4") return result("vec4");\n      error();\n    }\n    if (b === "vec3") {\n      if (a === "mat3x2") return result("vec2");\n      if (isMat3(a)) return result("vec3");\n      if (a === "mat3x4") return result("vec4");\n      error();\n    }\n    if (b === "vec4") {\n      if (a === "mat4x2") return result("vec2");\n      if (a === "mat4x3") return result("vec3");\n      if (isMat4(a)) return result("vec4");\n      error();\n    }\n    if (isMat2(a)) {\n      if (isMat2(b)) return result("mat2");\n      if (b === "mat3x2") return result("mat3x2");\n      if (b === "mat4x2") return result("mat4x2");\n      error();\n    }\n    if (a === "mat2x3") {\n      if (isMat2(b)) return result("mat2x3");\n      if (b === "mat3x2") return result("mat3");\n      if (b === "mat4x2") return result("mat4x3");\n      error();\n    }\n    if (a === "mat2x4") {\n      if (isMat2(b)) return result("mat2x4");\n      if (b === "mat3x2") return result("mat3x4");\n      if (b === "mat4x2") return result("mat4");\n      error();\n    }\n    if (a === "mat3x2") {\n      if (b === "mat2x3") return result("mat2");\n      if (isMat3(b)) return result("mat3x2");\n      if (b === "mat4x3") return result("mat4x2");\n      error();\n    }\n    if (isMat3(a)) {\n      if (b === "mat2x3") return result("mat2x3");\n      if (isMat3(b)) return result("mat3");\n      if (b === "mat4x3") return result("mat4x3");\n      error();\n    }\n    if (a === "mat3x4") {\n      if (b === "mat2x3") return result("mat2x4");\n      if (isMat3(b)) return result("mat3x4");\n      if (b === "mat4x3") return result("mat4");\n      error();\n    }\n    if (a === "mat4x2") {\n      if (b === "mat2x4") return result("mat2");\n      if (b === "mat3x4") return result("mat3x2");\n      if (isMat4(b)) return result("mat4x2");\n      error();\n    }\n    if (a === "mat4x3") {\n      if (b === "mat2x4") return result("mat2x3");\n      if (b === "mat3x4") return result("mat3");\n      if (isMat4(b)) return result("mat4x3");\n      error();\n    }\n    if (isMat4(a)) {\n      if (b === "mat2x4") return result("mat2x4");\n      if (b === "mat3x4") return result("mat3x4");\n      if (isMat4(b)) return result("mat4");\n      error();\n    }\n    throw new Error(`Invalid mul types: ${a}, ${b}`);\n  }\n  const add = (a, b) => new Add({ a, b });\n  const sub = (a, b) => new Sub({ a, b });\n  const mul = (a, b) => new Mul({ a, b });\n  class Add extends BinaryOp {\n    constructor({ a, b }) {\n      super({ a, b, outKey: "sum", outTypeFunc: addOutputType });\n      this.statements = ({ inputs, outputs }) => {\n        return [`${outputs.sum} = ${inputs.a} + ${inputs.b};`];\n      };\n    }\n  }\n  class Sub extends BinaryOp {\n    constructor({ a, b }) {\n      super({ a, b, outKey: "difference", outTypeFunc: subOutputType });\n      this.statements = ({ inputs, outputs }) => {\n        return [`${outputs.difference} = ${inputs.a} - ${inputs.b};`];\n      };\n    }\n  }\n  class Mul extends BinaryOp {\n    constructor({ a, b }) {\n      super({ a, b, outKey: "product", outTypeFunc: mulOutputType });\n      this.statements = ({ inputs, outputs }) => {\n        return [`${outputs.product} = ${inputs.a} * ${inputs.b};`];\n      };\n    }\n  }\n  const normalize = (a) => new Normalize({ a });\n  const split = (vector) => new Split({ vector });\n  const extendVec = (a, b) => new ExtendVec({ a, b });\n  class Normalize extends UnaryOp {\n    constructor({ a }) {\n      super({ a, outTypeFunc: (aType) => aType, outKey: "normalize" });\n      this.statements = ({ inputs, outputs }) => [\n        `${outputs.normalize} = normalize(${inputs.a});`\n      ];\n    }\n  }\n  function extendVecOutputType(type) {\n    if (type === "float") return "vec2";\n    if (type === "vec2") return "vec3";\n    if (type === "vec3") return "vec4";\n    throw new Error("Invalid type");\n  }\n  class ExtendVec extends BinaryOp {\n    constructor({ a, b }) {\n      const type = valType(a);\n      const outType = extendVecOutputType(type);\n      super({ a, b, outKey: "extend", outTypeFunc: () => outType });\n      this.statements = ({ inputs, outputs }) => [\n        `${outputs.extend} = ${outType}(${inputs.a}, ${inputs.b});`\n      ];\n    }\n  }\n  function splitOutTypes(type) {\n    const result = (value) => value;\n    switch (type) {\n      case "vec2":\n        return result({ x: "float", y: "float", r: "float", g: "float" });\n      case "vec3":\n        return result({\n          x: "float",\n          y: "float",\n          z: "float",\n          r: "float",\n          g: "float",\n          b: "float"\n        });\n      case "vec4":\n        return result({\n          x: "float",\n          y: "float",\n          z: "float",\n          w: "float",\n          r: "float",\n          g: "float",\n          b: "float",\n          a: "float"\n        });\n      case "ivec2":\n        return result({ x: "int", y: "int", r: "int", g: "int" });\n      case "ivec3":\n        return result({\n          x: "int",\n          y: "int",\n          z: "int",\n          r: "int",\n          g: "int",\n          b: "int"\n        });\n      case "ivec4":\n        return result({\n          x: "int",\n          y: "int",\n          z: "int",\n          w: "int",\n          r: "int",\n          g: "int",\n          b: "int",\n          a: "int"\n        });\n      case "uvec2":\n        return result({ x: "uint", y: "uint", r: "uint", g: "uint" });\n      case "uvec3":\n        return result({\n          x: "uint",\n          y: "uint",\n          z: "uint",\n          r: "uint",\n          g: "uint",\n          b: "uint"\n        });\n      case "uvec4":\n        return result({\n          x: "uint",\n          y: "uint",\n          z: "uint",\n          w: "uint",\n          r: "uint",\n          g: "uint",\n          b: "uint",\n          a: "uint"\n        });\n      default:\n        throw new Error(`Invalid vector type: ${type}`);\n    }\n  }\n  class Split extends Dyno {\n    constructor({ vector }) {\n      const type = valType(vector);\n      const inTypes = { vector: type };\n      const outTypes = splitOutTypes(inTypes.vector);\n      super({ inTypes, outTypes, inputs: { vector } });\n      this.statements = ({ inputs, outputs }) => {\n        const { x: x2, y, z, w, r, g, b, a } = outputs;\n        const { vector: vector2 } = inputs;\n        return [\n          x2 ? `${x2} = ${vector2}.x;` : null,\n          y ? `${y} = ${vector2}.y;` : null,\n          z ? `${z} = ${vector2}.z;` : null,\n          w ? `${w} = ${vector2}.w;` : null,\n          r ? `${r} = ${vector2}.r;` : null,\n          g ? `${g} = ${vector2}.g;` : null,\n          b ? `${b} = ${vector2}.b;` : null,\n          a ? `${a} = ${vector2}.a;` : null\n        ].filter(Boolean);\n      };\n    }\n  }\n  const transformPos = (position, {\n    scale,\n    scales,\n    rotate,\n    translate\n  }) => {\n    return new TransformPosition({ position, scale, scales, rotate, translate }).outputs.position;\n  };\n  const transformDir = (dir, {\n    scale,\n    scales,\n    rotate\n  }) => {\n    return new TransformDir({ dir, scale, scales, rotate }).outputs.dir;\n  };\n  class TransformPosition extends Dyno {\n    constructor({\n      position,\n      scale,\n      scales,\n      rotate,\n      translate\n    }) {\n      super({\n        inTypes: {\n          position: "vec3",\n          scale: "float",\n          scales: "vec3",\n          rotate: "vec4",\n          translate: "vec3"\n        },\n        outTypes: { position: "vec3" },\n        inputs: { position, scale, scales, rotate, translate },\n        statements: ({ inputs, outputs }) => {\n          const { position: position2 } = outputs;\n          if (!position2) {\n            return [];\n          }\n          const { scale: scale2, scales: scales2, rotate: rotate2, translate: translate2 } = inputs;\n          return [\n            `${position2} = ${inputs.position ?? "vec3(0.0, 0.0, 0.0)"};`,\n            !scale2 ? null : `${position2} *= ${scale2};`,\n            !scales2 ? null : `${position2} *= ${scales2};`,\n            !rotate2 ? null : `${position2} = quatVec(${rotate2}, ${position2});`,\n            !translate2 ? null : `${position2} += ${translate2};`\n          ].filter(Boolean);\n        }\n      });\n    }\n  }\n  class TransformDir extends Dyno {\n    constructor({\n      dir,\n      scale,\n      scales,\n      rotate\n    }) {\n      super({\n        inTypes: { dir: "vec3", scale: "float", scales: "vec3", rotate: "vec4" },\n        outTypes: { dir: "vec3" },\n        inputs: { dir, scale, scales, rotate },\n        statements: ({ inputs, outputs }) => {\n          const { dir: dir2 } = outputs;\n          if (!dir2) {\n            return [];\n          }\n          const { scale: scale2, scales: scales2, rotate: rotate2 } = inputs;\n          return [\n            `${dir2} = ${inputs.dir ?? "vec3(0.0, 0.0, 0.0)"};`,\n            !scale2 ? null : `${dir2} *= ${scale2};`,\n            !scales2 ? null : `${dir2} *= ${scales2};`,\n            !rotate2 ? null : `${dir2} = quatVec(${rotate2}, ${dir2});`\n          ].filter(Boolean);\n        }\n      });\n    }\n  }\n  var computeUvec4_default = "precision highp float;\\nprecision highp int;\\nprecision highp sampler2D;\\nprecision highp usampler2D;\\nprecision highp isampler2D;\\nprecision highp sampler2DArray;\\nprecision highp usampler2DArray;\\nprecision highp isampler2DArray;\\nprecision highp sampler3D;\\nprecision highp usampler3D;\\nprecision highp isampler3D;\\n\\n#include <splatDefines>\\n\\nuniform uint targetLayer;\\nuniform int targetBase;\\nuniform int targetCount;\\n\\nout uvec4 target;\\n\\n{{ GLOBALS }}\\n\\nvoid produceSplat(int index) {\\n    {{ STATEMENTS }}\\n}\\n\\nvoid main() {\\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\\n    int index = targetIndex - targetBase;\\n\\n    target = uvec4(0u, 0u, 0u, 0u);\\n    if ((index >= 0) && (index < targetCount)) {\\n        produceSplat(index);\\n    }\\n}";\n  const DEFAULT_SPLAT_ENCODING = {\n    rgbMin: 0,\n    rgbMax: 1,\n    lnScaleMin: LN_SCALE_MIN,\n    lnScaleMax: LN_SCALE_MAX,\n    sh1Min: -1,\n    sh1Max: 1,\n    sh2Min: -1,\n    sh2Max: 1,\n    sh3Min: -1,\n    sh3Max: 1,\n    lodOpacity: false\n  };\n  const _PackedSplats = class _PackedSplats {\n    constructor(options = {}) {\n      this.maxSplats = 0;\n      this.numSplats = 0;\n      this.packedArray = null;\n      this.pageCache = null;\n      this.chunkToPage = /* @__PURE__ */ new Map();\n      this.pageFreelist = [];\n      this.pageMax = 0;\n      this.pageTop = 0;\n      this.isInitialized = false;\n      this.target = null;\n      this.source = null;\n      this.needsUpdate = true;\n      this.extra = {};\n      this.dyno = new DynoPackedSplats({ packedSplats: this });\n      this.dynoRgbMinMaxLnScaleMinMax = new DynoVec4({\n        key: "rgbMinMaxLnScaleMinMax",\n        value: new Vector4(0, 1, LN_SCALE_MIN, LN_SCALE_MAX),\n        update: (value) => {\n          var _a2, _b2, _c, _d;\n          value.set(\n            ((_a2 = this.splatEncoding) == null ? void 0 : _a2.rgbMin) ?? 0,\n            ((_b2 = this.splatEncoding) == null ? void 0 : _b2.rgbMax) ?? 1,\n            ((_c = this.splatEncoding) == null ? void 0 : _c.lnScaleMin) ?? LN_SCALE_MIN,\n            ((_d = this.splatEncoding) == null ? void 0 : _d.lnScaleMax) ?? LN_SCALE_MAX\n          );\n          return value;\n        }\n      });\n      this.dynoSh1MinMax = new DynoVec2({\n        key: "sh1MinMax",\n        value: new Vector2(-1, 1),\n        update: (value) => {\n          var _a2, _b2;\n          value.set(\n            ((_a2 = this.splatEncoding) == null ? void 0 : _a2.sh1Min) ?? -1,\n            ((_b2 = this.splatEncoding) == null ? void 0 : _b2.sh1Max) ?? 1\n          );\n          return value;\n        }\n      });\n      this.dynoSh2MinMax = new DynoVec2({\n        key: "sh2MinMax",\n        value: new Vector2(-1, 1),\n        update: (value) => {\n          var _a2, _b2;\n          value.set(\n            ((_a2 = this.splatEncoding) == null ? void 0 : _a2.sh2Min) ?? -1,\n            ((_b2 = this.splatEncoding) == null ? void 0 : _b2.sh2Max) ?? 1\n          );\n          return value;\n        }\n      });\n      this.dynoSh3MinMax = new DynoVec2({\n        key: "sh3MinMax",\n        value: new Vector2(-1, 1),\n        update: (value) => {\n          var _a2, _b2;\n          value.set(\n            ((_a2 = this.splatEncoding) == null ? void 0 : _a2.sh3Min) ?? -1,\n            ((_b2 = this.splatEncoding) == null ? void 0 : _b2.sh3Max) ?? 1\n          );\n          return value;\n        }\n      });\n      this.initialized = Promise.resolve(this);\n      this.reinitialize(options);\n    }\n    reinitialize(options) {\n      this.isInitialized = false;\n      this.extra = {};\n      this.splatEncoding = options.splatEncoding;\n      this.lod = options.lod;\n      this.nonLod = options.nonLod;\n      if (options.url || options.fileBytes || options.construct) {\n        this.initialized = this.asyncInitialize(options).then(() => {\n          this.isInitialized = true;\n          return this;\n        });\n      } else {\n        this.initialize(options);\n        this.isInitialized = true;\n        this.initialized = Promise.resolve(this);\n      }\n    }\n    initialize(options) {\n      this.extra = options.extra ?? {};\n      this.lodSplats = options.lodSplats;\n      this.paged = options.paged;\n      if (options.packedArray) {\n        this.packedArray = options.packedArray;\n        this.numSplats = options.numSplats ?? this.packedArray.length / 4;\n        if (options.paged) {\n          this.maxSplats = options.maxSplats ?? 16777216;\n          this.ensurePagedTexture();\n          const numPages = Math.ceil(this.numSplats / 65536);\n          for (let page = 0; page < numPages; ++page) {\n            this.chunkToPage.set(page, page);\n          }\n          this.pageMax = Math.ceil(this.maxSplats / 65536);\n          this.pageTop = numPages;\n        } else {\n          this.maxSplats = Math.floor(this.packedArray.length / 4);\n          this.maxSplats = Math.floor(this.maxSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n          this.numSplats = Math.min(\n            this.maxSplats,\n            options.numSplats ?? Number.POSITIVE_INFINITY\n          );\n        }\n      } else {\n        this.maxSplats = options.maxSplats ?? 0;\n        this.numSplats = 0;\n      }\n    }\n    async asyncInitialize(options) {\n      const { url, fileBytes, construct, lod, nonLod } = options;\n      this.lod = lod;\n      this.nonLod = nonLod;\n      const loader = new SplatLoader();\n      loader.packedSplats = this;\n      if (fileBytes) {\n        await loader.loadAsync(\n          fileBytes,\n          options.onProgress\n        );\n      } else if (url) {\n        await loader.loadAsync(url, options.onProgress);\n      }\n      if (construct) {\n        const maybePromise = construct(this);\n        if (maybePromise instanceof Promise) {\n          await maybePromise;\n        }\n      }\n    }\n    // Call this when you are finished with the PackedSplats and want to free\n    // any buffers it holds.\n    dispose() {\n      if (this.target) {\n        this.target.dispose();\n        this.target = null;\n      }\n      if (this.source) {\n        this.source.dispose();\n        this.source = null;\n      }\n      if (this.lodSplats) {\n        this.lodSplats.dispose();\n        this.lodSplats = void 0;\n      }\n      if (this.pageCache) {\n        this.pageCache.dispose();\n        this.pageCache = null;\n      }\n    }\n    // Ensures that this.packedArray can fit numSplats Gsplats. If it\'s too small,\n    // resize exponentially and copy over the original data.\n    //\n    // Typically you don\'t need to call this, because calling this.setSplat(index, ...)\n    // and this.pushSplat(...) will automatically call ensureSplats() so we have\n    // enough splats.\n    ensureSplats(numSplats) {\n      const targetSize = numSplats <= this.maxSplats ? this.maxSplats : (\n        // Grow exponentially to avoid frequent reallocations\n        Math.max(numSplats, 2 * this.maxSplats)\n      );\n      const currentSize = !this.packedArray ? 0 : this.packedArray.length / 4;\n      if (!this.packedArray || targetSize > currentSize) {\n        this.maxSplats = getTextureSize(targetSize).maxSplats;\n        const newArray = new Uint32Array(this.maxSplats * 4);\n        if (this.packedArray) {\n          newArray.set(this.packedArray);\n        }\n        this.packedArray = newArray;\n      }\n      return this.packedArray;\n    }\n    // Ensure the extra array for the given level is large enough to hold numSplats\n    ensureSplatsSh(level, numSplats) {\n      let wordsPerSplat;\n      let key;\n      if (level === 0) {\n        return this.ensureSplats(numSplats);\n      }\n      if (level === 1) {\n        wordsPerSplat = 2;\n        key = "sh1";\n      } else if (level === 2) {\n        wordsPerSplat = 4;\n        key = "sh2";\n      } else if (level === 3) {\n        wordsPerSplat = 4;\n        key = "sh3";\n      } else {\n        throw new Error(`Invalid level: ${level}`);\n      }\n      let maxSplats = !this.extra[key] ? 0 : this.extra[key].length / wordsPerSplat;\n      const targetSize = numSplats <= maxSplats ? maxSplats : Math.max(numSplats, 2 * maxSplats);\n      if (!this.extra[key] || targetSize > maxSplats) {\n        maxSplats = getTextureSize(targetSize).maxSplats;\n        const newArray = new Uint32Array(maxSplats * wordsPerSplat);\n        if (this.extra[key]) {\n          newArray.set(this.extra[key]);\n        }\n        this.extra[key] = newArray;\n      }\n      return this.extra[key];\n    }\n    // Unpack the 16-byte Gsplat data at index into the Three.js components\n    // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\n    // opacity: number 0..1, color: THREE.Color 0..1.\n    getSplat(index) {\n      if (!this.packedArray || index >= this.numSplats) {\n        throw new Error("Invalid index");\n      }\n      return unpackSplat(this.packedArray, index, this.splatEncoding);\n    }\n    // Set all PackedSplat components at index with the provided Gsplat attributes\n    // (can be the same objects returned by getSplat). Ensures there is capacity\n    // for at least index+1 Gsplats.\n    setSplat(index, center, scales, quaternion, opacity, color) {\n      const packedSplats = this.ensureSplats(index + 1);\n      setPackedSplat(\n        packedSplats,\n        index,\n        center.x,\n        center.y,\n        center.z,\n        scales.x,\n        scales.y,\n        scales.z,\n        quaternion.x,\n        quaternion.y,\n        quaternion.z,\n        quaternion.w,\n        opacity,\n        color.r,\n        color.g,\n        color.b\n      );\n      this.numSplats = Math.max(this.numSplats, index + 1);\n    }\n    // Effectively calls this.setSplat(this.numSplats++, center, ...), useful on\n    // construction where you just want to iterate and create a collection of Gsplats.\n    pushSplat(center, scales, quaternion, opacity, color) {\n      const packedSplats = this.ensureSplats(this.numSplats + 1);\n      setPackedSplat(\n        packedSplats,\n        this.numSplats,\n        center.x,\n        center.y,\n        center.z,\n        scales.x,\n        scales.y,\n        scales.z,\n        quaternion.x,\n        quaternion.y,\n        quaternion.z,\n        quaternion.w,\n        opacity,\n        color.r,\n        color.g,\n        color.b\n      );\n      ++this.numSplats;\n    }\n    // Iterate over Gsplats index 0..=(this.numSplats-1), unpack each Gsplat\n    // and invoke the callback function with the Gsplat attributes.\n    forEachSplat(callback) {\n      if (!this.packedArray || !this.numSplats) {\n        return;\n      }\n      for (let i2 = 0; i2 < this.numSplats; ++i2) {\n        const unpacked = unpackSplat(this.packedArray, i2, this.splatEncoding);\n        callback(\n          i2,\n          unpacked.center,\n          unpacked.scales,\n          unpacked.quaternion,\n          unpacked.opacity,\n          unpacked.color\n        );\n      }\n    }\n    // Ensures our PackedSplats.target render target has enough space to generate\n    // maxSplats total Gsplats, and reallocate if not large enough.\n    ensureGenerate(maxSplats) {\n      if (this.target && (maxSplats ?? 1) <= this.maxSplats) {\n        return false;\n      }\n      this.dispose();\n      const textureSize = getTextureSize(maxSplats ?? 1);\n      const { width, height, depth } = textureSize;\n      this.maxSplats = textureSize.maxSplats;\n      this.target = new WebGLArrayRenderTarget(width, height, depth, {\n        depthBuffer: false,\n        stencilBuffer: false,\n        generateMipmaps: false,\n        magFilter: NearestFilter,\n        minFilter: NearestFilter\n      });\n      this.target.texture.format = RGBAIntegerFormat;\n      this.target.texture.type = UnsignedIntType;\n      this.target.texture.internalFormat = "RGBA32UI";\n      this.target.scissorTest = true;\n      return true;\n    }\n    // Given an array of splatCounts (.numSplats for each\n    // SplatGenerator/SplatMesh in the scene), compute a\n    // "mapping layout" in the composite array of generated outputs.\n    generateMapping(splatCounts) {\n      let maxSplats = 0;\n      const mapping = splatCounts.map((numSplats) => {\n        const base = maxSplats;\n        const rounded = Math.ceil(numSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n        maxSplats += rounded;\n        return { base, count: numSplats };\n      });\n      return { maxSplats, mapping };\n    }\n    // Returns a THREE.DataArrayTexture representing the PackedSplats content as\n    // a Uint32x4 data array texture (2048 x 2048 x depth in size)\n    getTexture() {\n      if (this.target) {\n        return this.target.texture;\n      }\n      if (this.source || this.packedArray) {\n        const source = this.maybeUpdateSource();\n        return source;\n      }\n      return _PackedSplats.getEmptyArray;\n    }\n    ensurePagedTexture() {\n      if (this.pageCache) {\n        const { width, height } = this.pageCache.image;\n        if (this.maxSplats !== width * height) {\n          this.pageCache.dispose();\n          this.pageCache = null;\n        }\n      }\n      if (!this.pageCache) {\n        const maxSplats = Math.max(this.maxSplats, 65536 * 4);\n        const width = SPLAT_PAGED_WIDTH;\n        const height = Math.ceil(maxSplats / SPLAT_PAGED_WIDTH);\n        if (height > SPLAT_PAGED_HEIGHT) {\n          throw new Error("Max splats exceeds paged height");\n        }\n        if (!this.packedArray || this.packedArray.length < width * height * 4) {\n          const newArray = new Uint32Array(width * height * 4);\n          if (this.packedArray) {\n            newArray.set(this.packedArray);\n          }\n          this.packedArray = newArray;\n        }\n        this.pageCache = new DataTexture(this.packedArray, width, height, RGBAIntegerFormat, UnsignedIntType);\n        this.pageCache.internalFormat = "RGBA32UI";\n        this.pageCache.needsUpdate = true;\n        this.maxSplats = width * height;\n        console.log("**** Created page cache", this.pageCache);\n      }\n    }\n    allocTexturePage() {\n      let page = this.pageFreelist.shift();\n      if (page != null) {\n        return page;\n      }\n      if (this.pageTop >= this.pageMax) {\n        return void 0;\n      }\n      page = this.pageTop;\n      this.pageTop += 1;\n      this.numSplats = this.pageTop * 65536;\n      return page;\n    }\n    uploadTexturePage(renderer, packedArray, page) {\n      const gl = renderer.getContext();\n      if (!renderer.properties.has(this.pageCache)) {\n        throw new Error("Page cache not found");\n      }\n      const props = renderer.properties.get(this.pageCache);\n      const glTexture = props.__webglTexture;\n      if (!glTexture) {\n        throw new Error("Page cache texture not found");\n      }\n      renderer.state.activeTexture(gl.TEXTURE0);\n      renderer.state.bindTexture(gl.TEXTURE_2D, glTexture);\n      const pageRows = 65536 / 4096;\n      gl.texSubImage2D(\n        gl.TEXTURE_2D,\n        0,\n        0,\n        page * pageRows,\n        SPLAT_PAGED_WIDTH,\n        pageRows,\n        gl.RGBA_INTEGER,\n        gl.UNSIGNED_INT,\n        packedArray\n      );\n      renderer.state.bindTexture(gl.TEXTURE_2D, null);\n    }\n    getPagedTexture() {\n      if (!this.paged) {\n        throw new Error("PackedSplats is not paged");\n      }\n      this.ensurePagedTexture();\n      return this.pageCache;\n    }\n    // Check if source texture needs to be created/updated\n    maybeUpdateSource() {\n      if (!this.packedArray) {\n        throw new Error("No packed splats");\n      }\n      if (this.needsUpdate || !this.source) {\n        this.needsUpdate = false;\n        if (this.source) {\n          const { width, height, depth } = this.source.image;\n          if (this.maxSplats !== width * height * depth) {\n            this.source.dispose();\n            this.source = null;\n          }\n        }\n        if (!this.source) {\n          const { width, height, depth } = getTextureSize(this.maxSplats);\n          this.source = new DataArrayTexture(\n            this.packedArray,\n            width,\n            height,\n            depth\n          );\n          this.source.format = RGBAIntegerFormat;\n          this.source.type = UnsignedIntType;\n          this.source.internalFormat = "RGBA32UI";\n          this.source.needsUpdate = true;\n        } else if (this.packedArray.buffer !== this.source.image.data.buffer) {\n          this.source.image.data = new Uint8Array(this.packedArray.buffer);\n        }\n        this.source.needsUpdate = true;\n      }\n      return this.source;\n    }\n    // Get a program and THREE.RawShaderMaterial for a given GsplatGenerator,\n    // generating it if necessary and caching the result.\n    prepareProgramMaterial(generator) {\n      let program = _PackedSplats.generatorProgram.get(generator);\n      if (!program) {\n        const graph = dynoBlock(\n          { index: "int" },\n          { output: "uvec4" },\n          ({ index }) => {\n            generator.inputs.index = index;\n            const gsplat = generator.outputs.gsplat;\n            const output = outputPackedSplat(\n              gsplat,\n              this.dynoRgbMinMaxLnScaleMinMax\n            );\n            return { output };\n          }\n        );\n        if (!_PackedSplats.programTemplate) {\n          _PackedSplats.programTemplate = new DynoProgramTemplate(\n            computeUvec4_default\n          );\n        }\n        program = new DynoProgram({\n          graph,\n          inputs: { index: "index" },\n          outputs: { output: "target" },\n          template: _PackedSplats.programTemplate\n        });\n        Object.assign(program.uniforms, {\n          targetLayer: { value: 0 },\n          targetBase: { value: 0 },\n          targetCount: { value: 0 }\n        });\n        _PackedSplats.generatorProgram.set(generator, program);\n      }\n      const material = program.prepareMaterial();\n      _PackedSplats.fullScreenQuad.material = material;\n      return { program, material };\n    }\n    saveRenderState(renderer) {\n      return {\n        xrEnabled: renderer.xr.enabled,\n        autoClear: renderer.autoClear\n      };\n    }\n    resetRenderState(renderer, state) {\n      renderer.setRenderTarget(null);\n      renderer.xr.enabled = state.xrEnabled;\n      renderer.autoClear = state.autoClear;\n    }\n    // Executes a dyno program specified by generator which is any DynoBlock that\n    // maps { index: "int" } to { gsplat: Gsplat }. This is called in\n    // SparkRenderer.updateInternal() to re-generate Gsplats in the scene for\n    // SplatGenerator instances whose version is newer than what was generated\n    // for it last time.\n    generate({\n      generator,\n      base,\n      count,\n      renderer\n    }) {\n      if (!this.target) {\n        throw new Error("Target must be initialized with ensureSplats");\n      }\n      if (base + count > this.maxSplats) {\n        throw new Error("Base + count exceeds maxSplats");\n      }\n      const { program, material } = this.prepareProgramMaterial(generator);\n      program.update();\n      const renderState = this.saveRenderState(renderer);\n      const nextBase = Math.ceil((base + count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n      material.uniforms.targetBase.value = base;\n      material.uniforms.targetCount.value = count;\n      while (base < nextBase) {\n        const layer = Math.floor(base / layerSize);\n        material.uniforms.targetLayer.value = layer;\n        const layerBase = layer * layerSize;\n        const layerYStart = Math.floor((base - layerBase) / SPLAT_TEX_WIDTH);\n        const layerYEnd = Math.min(\n          SPLAT_TEX_HEIGHT,\n          Math.ceil((nextBase - layerBase) / SPLAT_TEX_WIDTH)\n        );\n        this.target.scissor.set(\n          0,\n          layerYStart,\n          SPLAT_TEX_WIDTH,\n          layerYEnd - layerYStart\n        );\n        renderer.setRenderTarget(this.target, layer);\n        renderer.xr.enabled = false;\n        renderer.autoClear = false;\n        _PackedSplats.fullScreenQuad.render(renderer);\n        base += SPLAT_TEX_WIDTH * (layerYEnd - layerYStart);\n      }\n      this.resetRenderState(renderer, renderState);\n      return { nextBase };\n    }\n    async createLodSplats() {\n      const lodBase = typeof this.lod === "number" ? Math.max(1.1, Math.min(2, this.lod)) : 1.5;\n      const packedArray = this.packedArray.slice();\n      const extra = {\n        sh1: this.extra.sh1 ? this.extra.sh1.slice() : void 0,\n        sh2: this.extra.sh2 ? this.extra.sh2.slice() : void 0,\n        sh3: this.extra.sh3 ? this.extra.sh3.slice() : void 0\n      };\n      const decoded = await workerPool.withWorker(async (worker) => {\n        return await worker.call("quickLod", {\n          numSplats: this.numSplats,\n          packedArray,\n          extra,\n          lodBase\n        });\n      });\n      console.log("=> createLodSplats: decoded =", decoded);\n      const lodSplats = new _PackedSplats(decoded);\n      if (this.lodSplats) {\n        this.lodSplats.dispose();\n      }\n      this.lodSplats = lodSplats;\n      this.nonLod = true;\n      if (!this.lod) {\n        this.lod = lodBase;\n      }\n      console.log("=> createLodSplats: this =", this);\n    }\n  };\n  _PackedSplats.getEmptyArray = (() => {\n    const { width, height, depth, maxSplats } = getTextureSize(1);\n    const emptyArray = new Uint32Array(maxSplats * 4);\n    const texture = new DataArrayTexture(\n      emptyArray,\n      width,\n      height,\n      depth\n    );\n    texture.format = RGBAIntegerFormat;\n    texture.type = UnsignedIntType;\n    texture.internalFormat = "RGBA32UI";\n    texture.needsUpdate = true;\n    return texture;\n  })();\n  _PackedSplats.getEmptyFlat = (() => {\n    const empty = new Uint32Array(4096 * 4);\n    const texture = new DataTexture(empty, 4096, 1, RGBAIntegerFormat, UnsignedIntType);\n    texture.internalFormat = "RGBA32UI";\n    texture.needsUpdate = true;\n    return texture;\n  })();\n  _PackedSplats.programTemplate = null;\n  _PackedSplats.generatorProgram = /* @__PURE__ */ new Map();\n  _PackedSplats.fullScreenQuad = new FullScreenQuad(\n    new RawShaderMaterial({ visible: false })\n  );\n  let PackedSplats = _PackedSplats;\n  class DynoPackedSplats extends DynoUniform {\n    constructor({ packedSplats } = {}) {\n      super({\n        key: "packedSplats",\n        type: TPackedSplats,\n        globals: () => [definePackedSplats],\n        value: {\n          textureArray: PackedSplats.getEmptyArray,\n          texture: PackedSplats.getEmptyFlat,\n          numSplats: 0,\n          rgbMinMaxLnScaleMinMax: new Vector4(\n            0,\n            1,\n            LN_SCALE_MIN,\n            LN_SCALE_MAX\n          ),\n          flagsFlatLodOpacity: 0\n        },\n        update: (value) => {\n          var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;\n          if ((_a2 = this.packedSplats) == null ? void 0 : _a2.paged) {\n            value.textureArray = PackedSplats.getEmptyArray;\n            value.texture = ((_b2 = this.packedSplats) == null ? void 0 : _b2.getPagedTexture()) ?? PackedSplats.getEmptyFlat;\n            value.flagsFlatLodOpacity = 1;\n          } else {\n            value.textureArray = ((_c = this.packedSplats) == null ? void 0 : _c.getTexture()) ?? PackedSplats.getEmptyArray;\n            value.texture = PackedSplats.getEmptyFlat;\n            value.flagsFlatLodOpacity = 0;\n          }\n          value.numSplats = ((_d = this.packedSplats) == null ? void 0 : _d.numSplats) ?? 0;\n          value.rgbMinMaxLnScaleMinMax.set(\n            ((_f = (_e = this.packedSplats) == null ? void 0 : _e.splatEncoding) == null ? void 0 : _f.rgbMin) ?? 0,\n            ((_h = (_g = this.packedSplats) == null ? void 0 : _g.splatEncoding) == null ? void 0 : _h.rgbMax) ?? 1,\n            ((_j = (_i = this.packedSplats) == null ? void 0 : _i.splatEncoding) == null ? void 0 : _j.lnScaleMin) ?? LN_SCALE_MIN,\n            ((_l = (_k = this.packedSplats) == null ? void 0 : _k.splatEncoding) == null ? void 0 : _l.lnScaleMax) ?? LN_SCALE_MAX\n          );\n          value.flagsFlatLodOpacity = value.flagsFlatLodOpacity | (((_n = (_m = this.packedSplats) == null ? void 0 : _m.splatEncoding) == null ? void 0 : _n.lodOpacity) ? 2 : 0);\n          return value;\n        }\n      });\n      this.packedSplats = packedSplats;\n    }\n  }\n  var computeVec4_default = "precision highp float;\\nprecision highp int;\\nprecision highp sampler2D;\\nprecision highp usampler2D;\\nprecision highp isampler2D;\\nprecision highp sampler2DArray;\\nprecision highp usampler2DArray;\\nprecision highp isampler2DArray;\\nprecision highp sampler3D;\\nprecision highp usampler3D;\\nprecision highp isampler3D;\\n\\n#include <splatDefines>\\n\\nuniform uint targetLayer;\\nuniform int targetBase;\\nuniform int targetCount;\\n\\nout vec4 target;\\n\\n{{ GLOBALS }}\\n\\nvoid computeReadback(int index) {\\n    {{ STATEMENTS }}\\n}\\n\\nvoid main() {\\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\\n    int index = targetIndex - targetBase;\\n\\n    if ((index >= 0) && (index < targetCount)) {\\n        computeReadback(index);\\n    } else {\\n        target = vec4(0.0, 0.0, 0.0, 0.0);\\n    }\\n}";\n  const _Readback = class _Readback {\n    constructor({ renderer } = {}) {\n      this.renderer = renderer;\n      this.capacity = 0;\n      this.count = 0;\n    }\n    dispose() {\n      if (this.target) {\n        this.target.dispose();\n        this.target = void 0;\n      }\n    }\n    // Ensure we have a buffer large enough for the readback of count indices.\n    // Pass in previous bufer of the desired type.\n    static ensureBuffer(count, buffer) {\n      const roundedCount = Math.ceil(Math.max(1, count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      const bytes = roundedCount * 4;\n      if (buffer.byteLength >= bytes) {\n        return buffer;\n      }\n      const newBuffer = new ArrayBuffer(bytes);\n      if (buffer instanceof ArrayBuffer) {\n        return newBuffer;\n      }\n      const ctor = buffer.constructor;\n      return new ctor(newBuffer);\n    }\n    ensureBuffer(count, buffer) {\n      return _Readback.ensureBuffer(count, buffer);\n    }\n    // Ensure our render target is large enough for the readback of capacity indices.\n    ensureCapacity(capacity) {\n      const { width, height, depth, maxSplats } = getTextureSize(capacity);\n      if (!this.target || maxSplats > this.capacity) {\n        this.dispose();\n        this.capacity = maxSplats;\n        this.target = new WebGLArrayRenderTarget(width, height, depth, {\n          depthBuffer: false,\n          stencilBuffer: false,\n          generateMipmaps: false,\n          magFilter: NearestFilter,\n          minFilter: NearestFilter\n        });\n        this.target.texture.format = RGBAFormat;\n        this.target.texture.type = UnsignedByteType;\n        this.target.texture.internalFormat = "RGBA8";\n        this.target.scissorTest = true;\n      }\n    }\n    // Get a program and THREE.RawShaderMaterial for a given Rgba8Readback,\n    // generating it if necessary and caching the result.\n    prepareProgramMaterial(reader) {\n      let program = _Readback.readbackProgram.get(reader);\n      if (!program) {\n        const graph = dynoBlock(\n          { index: "int" },\n          { rgba8: "vec4" },\n          ({ index }) => {\n            reader.inputs.index = index;\n            const rgba8 = new OutputRgba8({ rgba8: reader.outputs.rgba8 });\n            return { rgba8 };\n          }\n        );\n        if (!_Readback.programTemplate) {\n          _Readback.programTemplate = new DynoProgramTemplate(computeVec4_default);\n        }\n        program = new DynoProgram({\n          graph,\n          inputs: { index: "index" },\n          outputs: { rgba8: "target" },\n          template: _Readback.programTemplate\n        });\n        Object.assign(program.uniforms, {\n          targetLayer: { value: 0 },\n          targetBase: { value: 0 },\n          targetCount: { value: 0 }\n        });\n        _Readback.readbackProgram.set(reader, program);\n      }\n      const material = program.prepareMaterial();\n      _Readback.fullScreenQuad.material = material;\n      return { program, material };\n    }\n    saveRenderState(renderer) {\n      return {\n        xrEnabled: renderer.xr.enabled,\n        autoClear: renderer.autoClear\n      };\n    }\n    resetRenderState(renderer, state) {\n      renderer.setRenderTarget(null);\n      renderer.xr.enabled = state.xrEnabled;\n      renderer.autoClear = state.autoClear;\n    }\n    process({\n      count,\n      material\n    }) {\n      const renderer = this.renderer;\n      if (!renderer) {\n        throw new Error("No renderer");\n      }\n      if (!this.target) {\n        throw new Error("No target");\n      }\n      const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n      material.uniforms.targetBase.value = 0;\n      material.uniforms.targetCount.value = count;\n      let baseIndex = 0;\n      while (baseIndex < count) {\n        const layer = Math.floor(baseIndex / layerSize);\n        const layerBase = layer * layerSize;\n        const layerYEnd = Math.min(\n          SPLAT_TEX_HEIGHT,\n          Math.ceil((count - layerBase) / SPLAT_TEX_WIDTH)\n        );\n        material.uniforms.targetLayer.value = layer;\n        this.target.scissor.set(0, 0, SPLAT_TEX_WIDTH, layerYEnd);\n        renderer.setRenderTarget(this.target, layer);\n        renderer.xr.enabled = false;\n        renderer.autoClear = false;\n        _Readback.fullScreenQuad.render(renderer);\n        baseIndex += SPLAT_TEX_WIDTH * layerYEnd;\n      }\n      this.count = count;\n    }\n    async read({\n      readback\n    }) {\n      const renderer = this.renderer;\n      if (!renderer) {\n        throw new Error("No renderer");\n      }\n      if (!this.target) {\n        throw new Error("No target");\n      }\n      const roundedCount = Math.ceil(this.count / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      if (readback.byteLength < roundedCount * 4) {\n        throw new Error(\n          `Readback buffer too small: ${readback.byteLength} < ${roundedCount * 4}`\n        );\n      }\n      const readbackUint8 = new Uint8Array(\n        readback instanceof ArrayBuffer ? readback : readback.buffer\n      );\n      const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n      let baseIndex = 0;\n      const promises = [];\n      while (baseIndex < this.count) {\n        const layer = Math.floor(baseIndex / layerSize);\n        const layerBase = layer * layerSize;\n        const layerYEnd = Math.min(\n          SPLAT_TEX_HEIGHT,\n          Math.ceil((this.count - layerBase) / SPLAT_TEX_WIDTH)\n        );\n        renderer.setRenderTarget(this.target, layer);\n        const readbackSize = SPLAT_TEX_WIDTH * layerYEnd * 4;\n        const subReadback = readbackUint8.subarray(\n          layerBase * 4,\n          layerBase * 4 + readbackSize\n        );\n        const promise = renderer == null ? void 0 : renderer.readRenderTargetPixelsAsync(\n          this.target,\n          0,\n          0,\n          SPLAT_TEX_WIDTH,\n          layerYEnd,\n          subReadback\n        );\n        promises.push(promise);\n        baseIndex += SPLAT_TEX_WIDTH * layerYEnd;\n      }\n      return Promise.all(promises).then(() => readback);\n    }\n    // Perform render operation to run the Rgba8Readback program\n    // but don\'t perform the readback yet.\n    render({\n      reader,\n      count,\n      renderer\n    }) {\n      this.renderer = renderer || this.renderer;\n      if (!this.renderer) {\n        throw new Error("No renderer");\n      }\n      this.ensureCapacity(count);\n      const { program, material } = this.prepareProgramMaterial(reader);\n      program.update();\n      const renderState = this.saveRenderState(this.renderer);\n      this.process({ count, material });\n      this.resetRenderState(this.renderer, renderState);\n    }\n    // Perform a readback of the render target, returning a buffer of the\n    // given type.\n    async readback({\n      readback\n    }) {\n      if (!this.renderer) {\n        throw new Error("No renderer");\n      }\n      const renderState = this.saveRenderState(this.renderer);\n      const promise = this.read({ readback });\n      this.resetRenderState(this.renderer, renderState);\n      return promise;\n    }\n    // Perform a render and readback operation for the given Rgba8Readback,\n    // and readback buffer (call ensureBuffer first).\n    async renderReadback({\n      reader,\n      count,\n      renderer,\n      readback\n    }) {\n      this.renderer = renderer || this.renderer;\n      if (!this.renderer) {\n        throw new Error("No renderer");\n      }\n      this.ensureCapacity(count);\n      const { program, material } = this.prepareProgramMaterial(reader);\n      program.update();\n      const renderState = this.saveRenderState(this.renderer);\n      this.process({ count, material });\n      const promise = this.read({ readback });\n      this.resetRenderState(this.renderer, renderState);\n      return promise;\n    }\n    getTexture() {\n      var _a2;\n      return (_a2 = this.target) == null ? void 0 : _a2.texture;\n    }\n  };\n  _Readback.programTemplate = null;\n  _Readback.readbackProgram = /* @__PURE__ */ new Map();\n  _Readback.fullScreenQuad = new FullScreenQuad(\n    new RawShaderMaterial({ visible: false })\n  );\n  let Readback = _Readback;\n  const _RgbaArray = class _RgbaArray {\n    constructor(options = {}) {\n      this.capacity = 0;\n      this.count = 0;\n      this.array = null;\n      this.readback = null;\n      this.source = null;\n      this.needsUpdate = true;\n      this.dyno = new DynoUniform({\n        key: "rgbaArray",\n        type: TRgbaArray,\n        globals: () => [defineRgbaArray],\n        value: {\n          texture: _RgbaArray.getEmpty(),\n          count: 0\n        },\n        update: (value) => {\n          var _a2;\n          value.texture = ((_a2 = this.readback) == null ? void 0 : _a2.getTexture()) ?? this.source ?? _RgbaArray.getEmpty();\n          value.count = this.count;\n          return value;\n        }\n      });\n      if (options.array) {\n        this.array = options.array;\n        this.capacity = Math.floor(this.array.length / 4);\n        this.capacity = Math.floor(this.capacity / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n        this.count = Math.min(\n          this.capacity,\n          options.count ?? Number.POSITIVE_INFINITY\n        );\n      } else {\n        this.capacity = options.capacity ?? 0;\n        this.count = 0;\n      }\n    }\n    // Free up resources\n    dispose() {\n      if (this.readback) {\n        this.readback.dispose();\n        this.readback = null;\n      }\n      if (this.source) {\n        this.source.dispose();\n        this.source = null;\n      }\n    }\n    // Ensure that our array is large enough to hold capacity RGBA8 values.\n    ensureCapacity(capacity) {\n      var _a2;\n      if (!this.array || capacity > (((_a2 = this.array) == null ? void 0 : _a2.length) ?? 0) / 4) {\n        this.capacity = getTextureSize(capacity).maxSplats;\n        const newArray = new Uint8Array(this.capacity * 4);\n        if (this.array) {\n          newArray.set(this.array);\n        }\n        this.array = newArray;\n      }\n      return this.array;\n    }\n    // Get the THREE.DataArrayTexture from either the readback or the source.\n    getTexture() {\n      var _a2;\n      let texture = (_a2 = this.readback) == null ? void 0 : _a2.getTexture();\n      if (this.source || this.array) {\n        texture = this.maybeUpdateSource();\n      }\n      return texture ?? _RgbaArray.getEmpty();\n    }\n    // Create or get a THREE.DataArrayTexture from the data array.\n    maybeUpdateSource() {\n      if (!this.array) {\n        throw new Error("No array");\n      }\n      if (this.needsUpdate || !this.source) {\n        this.needsUpdate = false;\n        if (this.source) {\n          const { width, height, depth } = this.source.image;\n          if (this.capacity !== width * height * depth) {\n            this.source.dispose();\n            this.source = null;\n          }\n        }\n        if (!this.source) {\n          const { width, height, depth } = getTextureSize(this.capacity);\n          this.source = new DataArrayTexture(\n            this.array,\n            width,\n            height,\n            depth\n          );\n          this.source.format = RGBAFormat;\n          this.source.type = UnsignedByteType;\n          this.source.internalFormat = "RGBA8";\n          this.source.needsUpdate = true;\n        } else if (this.array.buffer !== this.source.image.data.buffer) {\n          this.source.image.data = new Uint8Array(this.array.buffer);\n        }\n        this.source.needsUpdate = true;\n      }\n      return this.source;\n    }\n    // Generate the RGBA8 values from a Rgba8Readback dyno program.\n    render({\n      reader,\n      count,\n      renderer\n    }) {\n      if (!this.readback) {\n        this.readback = new Readback({ renderer });\n      }\n      this.readback.render({ reader, count, renderer });\n      this.capacity = this.readback.capacity;\n      this.count = this.readback.count;\n    }\n    // Extract the RGBA8 values from a PackedSplats collection.\n    fromPackedSplats({\n      packedSplats,\n      base,\n      count,\n      renderer\n    }) {\n      const { dynoSplats, dynoBase, dynoCount, reader } = _RgbaArray.makeDynos();\n      dynoSplats.packedSplats = packedSplats;\n      dynoBase.value = base;\n      dynoCount.value = count;\n      this.render({ reader, count, renderer });\n      return this;\n    }\n    // Read back the RGBA8 values from the readback buffer.\n    async read() {\n      if (!this.readback) {\n        throw new Error("No readback");\n      }\n      if (!this.array || this.array.length < this.count * 4) {\n        this.array = new Uint8Array(this.capacity * 4);\n      }\n      const result = await this.readback.readback({ readback: this.array });\n      return result.subarray(0, this.count * 4);\n    }\n    // Can be used where you need an uninitialized THREE.DataArrayTexture like\n    // a uniform you will update with the result of this.getTexture() later.\n    static getEmpty() {\n      if (!_RgbaArray.emptySource) {\n        const emptyArray = new Uint8Array(1 * 4);\n        _RgbaArray.emptySource = new DataArrayTexture(emptyArray, 1, 1, 1);\n        _RgbaArray.emptySource.format = RGBAFormat;\n        _RgbaArray.emptySource.type = UnsignedByteType;\n        _RgbaArray.emptySource.internalFormat = "RGBA8";\n        _RgbaArray.emptySource.needsUpdate = true;\n      }\n      return _RgbaArray.emptySource;\n    }\n    // Create a dyno program that can extract RGBA8 values from a PackedSplats\n    static makeDynos() {\n      if (!_RgbaArray.dynos) {\n        const dynoSplats = new DynoPackedSplats();\n        const dynoBase = new DynoInt({ value: 0 });\n        const dynoCount = new DynoInt({ value: 0 });\n        const reader = dynoBlock(\n          { index: "int" },\n          { rgba8: "vec4" },\n          ({ index }) => {\n            if (!index) {\n              throw new Error("index is undefined");\n            }\n            index = add(index, dynoBase);\n            const gsplat = readPackedSplatRange(\n              dynoSplats,\n              index,\n              dynoBase,\n              dynoCount\n            );\n            return { rgba8: splitGsplat(gsplat).outputs.rgba };\n          }\n        );\n        _RgbaArray.dynos = { dynoSplats, dynoBase, dynoCount, reader };\n      }\n      return _RgbaArray.dynos;\n    }\n  };\n  _RgbaArray.emptySource = null;\n  _RgbaArray.dynos = null;\n  let RgbaArray = _RgbaArray;\n  const TRgbaArray = { type: "RgbaArray" };\n  const defineRgbaArray = unindent(`\n  struct RgbaArray {\n    sampler2DArray texture;\n    int count;\n  };\n`);\n  function readRgbaArray(rgba, index) {\n    const dyno2 = new Dyno({\n      inTypes: { rgba: TRgbaArray, index: "int" },\n      outTypes: { rgba: "vec4" },\n      inputs: { rgba, index },\n      globals: () => [defineRgbaArray],\n      statements: ({ inputs, outputs }) => unindentLines(`\n        if ((index >= 0) && (index < ${inputs.rgba}.count)) {\n          ${outputs.rgba} = texelFetch(${inputs.rgba}.texture, splatTexCoord(index), 0);\n        } else {\n          ${outputs.rgba} = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      `)\n    });\n    return dyno2.outputs.rgba;\n  }\n  function sdfTypeToNumber(type) {\n    switch (type) {\n      case "all":\n        return 0;\n      case "plane":\n        return 1;\n      case "sphere":\n        return 2;\n      case "box":\n        return 3;\n      case "ellipsoid":\n        return 4;\n      case "cylinder":\n        return 5;\n      case "capsule":\n        return 6;\n      case "infinite_cone":\n        return 7;\n      default:\n        throw new Error(`Unknown SDF type: ${type}`);\n    }\n  }\n  function rgbaBlendModeToNumber(mode) {\n    switch (mode) {\n      case "multiply":\n        return 0;\n      case "set_rgb":\n        return 1;\n      case "add_rgba":\n        return 2;\n      default:\n        throw new Error(`Unknown blend mode: ${mode}`);\n    }\n  }\n  class SplatEditSdf extends Object3D {\n    constructor(options = {}) {\n      super();\n      const { type, invert, opacity, color, displace, radius } = options;\n      this.type = type ?? "sphere";\n      this.invert = invert ?? false;\n      this.opacity = opacity ?? 1;\n      this.color = color ?? new Color(1, 1, 1);\n      this.displace = displace ?? new Vector3(0, 0, 0);\n      this.radius = radius ?? 0;\n    }\n  }\n  const _SplatEdit = class _SplatEdit extends Object3D {\n    constructor(options = {}) {\n      const {\n        name,\n        rgbaBlendMode = "multiply",\n        sdfSmooth = 0,\n        softEdge = 0,\n        invert = false,\n        sdfs = null\n      } = options;\n      super();\n      this.rgbaBlendMode = rgbaBlendMode;\n      this.sdfSmooth = sdfSmooth;\n      this.softEdge = softEdge;\n      this.invert = invert;\n      this.sdfs = sdfs;\n      this.ordering = _SplatEdit.nextOrdering++;\n      this.name = name ?? `Edit ${this.ordering}`;\n    }\n    addSdf(sdf) {\n      if (this.sdfs == null) {\n        this.sdfs = [];\n      }\n      if (!this.sdfs.includes(sdf)) {\n        this.sdfs.push(sdf);\n      }\n    }\n    removeSdf(sdf) {\n      if (this.sdfs == null) {\n        return;\n      }\n      this.sdfs = this.sdfs.filter((s) => s !== sdf);\n    }\n  };\n  _SplatEdit.nextOrdering = 1;\n  let SplatEdit = _SplatEdit;\n  class SplatEdits {\n    constructor({ maxSdfs, maxEdits }) {\n      this.maxSdfs = Math.max(16, maxSdfs ?? 0);\n      this.numSdfs = 0;\n      this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);\n      this.sdfFloatData = new Float32Array(this.sdfData.buffer);\n      this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);\n      this.dynoSdfArray = new DynoUniform({\n        key: "sdfArray",\n        type: SdfArray,\n        globals: () => [defineSdfArray],\n        value: {\n          numSdfs: 0,\n          sdfTexture: this.sdfTexture\n        },\n        update: (uniform) => {\n          uniform.numSdfs = this.numSdfs;\n          uniform.sdfTexture = this.sdfTexture;\n          return uniform;\n        }\n      });\n      this.maxEdits = Math.max(16, maxEdits ?? 0);\n      this.numEdits = 0;\n      this.editData = new Uint32Array(this.maxEdits * 4);\n      this.editFloatData = new Float32Array(this.editData.buffer);\n      this.dynoNumEdits = new DynoInt({ value: 0 });\n      this.dynoEdits = this.newEdits(this.editData, this.maxEdits);\n    }\n    newSdfTexture(data, maxSdfs) {\n      const texture = new DataTexture(\n        data,\n        8,\n        maxSdfs,\n        RGBAIntegerFormat,\n        UnsignedIntType\n      );\n      texture.internalFormat = "RGBA32UI";\n      texture.needsUpdate = true;\n      return texture;\n    }\n    newEdits(data, maxEdits) {\n      return new DynoUniform({\n        key: "edits",\n        type: "uvec4",\n        count: maxEdits,\n        globals: () => [defineEdit],\n        value: data\n      });\n    }\n    // Ensure our SDF texture and edits uniform array have enough capacity.\n    // Reallocate if not.\n    ensureCapacity({\n      maxSdfs,\n      maxEdits\n    }) {\n      let dynoUpdated = false;\n      if (maxSdfs > this.sdfTexture.image.height) {\n        this.sdfTexture.dispose();\n        this.maxSdfs = Math.max(this.maxSdfs * 2, maxSdfs);\n        this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);\n        this.sdfFloatData = new Float32Array(this.sdfData.buffer);\n        this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);\n      }\n      if (maxEdits > (this.dynoEdits.count ?? 0)) {\n        this.maxEdits = Math.max(this.maxEdits * 2, maxEdits);\n        this.editData = new Uint32Array(this.maxEdits * 4);\n        this.editFloatData = new Float32Array(this.editData.buffer);\n        this.dynoEdits = this.newEdits(this.editData, this.maxEdits);\n        dynoUpdated = true;\n      }\n      return dynoUpdated;\n    }\n    updateEditData(offset, value) {\n      const updated = this.editData[offset] !== value;\n      this.editData[offset] = value;\n      return updated;\n    }\n    updateEditFloatData(offset, value) {\n      tempFloat32[0] = value;\n      const updated = this.editFloatData[offset] !== tempFloat32[0];\n      if (updated) {\n        this.editFloatData[offset] = tempFloat32[0];\n      }\n      return updated;\n    }\n    encodeEdit(editIndex, {\n      sdfFirst,\n      sdfCount,\n      invert,\n      rgbaBlendMode,\n      softEdge,\n      sdfSmooth\n    }) {\n      const base = editIndex * 4;\n      let updated = false;\n      updated = this.updateEditData(base + 0, rgbaBlendMode | (invert ? 1 << 8 : 0)) || updated;\n      updated = this.updateEditData(base + 1, sdfFirst | sdfCount << 16) || updated;\n      updated = this.updateEditFloatData(base + 2, softEdge) || updated;\n      updated = this.updateEditFloatData(base + 3, sdfSmooth) || updated;\n      return updated;\n    }\n    updateSdfData(offset, value) {\n      const updated = this.sdfData[offset] !== value;\n      this.sdfData[offset] = value;\n      return updated;\n    }\n    updateSdfFloatData(offset, value) {\n      tempFloat32[0] = value;\n      const updated = this.sdfFloatData[offset] !== tempFloat32[0];\n      if (updated) {\n        this.sdfFloatData[offset] = tempFloat32[0];\n      }\n      return updated;\n    }\n    encodeSdf(sdfIndex, {\n      sdfType,\n      invert,\n      center,\n      quaternion,\n      scale,\n      sizes\n    }, values) {\n      const base = sdfIndex * (8 * 4);\n      const flags = sdfType | (invert ? 1 << 8 : 0);\n      let updated = false;\n      updated = this.updateSdfFloatData(base + 0, (center == null ? void 0 : center.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 1, (center == null ? void 0 : center.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 2, (center == null ? void 0 : center.z) ?? 0) || updated;\n      updated = this.updateSdfData(base + 3, flags) || updated;\n      updated = this.updateSdfFloatData(base + 4, (quaternion == null ? void 0 : quaternion.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 5, (quaternion == null ? void 0 : quaternion.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 6, (quaternion == null ? void 0 : quaternion.z) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 7, (quaternion == null ? void 0 : quaternion.w) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 8, (scale == null ? void 0 : scale.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 9, (scale == null ? void 0 : scale.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 10, (scale == null ? void 0 : scale.z) ?? 0) || updated;\n      updated = this.updateSdfData(base + 11, 0) || updated;\n      updated = this.updateSdfFloatData(base + 12, (sizes == null ? void 0 : sizes.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 13, (sizes == null ? void 0 : sizes.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 14, (sizes == null ? void 0 : sizes.z) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 15, (sizes == null ? void 0 : sizes.w) ?? 0) || updated;\n      const nValues = Math.min(4, values.length);\n      for (let i2 = 0; i2 < nValues; ++i2) {\n        const vBase = base + 16 + i2 * 4;\n        updated = this.updateSdfFloatData(vBase + 0, values[i2].x) || updated;\n        updated = this.updateSdfFloatData(vBase + 1, values[i2].y) || updated;\n        updated = this.updateSdfFloatData(vBase + 2, values[i2].z) || updated;\n        updated = this.updateSdfFloatData(vBase + 3, values[i2].w) || updated;\n      }\n      return updated;\n    }\n    // Update the SDFs and edits from an array of SplatEdits and their\n    // associated SplatEditSdfs, updating it for the dyno shader program.\n    update(edits) {\n      const sdfCount = edits.reduce((total, { sdfs }) => total + sdfs.length, 0);\n      const dynoUpdated = this.ensureCapacity({\n        maxEdits: edits.length,\n        maxSdfs: sdfCount\n      });\n      const values = [new Vector4(), new Vector4()];\n      const center = new Vector3();\n      const quaternion = new Quaternion();\n      const scale = new Vector3();\n      const sizes = new Vector4();\n      let sdfIndex = 0;\n      let updated = dynoUpdated;\n      if (edits.length !== this.dynoNumEdits.value) {\n        this.dynoNumEdits.value = edits.length;\n        this.numEdits = edits.length;\n        updated = true;\n      }\n      for (const [editIndex, { edit, sdfs }] of edits.entries()) {\n        updated = this.encodeEdit(editIndex, {\n          sdfFirst: sdfIndex,\n          sdfCount: sdfs.length,\n          invert: edit.invert,\n          rgbaBlendMode: rgbaBlendModeToNumber(edit.rgbaBlendMode),\n          softEdge: edit.softEdge,\n          sdfSmooth: edit.sdfSmooth\n        }) || updated;\n        let sdfUpdated = false;\n        for (const sdf of sdfs) {\n          sizes.set(sdf.scale.x, sdf.scale.y, sdf.scale.z, sdf.radius);\n          sdf.scale.setScalar(1);\n          sdf.updateMatrixWorld();\n          const worldToSdf = sdf.matrixWorld.clone().invert();\n          worldToSdf.decompose(center, quaternion, scale);\n          sdf.scale.set(sizes.x, sizes.y, sizes.z);\n          sdf.updateMatrixWorld();\n          values[0].set(sdf.color.r, sdf.color.g, sdf.color.b, sdf.opacity);\n          values[1].set(sdf.displace.x, sdf.displace.y, sdf.displace.z, 1);\n          sdfUpdated = this.encodeSdf(\n            sdfIndex,\n            {\n              sdfType: sdfTypeToNumber(sdf.type),\n              invert: sdf.invert,\n              center,\n              quaternion,\n              scale,\n              sizes\n            },\n            values\n          ) || sdfUpdated;\n          sdfIndex += 1;\n        }\n        this.numSdfs = sdfIndex;\n        if (sdfUpdated) {\n          this.sdfTexture.needsUpdate = true;\n        }\n        updated || (updated = sdfUpdated);\n      }\n      return { updated, dynoUpdated };\n    }\n    // Modify a Gsplat in a dyno shader program using the current edits and SDFs.\n    modify(gsplat) {\n      return applyGsplatRgbaDisplaceEdits(\n        gsplat,\n        this.dynoSdfArray,\n        this.dynoNumEdits,\n        this.dynoEdits\n      );\n    }\n  }\n  const SdfArray = { type: "SdfArray" };\n  const defineSdfArray = unindent(`\n  struct SdfArray {\n    int numSdfs;\n    usampler2D sdfTexture;\n  };\n\n  void unpackSdfArray(\n    usampler2D sdfTexture, int sdfIndex, out uint flags,\n    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,\n    int numValues, out vec4 values[4]\n  ) {\n    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);\n    flags = temp.w;\n    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);\n    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);\n    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);\n    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    for (int i = 0; i < numValues; ++i) {\n      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);\n      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n    }\n  }\n\n  const uint SDF_FLAG_TYPE = 0xFFu;\n  const uint SDF_FLAG_INVERT = 1u << 8u;\n\n  const uint SDF_TYPE_ALL = 0u;\n  const uint SDF_TYPE_PLANE = 1u;\n  const uint SDF_TYPE_SPHERE = 2u;\n  const uint SDF_TYPE_BOX = 3u;\n  const uint SDF_TYPE_ELLIPSOID = 4u;\n  const uint SDF_TYPE_CYLINDER = 5u;\n  const uint SDF_TYPE_CAPSULE = 6u;\n  const uint SDF_TYPE_INFINITE_CONE = 7u;\n\n  float evaluateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 outValues[4]\n  ) {\n    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;\n    float maxExp = -1.0 / 0.0;\n    for (int i = 0; i < numValues; ++i) {\n        outValues[i] = vec4(0.0);\n    }\n\n    uint flags;\n    vec3 center, scale;\n    vec4 quaternion, sizes;\n    vec4 values[4];\n\n    int sdfLast = min(sdfFirst + sdfCount, numSdfs);\n    for (int index = sdfFirst; index < sdfLast; ++index) {\n      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);\n      uint sdfType = flags & SDF_FLAG_TYPE;\n      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;\n\n      float distance;\n      switch (sdfType) {\n        case SDF_TYPE_ALL:\n          distance = -1.0 / 0.0;\n          break;\n        case SDF_TYPE_PLANE: {\n          distance = sdfPos.z;\n          break;\n        }\n        case SDF_TYPE_SPHERE: {\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_BOX: {\n          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;\n          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_ELLIPSOID: {\n          vec3 sizes = sizes.xyz;\n          float k0 = length(sdfPos / sizes);\n          float k1 = length(sdfPos / dot(sizes, sizes));\n          distance = k0 * (k0 - 1.0) / k1;\n          break;\n        }\n        case SDF_TYPE_CYLINDER: {\n          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;\n          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n          break;\n        }\n        case SDF_TYPE_CAPSULE: {\n          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_INFINITE_CONE: {\n          float angle = 0.25 * PI * sizes.w;\n          vec2 c = vec2(sin(angle), cos(angle));\n          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);\n          float d = length(q - c * max(dot(q, c), 0.0));\n          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);\n          break;\n        }\n      }\n\n      if ((flags & SDF_FLAG_INVERT) != 0u) {\n        distance = -distance;\n      }\n\n      if (smoothK == 0.0) {\n        if (distance < distanceAccum) {\n          distanceAccum = distance;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] = values[i];\n          }\n        }\n      } else {\n        float scaledDistance = -distance / smoothK;\n        if (scaledDistance > maxExp) {\n          float scale = exp(maxExp - scaledDistance);\n          distanceAccum *= scale;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] *= scale;\n          }\n          maxExp = scaledDistance;\n        }\n\n        float weight = exp(scaledDistance - maxExp);\n        distanceAccum += weight;\n        for (int i = 0; i < numValues; ++i) {\n          outValues[i] += weight * values[i];\n        }\n      }\n    }\n\n    if (smoothK == 0.0) {\n      return distanceAccum;\n    } else {\n      // Very distant SDFs may result in 0 accumulation\n      if (distanceAccum == 0.0) {\n        return 1.0 / 0.0;\n      }\n      for (int i = 0; i < numValues; ++i) {\n        outValues[i] /= distanceAccum;\n      }\n      return (-log(distanceAccum) - maxExp) * smoothK;\n    }\n  }\n\n  float modulateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 values[4],\n    float softEdge, bool invert\n  ) {\n    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);\n    if (invert) {\n      distance = -distance;\n    }\n\n    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)\n      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);\n  }\n`);\n  const defineEdit = unindent(`\n  const uint EDIT_FLAG_BLEND = 0xFFu;\n  const uint EDIT_BLEND_MULTIPLY = 0u;\n  const uint EDIT_BLEND_SET_RGB = 1u;\n  const uint EDIT_BLEND_ADD_RGBA = 2u;\n  const uint EDIT_FLAG_INVERT = 0x100u;\n\n  void decodeEdit(\n    uvec4 packedEdit, out int sdfFirst, out int sdfCount,\n    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth\n  ) {\n    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;\n    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;\n\n    sdfFirst = int(packedEdit.y & 0xFFFFu);\n    sdfCount = int(packedEdit.y >> 16u);\n\n    softEdge = uintBitsToFloat(packedEdit.z);\n    sdfSmooth = uintBitsToFloat(packedEdit.w);\n  }\n\n  void applyRgbaDisplaceEdit(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,\n    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba\n  ) {\n    vec4 values[4];\n    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);\n    // On Android, moving values[0] is necessary to work around a compiler bug.\n    vec4 sdfRgba = values[0];\n    vec4 sdfDisplaceScale = values[1];\n\n    vec4 target;\n    switch (rgbaBlendMode) {\n      case EDIT_BLEND_MULTIPLY:\n        target = rgba * sdfRgba;\n        break;\n      case EDIT_BLEND_SET_RGB:\n        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);\n        break;\n      case EDIT_BLEND_ADD_RGBA:\n        target = rgba + sdfRgba;\n        break;\n      default:\n        // Debug output if blend mode not set\n        target = vec4(fract(pos), 1.0);\n    }\n    rgba = mix(rgba, target, modulate);\n    pos += sdfDisplaceScale.xyz * modulate;\n  }\n\n  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {\n    int sdfFirst, sdfCount;\n    bool invert;\n    uint rgbaBlendMode;\n    float softEdge, sdfSmooth;\n    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);\n    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);\n  }\n`);\n  function applyGsplatRgbaDisplaceEdits(gsplat, sdfArray, numEdits, rgbaDisplaceEdits) {\n    const dyno2 = new Dyno({\n      inTypes: {\n        gsplat: Gsplat,\n        sdfArray: SdfArray,\n        numEdits: "int",\n        rgbaDisplaceEdits: "uvec4"\n      },\n      outTypes: { gsplat: Gsplat },\n      globals: () => [defineSdfArray, defineEdit],\n      inputs: { gsplat, sdfArray, numEdits, rgbaDisplaceEdits },\n      statements: ({ inputs, outputs }) => {\n        const { sdfArray: sdfArray2, numEdits: numEdits2, rgbaDisplaceEdits: rgbaDisplaceEdits2 } = inputs;\n        const { gsplat: gsplat2 } = outputs;\n        return unindentLines(`\n        ${gsplat2} = ${inputs.gsplat};\n        if (isGsplatActive(${gsplat2}.flags)) {\n          for (int editIndex = 0; editIndex < ${numEdits2}; ++editIndex) {\n            applyPackedRgbaDisplaceEdit(\n              ${rgbaDisplaceEdits2}[editIndex], ${sdfArray2}.sdfTexture, ${sdfArray2}.numSdfs,\n              ${gsplat2}.center, ${gsplat2}.rgba\n            );\n          }\n        }\n      `);\n      }\n    });\n    return dyno2.outputs.gsplat;\n  }\n  const tempFloat32 = new Float32Array(1);\n  class SplatTransformer {\n    // Create the dyno uniforms that parameterize the transform, setting them\n    // to initial values that are different from any valid transform.\n    constructor() {\n      this.scale = new DynoFloat({ value: Number.NEGATIVE_INFINITY });\n      this.rotate = new DynoVec4({\n        value: new Quaternion(\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY\n        )\n      });\n      this.translate = new DynoVec3({\n        value: new Vector3(\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY\n        )\n      });\n    }\n    // Apply the transform to a Vec3 position in a dyno program.\n    apply(position) {\n      return transformPos(position, {\n        scale: this.scale,\n        rotate: this.rotate,\n        translate: this.translate\n      });\n    }\n    applyDir(dir) {\n      return transformDir(dir, {\n        rotate: this.rotate\n      });\n    }\n    // Apply the transform to a Gsplat in a dyno program.\n    applyGsplat(gsplat) {\n      return transformGsplat(gsplat, {\n        scale: this.scale,\n        rotate: this.rotate,\n        translate: this.translate\n      });\n    }\n    // Update the uniforms to match the given transform matrix.\n    updateFromMatrix(transform) {\n      const scale = new Vector3();\n      const quaternion = new Quaternion();\n      const position = new Vector3();\n      transform.decompose(position, quaternion, scale);\n      const newScale = (scale.x + scale.y + scale.z) / 3;\n      let updated = false;\n      if (newScale !== this.scale.value) {\n        this.scale.value = newScale;\n        updated = true;\n      }\n      if (!position.equals(this.translate.value)) {\n        this.translate.value.copy(position);\n        updated = true;\n      }\n      if (!quaternion.equals(this.rotate.value)) {\n        this.rotate.value.copy(quaternion);\n        updated = true;\n      }\n      return updated;\n    }\n    // Update this transform to match the object\'s to-world transform.\n    update(object) {\n      object.updateMatrixWorld();\n      return this.updateFromMatrix(object.matrixWorld);\n    }\n  }\n  class SplatGenerator extends Object3D {\n    constructor({\n      numSplats,\n      generator,\n      construct,\n      update\n    }) {\n      super();\n      this.numSplats = numSplats ?? 0;\n      this.generator = generator;\n      this.frameUpdate = update;\n      this.version = 0;\n      this.mappingVersion = 0;\n      if (construct) {\n        const constructed = construct(this);\n        Object.assign(this, constructed);\n      }\n    }\n    updateVersion() {\n      this.version += 1;\n    }\n    updateMappingVersion() {\n      this.mappingVersion += 1;\n      this.version += 1;\n    }\n    set needsUpdate(value) {\n      if (value) {\n        this.updateVersion();\n      }\n    }\n  }\n  const _SplatMesh = class _SplatMesh extends SplatGenerator {\n    constructor(options = {}) {\n      const context = {\n        transform: new SplatTransformer(),\n        viewToWorld: new SplatTransformer(),\n        worldToView: new SplatTransformer(),\n        viewToObject: new SplatTransformer(),\n        recolor: new DynoVec4({\n          value: new Vector4().setScalar(Number.NEGATIVE_INFINITY)\n        }),\n        time: new DynoFloat({ value: 0 }),\n        deltaTime: new DynoFloat({ value: 0 }),\n        numSplats: new DynoInt({ value: 0 }),\n        splats: new DynoPackedSplats(),\n        enableLod: new DynoBool({ value: false }),\n        lodIndices: new DynoUsampler2D({\n          value: emptyLodIndices,\n          key: "lodIndices"\n        })\n      };\n      super({\n        update: (context2) => this.update(context2)\n      });\n      this.isInitialized = false;\n      this.recolor = new Color(1, 1, 1);\n      this.opacity = 1;\n      this.enableViewToObject = false;\n      this.enableViewToWorld = false;\n      this.enableWorldToView = false;\n      this.skinning = null;\n      this.edits = null;\n      this.rgbaDisplaceEdits = null;\n      this.splatRgba = null;\n      this.maxSh = 3;\n      this.packedSplats = options.packedSplats ?? new PackedSplats();\n      this.packedSplats.splatEncoding = options.splatEncoding ?? {\n        ...DEFAULT_SPLAT_ENCODING\n      };\n      this.numSplats = this.packedSplats.numSplats;\n      this.editable = options.editable ?? true;\n      this.onFrame = options.onFrame;\n      this.context = context;\n      this.objectModifier = options.objectModifier;\n      this.worldModifier = options.worldModifier;\n      this.enableLod = options.enableLod;\n      this.lodScale = options.lodScale ?? 1;\n      this.outsideFoveate = options.outsideFoveate;\n      this.behindFoveate = options.behindFoveate;\n      this.updateGenerator();\n      if (options.url || options.fileBytes || options.constructSplats || options.packedSplats && !options.packedSplats.isInitialized) {\n        this.initialized = this.asyncInitialize(options).then(async () => {\n          this.updateGenerator();\n          this.isInitialized = true;\n          if (options.onLoad) {\n            const maybePromise = options.onLoad(this);\n            if (maybePromise instanceof Promise) {\n              await maybePromise;\n            }\n          }\n          return this;\n        });\n      } else {\n        this.isInitialized = true;\n        this.initialized = Promise.resolve(this);\n        if (options.onLoad) {\n          const maybePromise = options.onLoad(this);\n          if (maybePromise instanceof Promise) {\n            this.initialized = maybePromise.then(() => this);\n          }\n        }\n      }\n    }\n    async asyncInitialize(options) {\n      const {\n        url,\n        fileBytes,\n        fileType,\n        fileName,\n        maxSplats,\n        constructSplats,\n        onProgress,\n        splatEncoding,\n        lod,\n        nonLod\n      } = options;\n      if (url || fileBytes || constructSplats) {\n        const packedSplatsOptions = {\n          url,\n          fileBytes,\n          fileType,\n          fileName,\n          maxSplats,\n          construct: constructSplats,\n          onProgress,\n          splatEncoding,\n          lod,\n          nonLod\n        };\n        this.packedSplats.reinitialize(packedSplatsOptions);\n      }\n      if (this.packedSplats) {\n        await this.packedSplats.initialized;\n        this.numSplats = this.packedSplats.numSplats;\n        this.updateGenerator();\n      }\n    }\n    static async staticInitialize() {\n      await __wbg_init();\n      _SplatMesh.isStaticInitialized = true;\n    }\n    // Creates a new Gsplat with the provided parameters (all values in "float" space,\n    // i.e. 0-1 for opacity and color) and adds it to the end of the packedSplats,\n    // increasing numSplats by 1. If necessary, reallocates the buffer with an exponential\n    // doubling strategy to fit the new data, so it\'s fairly efficient to just\n    // pushSplat(...) each Gsplat you want to create in a loop.\n    pushSplat(center, scales, quaternion, opacity, color) {\n      this.packedSplats.pushSplat(center, scales, quaternion, opacity, color);\n    }\n    // This method iterates over all Gsplats in this instance\'s packedSplats,\n    // invoking the provided callback with index: number in 0..=(this.numSplats-1) and\n    // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\n    // opacity: number (0..1), and color: THREE.Color (rgb values in 0..1).\n    // Note that the objects passed in as center etc. are the same for every callback\n    // invocation: these objects are reused for efficiency. Changing these values has\n    // no effect as they are decoded/unpacked copies of the underlying data. To update\n    // the packedSplats, call .packedSplats.setSplat(index, center, scales,\n    // quaternion, opacity, color).\n    forEachSplat(callback) {\n      this.packedSplats.forEachSplat(callback);\n    }\n    // Call this when you are finished with the SplatMesh and want to free\n    // any buffers it holds (via packedSplats).\n    dispose() {\n      this.packedSplats.dispose();\n    }\n    // Returns axis-aligned bounding box of the SplatMesh. If centers_only is true,\n    // only the centers of the splats are used to compute the bounding box.\n    // IMPORTANT: This should only be called after the SplatMesh is initialized.\n    getBoundingBox(centers_only = true) {\n      if (!this.initialized) {\n        throw new Error(\n          "Cannot get bounding box before SplatMesh is initialized"\n        );\n      }\n      const minVec = new Vector3(\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY\n      );\n      const maxVec = new Vector3(\n        Number.NEGATIVE_INFINITY,\n        Number.NEGATIVE_INFINITY,\n        Number.NEGATIVE_INFINITY\n      );\n      const corners = new Vector3();\n      const signs = [-1, 1];\n      this.packedSplats.forEachSplat(\n        (_index, center, scales, quaternion, _opacity, _color2) => {\n          if (centers_only) {\n            minVec.min(center);\n            maxVec.max(center);\n          } else {\n            for (const x2 of signs) {\n              for (const y of signs) {\n                for (const z of signs) {\n                  corners.set(x2 * scales.x, y * scales.y, z * scales.z);\n                  corners.applyQuaternion(quaternion);\n                  corners.add(center);\n                  minVec.min(corners);\n                  maxVec.max(corners);\n                }\n              }\n            }\n          }\n        }\n      );\n      const box = new Box3(minVec, maxVec);\n      return box;\n    }\n    constructGenerator(context) {\n      const { transform, viewToObject, recolor } = context;\n      const generator = dynoBlock(\n        { index: "int" },\n        { gsplat: Gsplat },\n        ({ index }) => {\n          if (!index) {\n            throw new Error("index is undefined");\n          }\n          index = maybeLookupIndex(\n            context.lodIndices,\n            index,\n            context.numSplats,\n            context.enableLod\n          );\n          let gsplat = readPackedSplat(context.splats, index);\n          if (this.maxSh >= 1) {\n            const { sh1Texture, sh2Texture, sh3Texture } = this.ensureShTextures();\n            if (sh1Texture) {\n              let rescaleSh = function(sNorm, minMax) {\n                const { x: min, y: max2 } = split(minMax).outputs;\n                const mid = mul(add(min, max2), dynoConst("float", 0.5));\n                const scale = mul(sub(max2, min), dynoConst("float", 0.5));\n                return add(mid, mul(sNorm, scale));\n              };\n              const viewCenterInObject = viewToObject.translate;\n              const { center } = splitGsplat(gsplat).outputs;\n              const viewDir = normalize(sub(center, viewCenterInObject));\n              const sh1Snorm = evaluateSH1(gsplat, sh1Texture, viewDir);\n              let rgb = rescaleSh(sh1Snorm, this.packedSplats.dynoSh1MinMax);\n              if (this.maxSh >= 2 && sh2Texture) {\n                const sh2Snorm = evaluateSH2(gsplat, sh2Texture, viewDir);\n                rgb = add(\n                  rgb,\n                  rescaleSh(sh2Snorm, this.packedSplats.dynoSh2MinMax)\n                );\n              }\n              if (this.maxSh >= 3 && sh3Texture) {\n                const sh3Snorm = evaluateSH3(gsplat, sh3Texture, viewDir);\n                rgb = add(\n                  rgb,\n                  rescaleSh(sh3Snorm, this.packedSplats.dynoSh3MinMax)\n                );\n              }\n              let { rgba } = splitGsplat(gsplat).outputs;\n              rgba = add(rgba, extendVec(rgb, dynoConst("float", 0)));\n              gsplat = combineGsplat({ gsplat, rgba });\n            }\n          }\n          if (this.splatRgba) {\n            const rgba = readRgbaArray(this.splatRgba.dyno, index);\n            gsplat = combineGsplat({ gsplat, rgba });\n          }\n          if (this.skinning) {\n            gsplat = this.skinning.modify(gsplat);\n          }\n          if (this.objectModifier) {\n            gsplat = this.objectModifier.apply({ gsplat }).gsplat;\n          }\n          gsplat = transform.applyGsplat(gsplat);\n          const recolorRgba = mul(recolor, splitGsplat(gsplat).outputs.rgba);\n          gsplat = combineGsplat({ gsplat, rgba: recolorRgba });\n          if (this.rgbaDisplaceEdits) {\n            gsplat = this.rgbaDisplaceEdits.modify(gsplat);\n          }\n          if (this.worldModifier) {\n            gsplat = this.worldModifier.apply({ gsplat }).gsplat;\n          }\n          return { gsplat };\n        }\n      );\n      this.generator = generator;\n    }\n    // Call this whenever something changes in the Gsplat processing pipeline,\n    // for example changing maxSh or updating objectModifier or worldModifier.\n    // Compiled generators are cached for efficiency and re-use when the same\n    // pipeline structure emerges after successive changes.\n    updateGenerator() {\n      this.constructGenerator(this.context);\n    }\n    // This is called automatically by SparkRenderer and you should not have to\n    // call it. It updates parameters for the generated pipeline and calls\n    // updateGenerator() if the pipeline needs to change.\n    update({\n      renderer,\n      time,\n      deltaTime,\n      viewToWorld,\n      camera,\n      renderSize,\n      globalEdits,\n      lodIndices\n    }) {\n      var _a2;\n      this.context.time.value = time;\n      this.context.deltaTime.value = deltaTime;\n      _SplatMesh.dynoTime.value = time;\n      const { transform, viewToObject, recolor } = this.context;\n      let updated = transform.update(this);\n      if (this.context.viewToWorld.updateFromMatrix(viewToWorld) && this.enableViewToWorld) {\n        updated = true;\n      }\n      const worldToView = viewToWorld.clone().invert();\n      if (this.context.worldToView.updateFromMatrix(worldToView) && this.enableWorldToView) {\n        updated = true;\n      }\n      const objectToWorld = new Matrix4().compose(\n        transform.translate.value,\n        transform.rotate.value,\n        new Vector3().setScalar(transform.scale.value)\n      );\n      const worldToObject = objectToWorld.invert();\n      const viewToObjectMatrix = worldToObject.multiply(viewToWorld);\n      if (viewToObject.updateFromMatrix(viewToObjectMatrix) && (this.enableViewToObject || this.packedSplats.extra.sh1)) {\n        updated = true;\n      }\n      new Vector3().setFromMatrixColumn(\n        viewToObjectMatrix,\n        3\n      );\n      new Vector3().setFromMatrixColumn(viewToObjectMatrix, 2).negate().normalize();\n      const newRecolor = new Vector4(\n        this.recolor.r,\n        this.recolor.g,\n        this.recolor.b,\n        this.opacity\n      );\n      if (!newRecolor.equals(recolor.value)) {\n        recolor.value.copy(newRecolor);\n        updated = true;\n      }\n      const edits = this.editable ? (this.edits ?? []).concat(globalEdits) : [];\n      if (this.editable && !this.edits) {\n        this.traverseVisible((node) => {\n          if (node instanceof SplatEdit) {\n            edits.push(node);\n          }\n        });\n      }\n      edits.sort((a, b) => a.ordering - b.ordering);\n      const editsSdfs = edits.map((edit) => {\n        if (edit.sdfs != null) {\n          return { edit, sdfs: edit.sdfs };\n        }\n        const sdfs = [];\n        edit.traverseVisible((node) => {\n          if (node instanceof SplatEditSdf) {\n            sdfs.push(node);\n          }\n        });\n        return { edit, sdfs };\n      });\n      if (editsSdfs.length > 0 && !this.rgbaDisplaceEdits) {\n        const edits2 = editsSdfs.length;\n        const sdfs = editsSdfs.reduce(\n          (total, edit) => total + edit.sdfs.length,\n          0\n        );\n        this.rgbaDisplaceEdits = new SplatEdits({\n          maxEdits: edits2,\n          maxSdfs: sdfs\n        });\n        this.updateGenerator();\n      }\n      if (this.rgbaDisplaceEdits) {\n        const editResult = this.rgbaDisplaceEdits.update(editsSdfs);\n        updated || (updated = editResult.updated);\n        if (editResult.dynoUpdated) {\n          this.updateGenerator();\n        }\n      }\n      this.context.enableLod.value = this.packedSplats.lodSplats != null && lodIndices != null;\n      if (this.enableLod !== void 0) {\n        this.context.enableLod.value = this.enableLod;\n      }\n      this.context.lodIndices.value = (lodIndices == null ? void 0 : lodIndices.texture) ?? emptyLodIndices;\n      this.context.splats.packedSplats = this.packedSplats;\n      this.numSplats = this.packedSplats.numSplats;\n      if (this.context.enableLod.value) {\n        this.context.splats.packedSplats = this.packedSplats.lodSplats;\n        this.numSplats = (lodIndices == null ? void 0 : lodIndices.numSplats) ?? 0;\n      }\n      this.context.numSplats.value = this.numSplats;\n      if (updated) {\n        this.updateVersion();\n      }\n      (_a2 = this.onFrame) == null ? void 0 : _a2.call(this, { mesh: this, time, deltaTime });\n    }\n    // This method conforms to the standard THREE.Raycaster API, performing object-ray\n    // intersections using this method to populate the provided intersects[] array\n    // with each intersection point.\n    raycast(raycaster, intersects) {\n      var _a2, _b2;\n      if (!this.packedSplats.packedArray || !this.packedSplats.numSplats) {\n        return;\n      }\n      const { near, far, ray } = raycaster;\n      const worldToMesh = this.matrixWorld.clone().invert();\n      const worldToMeshRot = new Matrix3().setFromMatrix4(worldToMesh);\n      const origin = ray.origin.clone().applyMatrix4(worldToMesh);\n      const direction = ray.direction.clone().applyMatrix3(worldToMeshRot);\n      const scales = new Vector3();\n      worldToMesh.decompose(new Vector3(), new Quaternion(), scales);\n      const RAYCAST_ELLIPSOID = true;\n      const distances = raycast_splats(\n        origin.x,\n        origin.y,\n        origin.z,\n        direction.x,\n        direction.y,\n        direction.z,\n        near,\n        far,\n        this.packedSplats.numSplats,\n        this.packedSplats.packedArray,\n        RAYCAST_ELLIPSOID,\n        ((_a2 = this.packedSplats.splatEncoding) == null ? void 0 : _a2.lnScaleMin) ?? LN_SCALE_MIN,\n        ((_b2 = this.packedSplats.splatEncoding) == null ? void 0 : _b2.lnScaleMax) ?? LN_SCALE_MAX\n      );\n      for (const distance of distances) {\n        const point = ray.direction.clone().multiplyScalar(distance).add(ray.origin);\n        intersects.push({\n          distance,\n          point,\n          object: this\n        });\n      }\n    }\n    ensureShTextures() {\n      if (!this.packedSplats.extra.sh1) {\n        return {};\n      }\n      let sh1Texture = this.packedSplats.extra.sh1Texture;\n      if (!sh1Texture) {\n        let sh1 = this.packedSplats.extra.sh1;\n        const { width, height, depth, maxSplats } = getTextureSize(\n          sh1.length / 2\n        );\n        if (sh1.length < maxSplats * 2) {\n          const newSh1 = new Uint32Array(maxSplats * 2);\n          newSh1.set(sh1);\n          this.packedSplats.extra.sh1 = newSh1;\n          sh1 = newSh1;\n        }\n        const texture = new DataArrayTexture(sh1, width, height, depth);\n        texture.format = RGIntegerFormat;\n        texture.type = UnsignedIntType;\n        texture.internalFormat = "RG32UI";\n        texture.needsUpdate = true;\n        sh1Texture = new DynoUsampler2DArray({\n          value: texture,\n          key: "sh1"\n        });\n        this.packedSplats.extra.sh1Texture = sh1Texture;\n      }\n      if (!this.packedSplats.extra.sh2) {\n        return { sh1Texture };\n      }\n      let sh2Texture = this.packedSplats.extra.sh2Texture;\n      if (!sh2Texture) {\n        let sh2 = this.packedSplats.extra.sh2;\n        const { width, height, depth, maxSplats } = getTextureSize(\n          sh2.length / 4\n        );\n        if (sh2.length < maxSplats * 4) {\n          const newSh2 = new Uint32Array(maxSplats * 4);\n          newSh2.set(sh2);\n          this.packedSplats.extra.sh2 = newSh2;\n          sh2 = newSh2;\n        }\n        const texture = new DataArrayTexture(sh2, width, height, depth);\n        texture.format = RGBAIntegerFormat;\n        texture.type = UnsignedIntType;\n        texture.internalFormat = "RGBA32UI";\n        texture.needsUpdate = true;\n        sh2Texture = new DynoUsampler2DArray({\n          value: texture,\n          key: "sh2"\n        });\n        this.packedSplats.extra.sh2Texture = sh2Texture;\n      }\n      if (!this.packedSplats.extra.sh3) {\n        return { sh1Texture, sh2Texture };\n      }\n      let sh3Texture = this.packedSplats.extra.sh3Texture;\n      if (!sh3Texture) {\n        let sh3 = this.packedSplats.extra.sh3;\n        const { width, height, depth, maxSplats } = getTextureSize(\n          sh3.length / 4\n        );\n        if (sh3.length < maxSplats * 4) {\n          const newSh3 = new Uint32Array(maxSplats * 4);\n          newSh3.set(sh3);\n          this.packedSplats.extra.sh3 = newSh3;\n          sh3 = newSh3;\n        }\n        const texture = new DataArrayTexture(sh3, width, height, depth);\n        texture.format = RGBAIntegerFormat;\n        texture.type = UnsignedIntType;\n        texture.internalFormat = "RGBA32UI";\n        texture.needsUpdate = true;\n        sh3Texture = new DynoUsampler2DArray({\n          value: texture,\n          key: "sh3"\n        });\n        this.packedSplats.extra.sh3Texture = sh3Texture;\n      }\n      return { sh1Texture, sh2Texture, sh3Texture };\n    }\n    // ensureLodIndices() {\n    //   if (this.lodState) {\n    //     const maxSplats = Math.min(this.packedSplats.numSplats, 16 * 1048576);\n    //     const numSplats = Math.max(16384, Math.min(this.lodMaxSplats, maxSplats));\n    //     const rows = Math.ceil(numSplats / 16384);\n    //     const capacity = rows * 16384;\n    //     if (capacity > this.lodState.indices.length) {\n    //       this.context.lodIndices.value.dispose();\n    //       this.lodState.indices = new Uint32Array(capacity);\n    //       this.context.lodIndices.value = new THREE.DataTexture(\n    //         this.lodState.indices,\n    //         4096,\n    //         rows,\n    //         THREE.RGBAIntegerFormat,\n    //         THREE.UnsignedIntType,\n    //       );\n    //       this.context.lodIndices.value.internalFormat = "RGBA32UI";\n    //       this.context.lodIndices.value.needsUpdate = true;\n    //     }\n    //   }\n    // }\n  };\n  _SplatMesh.staticInitialized = _SplatMesh.staticInitialize();\n  _SplatMesh.isStaticInitialized = false;\n  _SplatMesh.dynoTime = new DynoFloat({ value: 0 });\n  let SplatMesh = _SplatMesh;\n  const defineEvaluateSH1 = unindent(`\n  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {\n    // Extract sint7 values packed into 2 x uint32\n    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;\n    vec3 sh1_0 = vec3(ivec3(\n      int(packed.x << 25u) >> 25,\n      int(packed.x << 18u) >> 25,\n      int(packed.x << 11u) >> 25\n    )) / 63.0;\n    vec3 sh1_1 = vec3(ivec3(\n      int(packed.x << 4u) >> 25,\n      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,\n      int(packed.y << 22u) >> 25\n    )) / 63.0;\n    vec3 sh1_2 = vec3(ivec3(\n      int(packed.y << 15u) >> 25,\n      int(packed.y << 8u) >> 25,\n      int(packed.y << 1u) >> 25\n    )) / 63.0;\n\n    return sh1_0 * (-0.4886025 * viewDir.y)\n      + sh1_1 * (0.4886025 * viewDir.z)\n      + sh1_2 * (-0.4886025 * viewDir.x);\n  }\n`);\n  const defineEvaluateSH2 = unindent(`\n  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {\n    // Extract sint8 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);\n    vec3 sh2_0 = vec3(ivec3(\n      int(packed.x << 24u) >> 24,\n      int(packed.x << 16u) >> 24,\n      int(packed.x << 8u) >> 24\n    )) / 127.0;\n    vec3 sh2_1 = vec3(ivec3(\n      int(packed.x) >> 24,\n      int(packed.y << 24u) >> 24,\n      int(packed.y << 16u) >> 24\n    )) / 127.0;\n    vec3 sh2_2 = vec3(ivec3(\n      int(packed.y << 8u) >> 24,\n      int(packed.y) >> 24,\n      int(packed.z << 24u) >> 24\n    )) / 127.0;\n    vec3 sh2_3 = vec3(ivec3(\n      int(packed.z << 16u) >> 24,\n      int(packed.z << 8u) >> 24,\n      int(packed.z) >> 24\n    )) / 127.0;\n    vec3 sh2_4 = vec3(ivec3(\n      int(packed.w << 24u) >> 24,\n      int(packed.w << 16u) >> 24,\n      int(packed.w << 8u) >> 24\n    )) / 127.0;\n\n    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)\n      + sh2_1 * (-1.0925484 * viewDir.y * viewDir.z)\n      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))\n      + sh2_3 * (-1.0925484 * viewDir.x * viewDir.z)\n      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));\n  }\n`);\n  const defineEvaluateSH3 = unindent(`\n  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {\n    // Extract sint6 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);\n    vec3 sh3_0 = vec3(ivec3(\n      int(packed.x << 26u) >> 26,\n      int(packed.x << 20u) >> 26,\n      int(packed.x << 14u) >> 26\n    )) / 31.0;\n    vec3 sh3_1 = vec3(ivec3(\n      int(packed.x << 8u) >> 26,\n      int(packed.x << 2u) >> 26,\n      int((packed.x >> 4u) | (packed.y << 28u)) >> 26\n    )) / 31.0;\n    vec3 sh3_2 = vec3(ivec3(\n      int(packed.y << 22u) >> 26,\n      int(packed.y << 16u) >> 26,\n      int(packed.y << 10u) >> 26\n    )) / 31.0;\n    vec3 sh3_3 = vec3(ivec3(\n      int(packed.y << 4u) >> 26,\n      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,\n      int(packed.z << 24u) >> 26\n    )) / 31.0;\n    vec3 sh3_4 = vec3(ivec3(\n      int(packed.z << 18u) >> 26,\n      int(packed.z << 12u) >> 26,\n      int(packed.z << 6u) >> 26\n    )) / 31.0;\n    vec3 sh3_5 = vec3(ivec3(\n      int(packed.z) >> 26,\n      int(packed.w << 26u) >> 26,\n      int(packed.w << 20u) >> 26\n    )) / 31.0;\n    vec3 sh3_6 = vec3(ivec3(\n      int(packed.w << 14u) >> 26,\n      int(packed.w << 8u) >> 26,\n      int(packed.w << 2u) >> 26\n    )) / 31.0;\n\n    float xx = viewDir.x * viewDir.x;\n    float yy = viewDir.y * viewDir.y;\n    float zz = viewDir.z * viewDir.z;\n    float xy = viewDir.x * viewDir.y;\n    float yz = viewDir.y * viewDir.z;\n    float zx = viewDir.z * viewDir.x;\n\n    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))\n      + sh3_1 * (2.8906114 * xy * viewDir.z) +\n      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))\n      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))\n      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))\n      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))\n      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));\n  }\n`);\n  function evaluateSH1(gsplat, sh1, viewDir) {\n    return dyno({\n      inTypes: { gsplat: Gsplat, sh1: "usampler2DArray", viewDir: "vec3" },\n      outTypes: { rgb: "vec3" },\n      inputs: { gsplat, sh1, viewDir },\n      globals: () => [defineGsplat, defineEvaluateSH1],\n      statements: ({ inputs, outputs }) => {\n        const statements = unindentLines(`\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\n          ${outputs.rgb} = evaluateSH1(${inputs.gsplat}, ${inputs.sh1}, ${inputs.viewDir});\n        } else {\n          ${outputs.rgb} = vec3(0.0);\n        }\n      `);\n        return statements;\n      }\n    }).outputs.rgb;\n  }\n  function evaluateSH2(gsplat, sh2, viewDir) {\n    return dyno({\n      inTypes: { gsplat: Gsplat, sh2: "usampler2DArray", viewDir: "vec3" },\n      outTypes: { rgb: "vec3" },\n      inputs: { gsplat, sh2, viewDir },\n      globals: () => [defineGsplat, defineEvaluateSH2],\n      statements: ({ inputs, outputs }) => unindentLines(`\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\n          ${outputs.rgb} = evaluateSH2(${inputs.gsplat}, ${inputs.sh2}, ${inputs.viewDir});\n        } else {\n          ${outputs.rgb} = vec3(0.0);\n        }\n      `)\n    }).outputs.rgb;\n  }\n  function evaluateSH3(gsplat, sh3, viewDir) {\n    return dyno({\n      inTypes: { gsplat: Gsplat, sh3: "usampler2DArray", viewDir: "vec3" },\n      outTypes: { rgb: "vec3" },\n      inputs: { gsplat, sh3, viewDir },\n      globals: () => [defineGsplat, defineEvaluateSH3],\n      statements: ({ inputs, outputs }) => unindentLines(`\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\n          ${outputs.rgb} = evaluateSH3(${inputs.gsplat}, ${inputs.sh3}, ${inputs.viewDir});\n        } else {\n          ${outputs.rgb} = vec3(0.0);\n        }\n      `)\n    }).outputs.rgb;\n  }\n  function maybeLookupIndex(lodIndices, index, numSplats, enableLod) {\n    return dyno({\n      inTypes: {\n        lodIndices: "usampler2D",\n        index: "int",\n        numSplats: "int",\n        enableLod: "bool"\n      },\n      outTypes: {\n        index: "int"\n      },\n      inputs: {\n        lodIndices,\n        index,\n        numSplats,\n        enableLod\n      },\n      statements: ({ inputs, outputs }) => unindentLines(`\n        if (${inputs.index} >= ${inputs.numSplats}) {\n          return;\n        }\n        if (${inputs.enableLod}) {\n          ivec2 lodIndexCoord = ivec2((${inputs.index} >> 2) & 4095, ${inputs.index} >> 14);\n          uint splatIndex = texelFetch(${inputs.lodIndices}, lodIndexCoord, 0)[${inputs.index} & 3];\n          ${outputs.index} = int(splatIndex);\n        } else {\n          ${outputs.index} = ${inputs.index};\n        }\n      `)\n    }).outputs.index;\n  }\n  const emptyLodIndices = (() => {\n    const texture = new DataTexture(\n      new Uint32Array(16384),\n      4096,\n      1,\n      RGBAIntegerFormat,\n      UnsignedIntType\n    );\n    texture.internalFormat = "RGBA32UI";\n    texture.needsUpdate = true;\n    return texture;\n  })();\n  new BufferGeometry();\n  new ShaderMaterial();\n  const PLY_PROPERTY_TYPES = [\n    "char",\n    "uchar",\n    "short",\n    "ushort",\n    "int",\n    "uint",\n    "float",\n    "double"\n  ];\n  const _PlyReader = class _PlyReader {\n    // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet\n    constructor({ fileBytes }) {\n      this.header = "";\n      this.littleEndian = true;\n      this.elements = {};\n      this.comments = [];\n      this.data = null;\n      this.numSplats = 0;\n      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\n    }\n    // Identify and parse the PLY text header (assumed to be <64KB in size).\n    // this.elements will contain all the elements in the file, typically\n    // "vertex" contains the Gsplat data.\n    async parseHeader() {\n      const bufferStream = new ReadableStream({\n        start: (controller) => {\n          controller.enqueue(this.fileBytes.slice(0, 65536));\n          controller.close();\n        }\n      });\n      const decoder = bufferStream.pipeThrough(new TextDecoderStream()).getReader();\n      this.header = "";\n      const headerTerminator = "end_header\\n";\n      while (true) {\n        const { value, done } = await decoder.read();\n        if (done) {\n          throw new Error("Failed to read header");\n        }\n        this.header += value;\n        const endHeader = this.header.indexOf(headerTerminator);\n        if (endHeader >= 0) {\n          this.header = this.header.slice(0, endHeader + headerTerminator.length);\n          break;\n        }\n      }\n      const headerLen = new TextEncoder().encode(this.header).length;\n      this.data = new DataView(this.fileBytes.buffer, headerLen);\n      this.elements = {};\n      let curElement = null;\n      this.comments = [];\n      this.header.trim().split("\\n").forEach((line, lineIndex) => {\n        const trimmedLine = line.trim();\n        if (lineIndex === 0) {\n          if (trimmedLine !== "ply") {\n            throw new Error("Invalid PLY header");\n          }\n          return;\n        }\n        if (trimmedLine.length === 0) {\n          return;\n        }\n        const fields = trimmedLine.split(" ");\n        switch (fields[0]) {\n          case "format":\n            if (fields[1] === "binary_little_endian") {\n              this.littleEndian = true;\n            } else if (fields[1] === "binary_big_endian") {\n              this.littleEndian = false;\n            } else {\n              throw new Error(`Unsupported PLY format: ${fields[1]}`);\n            }\n            if (fields[2] !== "1.0") {\n              throw new Error(`Unsupported PLY version: ${fields[2]}`);\n            }\n            break;\n          case "end_header":\n            break;\n          case "comment":\n            this.comments.push(trimmedLine.slice("comment ".length));\n            break;\n          case "element": {\n            const name = fields[1];\n            curElement = {\n              name,\n              count: Number.parseInt(fields[2]),\n              properties: {}\n            };\n            this.elements[name] = curElement;\n            break;\n          }\n          case "property":\n            if (curElement == null) {\n              throw new Error("Property must be inside an element");\n            }\n            if (fields[1] === "list") {\n              curElement.properties[fields[4]] = {\n                isList: true,\n                type: fields[3],\n                countType: fields[2]\n              };\n            } else {\n              curElement.properties[fields[2]] = {\n                isList: false,\n                type: fields[1]\n              };\n            }\n            break;\n        }\n      });\n      if (this.elements.vertex) {\n        this.numSplats = this.elements.vertex.count;\n      }\n    }\n    parseData(elementCallback) {\n      let offset = 0;\n      const data = this.data;\n      if (data == null) {\n        throw new Error("No data to parse");\n      }\n      for (const elementName in this.elements) {\n        const element = this.elements[elementName];\n        const { count, properties } = element;\n        const item = createEmptyItem(properties);\n        const parseFn = createParseFn(properties, this.littleEndian);\n        const callback = elementCallback(element) ?? (() => {\n        });\n        for (let index = 0; index < count; index++) {\n          offset = parseFn(data, offset, item);\n          callback(index, item);\n        }\n      }\n    }\n    // Parse all the Gsplat data in the PLY file in go, invoking the given\n    // callbacks for each Gsplat.\n    parseSplats(splatCallback, shCallback) {\n      if (this.elements.vertex == null) {\n        throw new Error("No vertex element found");\n      }\n      let isSuperSplat = false;\n      const ssChunks = [];\n      let numSh = 0;\n      let sh1Props = [];\n      let sh2Props = [];\n      let sh3Props = [];\n      let sh1 = void 0;\n      let sh2 = void 0;\n      let sh3 = void 0;\n      function prepareSh() {\n        const num_f_rest = NUM_SH_TO_NUM_F_REST[numSh];\n        sh1Props = new Array(3).fill(null).flatMap((_, k) => [0, 1, 2].map((_2, d) => k + d * num_f_rest / 3));\n        sh2Props = new Array(5).fill(null).flatMap(\n          (_, k) => [0, 1, 2].map((_2, d) => 3 + k + d * num_f_rest / 3)\n        );\n        sh3Props = new Array(7).fill(null).flatMap(\n          (_, k) => [0, 1, 2].map((_2, d) => 8 + k + d * num_f_rest / 3)\n        );\n        sh1 = numSh >= 1 ? new Float32Array(3 * 3) : void 0;\n        sh2 = numSh >= 2 ? new Float32Array(5 * 3) : void 0;\n        sh3 = numSh >= 3 ? new Float32Array(7 * 3) : void 0;\n      }\n      function ssShCallback(index, item) {\n        if (!sh1) {\n          throw new Error("Missing sh1");\n        }\n        const sh = item.f_rest;\n        for (let i2 = 0; i2 < sh1Props.length; i2++) {\n          sh1[i2] = sh[sh1Props[i2]] * 8 / 255 - 4;\n        }\n        if (sh2) {\n          for (let i2 = 0; i2 < sh2Props.length; i2++) {\n            sh2[i2] = sh[sh2Props[i2]] * 8 / 255 - 4;\n          }\n        }\n        if (sh3) {\n          for (let i2 = 0; i2 < sh3Props.length; i2++) {\n            sh3[i2] = sh[sh3Props[i2]] * 8 / 255 - 4;\n          }\n        }\n        shCallback == null ? void 0 : shCallback(index, sh1, sh2, sh3);\n      }\n      function initSuperSplat(element) {\n        const {\n          min_x,\n          min_y,\n          min_z,\n          max_x,\n          max_y,\n          max_z,\n          min_scale_x,\n          min_scale_y,\n          min_scale_z,\n          max_scale_x,\n          max_scale_y,\n          max_scale_z\n        } = element.properties;\n        if (!min_x || !min_y || !min_z || !max_x || !max_y || !max_z || !min_scale_x || !min_scale_y || !min_scale_z || !max_scale_x || !max_scale_y || !max_scale_z) {\n          throw new Error("Missing PLY chunk properties");\n        }\n        isSuperSplat = true;\n        return (index, item) => {\n          const {\n            min_x: min_x2,\n            min_y: min_y2,\n            min_z: min_z2,\n            max_x: max_x2,\n            max_y: max_y2,\n            max_z: max_z2,\n            min_scale_x: min_scale_x2,\n            min_scale_y: min_scale_y2,\n            min_scale_z: min_scale_z2,\n            max_scale_x: max_scale_x2,\n            max_scale_y: max_scale_y2,\n            max_scale_z: max_scale_z2,\n            min_r,\n            min_g,\n            min_b,\n            max_r,\n            max_g,\n            max_b\n          } = item;\n          ssChunks.push({\n            min_x: min_x2,\n            min_y: min_y2,\n            min_z: min_z2,\n            max_x: max_x2,\n            max_y: max_y2,\n            max_z: max_z2,\n            min_scale_x: min_scale_x2,\n            min_scale_y: min_scale_y2,\n            min_scale_z: min_scale_z2,\n            max_scale_x: max_scale_x2,\n            max_scale_y: max_scale_y2,\n            max_scale_z: max_scale_z2,\n            min_r,\n            min_g,\n            min_b,\n            max_r,\n            max_g,\n            max_b\n          });\n        };\n      }\n      function decodeSuperSplat(element) {\n        if (shCallback && element.name === "sh") {\n          numSh = getNumSh(element.properties);\n          prepareSh();\n          return ssShCallback;\n        }\n        if (element.name !== "vertex") {\n          return null;\n        }\n        const { packed_position, packed_rotation, packed_scale, packed_color } = element.properties;\n        if (!packed_position || !packed_rotation || !packed_scale || !packed_color) {\n          throw new Error(\n            "Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color"\n          );\n        }\n        const SQRT2 = Math.sqrt(2);\n        return (index, item) => {\n          const chunk = ssChunks[index >>> 8];\n          if (chunk == null) {\n            throw new Error("Missing PLY chunk");\n          }\n          const {\n            min_x,\n            min_y,\n            min_z,\n            max_x,\n            max_y,\n            max_z,\n            min_scale_x,\n            min_scale_y,\n            min_scale_z,\n            max_scale_x,\n            max_scale_y,\n            max_scale_z,\n            min_r,\n            min_g,\n            min_b,\n            max_r,\n            max_g,\n            max_b\n          } = chunk;\n          const { packed_position: packed_position2, packed_rotation: packed_rotation2, packed_scale: packed_scale2, packed_color: packed_color2 } = item;\n          const x2 = (packed_position2 >>> 21 & 2047) / 2047 * (max_x - min_x) + min_x;\n          const y = (packed_position2 >>> 11 & 1023) / 1023 * (max_y - min_y) + min_y;\n          const z = (packed_position2 & 2047) / 2047 * (max_z - min_z) + min_z;\n          const r0 = ((packed_rotation2 >>> 20 & 1023) / 1023 - 0.5) * SQRT2;\n          const r1 = ((packed_rotation2 >>> 10 & 1023) / 1023 - 0.5) * SQRT2;\n          const r2 = ((packed_rotation2 & 1023) / 1023 - 0.5) * SQRT2;\n          const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));\n          const rOrder = packed_rotation2 >>> 30;\n          const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\n          const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;\n          const quatZ = rOrder <= 2 ? r2 : rr;\n          const quatW = rOrder === 0 ? rr : r0;\n          const scaleX = Math.exp(\n            (packed_scale2 >>> 21 & 2047) / 2047 * (max_scale_x - min_scale_x) + min_scale_x\n          );\n          const scaleY = Math.exp(\n            (packed_scale2 >>> 11 & 1023) / 1023 * (max_scale_y - min_scale_y) + min_scale_y\n          );\n          const scaleZ = Math.exp(\n            (packed_scale2 & 2047) / 2047 * (max_scale_z - min_scale_z) + min_scale_z\n          );\n          const r = (packed_color2 >>> 24 & 255) / 255 * ((max_r ?? 1) - (min_r ?? 0)) + (min_r ?? 0);\n          const g = (packed_color2 >>> 16 & 255) / 255 * ((max_g ?? 1) - (min_g ?? 0)) + (min_g ?? 0);\n          const b = (packed_color2 >>> 8 & 255) / 255 * ((max_b ?? 1) - (min_b ?? 0)) + (min_b ?? 0);\n          const opacity = (packed_color2 & 255) / 255;\n          splatCallback(\n            index,\n            x2,\n            y,\n            z,\n            scaleX,\n            scaleY,\n            scaleZ,\n            quatX,\n            quatY,\n            quatZ,\n            quatW,\n            opacity,\n            r,\n            g,\n            b\n          );\n        };\n      }\n      const elementCallback = (element) => {\n        if (element.name === "chunk") {\n          return initSuperSplat(element);\n        }\n        if (isSuperSplat) {\n          return decodeSuperSplat(element);\n        }\n        if (element.name !== "vertex") {\n          return null;\n        }\n        const {\n          x: x2,\n          y,\n          z,\n          scale_0,\n          scale_1,\n          scale_2,\n          rot_0,\n          rot_1,\n          rot_2,\n          rot_3,\n          opacity,\n          f_dc_0,\n          f_dc_1,\n          f_dc_2,\n          red,\n          green,\n          blue,\n          alpha\n        } = element.properties;\n        if (!x2 || !y || !z) {\n          throw new Error("Missing PLY properties: x, y, z");\n        }\n        const hasScales = scale_0 && scale_1 && scale_2;\n        const hasRots = rot_0 && rot_1 && rot_2 && rot_3;\n        const alphaDiv = alpha != null ? FIELD_SCALE[alpha.type] : 1;\n        const redDiv = red != null ? FIELD_SCALE[red.type] : 1;\n        const greenDiv = green != null ? FIELD_SCALE[green.type] : 1;\n        const blueDiv = blue != null ? FIELD_SCALE[blue.type] : 1;\n        numSh = getNumSh(element.properties);\n        prepareSh();\n        return (index, item) => {\n          const scaleX = hasScales ? Math.exp(item.scale_0) : _PlyReader.defaultPointScale;\n          const scaleY = hasScales ? Math.exp(item.scale_1) : _PlyReader.defaultPointScale;\n          const scaleZ = hasScales ? Math.exp(item.scale_2) : _PlyReader.defaultPointScale;\n          const quatX = hasRots ? item.rot_1 : 0;\n          const quatY = hasRots ? item.rot_2 : 0;\n          const quatZ = hasRots ? item.rot_3 : 0;\n          const quatW = hasRots ? item.rot_0 : 1;\n          const op = opacity != null ? 1 / (1 + Math.exp(-item.opacity)) : alpha != null ? item.alpha / alphaDiv : 1;\n          const r = f_dc_0 != null ? item.f_dc_0 * SH_C0$1 + 0.5 : red != null ? item.red / redDiv : 1;\n          const g = f_dc_1 != null ? item.f_dc_1 * SH_C0$1 + 0.5 : green != null ? item.green / greenDiv : 1;\n          const b = f_dc_2 != null ? item.f_dc_2 * SH_C0$1 + 0.5 : blue != null ? item.blue / blueDiv : 1;\n          splatCallback(\n            index,\n            item.x,\n            item.y,\n            item.z,\n            scaleX,\n            scaleY,\n            scaleZ,\n            quatX,\n            quatY,\n            quatZ,\n            quatW,\n            op,\n            r,\n            g,\n            b\n          );\n          if (shCallback && sh1) {\n            const sh = item.f_rest;\n            if (sh1) {\n              for (let i2 = 0; i2 < sh1Props.length; i2++) {\n                sh1[i2] = sh[sh1Props[i2]];\n              }\n            }\n            if (sh2) {\n              for (let i2 = 0; i2 < sh2Props.length; i2++) {\n                sh2[i2] = sh[sh2Props[i2]];\n              }\n            }\n            if (sh3) {\n              for (let i2 = 0; i2 < sh3Props.length; i2++) {\n                sh3[i2] = sh[sh3Props[i2]];\n              }\n            }\n            shCallback(index, sh1, sh2, sh3);\n          }\n        };\n      };\n      this.parseData(elementCallback);\n    }\n    // Inject RGBA values into original PLY file, which can be used to modify\n    // the color/opacity of the Gsplats and write out the modified PLY file.\n    injectRgba(rgba) {\n      let offset = 0;\n      const data = this.data;\n      if (data == null) {\n        throw new Error("No parsed data");\n      }\n      if (rgba.length !== this.numSplats * 4) {\n        throw new Error("Invalid RGBA array length");\n      }\n      for (const elementName in this.elements) {\n        const element = this.elements[elementName];\n        const { count, properties } = element;\n        const parsers = [];\n        let rgbaOffset = 0;\n        const isVertex = elementName === "vertex";\n        if (isVertex) {\n          for (const name of ["opacity", "f_dc_0", "f_dc_1", "f_dc_2"]) {\n            if (!properties[name] || properties[name].type !== "float") {\n              throw new Error(`Can\'t injectRgba due to property: ${name}`);\n            }\n          }\n        }\n        for (const [propertyName, property] of Object.entries(properties)) {\n          if (!property.isList) {\n            if (isVertex) {\n              if (propertyName === "f_dc_0" || propertyName === "f_dc_1" || propertyName === "f_dc_2") {\n                const component = Number.parseInt(\n                  propertyName.slice("f_dc_".length)\n                );\n                parsers.push(() => {\n                  const value = (rgba[rgbaOffset + component] / 255 - 0.5) / SH_C0$1;\n                  SET_FIELD[property.type](\n                    data,\n                    offset,\n                    this.littleEndian,\n                    value\n                  );\n                });\n              } else if (propertyName === "opacity") {\n                parsers.push(() => {\n                  const value = Math.max(\n                    -100,\n                    Math.min(\n                      100,\n                      -Math.log(1 / (rgba[rgbaOffset + 3] / 255) - 1)\n                    )\n                  );\n                  SET_FIELD[property.type](\n                    data,\n                    offset,\n                    this.littleEndian,\n                    value\n                  );\n                });\n              }\n            }\n            parsers.push(() => {\n              offset += FIELD_BYTES[property.type];\n            });\n          } else {\n            parsers.push(() => {\n              const length = PARSE_FIELD[property.countType](\n                data,\n                offset,\n                this.littleEndian\n              );\n              offset += FIELD_BYTES[property.countType];\n              offset += length * FIELD_BYTES[property.type];\n            });\n          }\n        }\n        for (let index = 0; index < count; index++) {\n          for (const parser of parsers) {\n            parser();\n          }\n          if (isVertex) {\n            rgbaOffset += 4;\n          }\n        }\n      }\n    }\n  };\n  _PlyReader.defaultPointScale = 1e-3;\n  let PlyReader = _PlyReader;\n  const SH_C0$1 = 0.28209479177387814;\n  const PARSE_FIELD = {\n    char: (data, offset, littleEndian) => {\n      return data.getInt8(offset);\n    },\n    uchar: (data, offset, littleEndian) => {\n      return data.getUint8(offset);\n    },\n    short: (data, offset, littleEndian) => {\n      return data.getInt16(offset, littleEndian);\n    },\n    ushort: (data, offset, littleEndian) => {\n      return data.getUint16(offset, littleEndian);\n    },\n    int: (data, offset, littleEndian) => {\n      return data.getInt32(offset, littleEndian);\n    },\n    uint: (data, offset, littleEndian) => {\n      return data.getUint32(offset, littleEndian);\n    },\n    float: (data, offset, littleEndian) => {\n      return data.getFloat32(offset, littleEndian);\n    },\n    double: (data, offset, littleEndian) => {\n      return data.getFloat64(offset, littleEndian);\n    }\n  };\n  const SET_FIELD = {\n    char: (data, offset, littleEndian, value) => {\n      data.setInt8(offset, value);\n    },\n    uchar: (data, offset, littleEndian, value) => {\n      data.setUint8(offset, value);\n    },\n    short: (data, offset, littleEndian, value) => {\n      data.setInt16(offset, value, littleEndian);\n    },\n    ushort: (data, offset, littleEndian, value) => {\n      data.setUint16(offset, value, littleEndian);\n    },\n    int: (data, offset, littleEndian, value) => {\n      data.setInt32(offset, value, littleEndian);\n    },\n    uint: (data, offset, littleEndian, value) => {\n      data.setUint32(offset, value, littleEndian);\n    },\n    float: (data, offset, littleEndian, value) => {\n      data.setFloat32(offset, value, littleEndian);\n    },\n    double: (data, offset, littleEndian, value) => {\n      data.setFloat64(offset, value, littleEndian);\n    }\n  };\n  const FIELD_BYTES = {\n    char: 1,\n    uchar: 1,\n    short: 2,\n    ushort: 2,\n    int: 4,\n    uint: 4,\n    float: 4,\n    double: 8\n  };\n  const FIELD_SCALE = {\n    char: 127,\n    uchar: 255,\n    short: 32767,\n    ushort: 65535,\n    int: 2147483647,\n    uint: 4294967295,\n    float: 1,\n    double: 1\n  };\n  const NUM_F_REST_TO_NUM_SH = {\n    0: 0,\n    9: 1,\n    24: 2,\n    45: 3\n  };\n  const NUM_SH_TO_NUM_F_REST = {\n    0: 0,\n    1: 9,\n    2: 24,\n    3: 45\n  };\n  const F_REST_REGEX = /^f_rest_([0-9]{1,2})$/;\n  function createEmptyItem(properties) {\n    const item = {};\n    for (const [propertyName, property] of Object.entries(properties)) {\n      if (F_REST_REGEX.test(propertyName)) {\n        item.f_rest = new Array(getNumSh(properties));\n      } else {\n        item[propertyName] = property.isList ? [] : 0;\n      }\n    }\n    return item;\n  }\n  function createParseFn(properties, littleEndian) {\n    if (safeToCompile(properties)) {\n      return createCompiledParserFn(properties, littleEndian);\n    }\n    return createDynamicParserFn(properties, littleEndian);\n  }\n  const UNSAFE_EVAL_ALLOWED = (() => {\n    try {\n      new Function("return 42;");\n    } catch (e) {\n      return false;\n    }\n    return true;\n  })();\n  const PROPERTY_NAME_REGEX = /^[a-zA-Z0-9_]+$/;\n  function safeToCompile(properties) {\n    if (!UNSAFE_EVAL_ALLOWED) {\n      return false;\n    }\n    for (const [propertyName, property] of Object.entries(properties)) {\n      if (!PROPERTY_NAME_REGEX.test(propertyName)) {\n        return false;\n      }\n      if (property.isList && !PLY_PROPERTY_TYPES.includes(property.countType)) {\n        return false;\n      }\n      if (!PLY_PROPERTY_TYPES.includes(property.type)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function createCompiledParserFn(properties, littleEndian) {\n    const parserSrc = ["let list;"];\n    for (const [propertyName, property] of Object.entries(properties)) {\n      const fRestMatch = propertyName.match(F_REST_REGEX);\n      if (fRestMatch) {\n        const fRestIndex = +fRestMatch[1];\n        parserSrc.push(\n          /*js*/\n          `\n        item.f_rest[${fRestIndex}] = PARSE_FIELD[\'${property.type}\'](data, offset, ${littleEndian});\n        offset += ${FIELD_BYTES[property.type]};\n      `\n        );\n      } else if (!property.isList) {\n        parserSrc.push(\n          /*js*/\n          `\n        item[\'${propertyName}\'] = PARSE_FIELD[\'${property.type}\'](data, offset, ${littleEndian});\n        offset += ${FIELD_BYTES[property.type]};\n      `\n        );\n      } else {\n        parserSrc.push(\n          /*js*/\n          `\n        list = item[\'${propertyName}\'];\n        list.length = PARSE_FIELD[\'${property.countType}\'](data, offset, ${littleEndian});\n        offset += ${FIELD_BYTES[property.countType]};\n        for (let i = 0; i < list.length; i++) {\n          list[i] = PARSE_FIELD[\'${property.type}\'](data, offset, ${littleEndian});\n          offset += ${FIELD_BYTES[property.type]};\n        }\n      `\n        );\n      }\n    }\n    parserSrc.push("return offset;");\n    const fn = new Function(\n      "data",\n      "offset",\n      "item",\n      "PARSE_FIELD",\n      parserSrc.join("\\n")\n    );\n    return (data, offset, item) => fn(data, offset, item, PARSE_FIELD);\n  }\n  function createDynamicParserFn(properties, littleEndian) {\n    const parsers = [];\n    for (const [propertyName, property] of Object.entries(properties)) {\n      const fRestMatch = propertyName.match(F_REST_REGEX);\n      if (fRestMatch) {\n        const fRestIndex = +fRestMatch[1];\n        parsers.push(\n          (data, offset, item) => {\n            item.f_rest[fRestIndex] = PARSE_FIELD[property.type](\n              data,\n              offset,\n              littleEndian\n            );\n            return offset + FIELD_BYTES[property.type];\n          }\n        );\n      } else if (!property.isList) {\n        parsers.push(\n          (data, offset, item) => {\n            item[propertyName] = PARSE_FIELD[property.type](\n              data,\n              offset,\n              littleEndian\n            );\n            return offset + FIELD_BYTES[property.type];\n          }\n        );\n      } else {\n        parsers.push(\n          (data, offset, item) => {\n            const list = item[propertyName];\n            list.length = PARSE_FIELD[property.countType](\n              data,\n              offset,\n              littleEndian\n            );\n            let currentOffset = offset + FIELD_BYTES[property.countType];\n            for (let i2 = 0; i2 < list.length; i2++) {\n              list[i2] = PARSE_FIELD[property.type](\n                data,\n                currentOffset,\n                littleEndian\n              );\n              currentOffset += FIELD_BYTES[property.type];\n            }\n            return currentOffset;\n          }\n        );\n      }\n    }\n    return (data, offset, item) => {\n      let currentOffset = offset;\n      for (let parserIndex = 0; parserIndex < parsers.length; parserIndex++) {\n        currentOffset = parsers[parserIndex](data, currentOffset, item);\n      }\n      return currentOffset;\n    };\n  }\n  function getNumSh(properties) {\n    let num_f_rest = 0;\n    while (properties[`f_rest_${num_f_rest}`]) {\n      num_f_rest += 1;\n    }\n    const numSh = NUM_F_REST_TO_NUM_SH[num_f_rest];\n    if (numSh == null) {\n      throw new Error(`Unsupported number of SH coefficients: ${num_f_rest}`);\n    }\n    return numSh;\n  }\n  const _SplatLoader = class _SplatLoader extends Loader {\n    constructor(manager) {\n      super(manager);\n      this.fileLoader = new FileLoader(manager);\n    }\n    load(url, onLoad, onProgress, onError) {\n      const packedSplats = this.packedSplats;\n      const fileBytes = url instanceof Uint8Array ? url : void 0;\n      const resolvedURL = url instanceof Uint8Array ? void 0 : this.manager.resolveURL((this.path ?? "") + (url ?? ""));\n      this.manager.itemStart(resolvedURL ?? "");\n      let calledOnLoad = false;\n      workerPool.withWorker(async (worker) => {\n        let lod = _SplatLoader.lod;\n        let nonLod = _SplatLoader.nonLod;\n        let lodBase = 1.5;\n        if (packedSplats == null ? void 0 : packedSplats.lod) {\n          lod = true;\n          if (typeof packedSplats.lod === "number") {\n            lodBase = Math.max(1.1, Math.min(2, packedSplats.lod));\n          }\n        }\n        if (packedSplats == null ? void 0 : packedSplats.nonLod) {\n          nonLod = true;\n        }\n        let init = null;\n        const onStatus = (data) => {\n          const { loaded, total } = data;\n          if (loaded !== void 0 && onProgress) {\n            onProgress(\n              new ProgressEvent("progress", {\n                lengthComputable: total !== 0,\n                loaded,\n                total\n              })\n            );\n          }\n          if (data.orig) {\n            init = data.orig;\n            if (packedSplats) {\n              const { numSplats, packedArray, extra, splatEncoding } = init;\n              packedSplats.initialize({\n                numSplats,\n                packedArray,\n                extra,\n                splatEncoding\n              });\n              calledOnLoad = true;\n              onLoad == null ? void 0 : onLoad(packedSplats);\n            } else {\n              console.log("No packedSplats to initialize");\n            }\n          }\n        };\n        const basedUrl = resolvedURL ? new URL(resolvedURL, window.location.href).toString() : void 0;\n        const paged = basedUrl && (resolvedURL == null ? void 0 : resolvedURL.endsWith("-lod-0.spz")) ? {\n          url: basedUrl,\n          requestHeader: this.requestHeader,\n          withCredentials: this.withCredentials\n        } : void 0;\n        const decoded = await worker.call(\n          "loadSplats",\n          {\n            url: basedUrl,\n            // baseUri: window.location.href,\n            requestHeader: this.requestHeader,\n            withCredentials: this.withCredentials,\n            fileBytes: fileBytes == null ? void 0 : fileBytes.slice(),\n            fileType: this.fileType,\n            pathName: resolvedURL,\n            lod,\n            lodBase,\n            nonLod\n          },\n          { onStatus }\n        );\n        if (decoded.lodSplats) {\n          decoded.lodSplats = new PackedSplats({\n            ...decoded.lodSplats,\n            paged\n          });\n        }\n        const initSplats = {\n          ...init ?? {},\n          ...decoded\n        };\n        if (packedSplats) {\n          packedSplats.initialize(initSplats);\n          if (!calledOnLoad) {\n            onLoad == null ? void 0 : onLoad(packedSplats);\n          }\n        } else {\n          if (!calledOnLoad) {\n            onLoad == null ? void 0 : onLoad(new PackedSplats(initSplats));\n          }\n        }\n      }).catch((error) => {\n        this.manager.itemError(resolvedURL ?? "");\n        onError == null ? void 0 : onError(error);\n      }).finally(() => {\n        this.manager.itemEnd(resolvedURL ?? "");\n      });\n    }\n    async loadAsync(url, onProgress) {\n      return new Promise((resolve, reject) => {\n        this.load(\n          url,\n          (decoded) => {\n            resolve(decoded);\n          },\n          onProgress,\n          reject\n        );\n      });\n    }\n    parse(packedSplats) {\n      return new SplatMesh({ packedSplats });\n    }\n  };\n  _SplatLoader.lod = false;\n  _SplatLoader.nonLod = false;\n  let SplatLoader = _SplatLoader;\n  var SplatFileType = /* @__PURE__ */ ((SplatFileType2) => {\n    SplatFileType2["PLY"] = "ply";\n    SplatFileType2["SPZ"] = "spz";\n    SplatFileType2["SPLAT"] = "splat";\n    SplatFileType2["KSPLAT"] = "ksplat";\n    SplatFileType2["PCSOGS"] = "pcsogs";\n    SplatFileType2["PCSOGSZIP"] = "pcsogszip";\n    return SplatFileType2;\n  })(SplatFileType || {});\n  function getSplatFileType(fileBytes) {\n    const view = new DataView(fileBytes.buffer);\n    if ((view.getUint32(0, true) & 16777215) === 7957616) {\n      return "ply";\n    }\n    if ((view.getUint32(0, true) & 16777215) === 559903) {\n      const header = decompressPartialGzip(fileBytes, 4);\n      const gView = new DataView(header.buffer);\n      if (gView.getUint32(0, true) === 1347635022) {\n        return "spz";\n      }\n      return void 0;\n    }\n    if (view.getUint32(0, true) === 67324752) {\n      if (tryPcSogsZip(fileBytes)) {\n        return "pcsogszip";\n      }\n      return void 0;\n    }\n    return void 0;\n  }\n  function getFileExtension(pathOrUrl) {\n    const noTrailing = pathOrUrl.split(/[?#]/, 1)[0];\n    const lastSlash = Math.max(\n      noTrailing.lastIndexOf("/"),\n      noTrailing.lastIndexOf("\\\\")\n    );\n    const filename = noTrailing.slice(lastSlash + 1);\n    const lastDot = filename.lastIndexOf(".");\n    if (lastDot <= 0 || lastDot === filename.length - 1) {\n      return "";\n    }\n    return filename.slice(lastDot + 1).toLowerCase();\n  }\n  function getSplatFileTypeFromPath(pathOrUrl) {\n    const extension = getFileExtension(pathOrUrl);\n    if (extension === "ply") {\n      return "ply";\n    }\n    if (extension === "spz") {\n      return "spz";\n    }\n    if (extension === "splat") {\n      return "splat";\n    }\n    if (extension === "ksplat") {\n      return "ksplat";\n    }\n    if (extension === "sog") {\n      return "pcsogszip";\n    }\n    return void 0;\n  }\n  function tryPcSogs(input) {\n    try {\n      let text;\n      if (typeof input === "string") {\n        text = input;\n      } else {\n        const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n        if (fileBytes.length > 65536) {\n          return void 0;\n        }\n        text = new TextDecoder().decode(fileBytes);\n      }\n      const json = JSON.parse(text);\n      if (!json || typeof json !== "object" || Array.isArray(json)) {\n        return void 0;\n      }\n      const isVersion2 = json.version === 2;\n      for (const key of ["means", "scales", "quats", "sh0"]) {\n        if (!json[key] || typeof json[key] !== "object" || Array.isArray(json[key])) {\n          return void 0;\n        }\n        if (isVersion2) {\n          if (!json[key].files) {\n            return void 0;\n          }\n          if ((key === "scales" || key === "sh0") && !json[key].codebook) {\n            return void 0;\n          }\n          if (key === "means" && (!json[key].mins || !json[key].maxs)) {\n            return void 0;\n          }\n        } else {\n          if (!json[key].shape || !json[key].files) {\n            return void 0;\n          }\n          if (key !== "quats" && (!json[key].mins || !json[key].maxs)) {\n            return void 0;\n          }\n        }\n      }\n      return json;\n    } catch {\n      return void 0;\n    }\n  }\n  function tryPcSogsZip(input) {\n    try {\n      const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n      let metaFilename = null;\n      const unzipped = unzipSync(fileBytes, {\n        filter: ({ name }) => {\n          const filename = name.split(/[\\\\/]/).pop();\n          if (filename === "meta.json") {\n            metaFilename = name;\n            return true;\n          }\n          return false;\n        }\n      });\n      if (!metaFilename) {\n        return void 0;\n      }\n      const json = tryPcSogs(unzipped[metaFilename]);\n      if (!json) {\n        return void 0;\n      }\n      return { name: metaFilename, json };\n    } catch {\n      return void 0;\n    }\n  }\n  class SplatData {\n    constructor({ maxSplats = 1 } = {}) {\n      this.numSplats = 0;\n      this.maxSplats = getTextureSize(maxSplats).maxSplats;\n      this.centers = new Float32Array(this.maxSplats * 3);\n      this.scales = new Float32Array(this.maxSplats * 3);\n      this.quaternions = new Float32Array(this.maxSplats * 4);\n      this.opacities = new Float32Array(this.maxSplats);\n      this.colors = new Float32Array(this.maxSplats * 3);\n    }\n    pushSplat() {\n      const index = this.numSplats;\n      this.ensureIndex(index);\n      this.numSplats += 1;\n      return index;\n    }\n    unpushSplat(index) {\n      if (index === this.numSplats - 1) {\n        this.numSplats -= 1;\n      } else {\n        throw new Error("Cannot unpush splat from non-last position");\n      }\n    }\n    ensureCapacity(numSplats) {\n      if (numSplats > this.maxSplats) {\n        const targetSplats = Math.max(numSplats, this.maxSplats * 2);\n        const newCenters = new Float32Array(targetSplats * 3);\n        const newScales = new Float32Array(targetSplats * 3);\n        const newQuaternions = new Float32Array(targetSplats * 4);\n        const newOpacities = new Float32Array(targetSplats);\n        const newColors = new Float32Array(targetSplats * 3);\n        newCenters.set(this.centers);\n        newScales.set(this.scales);\n        newQuaternions.set(this.quaternions);\n        newOpacities.set(this.opacities);\n        newColors.set(this.colors);\n        this.centers = newCenters;\n        this.scales = newScales;\n        this.quaternions = newQuaternions;\n        this.opacities = newOpacities;\n        this.colors = newColors;\n        if (this.sh1) {\n          const newSh1 = new Float32Array(targetSplats * 9);\n          newSh1.set(this.sh1);\n          this.sh1 = newSh1;\n        }\n        if (this.sh2) {\n          const newSh2 = new Float32Array(targetSplats * 15);\n          newSh2.set(this.sh2);\n          this.sh2 = newSh2;\n        }\n        if (this.sh3) {\n          const newSh3 = new Float32Array(targetSplats * 21);\n          newSh3.set(this.sh3);\n          this.sh3 = newSh3;\n        }\n        this.maxSplats = targetSplats;\n      }\n    }\n    ensureIndex(index) {\n      this.ensureCapacity(index + 1);\n    }\n    setCenter(index, x2, y, z) {\n      this.centers[index * 3] = x2;\n      this.centers[index * 3 + 1] = y;\n      this.centers[index * 3 + 2] = z;\n    }\n    setScale(index, scaleX, scaleY, scaleZ) {\n      this.scales[index * 3] = scaleX;\n      this.scales[index * 3 + 1] = scaleY;\n      this.scales[index * 3 + 2] = scaleZ;\n    }\n    setQuaternion(index, x2, y, z, w) {\n      this.quaternions[index * 4] = x2;\n      this.quaternions[index * 4 + 1] = y;\n      this.quaternions[index * 4 + 2] = z;\n      this.quaternions[index * 4 + 3] = w;\n    }\n    setOpacity(index, opacity) {\n      this.opacities[index] = opacity;\n    }\n    setColor(index, r, g, b) {\n      this.colors[index * 3] = r;\n      this.colors[index * 3 + 1] = g;\n      this.colors[index * 3 + 2] = b;\n    }\n    setSh1(index, sh1) {\n      if (!this.sh1) {\n        this.sh1 = new Float32Array(this.maxSplats * 9);\n      }\n      for (let j = 0; j < 9; ++j) {\n        this.sh1[index * 9 + j] = sh1[j];\n      }\n    }\n    setSh2(index, sh2) {\n      if (!this.sh2) {\n        this.sh2 = new Float32Array(this.maxSplats * 15);\n      }\n      for (let j = 0; j < 15; ++j) {\n        this.sh2[index * 15 + j] = sh2[j];\n      }\n    }\n    setSh3(index, sh3) {\n      if (!this.sh3) {\n        this.sh3 = new Float32Array(this.maxSplats * 21);\n      }\n      for (let j = 0; j < 21; ++j) {\n        this.sh3[index * 21 + j] = sh3[j];\n      }\n    }\n  }\n  async function unpackPcSogs(json, extraFiles, splatEncoding) {\n    const isVersion2 = "version" in json;\n    if (!isVersion2 && json.quats.encoding !== "quaternion_packed") {\n      throw new Error("Unsupported quaternion encoding");\n    }\n    const numSplats = isVersion2 ? json.count : json.means.shape[0];\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    const meansPromise = Promise.all([\n      decodeImageRgba(extraFiles[json.means.files[0]]),\n      decodeImageRgba(extraFiles[json.means.files[1]])\n    ]).then((means) => {\n      for (let i2 = 0; i2 < numSplats; ++i2) {\n        const i4 = i2 * 4;\n        const fx = (means[0][i4 + 0] + (means[1][i4 + 0] << 8)) / 65535;\n        const fy = (means[0][i4 + 1] + (means[1][i4 + 1] << 8)) / 65535;\n        const fz = (means[0][i4 + 2] + (means[1][i4 + 2] << 8)) / 65535;\n        let x2 = json.means.mins[0] + (json.means.maxs[0] - json.means.mins[0]) * fx;\n        let y = json.means.mins[1] + (json.means.maxs[1] - json.means.mins[1]) * fy;\n        let z = json.means.mins[2] + (json.means.maxs[2] - json.means.mins[2]) * fz;\n        x2 = Math.sign(x2) * (Math.exp(Math.abs(x2)) - 1);\n        y = Math.sign(y) * (Math.exp(Math.abs(y)) - 1);\n        z = Math.sign(z) * (Math.exp(Math.abs(z)) - 1);\n        setPackedSplatCenter(packedArray, i2, x2, y, z);\n      }\n    });\n    const scalesPromise = decodeImageRgba(extraFiles[json.scales.files[0]]).then(\n      (scales) => {\n        let xLookup;\n        let yLookup;\n        let zLookup;\n        if (isVersion2) {\n          xLookup = yLookup = zLookup = json.scales.codebook.map((x2) => Math.exp(x2));\n        } else {\n          xLookup = new Array(256).fill(0).map(\n            (_, i2) => json.scales.mins[0] + (json.scales.maxs[0] - json.scales.mins[0]) * (i2 / 255)\n          ).map((x2) => Math.exp(x2));\n          yLookup = new Array(256).fill(0).map(\n            (_, i2) => json.scales.mins[1] + (json.scales.maxs[1] - json.scales.mins[1]) * (i2 / 255)\n          ).map((x2) => Math.exp(x2));\n          zLookup = new Array(256).fill(0).map(\n            (_, i2) => json.scales.mins[2] + (json.scales.maxs[2] - json.scales.mins[2]) * (i2 / 255)\n          ).map((x2) => Math.exp(x2));\n        }\n        for (let i2 = 0; i2 < numSplats; ++i2) {\n          const i4 = i2 * 4;\n          setPackedSplatScales(\n            packedArray,\n            i2,\n            xLookup[scales[i4 + 0]],\n            yLookup[scales[i4 + 1]],\n            zLookup[scales[i4 + 2]],\n            splatEncoding\n          );\n        }\n      }\n    );\n    const quatsPromise = decodeImageRgba(extraFiles[json.quats.files[0]]).then(\n      (quats) => {\n        const SQRT2 = Math.sqrt(2);\n        const lookup = new Array(256).fill(0).map((_, i2) => (i2 / 255 - 0.5) * SQRT2);\n        for (let i2 = 0; i2 < numSplats; ++i2) {\n          const i4 = i2 * 4;\n          const r0 = lookup[quats[i4 + 0]];\n          const r1 = lookup[quats[i4 + 1]];\n          const r2 = lookup[quats[i4 + 2]];\n          const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));\n          const rOrder = quats[i4 + 3] - 252;\n          const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\n          const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;\n          const quatZ = rOrder <= 2 ? r2 : rr;\n          const quatW = rOrder === 0 ? rr : r0;\n          setPackedSplatQuat(packedArray, i2, quatX, quatY, quatZ, quatW);\n        }\n      }\n    );\n    const sh0Promise = decodeImageRgba(extraFiles[json.sh0.files[0]]).then(\n      (sh0) => {\n        const SH_C02 = 0.28209479177387814;\n        let rLookup;\n        let gLookup;\n        let bLookup;\n        let aLookup;\n        if (isVersion2) {\n          rLookup = gLookup = bLookup = json.sh0.codebook.map((x2) => SH_C02 * x2 + 0.5);\n          aLookup = new Array(256).fill(0).map((_, i2) => i2 / 255);\n        } else {\n          rLookup = new Array(256).fill(0).map(\n            (_, i2) => json.sh0.mins[0] + (json.sh0.maxs[0] - json.sh0.mins[0]) * (i2 / 255)\n          ).map((x2) => SH_C02 * x2 + 0.5);\n          gLookup = new Array(256).fill(0).map(\n            (_, i2) => json.sh0.mins[1] + (json.sh0.maxs[1] - json.sh0.mins[1]) * (i2 / 255)\n          ).map((x2) => SH_C02 * x2 + 0.5);\n          bLookup = new Array(256).fill(0).map(\n            (_, i2) => json.sh0.mins[2] + (json.sh0.maxs[2] - json.sh0.mins[2]) * (i2 / 255)\n          ).map((x2) => SH_C02 * x2 + 0.5);\n          aLookup = new Array(256).fill(0).map(\n            (_, i2) => json.sh0.mins[3] + (json.sh0.maxs[3] - json.sh0.mins[3]) * (i2 / 255)\n          ).map((x2) => 1 / (1 + Math.exp(-x2)));\n        }\n        for (let i2 = 0; i2 < numSplats; ++i2) {\n          const i4 = i2 * 4;\n          setPackedSplatRgba(\n            packedArray,\n            i2,\n            rLookup[sh0[i4 + 0]],\n            gLookup[sh0[i4 + 1]],\n            bLookup[sh0[i4 + 2]],\n            aLookup[sh0[i4 + 3]],\n            splatEncoding\n          );\n        }\n      }\n    );\n    const promises = [meansPromise, scalesPromise, quatsPromise, sh0Promise];\n    if (json.shN) {\n      const useSH3 = isVersion2 ? json.shN.bands >= 3 : json.shN.shape[1] >= 48 - 3;\n      const useSH2 = isVersion2 ? json.shN.bands >= 2 : json.shN.shape[1] >= 27 - 3;\n      const useSH1 = isVersion2 ? json.shN.bands >= 1 : json.shN.shape[1] >= 12 - 3;\n      if (useSH1) extra.sh1 = new Uint32Array(numSplats * 2);\n      if (useSH2) extra.sh2 = new Uint32Array(numSplats * 4);\n      if (useSH3) extra.sh3 = new Uint32Array(numSplats * 4);\n      const sh1 = new Float32Array(9);\n      const sh2 = new Float32Array(15);\n      const sh3 = new Float32Array(21);\n      const shN = json.shN;\n      const shNPromise = Promise.all([\n        decodeImage(extraFiles[json.shN.files[0]]),\n        decodeImage(extraFiles[json.shN.files[1]])\n      ]).then(([centroids, labels]) => {\n        const lookup = "codebook" in shN ? shN.codebook : new Array(256).fill(0).map((_, i2) => shN.mins + (shN.maxs - shN.mins) * (i2 / 255));\n        for (let i2 = 0; i2 < numSplats; ++i2) {\n          const i4 = i2 * 4;\n          const label = labels.rgba[i4 + 0] + (labels.rgba[i4 + 1] << 8);\n          const col = (label & 63) * 15;\n          const row = label >>> 6;\n          const offset = row * centroids.width + col;\n          for (let d = 0; d < 3; ++d) {\n            if (useSH1) {\n              for (let k = 0; k < 3; ++k) {\n                sh1[k * 3 + d] = lookup[centroids.rgba[(offset + k) * 4 + d]];\n              }\n            }\n            if (useSH2) {\n              for (let k = 0; k < 5; ++k) {\n                sh2[k * 3 + d] = lookup[centroids.rgba[(offset + 3 + k) * 4 + d]];\n              }\n            }\n            if (useSH3) {\n              for (let k = 0; k < 7; ++k) {\n                sh3[k * 3 + d] = lookup[centroids.rgba[(offset + 8 + k) * 4 + d]];\n              }\n            }\n          }\n          if (useSH1)\n            encodeSh1Rgb(extra.sh1, i2, sh1, splatEncoding);\n          if (useSH2)\n            encodeSh2Rgb(extra.sh2, i2, sh2, splatEncoding);\n          if (useSH3)\n            encodeSh3Rgb(extra.sh3, i2, sh3, splatEncoding);\n        }\n      });\n      promises.push(shNPromise);\n    }\n    await Promise.all(promises);\n    return { packedArray, numSplats, extra };\n  }\n  let offscreenGlContext = null;\n  async function decodeImage(fileBytes) {\n    if (!offscreenGlContext) {\n      const canvas = new OffscreenCanvas(1, 1);\n      offscreenGlContext = canvas.getContext("webgl2");\n      if (!offscreenGlContext) {\n        throw new Error("Failed to create WebGL2 context");\n      }\n    }\n    const imageBlob = new Blob([fileBytes]);\n    const bitmap = await createImageBitmap(imageBlob, {\n      premultiplyAlpha: "none"\n    });\n    const gl = offscreenGlContext;\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bitmap);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    const framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      texture,\n      0\n    );\n    const data = new Uint8Array(bitmap.width * bitmap.height * 4);\n    gl.readPixels(\n      0,\n      0,\n      bitmap.width,\n      bitmap.height,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      data\n    );\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(framebuffer);\n    return { rgba: data, width: bitmap.width, height: bitmap.height };\n  }\n  async function decodeImageRgba(fileBytes) {\n    const { rgba } = await decodeImage(fileBytes);\n    return rgba;\n  }\n  async function unpackPcSogsZip(fileBytes, splatEncoding) {\n    var _a2;\n    const nameJson = tryPcSogsZip(fileBytes);\n    if (!nameJson) {\n      throw new Error("Invalid PC SOGS zip file");\n    }\n    const { name, json } = nameJson;\n    const lastSlash = name.lastIndexOf("/");\n    const lastBackslash = name.lastIndexOf("\\\\");\n    const prefix = name.slice(0, Math.max(lastSlash, lastBackslash) + 1);\n    const fileMap = /* @__PURE__ */ new Map();\n    const refFiles = [\n      ...json.means.files,\n      ...json.scales.files,\n      ...json.quats.files,\n      ...json.sh0.files,\n      ...((_a2 = json.shN) == null ? void 0 : _a2.files) ?? []\n    ];\n    for (const file of refFiles) {\n      fileMap.set(prefix + file, file);\n    }\n    const unzipped = await new Promise(\n      (resolve, reject) => {\n        unzip(\n          fileBytes,\n          {\n            filter: ({ name: name2 }) => {\n              return fileMap.has(name2);\n            }\n          },\n          (err2, files) => {\n            if (err2) {\n              reject(err2);\n            } else {\n              resolve(files);\n            }\n          }\n        );\n      }\n    );\n    const extraFiles = {};\n    for (const [full, name2] of fileMap.entries()) {\n      extraFiles[name2] = unzipped[full];\n    }\n    return await unpackPcSogs(json, extraFiles, splatEncoding);\n  }\n  class SpzReader {\n    constructor({ fileBytes }) {\n      this.version = -1;\n      this.numSplats = 0;\n      this.shDegree = 0;\n      this.fractionalBits = 0;\n      this.flags = 0;\n      this.flagAntiAlias = false;\n      this.flagLod = false;\n      this.reserved = 0;\n      this.headerParsed = false;\n      this.parsed = false;\n      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\n      this.reader = new GunzipReader({\n        fileBytes: this.fileBytes\n      });\n    }\n    async parseHeader() {\n      if (this.headerParsed) {\n        throw new Error("SPZ file header already parsed");\n      }\n      const header = new DataView((await this.reader.read(16)).buffer);\n      if (header.getUint32(0, true) !== 1347635022) {\n        throw new Error("Invalid SPZ file");\n      }\n      this.version = header.getUint32(4, true);\n      if (this.version < 1 || this.version > 3) {\n        throw new Error(`Unsupported SPZ version: ${this.version}`);\n      }\n      this.numSplats = header.getUint32(8, true);\n      this.shDegree = header.getUint8(12);\n      this.fractionalBits = header.getUint8(13);\n      this.flags = header.getUint8(14);\n      this.flagAntiAlias = (this.flags & 1) !== 0;\n      this.flagLod = (this.flags & 128) !== 0;\n      this.reserved = header.getUint8(15);\n      this.headerParsed = true;\n      this.parsed = false;\n    }\n    async parseSplats(centerCallback, alphaCallback, rgbCallback, scalesCallback, quatCallback, shCallback, {\n      childCounts,\n      childStarts\n    } = {}) {\n      if (!this.headerParsed) {\n        throw new Error("SPZ file header must be parsed first");\n      }\n      if (this.parsed) {\n        throw new Error("SPZ file already parsed");\n      }\n      this.parsed = true;\n      if (this.version === 1) {\n        const centerBytes = await this.reader.read(this.numSplats * 3 * 2);\n        const centerUint16 = new Uint16Array(centerBytes.buffer);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const x2 = fromHalf(centerUint16[i3]);\n          const y = fromHalf(centerUint16[i3 + 1]);\n          const z = fromHalf(centerUint16[i3 + 2]);\n          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);\n        }\n      } else if (this.version === 2 || this.version === 3) {\n        const fixed = 1 << this.fractionalBits;\n        const centerBytes = await this.reader.read(this.numSplats * 3 * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i9 = i2 * 9;\n          const x2 = ((centerBytes[i9 + 2] << 24 | centerBytes[i9 + 1] << 16 | centerBytes[i9] << 8) >> 8) / fixed;\n          const y = ((centerBytes[i9 + 5] << 24 | centerBytes[i9 + 4] << 16 | centerBytes[i9 + 3] << 8) >> 8) / fixed;\n          const z = ((centerBytes[i9 + 8] << 24 | centerBytes[i9 + 7] << 16 | centerBytes[i9 + 6] << 8) >> 8) / fixed;\n          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);\n        }\n      } else {\n        throw new Error("Unreachable");\n      }\n      {\n        const bytes = await this.reader.read(this.numSplats);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          alphaCallback == null ? void 0 : alphaCallback(i2, bytes[i2] / 255);\n        }\n      }\n      {\n        const rgbBytes = await this.reader.read(this.numSplats * 3);\n        const scale = SH_C0 / 0.15;\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const r = (rgbBytes[i3] / 255 - 0.5) * scale + 0.5;\n          const g = (rgbBytes[i3 + 1] / 255 - 0.5) * scale + 0.5;\n          const b = (rgbBytes[i3 + 2] / 255 - 0.5) * scale + 0.5;\n          rgbCallback == null ? void 0 : rgbCallback(i2, r, g, b);\n        }\n      }\n      {\n        const scalesBytes = await this.reader.read(this.numSplats * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const scaleX = Math.exp(scalesBytes[i3] / 16 - 10);\n          const scaleY = Math.exp(scalesBytes[i3 + 1] / 16 - 10);\n          const scaleZ = Math.exp(scalesBytes[i3 + 2] / 16 - 10);\n          scalesCallback == null ? void 0 : scalesCallback(i2, scaleX, scaleY, scaleZ);\n        }\n      }\n      if (this.version === 3) {\n        const maxValue = 1 / Math.sqrt(2);\n        const quatBytes = await this.reader.read(this.numSplats * 4);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 4;\n          const quaternion = [0, 0, 0, 0];\n          const values = [\n            quatBytes[i3],\n            quatBytes[i3 + 1],\n            quatBytes[i3 + 2],\n            quatBytes[i3 + 3]\n          ];\n          const combinedValues = values[0] + (values[1] << 8) + (values[2] << 16) + (values[3] << 24);\n          const valueMask = (1 << 9) - 1;\n          const largestIndex = combinedValues >>> 30;\n          let remainingValues = combinedValues;\n          let sumSquares = 0;\n          for (let i22 = 3; i22 >= 0; --i22) {\n            if (i22 !== largestIndex) {\n              const value = remainingValues & valueMask;\n              const sign = remainingValues >>> 9 & 1;\n              remainingValues = remainingValues >>> 10;\n              quaternion[i22] = maxValue * (value / valueMask);\n              quaternion[i22] = sign === 0 ? quaternion[i22] : -quaternion[i22];\n              sumSquares += quaternion[i22] * quaternion[i22];\n            }\n          }\n          const square = 1 - sumSquares;\n          quaternion[largestIndex] = Math.sqrt(Math.max(square, 0));\n          quatCallback == null ? void 0 : quatCallback(\n            i2,\n            quaternion[0],\n            quaternion[1],\n            quaternion[2],\n            quaternion[3]\n          );\n        }\n      } else {\n        const quatBytes = await this.reader.read(this.numSplats * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const quatX = quatBytes[i3] / 127.5 - 1;\n          const quatY = quatBytes[i3 + 1] / 127.5 - 1;\n          const quatZ = quatBytes[i3 + 2] / 127.5 - 1;\n          const quatW = Math.sqrt(\n            Math.max(0, 1 - quatX * quatX - quatY * quatY - quatZ * quatZ)\n          );\n          quatCallback == null ? void 0 : quatCallback(i2, quatX, quatY, quatZ, quatW);\n        }\n      }\n      if (shCallback && this.shDegree >= 1) {\n        const sh1 = new Float32Array(3 * 3);\n        const sh2 = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n        const sh3 = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n        const shBytes = await this.reader.read(\n          this.numSplats * SH_DEGREE_TO_VECS[this.shDegree] * 3\n        );\n        let offset = 0;\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          for (let j = 0; j < 9; ++j) {\n            sh1[j] = (shBytes[offset + j] - 128) / 128;\n          }\n          offset += 9;\n          if (sh2) {\n            for (let j = 0; j < 15; ++j) {\n              sh2[j] = (shBytes[offset + j] - 128) / 128;\n            }\n            offset += 15;\n          }\n          if (sh3) {\n            for (let j = 0; j < 21; ++j) {\n              sh3[j] = (shBytes[offset + j] - 128) / 128;\n            }\n            offset += 21;\n          }\n          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);\n        }\n      }\n      if (this.flagLod) {\n        let bytes = await this.reader.read(this.numSplats * 2);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i22 = i2 * 2;\n          const count = bytes[i22] + (bytes[i22 + 1] << 8);\n          childCounts == null ? void 0 : childCounts(i2, count);\n        }\n        bytes = await this.reader.read(this.numSplats * 4);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i4 = i2 * 4;\n          const start = bytes[i4] + (bytes[i4 + 1] << 8) + (bytes[i4 + 2] << 16) + (bytes[i4 + 3] << 24);\n          childStarts == null ? void 0 : childStarts(i2, start);\n        }\n      }\n    }\n  }\n  const SH_DEGREE_TO_VECS = { 1: 3, 2: 8, 3: 15 };\n  const SH_C0 = 0.28209479177387814;\n  const SPZ_MAGIC = 1347635022;\n  const SPZ_VERSION = 3;\n  const FLAG_ANTIALIASED = 1;\n  class SpzWriter {\n    constructor({\n      numSplats,\n      shDegree,\n      fractionalBits = 12,\n      flagAntiAlias = true\n    }) {\n      this.clippedCount = 0;\n      const splatSize = 9 + // Position\n      1 + // Opacity\n      3 + // Scale\n      3 + // DC-rgb\n      4 + // Rotation\n      (shDegree >= 1 ? 9 : 0) + (shDegree >= 2 ? 15 : 0) + (shDegree >= 3 ? 21 : 0);\n      const bufferSize = 16 + numSplats * splatSize;\n      this.buffer = new ArrayBuffer(bufferSize);\n      this.view = new DataView(this.buffer);\n      this.view.setUint32(0, SPZ_MAGIC, true);\n      this.view.setUint32(4, SPZ_VERSION, true);\n      this.view.setUint32(8, numSplats, true);\n      this.view.setUint8(12, shDegree);\n      this.view.setUint8(13, fractionalBits);\n      this.view.setUint8(14, flagAntiAlias ? FLAG_ANTIALIASED : 0);\n      this.view.setUint8(15, 0);\n      this.numSplats = numSplats;\n      this.shDegree = shDegree;\n      this.fractionalBits = fractionalBits;\n      this.fraction = 1 << fractionalBits;\n      this.flagAntiAlias = flagAntiAlias;\n    }\n    setCenter(index, x2, y, z) {\n      const xRounded = Math.round(x2 * this.fraction);\n      const xInt = Math.max(-8388607, Math.min(8388607, xRounded));\n      const yRounded = Math.round(y * this.fraction);\n      const yInt = Math.max(-8388607, Math.min(8388607, yRounded));\n      const zRounded = Math.round(z * this.fraction);\n      const zInt = Math.max(-8388607, Math.min(8388607, zRounded));\n      const clipped = xRounded !== xInt || yRounded !== yInt || zRounded !== zInt;\n      if (clipped) {\n        this.clippedCount += 1;\n      }\n      const i9 = index * 9;\n      const base = 16 + i9;\n      this.view.setUint8(base, xInt & 255);\n      this.view.setUint8(base + 1, xInt >> 8 & 255);\n      this.view.setUint8(base + 2, xInt >> 16 & 255);\n      this.view.setUint8(base + 3, yInt & 255);\n      this.view.setUint8(base + 4, yInt >> 8 & 255);\n      this.view.setUint8(base + 5, yInt >> 16 & 255);\n      this.view.setUint8(base + 6, zInt & 255);\n      this.view.setUint8(base + 7, zInt >> 8 & 255);\n      this.view.setUint8(base + 8, zInt >> 16 & 255);\n    }\n    setAlpha(index, alpha) {\n      const base = 16 + this.numSplats * 9 + index;\n      this.view.setUint8(\n        base,\n        Math.max(0, Math.min(255, Math.round(alpha * 255)))\n      );\n    }\n    static scaleRgb(r) {\n      const v = ((r - 0.5) / (SH_C0 / 0.15) + 0.5) * 255;\n      return Math.max(0, Math.min(255, Math.round(v)));\n    }\n    setRgb(index, r, g, b) {\n      const base = 16 + this.numSplats * 10 + index * 3;\n      this.view.setUint8(base, SpzWriter.scaleRgb(r));\n      this.view.setUint8(base + 1, SpzWriter.scaleRgb(g));\n      this.view.setUint8(base + 2, SpzWriter.scaleRgb(b));\n    }\n    setScale(index, scaleX, scaleY, scaleZ) {\n      const base = 16 + this.numSplats * 13 + index * 3;\n      this.view.setUint8(\n        base,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleX) + 10) * 16)))\n      );\n      this.view.setUint8(\n        base + 1,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleY) + 10) * 16)))\n      );\n      this.view.setUint8(\n        base + 2,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleZ) + 10) * 16)))\n      );\n    }\n    setQuat(index, ...q) {\n      const base = 16 + this.numSplats * 16 + index * 4;\n      const quat = normalize$1(q);\n      let iLargest = 0;\n      for (let i2 = 1; i2 < 4; ++i2) {\n        if (Math.abs(quat[i2]) > Math.abs(quat[iLargest])) {\n          iLargest = i2;\n        }\n      }\n      const negate = quat[iLargest] < 0 ? 1 : 0;\n      let comp = iLargest;\n      for (let i2 = 0; i2 < 4; ++i2) {\n        if (i2 !== iLargest) {\n          const negbit = (quat[i2] < 0 ? 1 : 0) ^ negate;\n          const mag = Math.floor(\n            ((1 << 9) - 1) * (Math.abs(quat[i2]) / Math.SQRT1_2) + 0.5\n          );\n          comp = comp << 10 | negbit << 9 | mag;\n        }\n      }\n      this.view.setUint8(base, comp & 255);\n      this.view.setUint8(base + 1, comp >> 8 & 255);\n      this.view.setUint8(base + 2, comp >> 16 & 255);\n      this.view.setUint8(base + 3, comp >>> 24 & 255);\n    }\n    static quantizeSh(sh, bits2) {\n      const value = Math.round(sh * 128) + 128;\n      const bucketSize = 1 << 8 - bits2;\n      const quantized = Math.floor((value + bucketSize / 2) / bucketSize) * bucketSize;\n      return Math.max(0, Math.min(255, quantized));\n    }\n    setSh(index, sh1, sh2, sh3) {\n      const shVecs = SH_DEGREE_TO_VECS[this.shDegree] || 0;\n      const base1 = 16 + this.numSplats * 20 + index * shVecs * 3;\n      for (let j = 0; j < 9; ++j) {\n        this.view.setUint8(base1 + j, SpzWriter.quantizeSh(sh1[j], 5));\n      }\n      if (sh2) {\n        const base2 = base1 + 9;\n        for (let j = 0; j < 15; ++j) {\n          this.view.setUint8(base2 + j, SpzWriter.quantizeSh(sh2[j], 4));\n        }\n        if (sh3) {\n          const base3 = base2 + 15;\n          for (let j = 0; j < 21; ++j) {\n            this.view.setUint8(base3 + j, SpzWriter.quantizeSh(sh3[j], 4));\n          }\n        }\n      }\n    }\n    async finalize() {\n      const input = new Uint8Array(this.buffer);\n      const stream = new ReadableStream({\n        async start(controller) {\n          controller.enqueue(input);\n          controller.close();\n        }\n      });\n      const compressed = stream.pipeThrough(new CompressionStream("gzip"));\n      const response = new Response(compressed);\n      const buffer = await response.arrayBuffer();\n      console.log(\n        "Compressed",\n        input.length,\n        "bytes to",\n        buffer.byteLength,\n        "bytes"\n      );\n      return new Uint8Array(buffer);\n    }\n  }\n  async function transcodeSpz(input) {\n    var _a2, _b2, _c;\n    const splats = new SplatData();\n    const {\n      inputs,\n      clipXyz,\n      maxSh,\n      fractionalBits = 12,\n      opacityThreshold\n    } = input;\n    for (const input2 of inputs) {\n      let transformPos2 = function(pos) {\n        pos.multiplyScalar(scale);\n        pos.applyQuaternion(quaternion);\n        pos.add(translate);\n        return pos;\n      }, transformScales = function(scales) {\n        scales.multiplyScalar(scale);\n        return scales;\n      }, transformQuaternion = function(quat) {\n        quat.premultiply(quaternion);\n        return quat;\n      }, withinClip = function(p) {\n        return !clip || clip.containsPoint(p);\n      }, withinOpacity = function(opacity) {\n        return opacityThreshold !== void 0 ? opacity >= opacityThreshold : true;\n      };\n      const scale = ((_a2 = input2.transform) == null ? void 0 : _a2.scale) ?? 1;\n      const quaternion = new Quaternion().fromArray(\n        ((_b2 = input2.transform) == null ? void 0 : _b2.quaternion) ?? [0, 0, 0, 1]\n      );\n      const translate = new Vector3().fromArray(\n        ((_c = input2.transform) == null ? void 0 : _c.translate) ?? [0, 0, 0]\n      );\n      const clip = clipXyz ? new Box3(\n        new Vector3().fromArray(clipXyz.min),\n        new Vector3().fromArray(clipXyz.max)\n      ) : void 0;\n      let fileType = input2.fileType;\n      if (!fileType) {\n        fileType = getSplatFileType(input2.fileBytes);\n        if (!fileType && input2.pathOrUrl) {\n          fileType = getSplatFileTypeFromPath(input2.pathOrUrl);\n        }\n      }\n      switch (fileType) {\n        case SplatFileType.PLY: {\n          const ply = new PlyReader({ fileBytes: input2.fileBytes });\n          await ply.parseHeader();\n          let lastIndex = null;\n          ply.parseSplats(\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos2(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                lastIndex = splats.pushSplat();\n                splats.setCenter(lastIndex, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(lastIndex, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  lastIndex,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(lastIndex, opacity);\n                splats.setColor(lastIndex, r, g, b);\n              } else {\n                lastIndex = null;\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (sh1 && lastIndex !== null) {\n                splats.setSh1(lastIndex, sh1);\n              }\n              if (sh2 && lastIndex !== null) {\n                splats.setSh2(lastIndex, sh2);\n              }\n              if (sh3 && lastIndex !== null) {\n                splats.setSh3(lastIndex, sh3);\n              }\n            }\n          );\n          break;\n        }\n        case SplatFileType.SPZ: {\n          const spz2 = new SpzReader({ fileBytes: input2.fileBytes });\n          await spz2.parseHeader();\n          const mapping = new Int32Array(spz2.numSplats);\n          mapping.fill(-1);\n          const centers = new Float32Array(spz2.numSplats * 3);\n          const center = new Vector3();\n          spz2.parseSplats(\n            (index, x2, y, z) => {\n              const center2 = transformPos2(new Vector3(x2, y, z));\n              centers[index * 3] = center2.x;\n              centers[index * 3 + 1] = center2.y;\n              centers[index * 3 + 2] = center2.z;\n            },\n            (index, alpha) => {\n              center.fromArray(centers, index * 3);\n              if (withinClip(center) && withinOpacity(alpha)) {\n                mapping[index] = splats.pushSplat();\n                splats.setCenter(mapping[index], center.x, center.y, center.z);\n                splats.setOpacity(mapping[index], alpha);\n              }\n            },\n            (index, r, g, b) => {\n              if (mapping[index] >= 0) {\n                splats.setColor(mapping[index], r, g, b);\n              }\n            },\n            (index, scaleX, scaleY, scaleZ) => {\n              if (mapping[index] >= 0) {\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(mapping[index], scales.x, scales.y, scales.z);\n              }\n            },\n            (index, quatX, quatY, quatZ, quatW) => {\n              if (mapping[index] >= 0) {\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  mapping[index],\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (mapping[index] >= 0) {\n                splats.setSh1(mapping[index], sh1);\n                if (sh2) {\n                  splats.setSh2(mapping[index], sh2);\n                }\n                if (sh3) {\n                  splats.setSh3(mapping[index], sh3);\n                }\n              }\n            }\n          );\n          break;\n        }\n        case SplatFileType.SPLAT:\n          decodeAntiSplat(\n            input2.fileBytes,\n            (numSplats) => {\n            },\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos2(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                const index2 = splats.pushSplat();\n                splats.setCenter(index2, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(index2, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  index2,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(index2, opacity);\n                splats.setColor(index2, r, g, b);\n              }\n            }\n          );\n          break;\n        case SplatFileType.KSPLAT: {\n          let lastIndex = null;\n          decodeKsplat(\n            input2.fileBytes,\n            (numSplats) => {\n            },\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos2(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                lastIndex = splats.pushSplat();\n                splats.setCenter(lastIndex, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(lastIndex, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  lastIndex,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(lastIndex, opacity);\n                splats.setColor(lastIndex, r, g, b);\n              } else {\n                lastIndex = null;\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (lastIndex !== null) {\n                splats.setSh1(lastIndex, sh1);\n                if (sh2) {\n                  splats.setSh2(lastIndex, sh2);\n                }\n                if (sh3) {\n                  splats.setSh3(lastIndex, sh3);\n                }\n              }\n            }\n          );\n          break;\n        }\n        default:\n          throw new Error(`transcodeSpz not implemented for ${fileType}`);\n      }\n    }\n    const shDegree = Math.min(\n      maxSh ?? 3,\n      splats.sh3 ? 3 : splats.sh2 ? 2 : splats.sh1 ? 1 : 0\n    );\n    const spz = new SpzWriter({\n      numSplats: splats.numSplats,\n      shDegree,\n      fractionalBits,\n      flagAntiAlias: true\n    });\n    for (let i2 = 0; i2 < splats.numSplats; ++i2) {\n      const i3 = i2 * 3;\n      const i4 = i2 * 4;\n      spz.setCenter(\n        i2,\n        splats.centers[i3],\n        splats.centers[i3 + 1],\n        splats.centers[i3 + 2]\n      );\n      spz.setScale(\n        i2,\n        splats.scales[i3],\n        splats.scales[i3 + 1],\n        splats.scales[i3 + 2]\n      );\n      spz.setQuat(\n        i2,\n        splats.quaternions[i4],\n        splats.quaternions[i4 + 1],\n        splats.quaternions[i4 + 2],\n        splats.quaternions[i4 + 3]\n      );\n      spz.setAlpha(i2, splats.opacities[i2]);\n      spz.setRgb(\n        i2,\n        splats.colors[i3],\n        splats.colors[i3 + 1],\n        splats.colors[i3 + 2]\n      );\n      if (splats.sh1 && shDegree >= 1) {\n        spz.setSh(\n          i2,\n          splats.sh1.slice(i2 * 9, (i2 + 1) * 9),\n          shDegree >= 2 && splats.sh2 ? splats.sh2.slice(i2 * 15, (i2 + 1) * 15) : void 0,\n          shDegree >= 3 && splats.sh3 ? splats.sh3.slice(i2 * 21, (i2 + 1) * 21) : void 0\n        );\n      }\n    }\n    const spzBytes = await spz.finalize();\n    return { fileBytes: spzBytes, clippedCount: spz.clippedCount };\n  }\n  async function onMessage(event) {\n    const { name, args, id } = event.data;\n    let result = void 0;\n    let error = void 0;\n    try {\n      switch (name) {\n        case "unpackPly": {\n          const { packedArray, fileBytes, splatEncoding } = args;\n          const decoded = await unpackPly({\n            packedArray,\n            fileBytes,\n            splatEncoding\n          });\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodeSpz": {\n          const { fileBytes, splatEncoding } = args;\n          const decoded = await unpackSpz(fileBytes, splatEncoding);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodeAntiSplat": {\n          const { fileBytes, splatEncoding } = args;\n          const decoded = unpackAntiSplat(fileBytes, splatEncoding);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray\n          };\n          break;\n        }\n        case "decodeKsplat": {\n          const { fileBytes, splatEncoding } = args;\n          const decoded = unpackKsplat(fileBytes, splatEncoding);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodePcSogs": {\n          const { fileBytes, extraFiles, splatEncoding } = args;\n          const json = JSON.parse(\n            new TextDecoder().decode(fileBytes)\n          );\n          const decoded = await unpackPcSogs(json, extraFiles, splatEncoding);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "decodePcSogsZip": {\n          const { fileBytes, splatEncoding } = args;\n          const decoded = await unpackPcSogsZip(fileBytes, splatEncoding);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case "sortSplats": {\n          const { totalSplats, readback, ordering } = args;\n          result = {\n            id,\n            readback,\n            ...sortSplats({ totalSplats, readback, ordering })\n          };\n          break;\n        }\n        case "sortDoubleSplats": {\n          const { numSplats, readback, ordering } = args;\n          {\n            result = {\n              id,\n              readback,\n              ordering,\n              activeSplats: sort_splats(numSplats, readback, ordering)\n            };\n          }\n          break;\n        }\n        case "sort32Splats": {\n          const { numSplats, readback, ordering } = args;\n          {\n            result = {\n              id,\n              readback,\n              ordering,\n              activeSplats: sort32_splats(numSplats, readback, ordering)\n            };\n          }\n          break;\n        }\n        case "transcodeSpz": {\n          const input = args;\n          const spzBytes = await transcodeSpz(input);\n          result = {\n            id,\n            fileBytes: spzBytes,\n            input\n          };\n          break;\n        }\n        default: {\n          throw new Error(`Unknown name: ${name}`);\n        }\n      }\n    } catch (e) {\n      error = e;\n      console.error(error);\n    }\n    self.postMessage(\n      { id, result, error },\n      { transfer: getArrayBuffers(result) }\n    );\n  }\n  async function unpackPly({\n    packedArray,\n    fileBytes,\n    splatEncoding\n  }) {\n    const ply = new PlyReader({ fileBytes });\n    await ply.parseHeader();\n    const numSplats = ply.numSplats;\n    const extra = {};\n    ply.parseSplats(\n      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n        setPackedSplat(\n          packedArray,\n          index,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b,\n          splatEncoding\n        );\n      },\n      (index, sh1, sh2, sh3) => {\n        if (sh1) {\n          if (!extra.sh1) {\n            extra.sh1 = new Uint32Array(numSplats * 2);\n          }\n          encodeSh1Rgb(extra.sh1, index, sh1, splatEncoding);\n        }\n        if (sh2) {\n          if (!extra.sh2) {\n            extra.sh2 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh2Rgb(extra.sh2, index, sh2, splatEncoding);\n        }\n        if (sh3) {\n          if (!extra.sh3) {\n            extra.sh3 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh3Rgb(extra.sh3, index, sh3, splatEncoding);\n        }\n      }\n    );\n    return { packedArray, numSplats, extra };\n  }\n  async function unpackSpz(fileBytes, splatEncoding) {\n    const spz = new SpzReader({ fileBytes });\n    await spz.parseHeader();\n    const numSplats = spz.numSplats;\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    let extraCallbacks = {};\n    if (spz.flagLod) {\n      const childCounts = new Uint16Array(numSplats);\n      const childStarts = new Uint32Array(numSplats);\n      extra.childCounts = childCounts;\n      extra.childStarts = childStarts;\n      extraCallbacks = {\n        childCounts: (index, count) => {\n          childCounts[index] = count;\n        },\n        childStarts: (index, start) => {\n          childStarts[index] = start;\n        }\n      };\n    }\n    await spz.parseSplats(\n      (index, x2, y, z) => {\n        setPackedSplatCenter(packedArray, index, x2, y, z);\n      },\n      (index, alpha) => {\n        setPackedSplatOpacity(packedArray, index, alpha);\n      },\n      (index, r, g, b) => {\n        setPackedSplatRgb(packedArray, index, r, g, b, splatEncoding);\n      },\n      (index, scaleX, scaleY, scaleZ) => {\n        setPackedSplatScales(\n          packedArray,\n          index,\n          scaleX,\n          scaleY,\n          scaleZ,\n          splatEncoding\n        );\n      },\n      (index, quatX, quatY, quatZ, quatW) => {\n        setPackedSplatQuat(packedArray, index, quatX, quatY, quatZ, quatW);\n      },\n      (index, sh1, sh2, sh3) => {\n        if (sh1) {\n          if (!extra.sh1) {\n            extra.sh1 = new Uint32Array(numSplats * 2);\n          }\n          encodeSh1Rgb(extra.sh1, index, sh1, splatEncoding);\n        }\n        if (sh2) {\n          if (!extra.sh2) {\n            extra.sh2 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh2Rgb(extra.sh2, index, sh2, splatEncoding);\n        }\n        if (sh3) {\n          if (!extra.sh3) {\n            extra.sh3 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh3Rgb(extra.sh3, index, sh3, splatEncoding);\n        }\n      },\n      extraCallbacks\n    );\n    return { packedArray, numSplats, extra };\n  }\n  const DEPTH_INFINITY_F16 = 31744;\n  const DEPTH_SIZE_16 = DEPTH_INFINITY_F16 + 1;\n  let depthArray16 = null;\n  function sortSplats({\n    totalSplats,\n    readback,\n    ordering\n  }) {\n    if (!depthArray16) {\n      depthArray16 = new Uint32Array(DEPTH_SIZE_16);\n    }\n    depthArray16.fill(0);\n    const readbackUint32 = readback.map((layer) => new Uint32Array(layer.buffer));\n    const layerSize = readbackUint32[0].length;\n    const numLayers = Math.ceil(totalSplats / layerSize);\n    let layerBase = 0;\n    for (let layer = 0; layer < numLayers; ++layer) {\n      const readbackLayer = readbackUint32[layer];\n      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);\n      for (let i2 = 0; i2 < layerSplats; ++i2) {\n        const pri = readbackLayer[i2] & 32767;\n        if (pri < DEPTH_INFINITY_F16) {\n          depthArray16[pri] += 1;\n        }\n      }\n      layerBase += layerSplats;\n    }\n    let activeSplats = 0;\n    for (let j = 0; j < DEPTH_SIZE_16; ++j) {\n      const nextIndex = activeSplats + depthArray16[j];\n      depthArray16[j] = activeSplats;\n      activeSplats = nextIndex;\n    }\n    layerBase = 0;\n    for (let layer = 0; layer < numLayers; ++layer) {\n      const readbackLayer = readbackUint32[layer];\n      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);\n      for (let i2 = 0; i2 < layerSplats; ++i2) {\n        const pri = readbackLayer[i2] & 32767;\n        if (pri < DEPTH_INFINITY_F16) {\n          ordering[depthArray16[pri]] = layerBase + i2;\n          depthArray16[pri] += 1;\n        }\n      }\n      layerBase += layerSplats;\n    }\n    if (depthArray16[DEPTH_SIZE_16 - 1] !== activeSplats) {\n      throw new Error(\n        `Expected ${activeSplats} active splats but got ${depthArray16[DEPTH_SIZE_16 - 1]}`\n      );\n    }\n    return { activeSplats, ordering };\n  }\n  const messageBuffer = [];\n  function bufferMessage(event) {\n    messageBuffer.push(event);\n  }\n  async function initialize() {\n    self.addEventListener("message", bufferMessage);\n    await __wbg_init();\n    self.removeEventListener("message", bufferMessage);\n    self.addEventListener("message", onMessage);\n    for (const event of messageBuffer) {\n      onMessage(event);\n    }\n    messageBuffer.length = 0;\n  }\n  initialize().catch(console.error);\n})();\n//# sourceMappingURL=worker-DkbdeUxj.js.map\n';
const blob = typeof self !== "undefined" && self.Blob && new Blob([jsContent], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper(options) {
  let objURL;
  try {
    objURL = blob && (self.URL || self.webkitURL).createObjectURL(blob);
    if (!objURL) throw "";
    const worker = new Worker(objURL, {
      name: options == null ? void 0 : options.name
    });
    worker.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(objURL);
    });
    return worker;
  } catch (e) {
    return new Worker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(jsContent),
      {
        name: options == null ? void 0 : options.name
      }
    );
  } finally {
    objURL && (self.URL || self.webkitURL).revokeObjectURL(objURL);
  }
}
class SplatWorker {
  constructor() {
    this.messages = {};
    this.messageIdNext = 0;
    this.worker = new WorkerWrapper();
    this.worker.onmessage = (event) => this.onMessage(event);
  }
  makeMessageId() {
    return ++this.messageIdNext;
  }
  makeMessagePromiseId() {
    const id = this.makeMessageId();
    const promise = new Promise((resolve, reject) => {
      this.messages[id] = { resolve, reject };
    });
    return { id, promise };
  }
  onMessage(event) {
    const { id, result, error } = event.data;
    const handler = this.messages[id];
    if (handler) {
      delete this.messages[id];
      if (error) {
        handler.reject(error);
      } else {
        handler.resolve(result);
      }
    }
  }
  // Invoke an RPC on the worker with the given name and arguments.
  // The normal usage of a worker is to run one activity at a time,
  // but this function allows for concurrent calls, tagging each request
  // with a unique message Id and awaiting a response to that same Id.
  // The method will automatically transfer any ArrayBuffers in the
  // arguments to the worker. If you'd like to transfer a copy of a
  // buffer then you must clone it before passing to this function.
  async call(name, args) {
    const { id, promise } = this.makeMessagePromiseId();
    this.worker.postMessage(
      { name, args, id },
      { transfer: getArrayBuffers(args) }
    );
    return promise;
  }
}
let maxWorkers = 4;
let numWorkers = 0;
const freeWorkers = [];
const workerQueue = [];
async function allocWorker() {
  const worker = freeWorkers.shift();
  if (worker) {
    return worker;
  }
  if (numWorkers < maxWorkers) {
    const worker2 = new SplatWorker();
    numWorkers += 1;
    return worker2;
  }
  return new Promise((resolve) => {
    workerQueue.push(resolve);
  });
}
function freeWorker(worker) {
  if (numWorkers > maxWorkers) {
    numWorkers -= 1;
    return;
  }
  const waiter = workerQueue.shift();
  if (waiter) {
    waiter(worker);
    return;
  }
  freeWorkers.push(worker);
}
async function withWorker(callback) {
  const worker = await allocWorker();
  try {
    return await callback(worker);
  } finally {
    freeWorker(worker);
  }
}
const _SplatLoader = class _SplatLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.fileLoader = new FileLoader(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const packedSplats = this.packedSplats;
    const fileBytes = url instanceof Uint8Array ? url : void 0;
    const resolvedURL = url instanceof Uint8Array ? void 0 : this.manager.resolveURL((this.path ?? "") + (url ?? ""));
    this.manager.itemStart(resolvedURL ?? "");
    let calledOnLoad = false;
    workerPool.withWorker(async (worker) => {
      let lod = _SplatLoader.lod;
      let nonLod = _SplatLoader.nonLod;
      let lodBase = 1.5;
      if (packedSplats == null ? void 0 : packedSplats.lod) {
        lod = true;
        if (typeof packedSplats.lod === "number") {
          lodBase = Math.max(1.1, Math.min(2, packedSplats.lod));
        }
      }
      if (packedSplats == null ? void 0 : packedSplats.nonLod) {
        nonLod = true;
      }
      let init = null;
      const onStatus = (data) => {
        const { loaded, total } = data;
        if (loaded !== void 0 && onProgress) {
          onProgress(
            new ProgressEvent("progress", {
              lengthComputable: total !== 0,
              loaded,
              total
            })
          );
        }
        if (data.orig) {
          init = data.orig;
          if (packedSplats) {
            const { numSplats, packedArray, extra, splatEncoding } = init;
            packedSplats.initialize({
              numSplats,
              packedArray,
              extra,
              splatEncoding
            });
            calledOnLoad = true;
            onLoad == null ? void 0 : onLoad(packedSplats);
          } else {
            console.log("No packedSplats to initialize");
          }
        }
      };
      const basedUrl = resolvedURL ? new URL(resolvedURL, window.location.href).toString() : void 0;
      const paged = basedUrl && (resolvedURL == null ? void 0 : resolvedURL.endsWith("-lod-0.spz")) ? {
        url: basedUrl,
        requestHeader: this.requestHeader,
        withCredentials: this.withCredentials
      } : void 0;
      const decoded = await worker.call(
        "loadSplats",
        {
          url: basedUrl,
          // baseUri: window.location.href,
          requestHeader: this.requestHeader,
          withCredentials: this.withCredentials,
          fileBytes: fileBytes == null ? void 0 : fileBytes.slice(),
          fileType: this.fileType,
          pathName: resolvedURL,
          lod,
          lodBase,
          nonLod
        },
        { onStatus }
      );
      if (decoded.lodSplats) {
        decoded.lodSplats = new PackedSplats({
          ...decoded.lodSplats,
          paged
        });
      }
      const initSplats = {
        ...init ?? {},
        ...decoded
      };
      if (packedSplats) {
        packedSplats.initialize(initSplats);
        if (!calledOnLoad) {
          onLoad == null ? void 0 : onLoad(packedSplats);
        }
      } else {
        if (!calledOnLoad) {
          onLoad == null ? void 0 : onLoad(new PackedSplats(initSplats));
        }
      }
    }).catch((error) => {
      this.manager.itemError(resolvedURL ?? "");
      onError == null ? void 0 : onError(error);
    }).finally(() => {
      this.manager.itemEnd(resolvedURL ?? "");
    });
  }
  async loadAsync(url, onProgress) {
    return new Promise((resolve, reject) => {
      this.load(
        url,
        (decoded) => {
          resolve(decoded);
        },
        onProgress,
        reject
      );
    });
  }
  parse(packedSplats) {
    return new SplatMesh({ packedSplats });
  }
};
_SplatLoader.lod = false;
_SplatLoader.nonLod = false;
let SplatLoader = _SplatLoader;
var SplatFileType = /* @__PURE__ */ ((SplatFileType2) => {
  SplatFileType2["PLY"] = "ply";
  SplatFileType2["SPZ"] = "spz";
  SplatFileType2["SPLAT"] = "splat";
  SplatFileType2["KSPLAT"] = "ksplat";
  SplatFileType2["PCSOGS"] = "pcsogs";
  SplatFileType2["PCSOGSZIP"] = "pcsogszip";
  return SplatFileType2;
})(SplatFileType || {});
function getSplatFileType(fileBytes) {
  const view = new DataView(fileBytes.buffer);
  if ((view.getUint32(0, true) & 16777215) === 7957616) {
    return "ply";
  }
  if ((view.getUint32(0, true) & 16777215) === 559903) {
    const header = decompressPartialGzip(fileBytes, 4);
    const gView = new DataView(header.buffer);
    if (gView.getUint32(0, true) === 1347635022) {
      return "spz";
    }
    return void 0;
  }
  if (view.getUint32(0, true) === 67324752) {
    if (tryPcSogsZip(fileBytes)) {
      return "pcsogszip";
    }
    return void 0;
  }
  return void 0;
}
function getFileExtension(pathOrUrl) {
  const noTrailing = pathOrUrl.split(/[?#]/, 1)[0];
  const lastSlash = Math.max(
    noTrailing.lastIndexOf("/"),
    noTrailing.lastIndexOf("\\")
  );
  const filename = noTrailing.slice(lastSlash + 1);
  const lastDot = filename.lastIndexOf(".");
  if (lastDot <= 0 || lastDot === filename.length - 1) {
    return "";
  }
  return filename.slice(lastDot + 1).toLowerCase();
}
function getSplatFileTypeFromPath(pathOrUrl) {
  const extension = getFileExtension(pathOrUrl);
  if (extension === "ply") {
    return "ply";
  }
  if (extension === "spz") {
    return "spz";
  }
  if (extension === "splat") {
    return "splat";
  }
  if (extension === "ksplat") {
    return "ksplat";
  }
  if (extension === "sog") {
    return "pcsogszip";
  }
  return void 0;
}
function isPcSogs(input) {
  return tryPcSogs(input) !== void 0;
}
function tryPcSogs(input) {
  try {
    let text;
    if (typeof input === "string") {
      text = input;
    } else {
      const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;
      if (fileBytes.length > 65536) {
        return void 0;
      }
      text = new TextDecoder().decode(fileBytes);
    }
    const json = JSON.parse(text);
    if (!json || typeof json !== "object" || Array.isArray(json)) {
      return void 0;
    }
    const isVersion2 = json.version === 2;
    for (const key of ["means", "scales", "quats", "sh0"]) {
      if (!json[key] || typeof json[key] !== "object" || Array.isArray(json[key])) {
        return void 0;
      }
      if (isVersion2) {
        if (!json[key].files) {
          return void 0;
        }
        if ((key === "scales" || key === "sh0") && !json[key].codebook) {
          return void 0;
        }
        if (key === "means" && (!json[key].mins || !json[key].maxs)) {
          return void 0;
        }
      } else {
        if (!json[key].shape || !json[key].files) {
          return void 0;
        }
        if (key !== "quats" && (!json[key].mins || !json[key].maxs)) {
          return void 0;
        }
      }
    }
    return json;
  } catch {
    return void 0;
  }
}
function tryPcSogsZip(input) {
  try {
    const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;
    let metaFilename = null;
    const unzipped = unzipSync(fileBytes, {
      filter: ({ name }) => {
        const filename = name.split(/[\\/]/).pop();
        if (filename === "meta.json") {
          metaFilename = name;
          return true;
        }
        return false;
      }
    });
    if (!metaFilename) {
      return void 0;
    }
    const json = tryPcSogs(unzipped[metaFilename]);
    if (!json) {
      return void 0;
    }
    return { name: metaFilename, json };
  } catch {
    return void 0;
  }
}
async function unpackSplats({
  input,
  extraFiles,
  fileType,
  pathOrUrl,
  splatEncoding
}) {
  const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;
  let splatFileType = fileType;
  if (!fileType) {
    splatFileType = getSplatFileType(fileBytes);
    if (!splatFileType && pathOrUrl) {
      splatFileType = getSplatFileTypeFromPath(pathOrUrl);
    }
  }
  switch (splatFileType) {
    case "ply": {
      const ply = new PlyReader({ fileBytes });
      await ply.parseHeader();
      const numSplats = ply.numSplats;
      const maxSplats = getTextureSize(numSplats).maxSplats;
      const args = {
        fileBytes,
        packedArray: new Uint32Array(maxSplats * 4),
        splatEncoding
      };
      return await withWorker(async (worker) => {
        const { packedArray, numSplats: numSplats2, extra } = await worker.call(
          "unpackPly",
          args
        );
        return { packedArray, numSplats: numSplats2, extra };
      });
    }
    case "spz": {
      return await withWorker(async (worker) => {
        const { packedArray, numSplats, extra } = await worker.call(
          "decodeSpz",
          {
            fileBytes,
            splatEncoding
          }
        );
        return { packedArray, numSplats, extra };
      });
    }
    case "splat": {
      return await withWorker(async (worker) => {
        const { packedArray, numSplats } = await worker.call(
          "decodeAntiSplat",
          {
            fileBytes,
            splatEncoding
          }
        );
        return { packedArray, numSplats };
      });
    }
    case "ksplat": {
      return await withWorker(async (worker) => {
        const { packedArray, numSplats, extra } = await worker.call(
          "decodeKsplat",
          { fileBytes, splatEncoding }
        );
        return { packedArray, numSplats, extra };
      });
    }
    case "pcsogs": {
      return await withWorker(async (worker) => {
        const { packedArray, numSplats, extra } = await worker.call(
          "decodePcSogs",
          { fileBytes, extraFiles, splatEncoding }
        );
        return { packedArray, numSplats, extra };
      });
    }
    case "pcsogszip": {
      return await withWorker(async (worker) => {
        const { packedArray, numSplats, extra } = await worker.call(
          "decodePcSogsZip",
          { fileBytes, splatEncoding }
        );
        return { packedArray, numSplats, extra };
      });
    }
    default: {
      throw new Error(`Unknown splat file type: ${splatFileType}`);
    }
  }
}
class SplatData {
  constructor({ maxSplats = 1 } = {}) {
    this.numSplats = 0;
    this.maxSplats = getTextureSize(maxSplats).maxSplats;
    this.centers = new Float32Array(this.maxSplats * 3);
    this.scales = new Float32Array(this.maxSplats * 3);
    this.quaternions = new Float32Array(this.maxSplats * 4);
    this.opacities = new Float32Array(this.maxSplats);
    this.colors = new Float32Array(this.maxSplats * 3);
  }
  pushSplat() {
    const index = this.numSplats;
    this.ensureIndex(index);
    this.numSplats += 1;
    return index;
  }
  unpushSplat(index) {
    if (index === this.numSplats - 1) {
      this.numSplats -= 1;
    } else {
      throw new Error("Cannot unpush splat from non-last position");
    }
  }
  ensureCapacity(numSplats) {
    if (numSplats > this.maxSplats) {
      const targetSplats = Math.max(numSplats, this.maxSplats * 2);
      const newCenters = new Float32Array(targetSplats * 3);
      const newScales = new Float32Array(targetSplats * 3);
      const newQuaternions = new Float32Array(targetSplats * 4);
      const newOpacities = new Float32Array(targetSplats);
      const newColors = new Float32Array(targetSplats * 3);
      newCenters.set(this.centers);
      newScales.set(this.scales);
      newQuaternions.set(this.quaternions);
      newOpacities.set(this.opacities);
      newColors.set(this.colors);
      this.centers = newCenters;
      this.scales = newScales;
      this.quaternions = newQuaternions;
      this.opacities = newOpacities;
      this.colors = newColors;
      if (this.sh1) {
        const newSh1 = new Float32Array(targetSplats * 9);
        newSh1.set(this.sh1);
        this.sh1 = newSh1;
      }
      if (this.sh2) {
        const newSh2 = new Float32Array(targetSplats * 15);
        newSh2.set(this.sh2);
        this.sh2 = newSh2;
      }
      if (this.sh3) {
        const newSh3 = new Float32Array(targetSplats * 21);
        newSh3.set(this.sh3);
        this.sh3 = newSh3;
      }
      this.maxSplats = targetSplats;
    }
  }
  ensureIndex(index) {
    this.ensureCapacity(index + 1);
  }
  setCenter(index, x, y, z) {
    this.centers[index * 3] = x;
    this.centers[index * 3 + 1] = y;
    this.centers[index * 3 + 2] = z;
  }
  setScale(index, scaleX, scaleY, scaleZ) {
    this.scales[index * 3] = scaleX;
    this.scales[index * 3 + 1] = scaleY;
    this.scales[index * 3 + 2] = scaleZ;
  }
  setQuaternion(index, x, y, z, w) {
    this.quaternions[index * 4] = x;
    this.quaternions[index * 4 + 1] = y;
    this.quaternions[index * 4 + 2] = z;
    this.quaternions[index * 4 + 3] = w;
  }
  setOpacity(index, opacity) {
    this.opacities[index] = opacity;
  }
  setColor(index, r, g, b) {
    this.colors[index * 3] = r;
    this.colors[index * 3 + 1] = g;
    this.colors[index * 3 + 2] = b;
  }
  setSh1(index, sh1) {
    if (!this.sh1) {
      this.sh1 = new Float32Array(this.maxSplats * 9);
    }
    for (let j = 0; j < 9; ++j) {
      this.sh1[index * 9 + j] = sh1[j];
    }
  }
  setSh2(index, sh2) {
    if (!this.sh2) {
      this.sh2 = new Float32Array(this.maxSplats * 15);
    }
    for (let j = 0; j < 15; ++j) {
      this.sh2[index * 15 + j] = sh2[j];
    }
  }
  setSh3(index, sh3) {
    if (!this.sh3) {
      this.sh3 = new Float32Array(this.maxSplats * 21);
    }
    for (let j = 0; j < 21; ++j) {
      this.sh3[index * 21 + j] = sh3[j];
    }
  }
}
var computeUvec4_default = "precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout uvec4 target;\n\n{{ GLOBALS }}\n\nvoid produceSplat(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    target = uvec4(0u, 0u, 0u, 0u);\n    if ((index >= 0) && (index < targetCount)) {\n        produceSplat(index);\n    }\n}";
const DEFAULT_SPLAT_ENCODING = {
  rgbMin: 0,
  rgbMax: 1,
  lnScaleMin: LN_SCALE_MIN,
  lnScaleMax: LN_SCALE_MAX,
  sh1Min: -1,
  sh1Max: 1,
  sh2Min: -1,
  sh2Max: 1,
  sh3Min: -1,
  sh3Max: 1,
  lodOpacity: false
};
const _PackedSplats = class _PackedSplats {
  constructor(options = {}) {
    this.maxSplats = 0;
    this.numSplats = 0;
    this.packedArray = null;
    this.pageCache = null;
    this.chunkToPage = /* @__PURE__ */ new Map();
    this.pageFreelist = [];
    this.pageMax = 0;
    this.pageTop = 0;
    this.isInitialized = false;
    this.target = null;
    this.source = null;
    this.needsUpdate = true;
    this.extra = {};
    this.dyno = new DynoPackedSplats({ packedSplats: this });
    this.dynoRgbMinMaxLnScaleMinMax = new DynoVec4({
      key: "rgbMinMaxLnScaleMinMax",
      value: new THREE.Vector4(0, 1, LN_SCALE_MIN, LN_SCALE_MAX),
      update: (value) => {
        var _a2, _b2, _c, _d;
        value.set(
          ((_a2 = this.splatEncoding) == null ? void 0 : _a2.rgbMin) ?? 0,
          ((_b2 = this.splatEncoding) == null ? void 0 : _b2.rgbMax) ?? 1,
          ((_c = this.splatEncoding) == null ? void 0 : _c.lnScaleMin) ?? LN_SCALE_MIN,
          ((_d = this.splatEncoding) == null ? void 0 : _d.lnScaleMax) ?? LN_SCALE_MAX
        );
        return value;
      }
    });
    this.dynoSh1MinMax = new DynoVec2({
      key: "sh1MinMax",
      value: new THREE.Vector2(-1, 1),
      update: (value) => {
        var _a2, _b2;
        value.set(
          ((_a2 = this.splatEncoding) == null ? void 0 : _a2.sh1Min) ?? -1,
          ((_b2 = this.splatEncoding) == null ? void 0 : _b2.sh1Max) ?? 1
        );
        return value;
      }
    });
    this.dynoSh2MinMax = new DynoVec2({
      key: "sh2MinMax",
      value: new THREE.Vector2(-1, 1),
      update: (value) => {
        var _a2, _b2;
        value.set(
          ((_a2 = this.splatEncoding) == null ? void 0 : _a2.sh2Min) ?? -1,
          ((_b2 = this.splatEncoding) == null ? void 0 : _b2.sh2Max) ?? 1
        );
        return value;
      }
    });
    this.dynoSh3MinMax = new DynoVec2({
      key: "sh3MinMax",
      value: new THREE.Vector2(-1, 1),
      update: (value) => {
        var _a2, _b2;
        value.set(
          ((_a2 = this.splatEncoding) == null ? void 0 : _a2.sh3Min) ?? -1,
          ((_b2 = this.splatEncoding) == null ? void 0 : _b2.sh3Max) ?? 1
        );
        return value;
      }
    });
    this.initialized = Promise.resolve(this);
    this.reinitialize(options);
  }
  reinitialize(options) {
    this.isInitialized = false;
    this.extra = {};
    this.splatEncoding = options.splatEncoding;
    this.lod = options.lod;
    this.nonLod = options.nonLod;
    if (options.url || options.fileBytes || options.construct) {
      this.initialized = this.asyncInitialize(options).then(() => {
        this.isInitialized = true;
        return this;
      });
    } else {
      this.initialize(options);
      this.isInitialized = true;
      this.initialized = Promise.resolve(this);
    }
  }
  initialize(options) {
    this.extra = options.extra ?? {};
    this.lodSplats = options.lodSplats;
    this.paged = options.paged;
    if (options.packedArray) {
      this.packedArray = options.packedArray;
      this.numSplats = options.numSplats ?? this.packedArray.length / 4;
      if (options.paged) {
        this.maxSplats = options.maxSplats ?? 16777216;
        this.ensurePagedTexture();
        const numPages = Math.ceil(this.numSplats / 65536);
        for (let page = 0; page < numPages; ++page) {
          this.chunkToPage.set(page, page);
        }
        this.pageMax = Math.ceil(this.maxSplats / 65536);
        this.pageTop = numPages;
      } else {
        this.maxSplats = Math.floor(this.packedArray.length / 4);
        this.maxSplats = Math.floor(this.maxSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;
        this.numSplats = Math.min(
          this.maxSplats,
          options.numSplats ?? Number.POSITIVE_INFINITY
        );
      }
    } else {
      this.maxSplats = options.maxSplats ?? 0;
      this.numSplats = 0;
    }
  }
  async asyncInitialize(options) {
    const { url, fileBytes, construct, lod, nonLod } = options;
    this.lod = lod;
    this.nonLod = nonLod;
    const loader = new SplatLoader();
    loader.packedSplats = this;
    if (fileBytes) {
      await loader.loadAsync(
        fileBytes,
        options.onProgress
      );
    } else if (url) {
      await loader.loadAsync(url, options.onProgress);
    }
    if (construct) {
      const maybePromise = construct(this);
      if (maybePromise instanceof Promise) {
        await maybePromise;
      }
    }
  }
  // Call this when you are finished with the PackedSplats and want to free
  // any buffers it holds.
  dispose() {
    if (this.target) {
      this.target.dispose();
      this.target = null;
    }
    if (this.source) {
      this.source.dispose();
      this.source = null;
    }
    if (this.lodSplats) {
      this.lodSplats.dispose();
      this.lodSplats = void 0;
    }
    if (this.pageCache) {
      this.pageCache.dispose();
      this.pageCache = null;
    }
  }
  // Ensures that this.packedArray can fit numSplats Gsplats. If it's too small,
  // resize exponentially and copy over the original data.
  //
  // Typically you don't need to call this, because calling this.setSplat(index, ...)
  // and this.pushSplat(...) will automatically call ensureSplats() so we have
  // enough splats.
  ensureSplats(numSplats) {
    const targetSize = numSplats <= this.maxSplats ? this.maxSplats : (
      // Grow exponentially to avoid frequent reallocations
      Math.max(numSplats, 2 * this.maxSplats)
    );
    const currentSize = !this.packedArray ? 0 : this.packedArray.length / 4;
    if (!this.packedArray || targetSize > currentSize) {
      this.maxSplats = getTextureSize(targetSize).maxSplats;
      const newArray2 = new Uint32Array(this.maxSplats * 4);
      if (this.packedArray) {
        newArray2.set(this.packedArray);
      }
      this.packedArray = newArray2;
    }
    return this.packedArray;
  }
  // Ensure the extra array for the given level is large enough to hold numSplats
  ensureSplatsSh(level, numSplats) {
    let wordsPerSplat;
    let key;
    if (level === 0) {
      return this.ensureSplats(numSplats);
    }
    if (level === 1) {
      wordsPerSplat = 2;
      key = "sh1";
    } else if (level === 2) {
      wordsPerSplat = 4;
      key = "sh2";
    } else if (level === 3) {
      wordsPerSplat = 4;
      key = "sh3";
    } else {
      throw new Error(`Invalid level: ${level}`);
    }
    let maxSplats = !this.extra[key] ? 0 : this.extra[key].length / wordsPerSplat;
    const targetSize = numSplats <= maxSplats ? maxSplats : Math.max(numSplats, 2 * maxSplats);
    if (!this.extra[key] || targetSize > maxSplats) {
      maxSplats = getTextureSize(targetSize).maxSplats;
      const newArray2 = new Uint32Array(maxSplats * wordsPerSplat);
      if (this.extra[key]) {
        newArray2.set(this.extra[key]);
      }
      this.extra[key] = newArray2;
    }
    return this.extra[key];
  }
  // Unpack the 16-byte Gsplat data at index into the Three.js components
  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,
  // opacity: number 0..1, color: THREE.Color 0..1.
  getSplat(index) {
    if (!this.packedArray || index >= this.numSplats) {
      throw new Error("Invalid index");
    }
    return unpackSplat(this.packedArray, index, this.splatEncoding);
  }
  // Set all PackedSplat components at index with the provided Gsplat attributes
  // (can be the same objects returned by getSplat). Ensures there is capacity
  // for at least index+1 Gsplats.
  setSplat(index, center, scales, quaternion, opacity, color) {
    const packedSplats = this.ensureSplats(index + 1);
    setPackedSplat(
      packedSplats,
      index,
      center.x,
      center.y,
      center.z,
      scales.x,
      scales.y,
      scales.z,
      quaternion.x,
      quaternion.y,
      quaternion.z,
      quaternion.w,
      opacity,
      color.r,
      color.g,
      color.b
    );
    this.numSplats = Math.max(this.numSplats, index + 1);
  }
  // Effectively calls this.setSplat(this.numSplats++, center, ...), useful on
  // construction where you just want to iterate and create a collection of Gsplats.
  pushSplat(center, scales, quaternion, opacity, color) {
    const packedSplats = this.ensureSplats(this.numSplats + 1);
    setPackedSplat(
      packedSplats,
      this.numSplats,
      center.x,
      center.y,
      center.z,
      scales.x,
      scales.y,
      scales.z,
      quaternion.x,
      quaternion.y,
      quaternion.z,
      quaternion.w,
      opacity,
      color.r,
      color.g,
      color.b
    );
    ++this.numSplats;
  }
  // Iterate over Gsplats index 0..=(this.numSplats-1), unpack each Gsplat
  // and invoke the callback function with the Gsplat attributes.
  forEachSplat(callback) {
    if (!this.packedArray || !this.numSplats) {
      return;
    }
    for (let i = 0; i < this.numSplats; ++i) {
      const unpacked = unpackSplat(this.packedArray, i, this.splatEncoding);
      callback(
        i,
        unpacked.center,
        unpacked.scales,
        unpacked.quaternion,
        unpacked.opacity,
        unpacked.color
      );
    }
  }
  // Ensures our PackedSplats.target render target has enough space to generate
  // maxSplats total Gsplats, and reallocate if not large enough.
  ensureGenerate(maxSplats) {
    if (this.target && (maxSplats ?? 1) <= this.maxSplats) {
      return false;
    }
    this.dispose();
    const textureSize2 = getTextureSize(maxSplats ?? 1);
    const { width, height, depth } = textureSize2;
    this.maxSplats = textureSize2.maxSplats;
    this.target = new THREE.WebGLArrayRenderTarget(width, height, depth, {
      depthBuffer: false,
      stencilBuffer: false,
      generateMipmaps: false,
      magFilter: THREE.NearestFilter,
      minFilter: THREE.NearestFilter
    });
    this.target.texture.format = THREE.RGBAIntegerFormat;
    this.target.texture.type = THREE.UnsignedIntType;
    this.target.texture.internalFormat = "RGBA32UI";
    this.target.scissorTest = true;
    return true;
  }
  // Given an array of splatCounts (.numSplats for each
  // SplatGenerator/SplatMesh in the scene), compute a
  // "mapping layout" in the composite array of generated outputs.
  generateMapping(splatCounts) {
    let maxSplats = 0;
    const mapping = splatCounts.map((numSplats) => {
      const base = maxSplats;
      const rounded = Math.ceil(numSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;
      maxSplats += rounded;
      return { base, count: numSplats };
    });
    return { maxSplats, mapping };
  }
  // Returns a THREE.DataArrayTexture representing the PackedSplats content as
  // a Uint32x4 data array texture (2048 x 2048 x depth in size)
  getTexture() {
    if (this.target) {
      return this.target.texture;
    }
    if (this.source || this.packedArray) {
      const source = this.maybeUpdateSource();
      return source;
    }
    return _PackedSplats.getEmptyArray;
  }
  ensurePagedTexture() {
    if (this.pageCache) {
      const { width, height } = this.pageCache.image;
      if (this.maxSplats !== width * height) {
        this.pageCache.dispose();
        this.pageCache = null;
      }
    }
    if (!this.pageCache) {
      const maxSplats = Math.max(this.maxSplats, 65536 * 4);
      const width = SPLAT_PAGED_WIDTH;
      const height = Math.ceil(maxSplats / SPLAT_PAGED_WIDTH);
      if (height > SPLAT_PAGED_HEIGHT) {
        throw new Error("Max splats exceeds paged height");
      }
      if (!this.packedArray || this.packedArray.length < width * height * 4) {
        const newArray2 = new Uint32Array(width * height * 4);
        if (this.packedArray) {
          newArray2.set(this.packedArray);
        }
        this.packedArray = newArray2;
      }
      this.pageCache = new THREE.DataTexture(this.packedArray, width, height, THREE.RGBAIntegerFormat, THREE.UnsignedIntType);
      this.pageCache.internalFormat = "RGBA32UI";
      this.pageCache.needsUpdate = true;
      this.maxSplats = width * height;
      console.log("**** Created page cache", this.pageCache);
    }
  }
  allocTexturePage() {
    let page = this.pageFreelist.shift();
    if (page != null) {
      return page;
    }
    if (this.pageTop >= this.pageMax) {
      return void 0;
    }
    page = this.pageTop;
    this.pageTop += 1;
    this.numSplats = this.pageTop * 65536;
    return page;
  }
  uploadTexturePage(renderer, packedArray, page) {
    const gl = renderer.getContext();
    if (!renderer.properties.has(this.pageCache)) {
      throw new Error("Page cache not found");
    }
    const props = renderer.properties.get(this.pageCache);
    const glTexture = props.__webglTexture;
    if (!glTexture) {
      throw new Error("Page cache texture not found");
    }
    renderer.state.activeTexture(gl.TEXTURE0);
    renderer.state.bindTexture(gl.TEXTURE_2D, glTexture);
    const pageRows = 65536 / 4096;
    gl.texSubImage2D(
      gl.TEXTURE_2D,
      0,
      0,
      page * pageRows,
      SPLAT_PAGED_WIDTH,
      pageRows,
      gl.RGBA_INTEGER,
      gl.UNSIGNED_INT,
      packedArray
    );
    renderer.state.bindTexture(gl.TEXTURE_2D, null);
  }
  getPagedTexture() {
    if (!this.paged) {
      throw new Error("PackedSplats is not paged");
    }
    this.ensurePagedTexture();
    return this.pageCache;
  }
  // Check if source texture needs to be created/updated
  maybeUpdateSource() {
    if (!this.packedArray) {
      throw new Error("No packed splats");
    }
    if (this.needsUpdate || !this.source) {
      this.needsUpdate = false;
      if (this.source) {
        const { width, height, depth } = this.source.image;
        if (this.maxSplats !== width * height * depth) {
          this.source.dispose();
          this.source = null;
        }
      }
      if (!this.source) {
        const { width, height, depth } = getTextureSize(this.maxSplats);
        this.source = new THREE.DataArrayTexture(
          this.packedArray,
          width,
          height,
          depth
        );
        this.source.format = THREE.RGBAIntegerFormat;
        this.source.type = THREE.UnsignedIntType;
        this.source.internalFormat = "RGBA32UI";
        this.source.needsUpdate = true;
      } else if (this.packedArray.buffer !== this.source.image.data.buffer) {
        this.source.image.data = new Uint8Array(this.packedArray.buffer);
      }
      this.source.needsUpdate = true;
    }
    return this.source;
  }
  // Get a program and THREE.RawShaderMaterial for a given GsplatGenerator,
  // generating it if necessary and caching the result.
  prepareProgramMaterial(generator) {
    let program = _PackedSplats.generatorProgram.get(generator);
    if (!program) {
      const graph = dynoBlock(
        { index: "int" },
        { output: "uvec4" },
        ({ index }) => {
          generator.inputs.index = index;
          const gsplat = generator.outputs.gsplat;
          const output = outputPackedSplat(
            gsplat,
            this.dynoRgbMinMaxLnScaleMinMax
          );
          return { output };
        }
      );
      if (!_PackedSplats.programTemplate) {
        _PackedSplats.programTemplate = new DynoProgramTemplate(
          computeUvec4_default
        );
      }
      program = new DynoProgram({
        graph,
        inputs: { index: "index" },
        outputs: { output: "target" },
        template: _PackedSplats.programTemplate
      });
      Object.assign(program.uniforms, {
        targetLayer: { value: 0 },
        targetBase: { value: 0 },
        targetCount: { value: 0 }
      });
      _PackedSplats.generatorProgram.set(generator, program);
    }
    const material = program.prepareMaterial();
    _PackedSplats.fullScreenQuad.material = material;
    return { program, material };
  }
  saveRenderState(renderer) {
    return {
      xrEnabled: renderer.xr.enabled,
      autoClear: renderer.autoClear
    };
  }
  resetRenderState(renderer, state) {
    renderer.setRenderTarget(null);
    renderer.xr.enabled = state.xrEnabled;
    renderer.autoClear = state.autoClear;
  }
  // Executes a dyno program specified by generator which is any DynoBlock that
  // maps { index: "int" } to { gsplat: Gsplat }. This is called in
  // SparkRenderer.updateInternal() to re-generate Gsplats in the scene for
  // SplatGenerator instances whose version is newer than what was generated
  // for it last time.
  generate({
    generator,
    base,
    count,
    renderer
  }) {
    if (!this.target) {
      throw new Error("Target must be initialized with ensureSplats");
    }
    if (base + count > this.maxSplats) {
      throw new Error("Base + count exceeds maxSplats");
    }
    const { program, material } = this.prepareProgramMaterial(generator);
    program.update();
    const renderState = this.saveRenderState(renderer);
    const nextBase = Math.ceil((base + count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;
    const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;
    material.uniforms.targetBase.value = base;
    material.uniforms.targetCount.value = count;
    while (base < nextBase) {
      const layer = Math.floor(base / layerSize);
      material.uniforms.targetLayer.value = layer;
      const layerBase = layer * layerSize;
      const layerYStart = Math.floor((base - layerBase) / SPLAT_TEX_WIDTH);
      const layerYEnd = Math.min(
        SPLAT_TEX_HEIGHT,
        Math.ceil((nextBase - layerBase) / SPLAT_TEX_WIDTH)
      );
      this.target.scissor.set(
        0,
        layerYStart,
        SPLAT_TEX_WIDTH,
        layerYEnd - layerYStart
      );
      renderer.setRenderTarget(this.target, layer);
      renderer.xr.enabled = false;
      renderer.autoClear = false;
      _PackedSplats.fullScreenQuad.render(renderer);
      base += SPLAT_TEX_WIDTH * (layerYEnd - layerYStart);
    }
    this.resetRenderState(renderer, renderState);
    return { nextBase };
  }
  async createLodSplats() {
    const lodBase = typeof this.lod === "number" ? Math.max(1.1, Math.min(2, this.lod)) : 1.5;
    const packedArray = this.packedArray.slice();
    const extra = {
      sh1: this.extra.sh1 ? this.extra.sh1.slice() : void 0,
      sh2: this.extra.sh2 ? this.extra.sh2.slice() : void 0,
      sh3: this.extra.sh3 ? this.extra.sh3.slice() : void 0
    };
    const decoded = await workerPool.withWorker(async (worker) => {
      return await worker.call("quickLod", {
        numSplats: this.numSplats,
        packedArray,
        extra,
        lodBase
      });
    });
    console.log("=> createLodSplats: decoded =", decoded);
    const lodSplats = new _PackedSplats(decoded);
    if (this.lodSplats) {
      this.lodSplats.dispose();
    }
    this.lodSplats = lodSplats;
    this.nonLod = true;
    if (!this.lod) {
      this.lod = lodBase;
    }
    console.log("=> createLodSplats: this =", this);
  }
};
_PackedSplats.getEmptyArray = (() => {
  const { width, height, depth, maxSplats } = getTextureSize(1);
  const emptyArray = new Uint32Array(maxSplats * 4);
  const texture2 = new THREE.DataArrayTexture(
    emptyArray,
    width,
    height,
    depth
  );
  texture2.format = THREE.RGBAIntegerFormat;
  texture2.type = THREE.UnsignedIntType;
  texture2.internalFormat = "RGBA32UI";
  texture2.needsUpdate = true;
  return texture2;
})();
_PackedSplats.getEmptyFlat = (() => {
  const empty = new Uint32Array(4096 * 4);
  const texture2 = new THREE.DataTexture(empty, 4096, 1, THREE.RGBAIntegerFormat, THREE.UnsignedIntType);
  texture2.internalFormat = "RGBA32UI";
  texture2.needsUpdate = true;
  return texture2;
})();
_PackedSplats.programTemplate = null;
_PackedSplats.generatorProgram = /* @__PURE__ */ new Map();
_PackedSplats.fullScreenQuad = new FullScreenQuad(
  new THREE.RawShaderMaterial({ visible: false })
);
let PackedSplats = _PackedSplats;
class DynoPackedSplats extends DynoUniform {
  constructor({ packedSplats } = {}) {
    super({
      key: "packedSplats",
      type: TPackedSplats,
      globals: () => [definePackedSplats],
      value: {
        textureArray: PackedSplats.getEmptyArray,
        texture: PackedSplats.getEmptyFlat,
        numSplats: 0,
        rgbMinMaxLnScaleMinMax: new THREE.Vector4(
          0,
          1,
          LN_SCALE_MIN,
          LN_SCALE_MAX
        ),
        flagsFlatLodOpacity: 0
      },
      update: (value) => {
        var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
        if ((_a2 = this.packedSplats) == null ? void 0 : _a2.paged) {
          value.textureArray = PackedSplats.getEmptyArray;
          value.texture = ((_b2 = this.packedSplats) == null ? void 0 : _b2.getPagedTexture()) ?? PackedSplats.getEmptyFlat;
          value.flagsFlatLodOpacity = 1;
        } else {
          value.textureArray = ((_c = this.packedSplats) == null ? void 0 : _c.getTexture()) ?? PackedSplats.getEmptyArray;
          value.texture = PackedSplats.getEmptyFlat;
          value.flagsFlatLodOpacity = 0;
        }
        value.numSplats = ((_d = this.packedSplats) == null ? void 0 : _d.numSplats) ?? 0;
        value.rgbMinMaxLnScaleMinMax.set(
          ((_f = (_e = this.packedSplats) == null ? void 0 : _e.splatEncoding) == null ? void 0 : _f.rgbMin) ?? 0,
          ((_h = (_g = this.packedSplats) == null ? void 0 : _g.splatEncoding) == null ? void 0 : _h.rgbMax) ?? 1,
          ((_j = (_i = this.packedSplats) == null ? void 0 : _i.splatEncoding) == null ? void 0 : _j.lnScaleMin) ?? LN_SCALE_MIN,
          ((_l = (_k = this.packedSplats) == null ? void 0 : _k.splatEncoding) == null ? void 0 : _l.lnScaleMax) ?? LN_SCALE_MAX
        );
        value.flagsFlatLodOpacity = value.flagsFlatLodOpacity | (((_n = (_m = this.packedSplats) == null ? void 0 : _m.splatEncoding) == null ? void 0 : _n.lodOpacity) ? 2 : 0);
        return value;
      }
    });
    this.packedSplats = packedSplats;
  }
}
class SplatGeometry extends THREE.InstancedBufferGeometry {
  constructor(ordering, activeSplats) {
    super();
    this.ordering = ordering;
    this.setAttribute("position", new THREE.BufferAttribute(QUAD_VERTICES$1, 3));
    this.setIndex(new THREE.BufferAttribute(QUAD_INDICES$1, 1));
    this._maxInstanceCount = ordering.length;
    this.instanceCount = activeSplats;
    this.attribute = new THREE.InstancedBufferAttribute(ordering, 1, false, 1);
    this.attribute.setUsage(THREE.DynamicDrawUsage);
    this.setAttribute("splatIndex", this.attribute);
  }
  update(ordering, activeSplats) {
    this.ordering = ordering;
    this.attribute.array = ordering;
    this.instanceCount = activeSplats;
    this.attribute.addUpdateRange(0, activeSplats);
    this.attribute.needsUpdate = true;
  }
}
const QUAD_VERTICES$1 = new Float32Array([
  -1,
  -1,
  0,
  1,
  -1,
  0,
  1,
  1,
  0,
  -1,
  1,
  0
]);
const QUAD_INDICES$1 = new Uint16Array([0, 1, 2, 0, 2, 3]);
const _SparkViewpoint = class _SparkViewpoint {
  constructor(options) {
    this.lastTime = null;
    this.encodeLinear = false;
    this.superXY = 1;
    this.display = null;
    this.sorting = null;
    this.pending = null;
    this.sortingCheck = false;
    this.readback16 = new Uint16Array(0);
    this.readback32 = new Uint32Array(0);
    this.spark = options.spark;
    this.camera = options.camera;
    this.viewToWorld = options.viewToWorld ?? new THREE.Matrix4();
    if (options.target) {
      const { width, height, doubleBuffer } = options.target;
      const superXY = Math.max(1, Math.min(4, options.target.superXY ?? 1));
      this.superXY = superXY;
      if (width * superXY > 8192 || height * superXY > 8192) {
        throw new Error("Target size too large");
      }
      this.target = new THREE.WebGLRenderTarget(
        width * superXY,
        height * superXY,
        {
          format: THREE.RGBAFormat,
          type: THREE.UnsignedByteType,
          colorSpace: THREE.SRGBColorSpace
        }
      );
      if (doubleBuffer) {
        this.back = new THREE.WebGLRenderTarget(
          width * superXY,
          height * superXY,
          {
            format: THREE.RGBAFormat,
            type: THREE.UnsignedByteType,
            colorSpace: THREE.SRGBColorSpace
          }
        );
      }
      this.encodeLinear = true;
    }
    this.onTextureUpdated = options.onTextureUpdated;
    this.sortRadial = options.sortRadial ?? true;
    this.sortDistance = options.sortDistance;
    this.sortCoorient = options.sortCoorient;
    this.depthBias = options.depthBias;
    this.sort360 = options.sort360;
    this.sort32 = options.sort32;
    this.stochastic = options.stochastic ?? false;
    this.orderingFreelist = new FreeList({
      allocate: (maxSplats) => new Uint32Array(maxSplats),
      valid: (ordering, maxSplats) => ordering.length === maxSplats
    });
    this.autoUpdate = false;
    this.setAutoUpdate(options.autoUpdate ?? false);
  }
  // Call this when you are done with the SparkViewpoint and want to
  // free up its resources (GPU targets, pixel buffers, etc.)
  dispose() {
    var _a2;
    this.setAutoUpdate(false);
    if (this.target) {
      this.target.dispose();
      this.target = void 0;
    }
    if (this.back) {
      this.back.dispose();
      this.back = void 0;
    }
    if (this.display) {
      this.spark.releaseAccumulator(this.display.accumulator);
      this.display.geometry.dispose();
      this.display = null;
    }
    if ((_a2 = this.pending) == null ? void 0 : _a2.accumulator) {
      this.spark.releaseAccumulator(this.pending.accumulator);
      this.pending = null;
    }
  }
  // Use this function to change whether this viewpoint will auto-update
  // its sort order whenever the attached SparkRenderer updates the Gsplats.
  // Turn this on or off depending on whether you expect to do renders from
  // this viewpoint most frames.
  setAutoUpdate(autoUpdate) {
    if (!this.autoUpdate && autoUpdate) {
      this.spark.autoViewpoints.push(this);
    } else if (this.autoUpdate && !autoUpdate) {
      this.spark.autoViewpoints = this.spark.autoViewpoints.filter(
        (v) => v !== this
      );
    }
    this.autoUpdate = autoUpdate;
  }
  // See below async prepareRenderPixels() for explanation of parameters.
  // Awaiting this method updates the Gsplats in the scene and performs a sort of the
  // Gsplats from this viewpoint, preparing it for a subsequent this.renderTarget()
  // call in the same tick.
  async prepare({
    scene,
    camera,
    viewToWorld,
    update,
    forceOrigin
  }) {
    var _a2;
    if (viewToWorld) {
      this.viewToWorld = viewToWorld;
    } else {
      this.camera = camera ?? this.camera;
      if (this.camera) {
        this.camera.updateMatrixWorld();
        this.viewToWorld = this.camera.matrixWorld.clone();
      }
    }
    while (update ?? true) {
      const originToWorld = forceOrigin ? this.viewToWorld : void 0;
      const updated = this.spark.updateInternal({ scene, originToWorld });
      if (updated) {
        break;
      }
      await new Promise((resolve) => setTimeout(resolve, 10));
    }
    const accumulator = this.spark.active;
    if (accumulator !== ((_a2 = this.display) == null ? void 0 : _a2.accumulator)) {
      this.spark.active.refCount += 1;
    }
    await this.sortUpdate({ accumulator, viewToWorld: this.viewToWorld });
  }
  // Render out the viewpoint to the view target RGBA buffer.
  // Swaps buffers if doubleBuffer: true was set.
  // Calls onTextureUpdated(texture) with the resulting texture.
  renderTarget({
    scene,
    camera
  }) {
    var _a2;
    const target = this.back ?? this.target;
    if (!target) {
      throw new Error("Must initialize SparkViewpoint with target");
    }
    camera = camera ?? this.camera;
    if (!camera) {
      throw new Error("Must provide camera");
    }
    if (camera instanceof THREE.PerspectiveCamera) {
      const newCam = new THREE.PerspectiveCamera().copy(camera, false);
      newCam.aspect = target.width / target.height;
      newCam.updateProjectionMatrix();
      camera = newCam;
    }
    this.viewToWorld = camera.matrixWorld.clone();
    try {
      this.spark.renderer.setRenderTarget(target);
      this.spark.prepareViewpoint(this);
      this.spark.renderer.render(scene, camera);
    } finally {
      this.spark.prepareViewpoint(this.spark.defaultView);
      this.spark.renderer.setRenderTarget(null);
    }
    if (target !== this.target) {
      [this.target, this.back] = [this.back, this.target];
    }
    (_a2 = this.onTextureUpdated) == null ? void 0 : _a2.call(this, target.texture);
  }
  // Read back the previously rendered target image as a Uint8Array of packed
  // RGBA values (in that order). If superXY was set greater than 1 then
  // downsampling is performed in the target pixel array with simple averaging
  // to derive the returned pixel values. Subsequent calls to this.readTarget()
  // will reuse the same buffers to minimize memory allocations.
  async readTarget() {
    if (!this.target) {
      throw new Error("Must initialize SparkViewpoint with target");
    }
    const { width, height } = this.target;
    const byteSize = width * height * 4;
    if (!this.superPixels || this.superPixels.length < byteSize) {
      this.superPixels = new Uint8Array(byteSize);
    }
    await this.spark.renderer.readRenderTargetPixelsAsync(
      this.target,
      0,
      0,
      width,
      height,
      this.superPixels
    );
    const { superXY } = this;
    if (superXY === 1) {
      return this.superPixels;
    }
    const subWidth = width / superXY;
    const subHeight = height / superXY;
    const subSize = subWidth * subHeight * 4;
    if (!this.pixels || this.pixels.length < subSize) {
      this.pixels = new Uint8Array(subSize);
    }
    const { superPixels, pixels } = this;
    const super2 = superXY * superXY;
    for (let y = 0; y < subHeight; y++) {
      const row = y * subWidth;
      for (let x = 0; x < subWidth; x++) {
        const superCol = x * superXY;
        let r = 0;
        let g = 0;
        let b = 0;
        let a = 0;
        for (let sy = 0; sy < superXY; sy++) {
          const superRow = (y * superXY + sy) * this.target.width;
          for (let sx = 0; sx < superXY; sx++) {
            const superIndex = (superRow + superCol + sx) * 4;
            r += superPixels[superIndex];
            g += superPixels[superIndex + 1];
            b += superPixels[superIndex + 2];
            a += superPixels[superIndex + 3];
          }
        }
        const pixelIndex = (row + x) * 4;
        pixels[pixelIndex] = r / super2;
        pixels[pixelIndex + 1] = g / super2;
        pixels[pixelIndex + 2] = b / super2;
        pixels[pixelIndex + 3] = a / super2;
      }
    }
    return pixels;
  }
  // Render out a viewpoint as a Uint8Array of RGBA values for the provided scene
  // and any camera/viewToWorld viewpoint overrides. By default update is true,
  // which triggers its SparkRenderer to check and potentially update the Gsplats.
  // Setting update to false disables this and sorts the Gsplats as they are.
  // Setting forceOrigin (default: false) to true forces the view update to
  // recalculate the splats with this view origin, potentially altering any
  // view-dependent effects. If you expect view-dependent effects to play a role
  // in the rendering quality, enable this.
  //
  // Underneath, prepareRenderPixels() simply calls await this.prepare(...),
  // this.renderTarget(...), and finally returns the result this.readTarget(),
  // a Promise to a Uint8Array with RGBA values for all the pixels (potentially
  // downsampled if the superXY parameter was used). These steps can also be called
  // manually, for example if you need to alter the scene before and after
  // this.renderTarget(...) to hide UI elements from being rendered.
  async prepareRenderPixels({
    scene,
    camera,
    viewToWorld,
    update,
    forceOrigin
  }) {
    await this.prepare({ scene, camera, viewToWorld, update, forceOrigin });
    this.renderTarget({ scene, camera });
    return this.readTarget();
  }
  // This is called automatically by SparkRenderer, there is no need to call it!
  // The method cannot be private because then SparkRenderer would
  // not be able to call it.
  autoPoll({ accumulator }) {
    var _a2, _b2, _c, _d;
    if (this.camera) {
      this.camera.updateMatrixWorld();
      this.viewToWorld = this.camera.matrixWorld.clone();
    }
    let needsSort = false;
    let displayed = false;
    if (!this.display) {
      needsSort = true;
    } else if (accumulator) {
      needsSort = true;
      const { mappingVersion } = this.display.accumulator;
      if (accumulator.mappingVersion === mappingVersion) {
        this.spark.releaseAccumulator(this.display.accumulator);
        this.display.accumulator = accumulator;
        displayed = true;
      }
    }
    const latestView = ((_a2 = this.sorting) == null ? void 0 : _a2.viewToWorld) ?? ((_b2 = this.display) == null ? void 0 : _b2.viewToWorld);
    if (latestView && !withinCoorientDist({
      matrix1: this.viewToWorld,
      matrix2: latestView,
      // By default update sort each 1 cm
      maxDistance: this.sortDistance ?? 0.01,
      // By default for radial sort, update for intermittent movement so that
      // we bring back splats culled by being behind the camera.
      // For depth sort, small rotations can change sort order a lot, so
      // update sort for even small rotations.
      minCoorient: this.sortCoorient ?? this.sortRadial ? 0.99 : 0.999
    })) {
      needsSort = true;
    }
    if (!needsSort) {
      return;
    }
    if (accumulator) {
      accumulator.refCount += 1;
    }
    if (accumulator && ((_c = this.pending) == null ? void 0 : _c.accumulator) && this.pending.accumulator !== ((_d = this.display) == null ? void 0 : _d.accumulator)) {
      this.spark.releaseAccumulator(this.pending.accumulator);
    }
    this.pending = { accumulator, viewToWorld: this.viewToWorld, displayed };
    this.driveSort();
  }
  async driveSort() {
    var _a2;
    while (true) {
      if (this.sorting || !this.pending) {
        return;
      }
      const { viewToWorld, displayed } = this.pending;
      let accumulator = this.pending.accumulator ?? ((_a2 = this.display) == null ? void 0 : _a2.accumulator);
      if (!accumulator) {
        accumulator = this.spark.active;
        accumulator.refCount += 1;
      }
      this.pending = null;
      if (!accumulator) {
        throw new Error("No accumulator to sort");
      }
      this.sorting = { viewToWorld };
      await this.sortUpdate({ accumulator, viewToWorld, displayed });
      this.sorting = null;
    }
  }
  async sortUpdate({
    accumulator,
    viewToWorld,
    displayed = false
  }) {
    if (this.sortingCheck) {
      throw new Error("Only one sort at a time");
    }
    this.sortingCheck = true;
    accumulator = accumulator ?? this.spark.active;
    const { numSplats, maxSplats } = accumulator.splats;
    let activeSplats = 0;
    let ordering = this.orderingFreelist.alloc(maxSplats);
    if (this.stochastic) {
      activeSplats = numSplats;
      for (let i = 0; i < numSplats; ++i) {
        ordering[i] = i;
      }
    } else if (numSplats > 0) {
      const {
        reader,
        doubleSortReader,
        sort32Reader,
        dynoSortRadial,
        dynoOrigin,
        dynoDirection,
        dynoDepthBias,
        dynoSort360,
        dynoSplats
      } = _SparkViewpoint.makeSorter();
      const sort32 = this.sort32 ?? false;
      let readback;
      if (sort32) {
        this.readback32 = reader.ensureBuffer(maxSplats, this.readback32);
        readback = this.readback32;
      } else {
        const halfMaxSplats = Math.ceil(maxSplats / 2);
        this.readback16 = reader.ensureBuffer(halfMaxSplats, this.readback16);
        readback = this.readback16;
      }
      const worldToOrigin = accumulator.toWorld.clone().invert();
      const viewToOrigin = viewToWorld.clone().premultiply(worldToOrigin);
      dynoSortRadial.value = this.sort360 ? true : this.sortRadial;
      dynoOrigin.value.set(0, 0, 0).applyMatrix4(viewToOrigin);
      dynoDirection.value.set(0, 0, -1).applyMatrix4(viewToOrigin).sub(dynoOrigin.value).normalize();
      dynoDepthBias.value = this.depthBias ?? 1;
      dynoSort360.value = this.sort360 ?? false;
      dynoSplats.packedSplats = accumulator.splats;
      const sortReader = sort32 ? sort32Reader : doubleSortReader;
      const count = sort32 ? numSplats : Math.ceil(numSplats / 2);
      await reader.renderReadback({
        renderer: this.spark.renderer,
        reader: sortReader,
        count,
        readback
      });
      const result = await withWorker(async (worker) => {
        const rpcName = sort32 ? "sort32Splats" : "sortDoubleSplats";
        return worker.call(rpcName, {
          maxSplats,
          numSplats,
          readback,
          ordering
        });
      });
      if (sort32) {
        this.readback32 = result.readback;
      } else {
        this.readback16 = result.readback;
      }
      ordering = result.ordering;
      activeSplats = result.activeSplats;
    }
    this.updateDisplay({
      accumulator,
      viewToWorld,
      ordering,
      activeSplats,
      displayed
    });
    this.sortingCheck = false;
  }
  updateDisplay({
    accumulator,
    viewToWorld,
    ordering,
    activeSplats,
    displayed = false
  }) {
    if (!this.display) {
      this.display = {
        accumulator,
        viewToWorld,
        geometry: new SplatGeometry(ordering, activeSplats)
      };
    } else {
      if (!displayed && accumulator !== this.display.accumulator) {
        this.spark.releaseAccumulator(this.display.accumulator);
        this.display.accumulator = accumulator;
      }
      this.display.viewToWorld = viewToWorld;
      const oldOrdering = this.display.geometry.ordering;
      if (oldOrdering.length === ordering.length) {
        this.display.geometry.update(ordering, activeSplats);
      } else {
        this.display.geometry.dispose();
        this.display.geometry = new SplatGeometry(ordering, activeSplats);
      }
      this.orderingFreelist.free(oldOrdering);
    }
    if (this.spark.viewpoint === this) {
      this.spark.prepareViewpoint(this);
    }
  }
  static makeSorter() {
    if (!_SparkViewpoint.dynos) {
      const dynoSortRadial = new DynoBool({ value: true });
      const dynoOrigin = new DynoVec3({ value: new THREE.Vector3() });
      const dynoDirection = new DynoVec3({ value: new THREE.Vector3() });
      const dynoDepthBias = new DynoFloat({ value: 1 });
      const dynoSort360 = new DynoBool({ value: false });
      const dynoSplats = new DynoPackedSplats();
      const reader = new Readback();
      const doubleSortReader = dynoBlock(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index }) => {
          if (!index) {
            throw new Error("No index");
          }
          const sortParams = {
            sortRadial: dynoSortRadial,
            sortOrigin: dynoOrigin,
            sortDirection: dynoDirection,
            sortDepthBias: dynoDepthBias,
            sort360: dynoSort360
          };
          const index2 = mul(index, dynoConst("int", 2));
          const gsplat0 = readPackedSplat(dynoSplats, index2);
          const metric0 = computeSortMetric({ gsplat: gsplat0, ...sortParams });
          const gsplat1 = readPackedSplat(
            dynoSplats,
            add(index2, dynoConst("int", 1))
          );
          const metric1 = computeSortMetric({ gsplat: gsplat1, ...sortParams });
          const combined = combine({
            vectorType: "vec2",
            x: metric0,
            y: metric1
          });
          const rgba8 = uintToRgba8(packHalf2x16(combined));
          return { rgba8 };
        }
      );
      const sort32Reader = dynoBlock(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index }) => {
          if (!index) {
            throw new Error("No index");
          }
          const sortParams = {
            sortRadial: dynoSortRadial,
            sortOrigin: dynoOrigin,
            sortDirection: dynoDirection,
            sortDepthBias: dynoDepthBias,
            sort360: dynoSort360
          };
          const gsplat = readPackedSplat(dynoSplats, index);
          const metric = computeSortMetric({ gsplat, ...sortParams });
          const rgba8 = uintToRgba8(floatBitsToUint(metric));
          return { rgba8 };
        }
      );
      _SparkViewpoint.dynos = {
        dynoSortRadial,
        dynoOrigin,
        dynoDirection,
        dynoDepthBias,
        dynoSort360,
        dynoSplats,
        reader,
        doubleSortReader,
        sort32Reader
      };
    }
    return _SparkViewpoint.dynos;
  }
};
_SparkViewpoint.EMPTY_TEXTURE = new THREE.Texture();
_SparkViewpoint.dynos = null;
let SparkViewpoint = _SparkViewpoint;
const defineComputeSortMetric = unindent(`
  float computeSort(Gsplat gsplat, bool sortRadial, vec3 sortOrigin, vec3 sortDirection, float sortDepthBias, bool sort360) {
    if (!isGsplatActive(gsplat.flags)) {
      return INFINITY;
    }

    vec3 center = gsplat.center - sortOrigin;
    float biasedDepth = dot(center, sortDirection) + sortDepthBias;
    if (!sort360 && (biasedDepth <= 0.0)) {
      return INFINITY;
    }

    return sortRadial ? length(center) : biasedDepth;
  }
`);
function computeSortMetric({
  gsplat,
  sortRadial,
  sortOrigin,
  sortDirection,
  sortDepthBias,
  sort360
}) {
  return dyno$1({
    inTypes: {
      gsplat: Gsplat,
      sortRadial: "bool",
      sortOrigin: "vec3",
      sortDirection: "vec3",
      sortDepthBias: "float",
      sort360: "bool"
    },
    outTypes: { metric: "float" },
    globals: () => [defineGsplat, defineComputeSortMetric],
    inputs: {
      gsplat,
      sortRadial,
      sortOrigin,
      sortDirection,
      sortDepthBias,
      sort360
    },
    statements: ({ inputs, outputs }) => {
      const {
        gsplat: gsplat2,
        sortRadial: sortRadial2,
        sortOrigin: sortOrigin2,
        sortDirection: sortDirection2,
        sortDepthBias: sortDepthBias2,
        sort360: sort3602
      } = inputs;
      return unindentLines(`
        ${outputs.metric} = computeSort(${gsplat2}, ${sortRadial2}, ${sortOrigin2}, ${sortDirection2}, ${sortDepthBias2}, ${sort3602});
      `);
    }
  }).outputs.metric;
}
class SplatAccumulator {
  constructor() {
    this.splats = new PackedSplats();
    this.toWorld = new THREE.Matrix4();
    this.mapping = [];
    this.refCount = 0;
    this.splatsVersion = -1;
    this.mappingVersion = -1;
  }
  ensureGenerate(maxSplats) {
    if (this.splats.ensureGenerate(maxSplats)) {
      this.mapping = [];
    }
  }
  // Generate all Gsplats from an array of generators
  generateSplats({
    renderer,
    modifier,
    generators: generators2,
    forceUpdate,
    originToWorld
  }) {
    const mapping = this.mapping.reduce((map, record) => {
      map.set(record.node, record);
      return map;
    }, /* @__PURE__ */ new Map());
    let updated = 0;
    let numSplats = 0;
    for (const { node, generator, version, base, count } of generators2) {
      const current = mapping.get(node);
      if (forceUpdate || generator !== (current == null ? void 0 : current.generator) || version !== (current == null ? void 0 : current.version) || base !== (current == null ? void 0 : current.base) || count !== (current == null ? void 0 : current.count)) {
        if (generator && count > 0) {
          const modGenerator = modifier.apply(generator);
          try {
            this.splats.generate({
              generator: modGenerator,
              base,
              count,
              renderer
            });
          } catch (error) {
            node.generator = void 0;
            node.generatorError = error;
          }
          updated += 1;
        }
      }
      numSplats = Math.max(numSplats, base + count);
    }
    this.splats.numSplats = numSplats;
    this.toWorld = originToWorld;
    this.mapping = generators2;
    return updated !== 0;
  }
  // Check if this accumulator has exactly the same generator mapping as
  // the previous one. If so, we can reuse the Gsplat sort order.
  hasCorrespondence(other) {
    if (this.mapping.length !== other.mapping.length) {
      return false;
    }
    return this.mapping.every(({ node, base, count }, i) => {
      const {
        node: otherNode,
        base: otherBase,
        count: otherCount
      } = other.mapping[i];
      return node === otherNode && base === otherBase && count === otherCount;
    });
  }
}
var newSplatFragment_default = "precision highp float;\nprecision highp int;\n\n#include <splatDefines>\n\nuniform float near;\nuniform float far;\nuniform bool encodeLinear;\nuniform float time;\nuniform bool debugFlag;\nuniform float maxStdDev;\nuniform float minAlpha;\nuniform bool disableFalloff;\nuniform float falloff;\n\nout vec4 fragColor;\n\nin vec4 vRgba;\nin vec2 vSplatUv;\nin vec3 vNdc;\nflat in uint vSplatIndex;\nflat in float adjustedStdDev;\n\nvoid main() {\n    vec4 rgba = vRgba;\n\n    float z2 = dot(vSplatUv, vSplatUv);\n    if (z2 > (adjustedStdDev * adjustedStdDev)) {\n        discard;\n    }\n\n    float a = rgba.a;\n    float shifted = sqrt(z2) - max(0.0, a - 1.0);\n    float exponent = -0.5 * max(1.0, a) * sqr(max(0.0, shifted));\n    rgba.a = min(1.0, a) * exp(exponent);\n\n    if (rgba.a < minAlpha) {\n        discard;\n    }\n    if (encodeLinear) {\n        rgba.rgb = srgbToLinear(rgba.rgb);\n    }\n\n    #ifdef PREMULTIPLIED_ALPHA\n        fragColor = vec4(rgba.rgb * rgba.a, rgba.a);\n    #else\n        fragColor = rgba;\n    #endif\n}";
var newSplatVertex_default = "precision highp float;\nprecision highp int;\nprecision highp usampler2DArray;\n\n#include <splatDefines>\n\nout vec4 vRgba;\nout vec2 vSplatUv;\nout vec3 vNdc;\nflat out uint vSplatIndex;\nflat out float adjustedStdDev;\n\nuniform uint numSplats;\nuniform vec2 renderSize;\nuniform vec4 renderToViewQuat;\nuniform vec3 renderToViewPos;\nuniform float maxStdDev;\nuniform float minPixelRadius;\nuniform float maxPixelRadius;\nuniform float time;\nuniform float deltaTime;\nuniform bool debugFlag;\nuniform float minAlpha;\nuniform bool enable2DGS;\nuniform float blurAmount;\nuniform float preBlurAmount;\nuniform float focalDistance;\nuniform float apertureAngle;\nuniform float clipXY;\nuniform float focalAdjustment;\n\nuniform usampler2D ordering;\nuniform usampler2DArray extSplats;\nuniform usampler2DArray extSplats2;\n\nvoid main() {\n    \n    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n\n    \n    \n    \n\n    ivec2 orderingCoord = ivec2((gl_InstanceID >> 2) & 4095, gl_InstanceID >> 14);\n    uint splatIndex = texelFetch(ordering, orderingCoord, 0)[gl_InstanceID & 3];\n    if (splatIndex == 0xffffffffu) {\n        \n        return;\n    }\n\n    ivec3 texCoord = splatTexCoord(int(splatIndex));\n    vec3 center, scales;\n    vec4 quaternion, rgba;\n\n    uvec4 ext1 = texelFetch(extSplats, texCoord, 0);\n    float alpha = unpackSplatExtAlpha(ext1);\n    if ((alpha == 0.0) || (alpha < minAlpha)) {\n        return;\n    }\n    uvec4 ext2 = texelFetch(extSplats2, texCoord, 0);\n    unpackSplatExt(ext1, ext2, center, scales, quaternion, rgba);\n\n    bvec3 zeroScales = equal(scales, vec3(0.0));\n    if (all(zeroScales)) {\n        return;\n    }\n\n    adjustedStdDev = maxStdDev;\n    \n    if (rgba.a > 1.0) {\n        \n        rgba.a = min(rgba.a * 4.0 - 3.0, 5.0);\n        adjustedStdDev = maxStdDev + 0.7 * (rgba.a - 1.0);\n    }\n\n    \n    vec3 viewCenter = quatVec(renderToViewQuat, center) + renderToViewPos;\n\n    \n    if (viewCenter.z >= 0.0) {\n        return;\n    }\n\n    \n    vec4 clipCenter = projectionMatrix * vec4(viewCenter, 1.0);\n\n    \n    if (abs(clipCenter.z) >= clipCenter.w) {\n        return;\n    }\n\n    \n    float clip = clipXY * clipCenter.w;\n    if (abs(clipCenter.x) > clip || abs(clipCenter.y) > clip) {\n        return;\n    }\n\n    \n    vSplatIndex = splatIndex;\n\n    \n    vec4 viewQuaternion = quatQuat(renderToViewQuat, quaternion);\n\n    if (enable2DGS && any(zeroScales)) {\n        vRgba = rgba;\n        vSplatUv = position.xy * maxStdDev;\n\n        vec3 offset;\n        if (zeroScales.z) {\n            offset = vec3(vSplatUv.xy * scales.xy, 0.0);\n        } else if (zeroScales.y) {\n            offset = vec3(vSplatUv.x * scales.x, 0.0, vSplatUv.y * scales.z);\n        } else {\n            offset = vec3(0.0, vSplatUv.xy * scales.yz);\n        }\n\n        vec3 viewPos = viewCenter + quatVec(viewQuaternion, offset);\n        gl_Position = projectionMatrix * vec4(viewPos, 1.0);\n        vNdc = gl_Position.xyz / gl_Position.w;\n        return;\n    }\n\n    \n    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n    \n    mat3 RS = scaleQuaternionToMatrix(scales, viewQuaternion);\n    mat3 cov3D = RS * transpose(RS);\n\n    \n    vec2 scaledRenderSize = renderSize * focalAdjustment;\n    vec2 focal = 0.5 * scaledRenderSize * vec2(projectionMatrix[0][0], projectionMatrix[1][1]);\n\n    mat3 J;\n    if (isOrthographic) {\n        J = mat3(\n            focal.x, 0.0, 0.0,\n            0.0, focal.y, 0.0,\n            0.0, 0.0, 0.0\n        );\n    } else {\n        float invZ = 1.0 / viewCenter.z;\n        vec2 J1 = focal * invZ;\n        vec2 J2 = -(J1 * viewCenter.xy) * invZ;\n        J = mat3(\n            J1.x, 0.0, J2.x,\n            0.0, J1.y, J2.y,\n            0.0, 0.0, 0.0\n        );\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    mat3 cov2D = transpose(J) * cov3D * J;\n    float a = cov2D[0][0];\n    float d = cov2D[1][1];\n    float b = cov2D[0][1];\n\n    \n    a += preBlurAmount;\n    d += preBlurAmount;\n\n    float fullBlurAmount = blurAmount;\n    if ((focalDistance > 0.0) && (apertureAngle > 0.0)) {\n        float focusRadius = maxPixelRadius;\n        if (viewCenter.z < 0.0) {\n            float focusBlur = abs((-viewCenter.z - focalDistance) / viewCenter.z);\n            float apertureRadius = focal.x * tan(0.5 * apertureAngle);\n            focusRadius = focusBlur * apertureRadius;\n        }\n        fullBlurAmount = clamp(sqr(focusRadius), blurAmount, sqr(maxPixelRadius));\n    }\n\n    \n    float detOrig = a * d - b * b;\n    a += fullBlurAmount;\n    d += fullBlurAmount;\n    float det = a * d - b * b;\n\n    \n    float blurAdjust = sqrt(max(0.0, detOrig / det));\n    rgba.a *= blurAdjust;\n    if (rgba.a < minAlpha) {\n        return;\n    }\n\n    \n    float eigenAvg = 0.5 * (a + d);\n    float eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));\n    float eigen1 = eigenAvg + eigenDelta;\n    float eigen2 = eigenAvg - eigenDelta;\n\n    vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));\n    vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);\n\n    float scale1 = min(maxPixelRadius, maxStdDev * sqrt(eigen1));\n    float scale2 = min(maxPixelRadius, maxStdDev * sqrt(eigen2));\n    if (scale1 < minPixelRadius && scale2 < minPixelRadius) {\n        return;\n    }\n\n    \n    vec2 pixelOffset = position.x * eigenVec1 * scale1 + position.y * eigenVec2 * scale2;\n    vec2 ndcOffset = (2.0 / scaledRenderSize) * pixelOffset;\n    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, ndcCenter.z);\n\n    vRgba = rgba;\n    vSplatUv = position.xy * maxStdDev;\n    vNdc = ndc;\n    gl_Position = vec4(ndc.xy * clipCenter.w, clipCenter.zw);\n}";
var splatDefines_default = "const float LN_SCALE_MIN = -12.0;\nconst float LN_SCALE_MAX = 9.0;\n\nconst uint SPLAT_TEX_WIDTH_BITS = 11u;\nconst uint SPLAT_TEX_HEIGHT_BITS = 11u;\nconst uint SPLAT_TEX_DEPTH_BITS = 11u;\nconst uint SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;\n\nconst uint SPLAT_TEX_WIDTH = 1u << SPLAT_TEX_WIDTH_BITS;\nconst uint SPLAT_TEX_HEIGHT = 1u << SPLAT_TEX_HEIGHT_BITS;\nconst uint SPLAT_TEX_DEPTH = 1u << SPLAT_TEX_DEPTH_BITS;\n\nconst uint SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1u;\nconst uint SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1u;\nconst uint SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1u;\n\nconst uint F16_INF = 0x7c00u;\nconst float PI = 3.1415926535897932384626433832795;\n\nconst float INFINITY = 1.0 / 0.0;\nconst float NEG_INFINITY = -INFINITY;\n\nfloat sqr(float x) {\n    return x * x;\n}\n\nfloat pow4(float x) {\n    float x2 = x * x;\n    return x2 * x2;\n}\n\nfloat pow8(float x) {\n    float x4 = pow4(x);\n    return x4 * x4;\n}\n\nvec3 srgbToLinear(vec3 rgb) {\n    return pow(rgb, vec3(2.2));\n}\n\nvec3 linearToSrgb(vec3 rgb) {\n    return pow(rgb, vec3(1.0 / 2.2));\n}\n\nuint encodeQuatOctXy88R8(vec4 q) {\n    \n    if (q.w < 0.0) {\n        q = -q;\n    }\n    \n    float theta = 2.0 * acos(q.w);\n    float halfTheta = theta * 0.5;\n    float s = sin(halfTheta);\n    \n    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, 0.0) : q.xyz / s;\n    \n    \n    \n    float sum = abs(axis.x) + abs(axis.y) + abs(axis.z);\n    vec2 p = vec2(axis.x, axis.y) / sum;\n    \n    if (axis.z < 0.0) {\n        float oldPx = p.x;\n        p.x = (1.0 - abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);\n        p.y = (1.0 - abs(oldPx)) * (p.y >= 0.0 ? 1.0 : -1.0);\n    }\n    \n    float u_f = p.x * 0.5 + 0.5;\n    float v_f = p.y * 0.5 + 0.5;\n    \n    uint quantU = uint(clamp(round(u_f * 255.0), 0.0, 255.0));\n    uint quantV = uint(clamp(round(v_f * 255.0), 0.0, 255.0));\n    \n    \n    \n    uint angleInt = uint(clamp(round((theta / 3.14159265359) * 255.0), 0.0, 255.0));\n    \n    \n    return (angleInt << 16u) | (quantV << 8u) | quantU;\n}\n\nvec4 decodeQuatOctXy88R8(uint encoded) {\n    \n    uint quantU = encoded & uint(0xFFu);               \n    uint quantV = (encoded >> 8u) & uint(0xFFu);         \n    uint angleInt = encoded >> 16u;                      \n\n    \n    float u_f = float(quantU) / 255.0;\n    float v_f = float(quantV) / 255.0;\n    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - 1.0);\n\n    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));\n    float t = max(-axis.z, 0.0);\n    axis.x += (axis.x >= 0.0) ? -t : t;\n    axis.y += (axis.y >= 0.0) ? -t : t;\n    axis = normalize(axis);\n    \n    \n    float theta = (float(angleInt) / 255.0) * 3.14159265359;\n    float halfTheta = theta * 0.5;\n    float s = sin(halfTheta);\n    float w = cos(halfTheta);\n    \n    return vec4(axis * s, w);\n}\n\nuint encodeQuatOctXy1010R12(vec4 q) {\n    \n    if (q.w < 0.0) {\n        q = -q;\n    }\n    \n    float halfTheta = acos(q.w);\n    float theta = 2.0 * halfTheta;\n    float s = sin(halfTheta);\n    \n    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, 0.0) : q.xyz / s;\n    \n    \n    \n    float sum = abs(axis.x) + abs(axis.y) + abs(axis.z);\n    vec2 p = vec2(axis.x, axis.y) / sum;\n    \n    if (axis.z < 0.0) {\n        float oldPx = p.x;\n        p.x = (1.0 - abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);\n        p.y = (1.0 - abs(oldPx)) * (p.y >= 0.0 ? 1.0 : -1.0);\n    }\n    \n    float u_f = p.x * 0.5 + 0.5;\n    float v_f = p.y * 0.5 + 0.5;\n    \n    uint quantU = uint(clamp(round(u_f * 1023.0), 0.0, 1023.0));\n    uint quantV = uint(clamp(round(v_f * 1023.0), 0.0, 1023.0));\n    \n    \n    \n    uint angleInt = uint(clamp(round((theta / PI) * 4095.0), 0.0, 4095.0));\n    \n    \n    return (angleInt << 20u) | (quantV << 10u) | quantU;\n}\n\nvec4 decodeQuatOctXy1010R12(uint encoded) {\n    \n    uint quantU = encoded & uint(0x3FFu);               \n    uint quantV = (encoded >> 10u) & uint(0x3FFu);         \n    uint angleInt = encoded >> 20u;                      \n\n    \n    float u_f = float(quantU) / 1023.0;\n    float v_f = float(quantV) / 1023.0;\n    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - 1.0);\n\n    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));\n    float t = max(-axis.z, 0.0);\n    axis.x += (axis.x >= 0.0) ? -t : t;\n    axis.y += (axis.y >= 0.0) ? -t : t;\n    axis = normalize(axis);\n    \n    \n    float theta = (float(angleInt) / 4095.0) * PI;\n    float halfTheta = theta * 0.5;\n    float s = sin(halfTheta);\n    float w = cos(halfTheta);\n    \n    return vec4(axis * s, w);\n}\n\nuvec4 packSplatEncoding(\n    vec3 center, vec3 scales, vec4 quaternion, vec4 rgba, vec4 rgbMinMaxLnScaleMinMax\n) {\n    float rgbMin = rgbMinMaxLnScaleMinMax.x;\n    float rgbMax = rgbMinMaxLnScaleMinMax.y;\n    vec3 encRgb = (rgba.rgb - vec3(rgbMin)) / (rgbMax - rgbMin);\n    uvec4 uRgba = uvec4(round(clamp(vec4(encRgb, rgba.a) * 255.0, 0.0, 255.0)));\n\n    uint uQuat = encodeQuatOctXy88R8(quaternion);\n    \n    \n    uvec3 uQuat3 = uvec3(uQuat & 0xffu, (uQuat >> 8u) & 0xffu, (uQuat >> 16u) & 0xffu);\n\n    \n    float lnScaleMin = rgbMinMaxLnScaleMinMax.z;\n    float lnScaleMax = rgbMinMaxLnScaleMinMax.w;\n    float lnScaleScale = 254.0 / (lnScaleMax - lnScaleMin);\n    uvec3 uScales = uvec3(\n        (scales.x == 0.0) ? 0u : uint(round(clamp((log(scales.x) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u,\n        (scales.y == 0.0) ? 0u : uint(round(clamp((log(scales.y) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u,\n        (scales.z == 0.0) ? 0u : uint(round(clamp((log(scales.z) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u\n    );\n\n    \n    uint word0 = uRgba.r | (uRgba.g << 8u) | (uRgba.b << 16u) | (uRgba.a << 24u);\n    uint word1 = packHalf2x16(center.xy);\n    uint word2 = packHalf2x16(vec2(center.z, 0.0)) | (uQuat3.x << 16u) | (uQuat3.y << 24u);\n    uint word3 = uScales.x | (uScales.y << 8u) | (uScales.z << 16u) | (uQuat3.z << 24u);\n    return uvec4(word0, word1, word2, word3);\n}\n\nuvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, vec4 rgba) {\n    return packSplatEncoding(center, scales, quaternion, rgba, vec4(0.0, 1.0, LN_SCALE_MIN, LN_SCALE_MAX));\n}\n\nvoid unpackSplatEncoding(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba, vec4 rgbMinMaxLnScaleMinMax) {\n    uint word0 = packed.x, word1 = packed.y, word2 = packed.z, word3 = packed.w;\n\n    uvec4 uRgba = uvec4(word0 & 0xffu, (word0 >> 8u) & 0xffu, (word0 >> 16u) & 0xffu, (word0 >> 24u) & 0xffu);\n    float rgbMin = rgbMinMaxLnScaleMinMax.x;\n    float rgbMax = rgbMinMaxLnScaleMinMax.y;\n    rgba = (vec4(uRgba) / 255.0);\n    rgba.rgb = rgba.rgb * (rgbMax - rgbMin) + rgbMin;\n\n    center = vec4(\n        unpackHalf2x16(word1),\n        unpackHalf2x16(word2 & 0xffffu)\n    ).xyz;\n\n    uvec3 uScales = uvec3(word3 & 0xffu, (word3 >> 8u) & 0xffu, (word3 >> 16u) & 0xffu);\n    float lnScaleMin = rgbMinMaxLnScaleMinMax.z;\n    float lnScaleMax = rgbMinMaxLnScaleMinMax.w;\n    float lnScaleScale = (lnScaleMax - lnScaleMin) / 254.0;\n    scales = vec3(\n        (uScales.x == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.x - 1u) * lnScaleScale),\n        (uScales.y == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.y - 1u) * lnScaleScale),\n        (uScales.z == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.z - 1u) * lnScaleScale)\n    );\n\n    uint uQuat = ((word2 >> 16u) & 0xFFFFu) | ((word3 >> 8u) & 0xFF0000u);\n    quaternion = decodeQuatOctXy88R8(uQuat);\n    \n    \n}\n\nvoid unpackSplat(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba) {\n    unpackSplatEncoding(packed, center, scales, quaternion, rgba, vec4(0.0, 1.0, LN_SCALE_MIN, LN_SCALE_MAX));\n}\n\nvoid packSplatExt(\n    out uvec4 packed, out uvec4 packed2,\n    vec3 center, vec3 scales, vec4 quaternion, vec4 rgba\n) {\n    packed.x = floatBitsToUint(center.x);\n    packed.y = floatBitsToUint(center.y);\n    packed.z = floatBitsToUint(center.z);\n    packed.w = packHalf2x16(vec2(rgba.a, 0.0));\n\n    packed2.x = packHalf2x16(rgba.rg);\n    packed2.y = packHalf2x16(vec2(rgba.b, log(scales.x)));\n    packed2.z = packHalf2x16(log(scales.yz));\n    packed2.w = encodeQuatOctXy1010R12(quaternion);\n}\n\nvec4 unpackSplatExtCenterAlpha(uvec4 packed) {\n    return vec4(\n        uintBitsToFloat(packed.x),\n        uintBitsToFloat(packed.y),\n        uintBitsToFloat(packed.z),\n        unpackHalf2x16(packed.w).x\n    );\n}\n\nfloat unpackSplatExtAlpha(uvec4 packed) {\n    return unpackHalf2x16(packed.w).x;\n}\n\nvoid unpackSplatExt(\n    uvec4 packed, uvec4 packed2,\n    out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba\n) {\n    center.x = uintBitsToFloat(packed.x);\n    center.y = uintBitsToFloat(packed.y);\n    center.z = uintBitsToFloat(packed.z);\n    rgba.a = unpackHalf2x16(packed.w).x;\n\n    rgba.rg = unpackHalf2x16(packed2.x);\n    vec2 split = unpackHalf2x16(packed2.y);\n    rgba.b = split.x;\n    scales.x = exp(split.y);\n    scales.yz = exp(unpackHalf2x16(packed2.z));\n    quaternion = decodeQuatOctXy1010R12(packed2.w);\n}\n\nvec3 quatVec(vec4 q, vec3 v) {\n    \n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\nvec4 quatQuat(vec4 q1, vec4 q2) {\n    return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,\n        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,\n        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,\n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n    );\n}\n\nmat3 scaleQuaternionToMatrix(vec3 s, vec4 q) {\n    \n    return mat3(\n        s.x * (1.0 - 2.0 * (q.y * q.y + q.z * q.z)),\n        s.x * (2.0 * (q.x * q.y + q.w * q.z)),\n        s.x * (2.0 * (q.x * q.z - q.w * q.y)),\n        s.y * (2.0 * (q.x * q.y - q.w * q.z)),\n        s.y * (1.0 - 2.0 * (q.x * q.x + q.z * q.z)),\n        s.y * (2.0 * (q.y * q.z + q.w * q.x)),\n        s.z * (2.0 * (q.x * q.z + q.w * q.y)),\n        s.z * (2.0 * (q.y * q.z - q.w * q.x)),\n        s.z * (1.0 - 2.0 * (q.x * q.x + q.y * q.y))\n    );\n}\n\nvec4 slerp(vec4 q1, vec4 q2, float t) {\n    \n    float cosHalfTheta = dot(q1, q2);\n\n    \n    if (abs(cosHalfTheta) >= 0.999) {\n        return q1;\n    }\n    \n    \n    \n    if (cosHalfTheta < 0.0) {\n        q2 = -q2;\n        cosHalfTheta = -cosHalfTheta;\n    }\n\n    \n    float halfTheta = acos(cosHalfTheta);\n    float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);\n\n    \n    float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;\n    float ratioB = sin(t * halfTheta) / sinHalfTheta;\n\n    \n    return q1 * ratioA + q2 * ratioB;\n}\n\nivec3 splatTexCoord(int index) {\n    uint x = uint(index) & SPLAT_TEX_WIDTH_MASK;\n    uint y = (uint(index) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK;\n    uint z = uint(index) >> SPLAT_TEX_LAYER_BITS;\n    return ivec3(x, y, z);\n}\n\nvec4 floatToVec4(float f) {\n    uint u32 = floatBitsToUint(f);\n    uvec4 bytes = uvec4(\n        u32 & 0xFFu,\n        (u32 >> 8u) & 0xFFu,\n        (u32 >> 16u) & 0xFFu,\n        (u32 >> 24u) & 0xFFu\n    );\n    return vec4(bytes) / 255.0;\n}";
var splatFragment_default = "precision highp float;\nprecision highp int;\n\n#include <splatDefines>\n\nuniform float near;\nuniform float far;\nuniform bool encodeLinear;\nuniform float time;\nuniform bool debugFlag;\nuniform float maxStdDev;\nuniform float minAlpha;\nuniform bool stochastic;\nuniform bool disableFalloff;\nuniform float falloff;\n\nuniform bool splatTexEnable;\nuniform sampler3D splatTexture;\nuniform mat2 splatTexMul;\nuniform vec2 splatTexAdd;\nuniform float splatTexNear;\nuniform float splatTexFar;\nuniform float splatTexMid;\n\nout vec4 fragColor;\n\nin vec4 vRgba;\nin vec2 vSplatUv;\nin vec3 vNdc;\nflat in uint vSplatIndex;\n\nvoid main() {\n    vec4 rgba = vRgba;\n\n    float z = dot(vSplatUv, vSplatUv);\n    if (!splatTexEnable) {\n        if (z > (maxStdDev * maxStdDev)) {\n            discard;\n        }\n    } else {\n        vec2 uv = splatTexMul * vSplatUv + splatTexAdd;\n        float ndcZ = vNdc.z;\n        float depth = (2.0 * near * far) / (far + near - ndcZ * (far - near));\n        float clampedFar = max(splatTexFar, splatTexNear);\n        float clampedDepth = clamp(depth, splatTexNear, clampedFar);\n        float logDepth = log2(clampedDepth + 1.0);\n        float logNear = log2(splatTexNear + 1.0);\n        float logFar = log2(clampedFar + 1.0);\n\n        float texZ;\n        if (splatTexMid > 0.0) {\n            float clampedMid = clamp(splatTexMid, splatTexNear, clampedFar);\n            float logMid = log2(clampedMid + 1.0);\n            texZ = (clampedDepth <= clampedMid) ?\n                (0.5 * ((logDepth - logNear) / (logMid - logNear))) :\n                (0.5 * ((logDepth - logMid) / (logFar - logMid)) + 0.5);\n        } else {\n            texZ = (logDepth - logNear) / (logFar - logNear);\n        }\n\n        vec4 modulate = texture(splatTexture, vec3(uv, 1.0 - texZ));\n        rgba *= modulate;\n    }\n\n    rgba.a *= mix(1.0, exp(-0.5 * z), falloff);\n\n    if (rgba.a < minAlpha) {\n        discard;\n    }\n    if (encodeLinear) {\n        rgba.rgb = srgbToLinear(rgba.rgb);\n    }\n\n    if (stochastic) {\n        const bool STEADY = false;\n        uint uTime = STEADY ? 0u : floatBitsToUint(time);\n        uvec2 coord = uvec2(gl_FragCoord.xy);\n        uint state = uTime + 0x9e3779b9u * coord.x + 0x85ebca6bu * coord.y + 0xc2b2ae35u * uint(vSplatIndex);\n        state = state * 747796405u + 2891336453u;\n        uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n        hash = (hash >> 22u) ^ hash;\n        float rand = float(hash) / 4294967296.0;\n        if (rand < rgba.a) {\n            fragColor = vec4(rgba.rgb, 1.0);\n        } else {\n            discard;\n        }\n    } else {\n        #ifdef PREMULTIPLIED_ALPHA\n            fragColor = vec4(rgba.rgb * rgba.a, rgba.a);\n        #else\n            fragColor = rgba;\n        #endif\n    }\n}";
var splatVertex_default = "precision highp float;\nprecision highp int;\nprecision highp usampler2DArray;\n\n#include <splatDefines>\n\nattribute uint splatIndex;\n\nout vec4 vRgba;\nout vec2 vSplatUv;\nout vec3 vNdc;\nflat out uint vSplatIndex;\n\nuniform vec2 renderSize;\nuniform uint numSplats;\nuniform vec4 renderToViewQuat;\nuniform vec3 renderToViewPos;\nuniform float maxStdDev;\nuniform float minPixelRadius;\nuniform float maxPixelRadius;\nuniform float time;\nuniform float deltaTime;\nuniform bool debugFlag;\nuniform float minAlpha;\nuniform bool stochastic;\nuniform bool enable2DGS;\nuniform float blurAmount;\nuniform float preBlurAmount;\nuniform float focalDistance;\nuniform float apertureAngle;\nuniform float clipXY;\nuniform float focalAdjustment;\n\nuniform usampler2DArray packedSplats;\nuniform vec4 rgbMinMaxLnScaleMinMax;\n\nvoid main() {\n    \n    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n\n    if (uint(gl_InstanceID) >= numSplats) {\n        return;\n    }\n\n    ivec3 texCoord;\n    if (stochastic) {\n        texCoord = ivec3(\n            uint(gl_InstanceID) & SPLAT_TEX_WIDTH_MASK,\n            (uint(gl_InstanceID) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,\n            (uint(gl_InstanceID) >> SPLAT_TEX_LAYER_BITS)\n        );\n    } else {\n        if (splatIndex == 0xffffffffu) {\n            \n            return;\n        }\n        texCoord = ivec3(\n            splatIndex & SPLAT_TEX_WIDTH_MASK,\n            (splatIndex >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,\n            splatIndex >> SPLAT_TEX_LAYER_BITS\n        );\n    }\n    uvec4 packed = texelFetch(packedSplats, texCoord, 0);\n\n    vec3 center, scales;\n    vec4 quaternion, rgba;\n    unpackSplatEncoding(packed, center, scales, quaternion, rgba, rgbMinMaxLnScaleMinMax);\n\n    if (rgba.a < minAlpha) {\n        return;\n    }\n    bvec3 zeroScales = equal(scales, vec3(0.0));\n    if (all(zeroScales)) {\n        return;\n    }\n\n    \n    vec3 viewCenter = quatVec(renderToViewQuat, center) + renderToViewPos;\n\n    \n    if (viewCenter.z >= 0.0) {\n        return;\n    }\n\n    \n    vec4 clipCenter = projectionMatrix * vec4(viewCenter, 1.0);\n\n    \n    if (abs(clipCenter.z) >= clipCenter.w) {\n        return;\n    }\n\n    \n    float clip = clipXY * clipCenter.w;\n    if (abs(clipCenter.x) > clip || abs(clipCenter.y) > clip) {\n        return;\n    }\n\n    \n    vSplatIndex = splatIndex;\n\n    \n    vec4 viewQuaternion = quatQuat(renderToViewQuat, quaternion);\n\n    if (enable2DGS && any(zeroScales)) {\n        vRgba = rgba;\n        vSplatUv = position.xy * maxStdDev;\n\n        vec3 offset;\n        if (zeroScales.z) {\n            offset = vec3(vSplatUv.xy * scales.xy, 0.0);\n        } else if (zeroScales.y) {\n            offset = vec3(vSplatUv.x * scales.x, 0.0, vSplatUv.y * scales.z);\n        } else {\n            offset = vec3(0.0, vSplatUv.xy * scales.yz);\n        }\n\n        vec3 viewPos = viewCenter + quatVec(viewQuaternion, offset);\n        gl_Position = projectionMatrix * vec4(viewPos, 1.0);\n        vNdc = gl_Position.xyz / gl_Position.w;\n        return;\n    }\n\n    \n    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n    \n    mat3 RS = scaleQuaternionToMatrix(scales, viewQuaternion);\n    mat3 cov3D = RS * transpose(RS);\n\n    \n    vec2 scaledRenderSize = renderSize * focalAdjustment;\n    vec2 focal = 0.5 * scaledRenderSize * vec2(projectionMatrix[0][0], projectionMatrix[1][1]);\n\n    mat3 J;\n    if(isOrthographic) {\n        J = mat3(\n            focal.x, 0.0, 0.0,\n            0.0, focal.y, 0.0,\n            0.0, 0.0, 0.0\n        );\n    } else {\n        float invZ = 1.0 / viewCenter.z;\n        vec2 J1 = focal * invZ;\n        vec2 J2 = -(J1 * viewCenter.xy) * invZ;\n        J = mat3(\n            J1.x, 0.0, J2.x,\n            0.0, J1.y, J2.y,\n            0.0, 0.0, 0.0\n        );\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    mat3 cov2D = transpose(J) * cov3D * J;\n    float a = cov2D[0][0];\n    float d = cov2D[1][1];\n    float b = cov2D[0][1];\n\n    \n    a += preBlurAmount;\n    d += preBlurAmount;\n\n    float fullBlurAmount = blurAmount;\n    if ((focalDistance > 0.0) && (apertureAngle > 0.0)) {\n        float focusRadius = maxPixelRadius;\n        if (viewCenter.z < 0.0) {\n            float focusBlur = abs((-viewCenter.z - focalDistance) / viewCenter.z);\n            float apertureRadius = focal.x * tan(0.5 * apertureAngle);\n            focusRadius = focusBlur * apertureRadius;\n        }\n        fullBlurAmount = clamp(sqr(focusRadius), blurAmount, sqr(maxPixelRadius));\n    }\n\n    \n    float detOrig = a * d - b * b;\n    a += fullBlurAmount;\n    d += fullBlurAmount;\n    float det = a * d - b * b;\n\n    \n    float blurAdjust = sqrt(max(0.0, detOrig / det));\n    rgba.a *= blurAdjust;\n    if (rgba.a < minAlpha) {\n        return;\n    }\n\n    \n    float eigenAvg = 0.5 * (a + d);\n    float eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));\n    float eigen1 = eigenAvg + eigenDelta;\n    float eigen2 = eigenAvg - eigenDelta;\n\n    vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));\n    vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);\n\n    float scale1 = min(maxPixelRadius, maxStdDev * sqrt(eigen1));\n    float scale2 = min(maxPixelRadius, maxStdDev * sqrt(eigen2));\n    if (scale1 < minPixelRadius && scale2 < minPixelRadius) {\n        return;\n    }\n\n    \n    vec2 pixelOffset = position.x * eigenVec1 * scale1 + position.y * eigenVec2 * scale2;\n    vec2 ndcOffset = (2.0 / scaledRenderSize) * pixelOffset;\n    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, ndcCenter.z);\n\n    vRgba = rgba;\n    vSplatUv = position.xy * maxStdDev;\n    vNdc = ndc;\n    gl_Position = vec4(ndc.xy * clipCenter.w, clipCenter.zw);\n}";
let shaders = null;
function getShaders() {
  if (!shaders) {
    THREE.ShaderChunk.splatDefines = splatDefines_default;
    shaders = {
      splatVertex: splatVertex_default,
      splatFragment: splatFragment_default,
      newSplatVertex: newSplatVertex_default,
      newSplatFragment: newSplatFragment_default
    };
  }
  return shaders;
}
const MAX_ACCUMULATORS = 5;
const _SparkRenderer = class _SparkRenderer extends THREE.Mesh {
  constructor(options) {
    const uniforms = _SparkRenderer.makeUniforms();
    const shaders2 = getShaders();
    const premultipliedAlpha = options.premultipliedAlpha ?? true;
    const material = new THREE.ShaderMaterial({
      glslVersion: THREE.GLSL3,
      vertexShader: shaders2.splatVertex,
      fragmentShader: shaders2.splatFragment,
      uniforms,
      premultipliedAlpha,
      transparent: true,
      depthTest: true,
      depthWrite: false,
      side: THREE.DoubleSide
    });
    super(EMPTY_GEOMETRY, material);
    this.splatTexture = null;
    this.autoViewpoints = [];
    this.rotateToAccumulator = new DynoVec4({ value: new THREE.Quaternion() });
    this.translateToAccumulator = new DynoVec3({ value: new THREE.Vector3() });
    this.lastFrame = -1;
    this.lastUpdateTime = null;
    this.defaultCameras = [];
    this.lastStochastic = null;
    this.pendingUpdate = {
      scene: null,
      originToWorld: new THREE.Matrix4(),
      timeoutId: -1
    };
    this.envViewpoint = null;
    this.frustumCulled = false;
    this.renderer = options.renderer;
    this.material = material;
    this.uniforms = uniforms;
    const modifier = dynoBlock(
      { gsplat: Gsplat },
      { gsplat: Gsplat },
      ({ gsplat }) => {
        if (!gsplat) {
          throw new Error("gsplat not defined");
        }
        gsplat = transformGsplat(gsplat, {
          rotate: this.rotateToAccumulator,
          translate: this.translateToAccumulator
        });
        return { gsplat };
      }
    );
    this.modifier = new SplatModifier(modifier);
    this.premultipliedAlpha = premultipliedAlpha;
    this.autoUpdate = options.autoUpdate ?? true;
    this.preUpdate = options.preUpdate ?? false;
    this.needsUpdate = false;
    this.originDistance = options.originDistance ?? 1;
    this.maxStdDev = options.maxStdDev ?? Math.sqrt(8);
    this.minPixelRadius = options.minPixelRadius ?? 0;
    this.maxPixelRadius = options.maxPixelRadius ?? 512;
    this.minAlpha = options.minAlpha ?? 0.5 * (1 / 255);
    this.enable2DGS = options.enable2DGS ?? false;
    this.preBlurAmount = options.preBlurAmount ?? 0;
    this.blurAmount = options.blurAmount ?? 0.3;
    this.focalDistance = options.focalDistance ?? 0;
    this.apertureAngle = options.apertureAngle ?? 0;
    this.falloff = options.falloff ?? 1;
    this.clipXY = options.clipXY ?? 1.4;
    this.focalAdjustment = options.focalAdjustment ?? 1;
    this.splatEncoding = options.splatEncoding ?? { ...DEFAULT_SPLAT_ENCODING };
    this.active = new SplatAccumulator();
    this.accumulatorCount = 1;
    this.freeAccumulators = [];
    for (let count = 0; count < 1; ++count) {
      this.freeAccumulators.push(new SplatAccumulator());
      this.accumulatorCount += 1;
    }
    this.defaultView = new SparkViewpoint({
      ...options.view,
      autoUpdate: true,
      spark: this
    });
    this.viewpoint = this.defaultView;
    this.prepareViewpoint(this.viewpoint);
    this.clock = options.clock ? cloneClock(options.clock) : new THREE.Clock();
  }
  static makeUniforms() {
    const uniforms = {
      // Size of render viewport in pixels
      renderSize: { value: new THREE.Vector2() },
      // Near and far plane distances
      near: { value: 0.1 },
      far: { value: 1e3 },
      // Total number of Gsplats in packedSplats to render
      numSplats: { value: 0 },
      // SplatAccumulator to view transformation quaternion
      renderToViewQuat: { value: new THREE.Quaternion() },
      // SplatAccumulator to view transformation translation
      renderToViewPos: { value: new THREE.Vector3() },
      // Maximum distance (in stddevs) from Gsplat center to render
      maxStdDev: { value: 1 },
      // Minimum pixel radius for splat rendering
      minPixelRadius: { value: 0 },
      // Maximum pixel radius for splat rendering
      maxPixelRadius: { value: 512 },
      // Minimum alpha value for splat rendering
      minAlpha: { value: 0.5 * (1 / 255) },
      // Enable stochastic splat rendering
      stochastic: { value: false },
      // Enable interpreting 0-thickness Gsplats as 2DGS
      enable2DGS: { value: false },
      // Add to projected 2D splat covariance diagonal (thickens and brightens)
      preBlurAmount: { value: 0 },
      // Add to 2D splat covariance diagonal and adjust opacity (anti-aliasing)
      blurAmount: { value: 0.3 },
      // Depth-of-field distance to focal plane
      focalDistance: { value: 0 },
      // Full-width angle of aperture opening (in radians)
      apertureAngle: { value: 0 },
      // Modulate Gaussian kernal falloff. 0 means "no falloff, flat shading",
      // 1 is normal e^-x^2 falloff.
      falloff: { value: 1 },
      // Clip Gsplats that are clipXY times beyond the +-1 frustum bounds
      clipXY: { value: 1.4 },
      // Debug renderSize scale factor
      focalAdjustment: { value: 1 },
      // Enable splat texture rendering
      splatTexEnable: { value: false },
      // Splat texture to render
      splatTexture: { type: "t", value: _SparkRenderer.EMPTY_SPLAT_TEXTURE },
      // Splat texture UV transform (multiply)
      splatTexMul: { value: new THREE.Matrix2() },
      // Splat texture UV transform (add)
      splatTexAdd: { value: new THREE.Vector2() },
      // Splat texture near plane distance
      splatTexNear: { value: 0.1 },
      // Splat texture far plane distance
      splatTexFar: { value: 1e3 },
      // Splat texture mid plane distance, or 0.0 to disable
      splatTexMid: { value: 0 },
      // Gsplat collection to render
      packedSplats: { type: "t", value: PackedSplats.getEmptyArray },
      // Splat encoding ranges
      rgbMinMaxLnScaleMinMax: { value: new THREE.Vector4() },
      // Time in seconds for time-based effects
      time: { value: 0 },
      // Delta time in seconds since last frame
      deltaTime: { value: 0 },
      // Whether to encode Gsplat with linear RGB (for environment mapping)
      encodeLinear: { value: false },
      // Debug flag that alternates each frame
      debugFlag: { value: false }
    };
    return uniforms;
  }
  canAllocAccumulator() {
    return this.freeAccumulators.length > 0 || this.accumulatorCount < MAX_ACCUMULATORS;
  }
  maybeAllocAccumulator() {
    let accumulator = this.freeAccumulators.pop();
    if (accumulator === void 0) {
      if (this.accumulatorCount >= MAX_ACCUMULATORS) {
        return null;
      }
      accumulator = new SplatAccumulator();
      this.accumulatorCount += 1;
    }
    accumulator.refCount = 1;
    return accumulator;
  }
  releaseAccumulator(accumulator) {
    accumulator.refCount -= 1;
    if (accumulator.refCount === 0) {
      this.freeAccumulators.push(accumulator);
    }
  }
  newViewpoint(options) {
    return new SparkViewpoint({ ...options, spark: this });
  }
  onBeforeRender(renderer, scene, camera) {
    throw new Error("onBeforeRender disabled in SparkRenderer");
  }
  // Update the uniforms for the given viewpoint.
  // Note that the client expects to be able to call render() at any point
  // to update the canvas, so we must switch the viewpoint back to
  // defaultView when we're finished.
  prepareViewpoint(viewpoint) {
    var _a2, _b2, _c, _d;
    this.viewpoint = viewpoint ?? this.viewpoint;
    if (this.viewpoint.display) {
      const { accumulator, geometry } = this.viewpoint.display;
      this.uniforms.numSplats.value = accumulator.splats.numSplats;
      this.uniforms.packedSplats.value = accumulator.splats.getTexture();
      this.uniforms.rgbMinMaxLnScaleMinMax.value.set(
        ((_a2 = accumulator.splats.splatEncoding) == null ? void 0 : _a2.rgbMin) ?? 0,
        ((_b2 = accumulator.splats.splatEncoding) == null ? void 0 : _b2.rgbMax) ?? 1,
        ((_c = accumulator.splats.splatEncoding) == null ? void 0 : _c.lnScaleMin) ?? LN_SCALE_MIN,
        ((_d = accumulator.splats.splatEncoding) == null ? void 0 : _d.lnScaleMax) ?? LN_SCALE_MAX
      );
      this.geometry = geometry;
      this.material.transparent = !this.viewpoint.stochastic;
      this.material.depthWrite = this.viewpoint.stochastic;
      this.material.needsUpdate = true;
    } else {
      this.uniforms.numSplats.value = 0;
      this.uniforms.packedSplats.value = PackedSplats.getEmptyArray;
      this.geometry = EMPTY_GEOMETRY;
    }
  }
  // If spark.autoUpdate is false then you must manually call
  // spark.update({ scene }) to have the scene Gsplats be re-generated.
  update({
    scene,
    viewToWorld
  }) {
    const originToWorld = this.matrixWorld;
    if (this.preUpdate) {
      this.updateInternal({
        scene,
        originToWorld: originToWorld.clone(),
        viewToWorld
      });
    } else {
      this.pendingUpdate.scene = scene;
      this.pendingUpdate.originToWorld.copy(originToWorld);
      if (this.pendingUpdate.timeoutId === -1) {
        this.pendingUpdate.timeoutId = setTimeout(() => {
          const { scene: scene2, originToWorld: originToWorld2 } = this.pendingUpdate;
          this.pendingUpdate.scene = null;
          this.pendingUpdate.timeoutId = -1;
          const updated = this.updateInternal({
            scene: scene2,
            originToWorld: originToWorld2,
            viewToWorld
          });
          if (updated) {
            const gl = this.renderer.getContext();
            gl.flush();
          }
        }, 1);
      }
    }
  }
  updateInternal({
    scene,
    originToWorld,
    viewToWorld
  }) {
    var _a2;
    if (!this.canAllocAccumulator()) {
      return false;
    }
    if (!originToWorld) {
      originToWorld = this.active.toWorld;
    }
    viewToWorld = viewToWorld ?? originToWorld.clone();
    const time = this.time ?? this.clock.getElapsedTime();
    const deltaTime = time - (this.lastUpdateTime ?? time);
    this.lastUpdateTime = time;
    const activeMapping = this.active.mapping.reduce((map, record) => {
      map.set(record.node, record);
      return map;
    }, /* @__PURE__ */ new Map());
    const { generators: generators2, visibleGenerators, globalEdits } = this.compileScene(scene);
    for (const object of generators2) {
      (_a2 = object.frameUpdate) == null ? void 0 : _a2.call(object, {
        renderer: this.renderer,
        object,
        time,
        deltaTime,
        viewToWorld,
        globalEdits
      });
    }
    const visibleGenHash = new Set(visibleGenerators.map((g) => g.uuid));
    for (const object of generators2) {
      const current = activeMapping.get(object);
      const isVisible = object.generator && visibleGenHash.has(object.uuid);
      const numSplats = isVisible ? object.numSplats : 0;
      if (this.needsUpdate || object.generator !== (current == null ? void 0 : current.generator) || numSplats !== (current == null ? void 0 : current.count)) {
        object.updateVersion();
      }
    }
    const originUpdate = !withinCoorientDist({
      matrix1: originToWorld,
      matrix2: this.active.toWorld,
      maxDistance: this.originDistance
    });
    const needsUpdate = this.needsUpdate || originUpdate || generators2.length !== activeMapping.size || generators2.some((g) => {
      var _a3;
      return g.version !== ((_a3 = activeMapping.get(g)) == null ? void 0 : _a3.version);
    });
    this.needsUpdate = false;
    let accumulator = null;
    if (needsUpdate) {
      accumulator = this.maybeAllocAccumulator();
      if (!accumulator) {
        throw new Error("Unreachable");
      }
      const originChanged = !withinCoorientDist({
        matrix1: originToWorld,
        matrix2: this.active.toWorld,
        maxDistance: 1e-5,
        minCoorient: 0.99999
      });
      const sorted = visibleGenerators.map((g, gIndex) => {
        const lastGen = activeMapping.get(g);
        return !lastGen ? [Number.POSITIVE_INFINITY, g.version, g] : (
          // Sort by version deltas then by previous ordering in the mapping,
          // attempting to keep unchanging generators near the front
          // to improve our chances of avoiding a re-generation.
          [g.version - lastGen.version, lastGen.base, g]
        );
      }).sort((a, b) => {
        if (a[0] !== b[0]) {
          return a[0] - b[0];
        }
        return a[1] - b[1];
      });
      const genOrder = sorted.map(([_version, _seq, g]) => g);
      const splatCounts = genOrder.map((g) => g.numSplats);
      const { maxSplats, mapping } = accumulator.splats.generateMapping(splatCounts);
      const newGenerators = genOrder.map((node, gIndex) => {
        const { base, count } = mapping[gIndex];
        return {
          node,
          generator: node.generator,
          version: node.version,
          base,
          count
        };
      });
      originToWorld.clone().invert().decompose(
        this.translateToAccumulator.value,
        this.rotateToAccumulator.value,
        new THREE.Vector3()
      );
      accumulator.ensureGenerate(maxSplats);
      accumulator.splats.splatEncoding = { ...this.splatEncoding };
      accumulator.generateSplats({
        renderer: this.renderer,
        modifier: this.modifier,
        generators: newGenerators,
        forceUpdate: originChanged,
        originToWorld
      });
      accumulator.splatsVersion = this.active.splatsVersion + 1;
      const hasCorrespondence = accumulator.hasCorrespondence(this.active);
      accumulator.mappingVersion = this.active.mappingVersion + (hasCorrespondence ? 0 : 1);
      this.releaseAccumulator(this.active);
      this.active = accumulator;
      this.prepareViewpoint();
    }
    setTimeout(() => {
      for (const view of this.autoViewpoints) {
        view.autoPoll({ accumulator: accumulator ?? void 0 });
      }
    }, 1);
    return true;
  }
  compileScene(scene) {
    const generators2 = [];
    scene.traverse((node) => {
      if (node instanceof SplatGenerator) {
        generators2.push(node);
      }
    });
    const visibleGenerators = [];
    scene.traverseVisible((node) => {
      if (node instanceof SplatGenerator) {
        visibleGenerators.push(node);
      }
    });
    const globalEdits = /* @__PURE__ */ new Set();
    scene.traverseVisible((node) => {
      if (node instanceof SplatEdit) {
        let ancestor = node.parent;
        while (ancestor != null && !(ancestor instanceof SplatMesh)) {
          ancestor = ancestor.parent;
        }
        if (ancestor == null) {
          globalEdits.add(node);
        }
      }
    });
    return {
      generators: generators2,
      visibleGenerators,
      globalEdits: Array.from(globalEdits)
    };
  }
  // Renders out the scene to an environment map that can be used for
  // Image-based lighting or similar applications. First optionally updates Gsplats,
  // sorts them with respect to the provided worldCenter, renders 6 cube faces,
  // then pre-filters them using THREE.PMREMGenerator and returns a THREE.Texture
  // that can assigned directly to a THREE.MeshStandardMaterial.envMap property.
  async renderEnvMap({
    renderer,
    scene,
    worldCenter,
    size = 256,
    near = 0.1,
    far = 1e3,
    hideObjects = [],
    update = false
  }) {
    var _a2, _b2;
    if (!this.envViewpoint) {
      this.envViewpoint = this.newViewpoint({ sort360: true });
    }
    if (!_SparkRenderer.cubeRender || _SparkRenderer.cubeRender.target.width !== size || _SparkRenderer.cubeRender.near !== near || _SparkRenderer.cubeRender.far !== far) {
      if (_SparkRenderer.cubeRender) {
        _SparkRenderer.cubeRender.target.dispose();
      }
      const target2 = new THREE.WebGLCubeRenderTarget(size, {
        format: THREE.RGBAFormat,
        generateMipmaps: true,
        minFilter: THREE.LinearMipMapLinearFilter
      });
      const camera2 = new THREE.CubeCamera(near, far, target2);
      _SparkRenderer.cubeRender = { target: target2, camera: camera2, near, far };
    }
    if (!_SparkRenderer.pmrem) {
      _SparkRenderer.pmrem = new THREE.PMREMGenerator(renderer ?? this.renderer);
    }
    const viewToWorld = new THREE.Matrix4().setPosition(worldCenter);
    await ((_a2 = this.envViewpoint) == null ? void 0 : _a2.prepare({ scene, viewToWorld, update }));
    const { target, camera } = _SparkRenderer.cubeRender;
    camera.position.copy(worldCenter);
    const objectVisibility = /* @__PURE__ */ new Map();
    for (const object of hideObjects) {
      objectVisibility.set(object, object.visible);
      object.visible = false;
    }
    this.prepareViewpoint(this.envViewpoint);
    camera.update(renderer ?? this.renderer, scene);
    this.prepareViewpoint(this.defaultView);
    for (const [object, visible] of objectVisibility.entries()) {
      object.visible = visible;
    }
    return (_b2 = _SparkRenderer.pmrem) == null ? void 0 : _b2.fromCubemap(target.texture).texture;
  }
  // Utility function to recursively set the envMap property for any
  // THREE.MeshStandardMaterial within the subtree of root.
  recurseSetEnvMap(root, envMap) {
    root.traverse((node) => {
      if (node instanceof THREE.Mesh) {
        if (Array.isArray(node.material)) {
          for (const material of node.material) {
            if (material instanceof THREE.MeshStandardMaterial) {
              material.envMap = envMap;
            }
          }
        } else {
          if (node.material instanceof THREE.MeshStandardMaterial) {
            node.material.envMap = envMap;
          }
        }
      }
    });
  }
  // Utility function that helps extract the Gsplat RGBA values from a
  // SplatGenerator, including the result of any real-time RGBA SDF edits applied
  // to a SplatMesh. This effectively "bakes" any computed RGBA values, which can
  // now be used as a pipeline input via SplatMesh.splatRgba to inject these
  // baked values into the Gsplat data.
  getRgba({
    generator,
    rgba
  }) {
    const mapping = this.active.mapping.find(({ node }) => node === generator);
    if (!mapping) {
      throw new Error("Generator not found");
    }
    rgba = rgba ?? new RgbaArray();
    rgba.fromPackedSplats({
      packedSplats: this.active.splats,
      base: mapping.base,
      count: mapping.count,
      renderer: this.renderer
    });
    return rgba;
  }
  // Utility function that builds on getRgba({ generator }) and additionally
  // reads back the RGBA values to the CPU in a Uint8Array with packed RGBA
  // in that byte order.
  async readRgba({
    generator,
    rgba
  }) {
    rgba = this.getRgba({ generator, rgba });
    return rgba.read();
  }
};
_SparkRenderer.cubeRender = null;
_SparkRenderer.pmrem = null;
_SparkRenderer.EMPTY_SPLAT_TEXTURE = new THREE.Data3DTexture();
let SparkRenderer = _SparkRenderer;
const EMPTY_GEOMETRY = new SplatGeometry(new Uint32Array(1), 0);
dynoBlock(
  { packedSplats: TPackedSplats, index: "int" },
  { gsplat: Gsplat },
  ({ packedSplats, index }) => {
    if (!packedSplats || !index) {
      throw new Error("Invalid input");
    }
    const gsplat = readPackedSplat(packedSplats, index);
    return { gsplat };
  }
);
var computeUvec4x2_Vec4_default = "precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nlayout(location = 0) out uvec4 target;\nlayout(location = 1) out uvec4 target2;\nlayout(location = 2) out vec4 target3;\n\n{{ GLOBALS }}\n\nvoid produceSplat(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    \n    target = uvec4(0u, 0u, 0u, 0u);\n    target2 = uvec4(0u, 0u, 0u, 0u);\n\n    \n    target3 = floatToVec4(1.0 / 0.0);\n\n    if ((index >= 0) && (index < targetCount)) {\n        produceSplat(index);\n    }\n}";
const _NewSplatAccumulator = class _NewSplatAccumulator {
  constructor() {
    this.accumulatorId = ++_NewSplatAccumulator.lastAccumulatorId;
    this.time = 0;
    this.deltaTime = 0;
    this.viewToWorld = new THREE.Matrix4();
    this.viewOrigin = new THREE.Vector3();
    this.viewDirection = new THREE.Vector3();
    this.maxSplats = 0;
    this.numSplats = 0;
    this.target = null;
    this.mapping = [];
    this.version = -1;
    this.mappingVersion = -1;
    if (!threeMrtArray) {
      throw new Error("Spark requires THREE.js r179 or above");
    }
  }
  dispose() {
    if (this.target) {
      this.target.dispose();
      this.target = null;
    }
  }
  // Returns a THREE.DataArrayTexture representing the NewSplatAccumulator
  // content as 2 x Uint32x4 data array textures (2048 x 2048 x 2048 in size)
  getTextures() {
    if (this.target) {
      return this.target.textures;
    }
    return _NewSplatAccumulator.emptyTextures;
  }
  // Given an array of splatCounts (.numSplats for each
  // SplatGenerator/SplatMesh in the scene), compute a
  // "mapping layout" in the composite array of generated outputs.
  generateMapping(splatCounts) {
    let maxSplats = 0;
    const mapping = splatCounts.map((numSplats) => {
      const base = maxSplats;
      const rounded = Math.ceil(numSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;
      maxSplats += rounded;
      return { base, count: numSplats };
    });
    return { maxSplats, mapping };
  }
  // Ensures our NewSplatAccumulator.target render target has enough space
  // to generate maxSplats total Gsplats, and reallocate if not large enough.
  ensureGenerate({ maxSplats }) {
    if (this.target && (maxSplats ?? 1) <= this.maxSplats) {
      return false;
    }
    this.dispose();
    const textureSize2 = getTextureSize(maxSplats ?? 1);
    const { width, height, depth } = textureSize2;
    this.maxSplats = textureSize2.maxSplats;
    this.target = new THREE.WebGLArrayRenderTarget(width, height, depth, {
      depthBuffer: false,
      stencilBuffer: false,
      generateMipmaps: false,
      magFilter: THREE.NearestFilter,
      minFilter: THREE.NearestFilter,
      format: THREE.RGBAIntegerFormat,
      type: THREE.UnsignedIntType
      // format: THREE.RGBAFormat,
      // type: THREE.UnsignedByteType,
    });
    this.target.scissorTest = true;
    const target2 = this.target.texture.clone();
    const target3 = this.target.texture.clone();
    target3.format = THREE.RGBAFormat;
    target3.type = THREE.UnsignedByteType;
    target3.internalFormat = "RGBA8";
    this.target.textures = [this.target.texture, target2, target3];
    return true;
  }
  saveRenderState(renderer) {
    return {
      xrEnabled: renderer.xr.enabled,
      autoClear: renderer.autoClear
    };
  }
  resetRenderState(renderer, state) {
    renderer.setRenderTarget(null);
    renderer.xr.enabled = state.xrEnabled;
    renderer.autoClear = state.autoClear;
  }
  // Get a program and THREE.RawShaderMaterial for a given GsplatGenerator,
  // generating it if necessary and caching the result.
  prepareProgramMaterial(generator) {
    let program = _NewSplatAccumulator.generatorProgram.get(generator);
    if (!program) {
      const graph = dynoBlock(
        { index: "int" },
        {},
        ({ index }, _outputs, { roots }) => {
          generator.inputs.index = index;
          const output = outputExtendedSplat(generator.outputs.gsplat);
          const outputDepth = outputSplatDepth(
            generator.outputs.gsplat,
            _NewSplatAccumulator.viewCenterUniform,
            _NewSplatAccumulator.viewDirUniform,
            _NewSplatAccumulator.sortRadialUniform
          );
          roots.push(output, outputDepth);
          return void 0;
        }
      );
      program = new DynoProgram({
        graph,
        inputs: { index: "index" },
        outputs: {},
        template: _NewSplatAccumulator.programTemplate
      });
    }
    Object.assign(program.uniforms, {
      targetLayer: { value: 0 },
      targetBase: { value: 0 },
      targetCount: { value: 0 }
    });
    _NewSplatAccumulator.generatorProgram.set(generator, program);
    const material = program.prepareMaterial();
    _NewSplatAccumulator.fullScreenQuad.material = material;
    return { program, material };
  }
  generate({
    generator,
    base,
    count,
    renderer
  }) {
    if (!this.target) {
      throw new Error("Target must be initialized with ensureGenerate");
    }
    if (base + count > this.maxSplats) {
      throw new Error("Base + count exceeds maxSplats");
    }
    const { program, material } = this.prepareProgramMaterial(generator);
    program.update();
    const renderState = this.saveRenderState(renderer);
    const nextBase = Math.ceil((base + count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;
    const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;
    material.uniforms.targetBase.value = base;
    material.uniforms.targetCount.value = count;
    while (base < nextBase) {
      const layer = Math.floor(base / layerSize);
      material.uniforms.targetLayer.value = layer;
      const layerBase = layer * layerSize;
      const layerYStart = Math.floor((base - layerBase) / SPLAT_TEX_WIDTH);
      const layerYEnd = Math.min(
        SPLAT_TEX_HEIGHT,
        Math.ceil((nextBase - layerBase) / SPLAT_TEX_WIDTH)
      );
      this.target.scissor.set(
        0,
        layerYStart,
        SPLAT_TEX_WIDTH,
        layerYEnd - layerYStart
      );
      renderer.setRenderTarget(this.target, layer);
      renderer.xr.enabled = false;
      renderer.autoClear = false;
      _NewSplatAccumulator.fullScreenQuad.render(renderer);
      base += SPLAT_TEX_WIDTH * (layerYEnd - layerYStart);
    }
    this.resetRenderState(renderer, renderState);
    return { nextBase };
  }
  prepareGenerate({
    renderer,
    scene,
    time,
    camera,
    sortRadial,
    renderSize,
    previous,
    lodInstances
  }) {
    var _a2;
    this.viewToWorld.copy(camera.matrixWorld);
    camera.getWorldPosition(this.viewOrigin);
    camera.getWorldDirection(this.viewDirection);
    _NewSplatAccumulator.viewCenterUniform.value.copy(this.viewOrigin);
    _NewSplatAccumulator.viewDirUniform.value.copy(this.viewDirection);
    _NewSplatAccumulator.sortRadialUniform.value = sortRadial;
    this.time = time;
    this.deltaTime = time - previous.time;
    const allGenerators = [];
    scene.traverse((node) => {
      if (node instanceof SplatGenerator) {
        if (!camera.layers || camera.layers.test(node.layers)) {
          allGenerators.push(node);
        }
      }
    });
    const globalEditsSet = /* @__PURE__ */ new Set();
    scene.traverseVisible((node) => {
      if (node instanceof SplatEdit) {
        let ancestor = node.parent;
        while (ancestor != null && !(ancestor instanceof SplatMesh)) {
          ancestor = ancestor.parent;
        }
        if (ancestor == null) {
          globalEditsSet.add(node);
        }
      }
    });
    const globalEdits = Array.from(globalEditsSet);
    for (const object of allGenerators) {
      try {
        (_a2 = object.frameUpdate) == null ? void 0 : _a2.call(object, {
          renderer,
          object,
          time: this.time,
          deltaTime: this.deltaTime,
          viewToWorld: this.viewToWorld,
          camera,
          renderSize,
          globalEdits,
          lodIndices: object instanceof SplatMesh ? lodInstances.get(object) : void 0
        });
      } catch (error) {
        console.error("frameUpdate error", error);
        object.generator = void 0;
        object.generatorError = error;
      }
    }
    const visibleGenerators = [];
    scene.traverseVisible((node) => {
      if (node instanceof SplatGenerator) {
        if (!camera.layers || camera.layers.test(node.layers)) {
          visibleGenerators.push(node);
        }
      }
    });
    const splatCounts = visibleGenerators.map(
      (generator) => generator.numSplats
    );
    const { maxSplats, mapping: baseCounts } = this.generateMapping(splatCounts);
    const previousMappings = previous.mapping.reduce((mappings, mapping) => {
      mappings.set(mapping.node, mapping);
      return mappings;
    }, /* @__PURE__ */ new Map());
    this.mapping = [];
    this.numSplats = 0;
    baseCounts.forEach(({ base, count }, index) => {
      const node = visibleGenerators[index];
      const previousNode = previousMappings.get(node);
      if (previousNode && previousNode.count !== node.numSplats) {
        node.updateMappingVersion();
      }
      const generator = node.generator;
      if (generator && count > 0) {
        const { version, mappingVersion } = node;
        this.mapping.push({
          node,
          generator,
          version,
          mappingVersion,
          base,
          count
        });
        this.numSplats = Math.max(this.numSplats, base + count);
      }
    });
    const { splatsUpdated, mappingUpdated } = previous.checkVersions(
      this.mapping
    );
    this.version = previous.version + (splatsUpdated ? 1 : 0);
    this.mappingVersion = previous.mappingVersion + (mappingUpdated ? 1 : 0);
    return {
      sameMapping: !mappingUpdated,
      version: this.version,
      mappingVersion: this.mappingVersion,
      visibleGenerators,
      generate: () => {
        this.ensureGenerate({ maxSplats });
        for (const { node, base, count } of this.mapping) {
          const generator = node.generator;
          if (generator && count > 0) {
            this.generate({ generator, base, count, renderer });
          }
        }
      }
    };
  }
  // // Check if this accumulator has exactly the same generator mapping as
  // // the previous one. If so, we can reuse the Gsplat sort order.
  // hasCorrespondence(mapping: GeneratorMapping[]) {
  //   if (this.mapping.length !== mapping.length) {
  //     return false;
  //   }
  //   return this.mapping.every(({ node, mappingVersion, base, count }, i) => {
  //     const {
  //       node: otherNode,
  //       base: otherBase,
  //       count: otherCount,
  //       mappingVersion: otherMappingVersion,
  //     } = mapping[i];
  //     return (
  //       node === otherNode &&
  //       base === otherBase &&
  //       count === otherCount &&
  //       mappingVersion === otherMappingVersion
  //     );
  //   });
  // }
  // Check if this accumulator has exactly the same generator mapping as
  // the previous one. If so, we can reuse the Gsplat sort order.
  checkVersions(otherMapping) {
    if (this.mapping.length !== otherMapping.length) {
      return { splatsUpdated: true, mappingUpdated: true };
    }
    const mappingUpdated = this.mapping.some((item, i) => {
      const other = otherMapping[i];
      return item.node !== other.node || item.base !== other.base || item.count !== other.count || item.mappingVersion !== other.mappingVersion;
    });
    if (mappingUpdated) {
      return { splatsUpdated: true, mappingUpdated: true };
    }
    const splatsUpdated = this.mapping.some((item, i) => {
      return item.version !== otherMapping[i].version;
    });
    return { splatsUpdated, mappingUpdated };
  }
};
_NewSplatAccumulator.lastAccumulatorId = 0;
_NewSplatAccumulator.viewCenterUniform = new DynoVec3({ value: new THREE.Vector3() });
_NewSplatAccumulator.viewDirUniform = new DynoVec3({ value: new THREE.Vector3() });
_NewSplatAccumulator.sortRadialUniform = new DynoBool({ value: true });
_NewSplatAccumulator.emptyTexture = (() => {
  const { width, height, depth, maxSplats } = getTextureSize(1);
  const emptyArray = new Uint32Array(maxSplats * 4);
  const texture2 = new THREE.DataArrayTexture(
    emptyArray,
    width,
    height,
    depth
  );
  texture2.format = THREE.RGBAIntegerFormat;
  texture2.type = THREE.UnsignedIntType;
  texture2.internalFormat = "RGBA32UI";
  texture2.needsUpdate = true;
  return texture2;
})();
_NewSplatAccumulator.emptyTextures = (() => {
  return [_NewSplatAccumulator.emptyTexture, _NewSplatAccumulator.emptyTexture];
})();
_NewSplatAccumulator.programTemplate = new DynoProgramTemplate(computeUvec4x2_Vec4_default);
_NewSplatAccumulator.generatorProgram = /* @__PURE__ */ new Map();
_NewSplatAccumulator.fullScreenQuad = new FullScreenQuad(
  new THREE.RawShaderMaterial({ visible: false })
);
let NewSplatAccumulator = _NewSplatAccumulator;
class NewSplatGeometry extends THREE.InstancedBufferGeometry {
  constructor() {
    super();
    this.setAttribute("position", new THREE.BufferAttribute(QUAD_VERTICES, 3));
    this.setIndex(new THREE.BufferAttribute(QUAD_INDICES, 1));
  }
}
const QUAD_VERTICES = new Float32Array([
  -1,
  -1,
  0,
  1,
  -1,
  0,
  1,
  1,
  0,
  -1,
  1,
  0
]);
const QUAD_INDICES = new Uint16Array([0, 1, 2, 0, 2, 3]);
const _NewSparkRenderer = class _NewSparkRenderer extends THREE.Mesh {
  constructor(options) {
    const uniforms = _NewSparkRenderer.makeUniforms();
    const shaders2 = getShaders();
    const premultipliedAlpha = options.premultipliedAlpha ?? true;
    const geometry = new NewSplatGeometry();
    const material = new THREE.ShaderMaterial({
      glslVersion: THREE.GLSL3,
      vertexShader: shaders2.newSplatVertex,
      fragmentShader: shaders2.newSplatFragment,
      uniforms,
      premultipliedAlpha,
      transparent: true,
      depthTest: true,
      depthWrite: false,
      side: THREE.DoubleSide
    });
    super(geometry, material);
    this.renderSize = new THREE.Vector2();
    this.lastFrame = -1;
    this.updateTimeoutId = -1;
    this.orderingTexture = null;
    this.maxSplats = 0;
    this.activeSplats = 0;
    this.accumulators = [];
    this.sorting = false;
    this.sortDirty = false;
    this.lastSortTime = 0;
    this.sortWorker = null;
    this.sortTimeoutId = -1;
    this.sortedCenter = new THREE.Vector3().setScalar(Number.NEGATIVE_INFINITY);
    this.sortedDir = new THREE.Vector3().setScalar(0);
    this.readback32 = new Uint32Array(0);
    this.lodWorker = null;
    this.lodMeshes = [];
    this.lodDirty = false;
    this.lodIds = /* @__PURE__ */ new Map();
    this.lodIdToSplats = /* @__PURE__ */ new Map();
    this.lodInitQueue = [];
    this.lodPos = new THREE.Vector3().setScalar(Number.NEGATIVE_INFINITY);
    this.lodQuat = new THREE.Quaternion().set(0, 0, 0, 0);
    this.lodInstances = /* @__PURE__ */ new Map();
    this.lodFetchers = [];
    this.lodInserts = [];
    this.flushAfterGenerate = false;
    this.flushAfterRead = false;
    this.readPause = 1;
    this.sortPause = 0;
    this.sortDelay = 0;
    this.material = material;
    this.uniforms = uniforms;
    this.frustumCulled = false;
    this.renderer = options.renderer;
    this.premultipliedAlpha = premultipliedAlpha;
    this.autoUpdate = options.autoUpdate ?? true;
    this.preUpdate = options.preUpdate ?? true;
    this.maxStdDev = options.maxStdDev ?? Math.sqrt(8);
    this.minPixelRadius = options.minPixelRadius ?? 0;
    this.maxPixelRadius = options.maxPixelRadius ?? 512;
    this.minAlpha = options.minAlpha ?? 0.5 * (1 / 255);
    this.enable2DGS = options.enable2DGS ?? false;
    this.preBlurAmount = options.preBlurAmount ?? 0;
    this.blurAmount = options.blurAmount ?? 0.3;
    this.focalDistance = options.focalDistance ?? 0;
    this.apertureAngle = options.apertureAngle ?? 0;
    this.falloff = options.falloff ?? 1;
    this.clipXY = options.clipXY ?? 1.4;
    this.focalAdjustment = options.focalAdjustment ?? 1;
    this.encodeLinear = options.encodeLinear ?? false;
    this.sortRadial = options.sortRadial ?? true;
    this.depthBias = options.depthBias;
    this.minSortIntervalMs = options.minSortIntervalMs ?? 10;
    this.minLodIntervalMs = options.minLodIntervalMs ?? 10;
    this.lodSplatCount = options.lodSplatCount;
    this.lodSplatScale = options.lodSplatScale ?? 1;
    this.globalLodScale = options.globalLodScale ?? 1;
    this.outsideFoveate = options.outsideFoveate ?? 1;
    this.behindFoveate = options.behindFoveate ?? 1;
    this.numLodFetchers = options.numLodFetchers ?? 4;
    this.clock = options.clock ? cloneClock(options.clock) : new THREE.Clock();
    this.display = new NewSplatAccumulator();
    this.current = this.display;
    this.accumulators.push(new NewSplatAccumulator());
    this.accumulators.push(new NewSplatAccumulator());
  }
  static makeUniforms() {
    const uniforms = {
      // number of active splats to render
      numSplats: { value: 0 },
      // Size of render viewport in pixels
      renderSize: { value: new THREE.Vector2() },
      // Near and far plane distances
      near: { value: 0.1 },
      far: { value: 1e3 },
      // SplatAccumulator to view transformation quaternion
      renderToViewQuat: { value: new THREE.Quaternion() },
      // SplatAccumulator to view transformation translation
      renderToViewPos: { value: new THREE.Vector3() },
      // Maximum distance (in stddevs) from Gsplat center to render
      maxStdDev: { value: 1 },
      // Minimum pixel radius for splat rendering
      minPixelRadius: { value: 0 },
      // Maximum pixel radius for splat rendering
      maxPixelRadius: { value: 512 },
      // Minimum alpha value for splat rendering
      minAlpha: { value: 0.5 * (1 / 255) },
      // Enable interpreting 0-thickness Gsplats as 2DGS
      enable2DGS: { value: false },
      // Add to projected 2D splat covariance diagonal (thickens and brightens)
      preBlurAmount: { value: 0 },
      // Add to 2D splat covariance diagonal and adjust opacity (anti-aliasing)
      blurAmount: { value: 0.3 },
      // Depth-of-field distance to focal plane
      focalDistance: { value: 0 },
      // Full-width angle of aperture opening (in radians)
      apertureAngle: { value: 0 },
      // Modulate Gaussian kernal falloff. 0 means "no falloff, flat shading",
      // 1 is normal e^-x^2 falloff.
      falloff: { value: 1 },
      // Clip Gsplats that are clipXY times beyond the +-1 frustum bounds
      clipXY: { value: 1.4 },
      // Debug renderSize scale factor
      focalAdjustment: { value: 1 },
      // Whether to encode Gsplat with linear RGB (for environment mapping)
      encodeLinear: { value: false },
      // Back-to-front sort ordering of splat indices
      ordering: { type: "t", value: _NewSparkRenderer.emptyOrdering },
      // Gsplat collection to render
      extSplats: { type: "t", value: NewSplatAccumulator.emptyTexture },
      extSplats2: { type: "t", value: NewSplatAccumulator.emptyTexture },
      // Time in seconds for time-based effects
      time: { value: 0 },
      // Delta time in seconds since last frame
      deltaTime: { value: 0 },
      // Debug flag that alternates each frame
      debugFlag: { value: false }
    };
    return uniforms;
  }
  onBeforeRender(renderer, scene, camera) {
    var _a2;
    const frame = renderer.info.render.frame;
    const isNewFrame = frame !== this.lastFrame;
    this.lastFrame = frame;
    const renderSize = renderer.getDrawingBufferSize(this.renderSize);
    if (renderer.xr.isPresenting) {
      if (renderSize.x === 1 && renderSize.y === 1) {
        const baseLayer = (_a2 = renderer.xr.getSession()) == null ? void 0 : _a2.renderState.baseLayer;
        if (baseLayer) {
          renderSize.x = baseLayer.framebufferWidth;
          renderSize.y = baseLayer.framebufferHeight;
        }
      }
    }
    this.uniforms.renderSize.value.copy(renderSize);
    const typedCamera = camera;
    this.uniforms.near.value = typedCamera.near;
    this.uniforms.far.value = typedCamera.far;
    const geometry = this.geometry;
    geometry.instanceCount = this.activeSplats;
    this.uniforms.numSplats.value = this.activeSplats;
    const worldToCamera = camera.matrixWorld.clone().invert();
    worldToCamera.decompose(
      this.uniforms.renderToViewPos.value,
      this.uniforms.renderToViewQuat.value,
      new THREE.Vector3()
    );
    this.uniforms.maxStdDev.value = this.maxStdDev;
    this.uniforms.minPixelRadius.value = this.minPixelRadius;
    this.uniforms.maxPixelRadius.value = this.maxPixelRadius;
    this.uniforms.minAlpha.value = this.minAlpha;
    this.uniforms.enable2DGS.value = this.enable2DGS;
    this.uniforms.preBlurAmount.value = this.preBlurAmount;
    this.uniforms.blurAmount.value = this.blurAmount;
    this.uniforms.focalDistance.value = this.focalDistance;
    this.uniforms.apertureAngle.value = this.apertureAngle;
    this.uniforms.falloff.value = this.falloff;
    this.uniforms.clipXY.value = this.clipXY;
    this.uniforms.focalAdjustment.value = this.focalAdjustment;
    this.uniforms.encodeLinear.value = this.encodeLinear;
    this.uniforms.ordering.value = this.orderingTexture ?? _NewSparkRenderer.emptyOrdering;
    const extSplats = this.display.getTextures();
    this.uniforms.extSplats.value = extSplats[0];
    this.uniforms.extSplats2.value = extSplats[1];
    this.uniforms.time.value = this.display.time;
    this.uniforms.deltaTime.value = this.display.deltaTime;
    this.uniforms.debugFlag.value = performance.now() / 1e3 % 2 < 1;
    if (this.autoUpdate && isNewFrame) {
      const preUpdate = this.preUpdate && !renderer.xr.isPresenting;
      const useCamera = renderer.xr.isPresenting ? renderer.xr.getCamera() : camera;
      if (preUpdate) {
        this.updateInternal({
          renderer,
          scene,
          camera: useCamera,
          autoUpdate: true
        });
      } else {
        if (this.updateTimeoutId === -1) {
          this.updateTimeoutId = setTimeout(() => {
            this.updateTimeoutId = -1;
            this.updateInternal({
              renderer,
              scene,
              camera: useCamera,
              autoUpdate: true
            });
          }, 1);
        }
      }
    }
  }
  update({
    renderer,
    scene,
    camera
  }) {
    this.updateInternal({ renderer, scene, camera, autoUpdate: false });
  }
  updateInternal({
    renderer,
    scene,
    camera,
    autoUpdate
  }) {
    const time = this.time ?? this.clock.getElapsedTime();
    const center = camera.getWorldPosition(new THREE.Vector3());
    const dir = camera.getWorldDirection(new THREE.Vector3());
    const viewChanged = center.distanceTo(this.sortedCenter) > 1e-3 || dir.dot(this.sortedDir) < 0.999;
    const next = this.accumulators.pop();
    if (!next) {
      throw new Error("No next accumulator");
    }
    const { version, visibleGenerators, generate } = next.prepareGenerate({
      renderer,
      scene,
      time,
      camera,
      sortRadial: this.sortRadial ?? true,
      renderSize: this.renderSize,
      previous: this.current,
      lodInstances: this.lodInstances
    });
    this.driveLod({ visibleGenerators, camera });
    this.driveSort();
    const needsUpdate = viewChanged || version !== this.current.version;
    if (autoUpdate && !needsUpdate) {
      this.accumulators.push(next);
      return null;
    }
    if (needsUpdate && this.sorting) {
      this.accumulators.push(next);
      return null;
    }
    generate();
    if (this.flushAfterGenerate) {
      const gl = renderer.getContext();
      gl.flush();
    }
    if (this.display.mappingVersion === next.mappingVersion) {
      this.accumulators.push(this.display);
      this.display = next;
    } else {
      if (this.display !== this.current) {
        this.accumulators.push(this.current);
      }
    }
    this.current = next;
    this.sortDirty = true;
    this.driveSort();
  }
  async driveSort() {
    if (this.sorting || !this.sortDirty) {
      return;
    }
    if (this.sortTimeoutId !== -1) {
      clearTimeout(this.sortTimeoutId);
      this.sortTimeoutId = -1;
    }
    const now = performance.now();
    const nextSortTime = this.lastSortTime ? this.lastSortTime + this.minSortIntervalMs : now;
    if (now < nextSortTime) {
      this.sortTimeoutId = setTimeout(() => {
        this.sortTimeoutId = -1;
        this.driveSort();
      }, nextSortTime - now);
      return;
    }
    this.sorting = true;
    this.sortDirty = false;
    this.lastSortTime = now;
    if (this.readPause > 0) {
      await new Promise((resolve) => setTimeout(resolve, this.readPause));
    }
    const current = this.current;
    this.sortedCenter.copy(current.viewOrigin);
    this.sortedDir.copy(current.viewDirection);
    const { numSplats, maxSplats } = current;
    const rows = Math.max(1, Math.ceil(maxSplats / 16384));
    const orderingMaxSplats = rows * 16384;
    this.maxSplats = Math.max(this.maxSplats, orderingMaxSplats);
    const ordering = new Uint32Array(this.maxSplats);
    const readback = Readback.ensureBuffer(maxSplats, this.readback32);
    this.readback32 = readback;
    await this.readbackDepth({
      current,
      renderer: this.renderer,
      numSplats,
      readback
    });
    if (this.sortPause > 0) {
      await new Promise((resolve) => setTimeout(resolve, this.sortPause));
    }
    if (!this.sortWorker) {
      this.sortWorker = new NewSplatWorker();
    }
    const result = await this.sortWorker.call("sortSplats32", {
      numSplats,
      readback,
      ordering
    });
    if (this.sortDelay > 0) {
      await new Promise((resolve) => setTimeout(resolve, this.sortDelay));
    }
    this.readback32 = result.readback;
    this.activeSplats = result.activeSplats;
    if (this.orderingTexture) {
      if (rows > this.orderingTexture.image.height) {
        this.orderingTexture.dispose();
        this.orderingTexture = null;
      }
    }
    if (!this.orderingTexture) {
      const orderingTexture = new THREE.DataTexture(
        result.ordering,
        4096,
        rows,
        THREE.RGBAIntegerFormat,
        THREE.UnsignedIntType
      );
      orderingTexture.internalFormat = "RGBA32UI";
      orderingTexture.needsUpdate = true;
      this.orderingTexture = orderingTexture;
    } else {
      const renderer = this.renderer;
      const gl = renderer.getContext();
      if (!renderer.properties.has(this.orderingTexture)) {
        this.orderingTexture.needsUpdate = true;
      } else {
        const props = renderer.properties.get(this.orderingTexture);
        const glTexture = props.__webglTexture;
        if (!glTexture) {
          throw new Error("ordering texture not found");
        }
        renderer.state.activeTexture(gl.TEXTURE0);
        renderer.state.bindTexture(gl.TEXTURE_2D, glTexture);
        gl.texSubImage2D(
          gl.TEXTURE_2D,
          0,
          0,
          0,
          4096,
          rows,
          gl.RGBA_INTEGER,
          gl.UNSIGNED_INT,
          // data,
          result.ordering
        );
        renderer.state.bindTexture(gl.TEXTURE_2D, null);
      }
    }
    if (this.display.mappingVersion !== current.mappingVersion) {
      this.accumulators.push(this.display);
      this.display = this.current;
    }
    this.sorting = false;
    this.driveSort();
  }
  async driveLod({
    visibleGenerators,
    camera: inputCamera
  }) {
    const lodMeshes = visibleGenerators.filter((generator) => {
      return generator instanceof SplatMesh && generator.packedSplats.lodSplats && generator.enableLod !== false;
    });
    let forceUpdate = this.lodMeshes.length !== lodMeshes.length;
    if (!forceUpdate && lodMeshes.some((m, i) => m !== this.lodMeshes[i].mesh || m.version > this.lodMeshes[i].version)) {
      forceUpdate = true;
    }
    this.lodMeshes = lodMeshes.map((mesh) => ({ mesh, version: mesh.version + 1 }));
    if (forceUpdate) {
      this.lodDirty = true;
    }
    if (!this.lodDirty && lodMeshes.length === 0 && this.lodIds.size === 0) {
      return;
    }
    const camera = inputCamera.clone();
    const lodSplats = lodMeshes.reduce((splats, mesh) => {
      splats.add(mesh.packedSplats.lodSplats);
      return splats;
    }, /* @__PURE__ */ new Set());
    this.lodInitQueue = [];
    const now = performance.now();
    for (const splat of lodSplats) {
      const record = this.lodIds.get(splat);
      if (record) {
        record.lastTouched = now;
      } else {
        this.lodInitQueue.push(splat);
      }
    }
    if (!this.lodWorker) {
      this.lodWorker = new NewSplatWorker();
    }
    this.lodWorker.tryExclusive(async (worker) => {
      if (this.lodInitQueue.length > 0) {
        const lodInitQueue = this.lodInitQueue;
        this.lodInitQueue = [];
        while (lodInitQueue.length > 0) {
          const splats = lodInitQueue.shift();
          await this.initLodTree(worker, splats);
        }
      }
      if (this.lodInserts.length > 0) {
        const lodInserts = this.lodInserts;
        this.lodInserts = [];
        await worker.call("insertLodTrees", { ranges: lodInserts });
      }
      const viewPos = new THREE.Vector3();
      const viewQuat = new THREE.Quaternion();
      this.current.viewToWorld.decompose(
        viewPos,
        viewQuat,
        new THREE.Vector3()
      );
      const viewChanged = viewPos.distanceTo(this.lodPos) > 1e-3 || viewQuat.dot(this.lodQuat) < 0.999;
      if (this.lodDirty || viewChanged) {
        this.lodPos.copy(viewPos);
        this.lodQuat.copy(viewQuat);
        this.lodDirty = false;
        await this.updateLodInstances(worker, camera, lodMeshes);
      }
      await this.cleanupLodTrees(worker);
    });
  }
  async initLodTree(worker, splats) {
    const { lodId, chunkToPage } = await worker.call("initLodTree", {
      numSplats: splats.numSplats ?? 0,
      lodTree: splats.extra.lodTree.slice()
    });
    console.log("=> initLodTree: lodId =", lodId);
    this.lodIds.set(splats, { lodId, lastTouched: performance.now() });
    this.lodIdToSplats.set(lodId, splats);
  }
  async updateLodInstances(worker, camera, lodMeshes) {
    const splatCount = this.lodSplatCount ?? (isAndroid() || isOculus() ? 5e5 : isIos() ? 5e5 : 15e5);
    const maxSplats = splatCount * this.lodSplatScale;
    let pixelScaleLimit = 0;
    let fovXdegrees = Number.POSITIVE_INFINITY;
    let fovYdegrees = Number.POSITIVE_INFINITY;
    if (camera instanceof THREE.PerspectiveCamera) {
      const tanYfov = Math.tan(0.5 * camera.fov * Math.PI / 180);
      pixelScaleLimit = 2 * tanYfov / this.renderSize.y;
      fovYdegrees = camera.fov;
      fovXdegrees = Math.atan(tanYfov * camera.aspect) * 180 / Math.PI * 2;
    }
    const uuidToMesh = /* @__PURE__ */ new Map();
    const instances = lodMeshes.reduce(
      (instances2, mesh) => {
        const record = this.lodIds.get(
          mesh.packedSplats.lodSplats
        );
        if (record) {
          const viewToObject = mesh.matrixWorld.clone().invert().multiply(camera.matrixWorld);
          uuidToMesh.set(mesh.uuid, mesh);
          instances2[mesh.uuid] = {
            lodId: record.lodId,
            viewToObjectCols: viewToObject.elements,
            lodScale: mesh.lodScale * this.globalLodScale,
            outsideFoveate: mesh.outsideFoveate ?? this.outsideFoveate,
            behindFoveate: mesh.behindFoveate ?? this.behindFoveate
          };
        }
        return instances2;
      },
      {}
    );
    const traverseStart = performance.now();
    const { keyIndices, chunks } = await worker.call("traverseLodTrees", {
      maxSplats,
      pixelScaleLimit,
      fovXdegrees,
      fovYdegrees,
      instances
    });
    const splatCounts = Object.keys(keyIndices).map(
      (uuid) => keyIndices[uuid].numSplats
    );
    console.log(
      `traverseLodTrees in ${performance.now() - traverseStart} ms, splatCounts=${JSON.stringify(splatCounts)}`
      // JSON.stringify(chunks),
    );
    this.updateLodIndices(uuidToMesh, keyIndices);
    let availableFetchers = this.numLodFetchers - this.lodFetchers.length;
    if (availableFetchers > 0) {
      for (const [lodId, chunk] of chunks) {
        const splats = this.lodIdToSplats.get(lodId);
        if (!splats.paged) {
          continue;
        }
        let page = splats.chunkToPage.get(chunk);
        if (page !== void 0) {
          splats.chunkToPage.delete(chunk);
          splats.chunkToPage.set(chunk, page);
          continue;
        }
        page = splats.allocTexturePage();
        if (page === void 0) {
          continue;
        }
        const promise = (async () => {
          var _a2;
          const start = performance.now();
          const url = (((_a2 = splats.paged) == null ? void 0 : _a2.url) ?? "").replace(/-lod-0\./, `-lod-${chunk}.`);
          const decoded = await workerPool.withWorker(async (worker2) => {
            var _a3, _b2;
            const decoded2 = await worker2.call("loadSplats", {
              url,
              requestHeader: (_a3 = splats.paged) == null ? void 0 : _a3.requestHeader,
              withCredentials: (_b2 = splats.paged) == null ? void 0 : _b2.withCredentials
            });
            return decoded2.lodSplats;
          });
          console.log(`Uploading chunk ${chunk} to page ${page}`);
          splats.uploadTexturePage(this.renderer, decoded.packedArray, page);
          splats.chunkToPage.set(chunk, page);
          console.log("chunkToPage", splats.chunkToPage);
          this.lodInserts.push({
            lodId,
            pageBase: page * 65536,
            chunkBase: chunk * 65536,
            count: decoded.numSplats,
            lodTreeData: decoded.extra.lodTree
          });
          this.lodDirty = true;
          console.log("Fetched LOD chunk", chunk, decoded.numSplats, performance.now() - start);
          this.lodFetchers = this.lodFetchers.filter((p) => p !== promise);
        })();
        this.lodFetchers.push(promise);
        availableFetchers -= 1;
        if (availableFetchers == 0) {
          break;
        }
      }
    }
  }
  async cleanupLodTrees(worker) {
    var _a2;
    const DISPOSE_TIMEOUT_MS = 3e3;
    let oldest = null;
    for (const [splats, record] of this.lodIds.entries()) {
      if (oldest == null || record.lastTouched < (((_a2 = this.lodIds.get(oldest)) == null ? void 0 : _a2.lastTouched) ?? 0)) {
        oldest = splats;
      }
    }
    if (oldest != null) {
      const now = performance.now();
      const { lastTouched, lodId } = this.lodIds.get(oldest) ?? {
        lastTouched: 0,
        lodId: 0
      };
      if (lastTouched < now - DISPOSE_TIMEOUT_MS) {
        for (const [mesh, indices] of this.lodInstances.entries()) {
          if (mesh.packedSplats.lodSplats === oldest) {
            indices.texture.dispose();
            this.lodInstances.delete(mesh);
            this.lodIds.delete(oldest);
            this.lodIdToSplats.delete(lodId);
          }
        }
        await worker.call("disposeLodTree", { lodId });
        console.log("*** disposed lodTree", lodId);
      }
    }
  }
  updateLodIndices(uuidToMesh, keyIndices) {
    for (const [uuid, countIndices] of Object.entries(keyIndices)) {
      const { numSplats, indices } = countIndices;
      const mesh = uuidToMesh.get(uuid);
      let instance = this.lodInstances.get(mesh);
      if (instance) {
        if (indices.length > instance.indices.length) {
          instance.texture.dispose();
          instance = void 0;
        }
      }
      const rows = Math.ceil(indices.length / 16384);
      if (!instance) {
        const capacity = rows * 16384;
        if (indices.length !== capacity) {
          throw new Error("Indices length != capacity");
        }
        const texture2 = new THREE.DataTexture(
          indices,
          4096,
          rows,
          THREE.RGBAIntegerFormat,
          THREE.UnsignedIntType
        );
        texture2.internalFormat = "RGBA32UI";
        texture2.needsUpdate = true;
        instance = { numSplats, indices, texture: texture2 };
        this.lodInstances.set(mesh, instance);
      } else {
        instance.numSplats = numSplats;
        const renderer = this.renderer;
        const gl = renderer.getContext();
        if (renderer.properties.has(instance.texture)) {
          const props = renderer.properties.get(instance.texture);
          const glTexture = props.__webglTexture;
          if (!glTexture) {
            throw new Error("lodIndices texture not found");
          }
          renderer.state.activeTexture(gl.TEXTURE0);
          renderer.state.bindTexture(gl.TEXTURE_2D, glTexture);
          gl.texSubImage2D(
            gl.TEXTURE_2D,
            0,
            0,
            0,
            4096,
            rows,
            gl.RGBA_INTEGER,
            gl.UNSIGNED_INT,
            indices
          );
          renderer.state.bindTexture(gl.TEXTURE_2D, null);
        }
      }
      mesh.updateMappingVersion();
    }
  }
  async readbackDepth({
    current,
    renderer,
    numSplats,
    readback
  }) {
    if (!renderer) {
      throw new Error("No renderer");
    }
    if (!current.target) {
      throw new Error("No target");
    }
    const roundedCount = Math.ceil(numSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;
    if (readback.byteLength < roundedCount * 4) {
      throw new Error(
        `Readback buffer too small: ${readback.byteLength} < ${roundedCount * 4}`
      );
    }
    const readbackUint8 = new Uint8Array(readback.buffer);
    const renderState = this.saveRenderState(renderer);
    const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;
    let baseIndex = 0;
    const promises = [];
    while (baseIndex < numSplats) {
      const layer = Math.floor(baseIndex / layerSize);
      const layerBase = layer * layerSize;
      const layerYEnd = Math.min(
        SPLAT_TEX_HEIGHT,
        Math.ceil((numSplats - layerBase) / SPLAT_TEX_WIDTH)
      );
      const readbackSize = SPLAT_TEX_WIDTH * layerYEnd * 4;
      const subReadback = readbackUint8.subarray(
        layerBase * 4,
        layerBase * 4 + readbackSize
      );
      renderer.setRenderTarget(current.target, layer);
      const promise = renderer.readRenderTargetPixelsAsync(
        current.target,
        0,
        0,
        SPLAT_TEX_WIDTH,
        layerYEnd,
        subReadback,
        void 0,
        2
      );
      promises.push(promise);
      if (this.flushAfterRead) {
        const gl = renderer.getContext();
        gl.flush();
      }
      baseIndex += SPLAT_TEX_WIDTH * layerYEnd;
    }
    this.resetRenderState(renderer, renderState);
    return Promise.all(promises).then(() => readback);
  }
  saveRenderState(renderer) {
    return {
      xrEnabled: renderer.xr.enabled,
      autoClear: renderer.autoClear
    };
  }
  resetRenderState(renderer, state) {
    renderer.setRenderTarget(null);
    renderer.xr.enabled = state.xrEnabled;
    renderer.autoClear = state.autoClear;
  }
};
_NewSparkRenderer.emptyOrdering = (() => {
  const numIndices = 4 * 4096 * 1;
  const emptyArray = new Uint32Array(numIndices);
  const texture2 = new THREE.DataTexture(emptyArray, 4096, 1);
  texture2.format = THREE.RGBAIntegerFormat;
  texture2.type = THREE.UnsignedIntType;
  texture2.internalFormat = "RGBA32UI";
  texture2.needsUpdate = true;
  return texture2;
})();
let NewSparkRenderer = _NewSparkRenderer;
function decodeAntiSplat(fileBytes, initNumSplats, splatCallback) {
  const numSplats = Math.floor(fileBytes.length / 32);
  if (numSplats * 32 !== fileBytes.length) {
    throw new Error("Invalid .splat file size");
  }
  const f32 = new Float32Array(fileBytes.buffer);
  for (let i = 0; i < numSplats; ++i) {
    const i322 = i * 32;
    const i8 = i * 8;
    const x = f32[i8 + 0];
    const y = f32[i8 + 1];
    const z = f32[i8 + 2];
    const scaleX = f32[i8 + 3];
    const scaleY = f32[i8 + 4];
    const scaleZ = f32[i8 + 5];
    const r = fileBytes[i322 + 24] / 255;
    const g = fileBytes[i322 + 25] / 255;
    const b = fileBytes[i322 + 26] / 255;
    const opacity = fileBytes[i322 + 27] / 255;
    const quatW = (fileBytes[i322 + 28] - 128) / 128;
    const quatX = (fileBytes[i322 + 29] - 128) / 128;
    const quatY = (fileBytes[i322 + 30] - 128) / 128;
    const quatZ = (fileBytes[i322 + 31] - 128) / 128;
    splatCallback(
      i,
      x,
      y,
      z,
      scaleX,
      scaleY,
      scaleZ,
      quatX,
      quatY,
      quatZ,
      quatW,
      opacity,
      r,
      g,
      b
    );
  }
}
const KSPLAT_COMPRESSION = {
  0: {
    bytesPerCenter: 12,
    bytesPerScale: 12,
    bytesPerRotation: 16,
    bytesPerColor: 4,
    bytesPerSphericalHarmonicsComponent: 4,
    scaleOffsetBytes: 12,
    rotationOffsetBytes: 24,
    colorOffsetBytes: 40,
    sphericalHarmonicsOffsetBytes: 44,
    scaleRange: 1
  },
  1: {
    bytesPerCenter: 6,
    bytesPerScale: 6,
    bytesPerRotation: 8,
    bytesPerColor: 4,
    bytesPerSphericalHarmonicsComponent: 2,
    scaleOffsetBytes: 6,
    rotationOffsetBytes: 12,
    colorOffsetBytes: 20,
    sphericalHarmonicsOffsetBytes: 24,
    scaleRange: 32767
  },
  2: {
    bytesPerCenter: 6,
    bytesPerScale: 6,
    bytesPerRotation: 8,
    bytesPerColor: 4,
    bytesPerSphericalHarmonicsComponent: 1,
    scaleOffsetBytes: 6,
    rotationOffsetBytes: 12,
    colorOffsetBytes: 20,
    sphericalHarmonicsOffsetBytes: 24,
    scaleRange: 32767
  }
};
const KSPLAT_SH_DEGREE_TO_COMPONENTS = {
  0: 0,
  1: 9,
  2: 24,
  3: 45
};
function decodeKsplat(fileBytes, initNumSplats, splatCallback, shCallback) {
  var _a2;
  const HEADER_BYTES = 4096;
  const SECTION_BYTES = 1024;
  let headerOffset = 0;
  const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);
  headerOffset += HEADER_BYTES;
  const versionMajor = header.getUint8(0);
  const versionMinor = header.getUint8(1);
  if (versionMajor !== 0 || versionMinor < 1) {
    throw new Error(
      `Unsupported .ksplat version: ${versionMajor}.${versionMinor}`
    );
  }
  const maxSectionCount = header.getUint32(4, true);
  header.getUint32(16, true);
  const compressionLevel = header.getUint16(20, true);
  if (compressionLevel < 0 || compressionLevel > 2) {
    throw new Error(`Invalid .ksplat compression level: ${compressionLevel}`);
  }
  const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;
  const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;
  let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;
  for (let section = 0; section < maxSectionCount; ++section) {
    let getSh = function(splatOffset, component) {
      if (compressionLevel === 0) {
        return data.getFloat32(
          splatOffset + sphericalHarmonicsOffsetBytes + component * 4,
          true
        );
      }
      if (compressionLevel === 1) {
        return fromHalf(
          data.getUint16(
            splatOffset + sphericalHarmonicsOffsetBytes + component * 2,
            true
          )
        );
      }
      const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;
      return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);
    };
    const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);
    headerOffset += SECTION_BYTES;
    const sectionSplatCount = section2.getUint32(0, true);
    const sectionMaxSplatCount = section2.getUint32(4, true);
    const bucketSize = section2.getUint32(8, true);
    const bucketCount = section2.getUint32(12, true);
    const bucketBlockSize = section2.getFloat32(16, true);
    const bucketStorageSizeBytes = section2.getUint16(20, true);
    const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;
    const fullBucketCount = section2.getUint32(32, true);
    const fullBucketSplats = fullBucketCount * bucketSize;
    const partiallyFilledBucketCount = section2.getUint32(36, true);
    const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;
    const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;
    const sphericalHarmonicsDegree = section2.getUint16(40, true);
    const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];
    const {
      bytesPerCenter,
      bytesPerScale,
      bytesPerRotation,
      bytesPerColor,
      bytesPerSphericalHarmonicsComponent,
      scaleOffsetBytes,
      rotationOffsetBytes,
      colorOffsetBytes,
      sphericalHarmonicsOffsetBytes
    } = KSPLAT_COMPRESSION[compressionLevel];
    const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;
    const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;
    const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;
    const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];
    const sh2Index = [
      9,
      14,
      19,
      10,
      15,
      20,
      11,
      16,
      21,
      12,
      17,
      22,
      13,
      18,
      23
    ];
    const sh3Index = [
      24,
      31,
      38,
      25,
      32,
      39,
      26,
      33,
      40,
      27,
      34,
      41,
      28,
      35,
      42,
      29,
      36,
      43,
      30,
      37,
      44
    ];
    const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;
    const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;
    const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;
    const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;
    const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;
    const dataBase = sectionBase + bucketsStorageSizeBytes;
    const data = new DataView(
      fileBytes.buffer,
      dataBase,
      splatDataStorageSizeBytes
    );
    const bucketArray = new Float32Array(
      fileBytes.buffer,
      bucketsBase,
      bucketCount * 3
    );
    const partiallyFilledBucketLengths = new Uint32Array(
      fileBytes.buffer,
      sectionBase,
      partiallyFilledBucketCount
    );
    let partialBucketIndex = fullBucketCount;
    let partialBucketBase = fullBucketSplats;
    for (let i = 0; i < sectionSplatCount; ++i) {
      const splatOffset = i * bytesPerSplat;
      let bucketIndex;
      if (i < fullBucketSplats) {
        bucketIndex = Math.floor(i / bucketSize);
      } else {
        const bucketLength = partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];
        if (i >= partialBucketBase + bucketLength) {
          partialBucketIndex += 1;
          partialBucketBase += bucketLength;
        }
        bucketIndex = partialBucketIndex;
      }
      const x = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];
      const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];
      const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];
      const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));
      const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));
      const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));
      const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(
        data.getUint16(splatOffset + rotationOffsetBytes + 0, true)
      );
      const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(
        data.getUint16(splatOffset + rotationOffsetBytes + 2, true)
      );
      const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(
        data.getUint16(splatOffset + rotationOffsetBytes + 4, true)
      );
      const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(
        data.getUint16(splatOffset + rotationOffsetBytes + 6, true)
      );
      const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;
      const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;
      const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;
      const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;
      splatCallback(
        i,
        x,
        y,
        z,
        scaleX,
        scaleY,
        scaleZ,
        quatX,
        quatY,
        quatZ,
        quatW,
        opacity,
        r,
        g,
        b
      );
      if (sphericalHarmonicsDegree >= 1 && sh1) {
        for (const [i2, key] of sh1Index.entries()) {
          sh1[i2] = getSh(splatOffset, key);
        }
        if (sh2) {
          for (const [i2, key] of sh2Index.entries()) {
            sh2[i2] = getSh(splatOffset, key);
          }
        }
        if (sh3) {
          for (const [i2, key] of sh3Index.entries()) {
            sh3[i2] = getSh(splatOffset, key);
          }
        }
        shCallback == null ? void 0 : shCallback(i, sh1, sh2, sh3);
      }
    }
    sectionBase += storageSizeBytes;
  }
}
class SpzReader {
  constructor({ fileBytes }) {
    this.version = -1;
    this.numSplats = 0;
    this.shDegree = 0;
    this.fractionalBits = 0;
    this.flags = 0;
    this.flagAntiAlias = false;
    this.flagLod = false;
    this.reserved = 0;
    this.headerParsed = false;
    this.parsed = false;
    this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;
    this.reader = new GunzipReader({
      fileBytes: this.fileBytes
    });
  }
  async parseHeader() {
    if (this.headerParsed) {
      throw new Error("SPZ file header already parsed");
    }
    const header = new DataView((await this.reader.read(16)).buffer);
    if (header.getUint32(0, true) !== 1347635022) {
      throw new Error("Invalid SPZ file");
    }
    this.version = header.getUint32(4, true);
    if (this.version < 1 || this.version > 3) {
      throw new Error(`Unsupported SPZ version: ${this.version}`);
    }
    this.numSplats = header.getUint32(8, true);
    this.shDegree = header.getUint8(12);
    this.fractionalBits = header.getUint8(13);
    this.flags = header.getUint8(14);
    this.flagAntiAlias = (this.flags & 1) !== 0;
    this.flagLod = (this.flags & 128) !== 0;
    this.reserved = header.getUint8(15);
    this.headerParsed = true;
    this.parsed = false;
  }
  async parseSplats(centerCallback, alphaCallback, rgbCallback, scalesCallback, quatCallback, shCallback, {
    childCounts,
    childStarts
  } = {}) {
    if (!this.headerParsed) {
      throw new Error("SPZ file header must be parsed first");
    }
    if (this.parsed) {
      throw new Error("SPZ file already parsed");
    }
    this.parsed = true;
    if (this.version === 1) {
      const centerBytes = await this.reader.read(this.numSplats * 3 * 2);
      const centerUint16 = new Uint16Array(centerBytes.buffer);
      for (let i = 0; i < this.numSplats; i++) {
        const i3 = i * 3;
        const x = fromHalf(centerUint16[i3]);
        const y = fromHalf(centerUint16[i3 + 1]);
        const z = fromHalf(centerUint16[i3 + 2]);
        centerCallback == null ? void 0 : centerCallback(i, x, y, z);
      }
    } else if (this.version === 2 || this.version === 3) {
      const fixed = 1 << this.fractionalBits;
      const centerBytes = await this.reader.read(this.numSplats * 3 * 3);
      for (let i = 0; i < this.numSplats; i++) {
        const i9 = i * 9;
        const x = ((centerBytes[i9 + 2] << 24 | centerBytes[i9 + 1] << 16 | centerBytes[i9] << 8) >> 8) / fixed;
        const y = ((centerBytes[i9 + 5] << 24 | centerBytes[i9 + 4] << 16 | centerBytes[i9 + 3] << 8) >> 8) / fixed;
        const z = ((centerBytes[i9 + 8] << 24 | centerBytes[i9 + 7] << 16 | centerBytes[i9 + 6] << 8) >> 8) / fixed;
        centerCallback == null ? void 0 : centerCallback(i, x, y, z);
      }
    } else {
      throw new Error("Unreachable");
    }
    {
      const bytes = await this.reader.read(this.numSplats);
      for (let i = 0; i < this.numSplats; i++) {
        alphaCallback == null ? void 0 : alphaCallback(i, bytes[i] / 255);
      }
    }
    {
      const rgbBytes = await this.reader.read(this.numSplats * 3);
      const scale = SH_C0 / 0.15;
      for (let i = 0; i < this.numSplats; i++) {
        const i3 = i * 3;
        const r = (rgbBytes[i3] / 255 - 0.5) * scale + 0.5;
        const g = (rgbBytes[i3 + 1] / 255 - 0.5) * scale + 0.5;
        const b = (rgbBytes[i3 + 2] / 255 - 0.5) * scale + 0.5;
        rgbCallback == null ? void 0 : rgbCallback(i, r, g, b);
      }
    }
    {
      const scalesBytes = await this.reader.read(this.numSplats * 3);
      for (let i = 0; i < this.numSplats; i++) {
        const i3 = i * 3;
        const scaleX = Math.exp(scalesBytes[i3] / 16 - 10);
        const scaleY = Math.exp(scalesBytes[i3 + 1] / 16 - 10);
        const scaleZ = Math.exp(scalesBytes[i3 + 2] / 16 - 10);
        scalesCallback == null ? void 0 : scalesCallback(i, scaleX, scaleY, scaleZ);
      }
    }
    if (this.version === 3) {
      const maxValue = 1 / Math.sqrt(2);
      const quatBytes = await this.reader.read(this.numSplats * 4);
      for (let i = 0; i < this.numSplats; i++) {
        const i3 = i * 4;
        const quaternion = [0, 0, 0, 0];
        const values = [
          quatBytes[i3],
          quatBytes[i3 + 1],
          quatBytes[i3 + 2],
          quatBytes[i3 + 3]
        ];
        const combinedValues = values[0] + (values[1] << 8) + (values[2] << 16) + (values[3] << 24);
        const valueMask = (1 << 9) - 1;
        const largestIndex = combinedValues >>> 30;
        let remainingValues = combinedValues;
        let sumSquares = 0;
        for (let i2 = 3; i2 >= 0; --i2) {
          if (i2 !== largestIndex) {
            const value = remainingValues & valueMask;
            const sign2 = remainingValues >>> 9 & 1;
            remainingValues = remainingValues >>> 10;
            quaternion[i2] = maxValue * (value / valueMask);
            quaternion[i2] = sign2 === 0 ? quaternion[i2] : -quaternion[i2];
            sumSquares += quaternion[i2] * quaternion[i2];
          }
        }
        const square = 1 - sumSquares;
        quaternion[largestIndex] = Math.sqrt(Math.max(square, 0));
        quatCallback == null ? void 0 : quatCallback(
          i,
          quaternion[0],
          quaternion[1],
          quaternion[2],
          quaternion[3]
        );
      }
    } else {
      const quatBytes = await this.reader.read(this.numSplats * 3);
      for (let i = 0; i < this.numSplats; i++) {
        const i3 = i * 3;
        const quatX = quatBytes[i3] / 127.5 - 1;
        const quatY = quatBytes[i3 + 1] / 127.5 - 1;
        const quatZ = quatBytes[i3 + 2] / 127.5 - 1;
        const quatW = Math.sqrt(
          Math.max(0, 1 - quatX * quatX - quatY * quatY - quatZ * quatZ)
        );
        quatCallback == null ? void 0 : quatCallback(i, quatX, quatY, quatZ, quatW);
      }
    }
    if (shCallback && this.shDegree >= 1) {
      const sh1 = new Float32Array(3 * 3);
      const sh2 = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0;
      const sh3 = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0;
      const shBytes = await this.reader.read(
        this.numSplats * SH_DEGREE_TO_VECS[this.shDegree] * 3
      );
      let offset = 0;
      for (let i = 0; i < this.numSplats; i++) {
        for (let j = 0; j < 9; ++j) {
          sh1[j] = (shBytes[offset + j] - 128) / 128;
        }
        offset += 9;
        if (sh2) {
          for (let j = 0; j < 15; ++j) {
            sh2[j] = (shBytes[offset + j] - 128) / 128;
          }
          offset += 15;
        }
        if (sh3) {
          for (let j = 0; j < 21; ++j) {
            sh3[j] = (shBytes[offset + j] - 128) / 128;
          }
          offset += 21;
        }
        shCallback == null ? void 0 : shCallback(i, sh1, sh2, sh3);
      }
    }
    if (this.flagLod) {
      let bytes = await this.reader.read(this.numSplats * 2);
      for (let i = 0; i < this.numSplats; i++) {
        const i2 = i * 2;
        const count = bytes[i2] + (bytes[i2 + 1] << 8);
        childCounts == null ? void 0 : childCounts(i, count);
      }
      bytes = await this.reader.read(this.numSplats * 4);
      for (let i = 0; i < this.numSplats; i++) {
        const i4 = i * 4;
        const start = bytes[i4] + (bytes[i4 + 1] << 8) + (bytes[i4 + 2] << 16) + (bytes[i4 + 3] << 24);
        childStarts == null ? void 0 : childStarts(i, start);
      }
    }
  }
}
const SH_DEGREE_TO_VECS = { 1: 3, 2: 8, 3: 15 };
const SH_C0 = 0.28209479177387814;
const SPZ_MAGIC = 1347635022;
const SPZ_VERSION = 3;
const FLAG_ANTIALIASED = 1;
class SpzWriter {
  constructor({
    numSplats,
    shDegree,
    fractionalBits = 12,
    flagAntiAlias = true
  }) {
    this.clippedCount = 0;
    const splatSize = 9 + // Position
    1 + // Opacity
    3 + // Scale
    3 + // DC-rgb
    4 + // Rotation
    (shDegree >= 1 ? 9 : 0) + (shDegree >= 2 ? 15 : 0) + (shDegree >= 3 ? 21 : 0);
    const bufferSize = 16 + numSplats * splatSize;
    this.buffer = new ArrayBuffer(bufferSize);
    this.view = new DataView(this.buffer);
    this.view.setUint32(0, SPZ_MAGIC, true);
    this.view.setUint32(4, SPZ_VERSION, true);
    this.view.setUint32(8, numSplats, true);
    this.view.setUint8(12, shDegree);
    this.view.setUint8(13, fractionalBits);
    this.view.setUint8(14, flagAntiAlias ? FLAG_ANTIALIASED : 0);
    this.view.setUint8(15, 0);
    this.numSplats = numSplats;
    this.shDegree = shDegree;
    this.fractionalBits = fractionalBits;
    this.fraction = 1 << fractionalBits;
    this.flagAntiAlias = flagAntiAlias;
  }
  setCenter(index, x, y, z) {
    const xRounded = Math.round(x * this.fraction);
    const xInt = Math.max(-8388607, Math.min(8388607, xRounded));
    const yRounded = Math.round(y * this.fraction);
    const yInt = Math.max(-8388607, Math.min(8388607, yRounded));
    const zRounded = Math.round(z * this.fraction);
    const zInt = Math.max(-8388607, Math.min(8388607, zRounded));
    const clipped = xRounded !== xInt || yRounded !== yInt || zRounded !== zInt;
    if (clipped) {
      this.clippedCount += 1;
    }
    const i9 = index * 9;
    const base = 16 + i9;
    this.view.setUint8(base, xInt & 255);
    this.view.setUint8(base + 1, xInt >> 8 & 255);
    this.view.setUint8(base + 2, xInt >> 16 & 255);
    this.view.setUint8(base + 3, yInt & 255);
    this.view.setUint8(base + 4, yInt >> 8 & 255);
    this.view.setUint8(base + 5, yInt >> 16 & 255);
    this.view.setUint8(base + 6, zInt & 255);
    this.view.setUint8(base + 7, zInt >> 8 & 255);
    this.view.setUint8(base + 8, zInt >> 16 & 255);
  }
  setAlpha(index, alpha) {
    const base = 16 + this.numSplats * 9 + index;
    this.view.setUint8(
      base,
      Math.max(0, Math.min(255, Math.round(alpha * 255)))
    );
  }
  static scaleRgb(r) {
    const v = ((r - 0.5) / (SH_C0 / 0.15) + 0.5) * 255;
    return Math.max(0, Math.min(255, Math.round(v)));
  }
  setRgb(index, r, g, b) {
    const base = 16 + this.numSplats * 10 + index * 3;
    this.view.setUint8(base, SpzWriter.scaleRgb(r));
    this.view.setUint8(base + 1, SpzWriter.scaleRgb(g));
    this.view.setUint8(base + 2, SpzWriter.scaleRgb(b));
  }
  setScale(index, scaleX, scaleY, scaleZ) {
    const base = 16 + this.numSplats * 13 + index * 3;
    this.view.setUint8(
      base,
      Math.max(0, Math.min(255, Math.round((Math.log(scaleX) + 10) * 16)))
    );
    this.view.setUint8(
      base + 1,
      Math.max(0, Math.min(255, Math.round((Math.log(scaleY) + 10) * 16)))
    );
    this.view.setUint8(
      base + 2,
      Math.max(0, Math.min(255, Math.round((Math.log(scaleZ) + 10) * 16)))
    );
  }
  setQuat(index, ...q) {
    const base = 16 + this.numSplats * 16 + index * 4;
    const quat = normalize$1(q);
    let iLargest = 0;
    for (let i = 1; i < 4; ++i) {
      if (Math.abs(quat[i]) > Math.abs(quat[iLargest])) {
        iLargest = i;
      }
    }
    const negate = quat[iLargest] < 0 ? 1 : 0;
    let comp = iLargest;
    for (let i = 0; i < 4; ++i) {
      if (i !== iLargest) {
        const negbit = (quat[i] < 0 ? 1 : 0) ^ negate;
        const mag = Math.floor(
          ((1 << 9) - 1) * (Math.abs(quat[i]) / Math.SQRT1_2) + 0.5
        );
        comp = comp << 10 | negbit << 9 | mag;
      }
    }
    this.view.setUint8(base, comp & 255);
    this.view.setUint8(base + 1, comp >> 8 & 255);
    this.view.setUint8(base + 2, comp >> 16 & 255);
    this.view.setUint8(base + 3, comp >>> 24 & 255);
  }
  static quantizeSh(sh, bits2) {
    const value = Math.round(sh * 128) + 128;
    const bucketSize = 1 << 8 - bits2;
    const quantized = Math.floor((value + bucketSize / 2) / bucketSize) * bucketSize;
    return Math.max(0, Math.min(255, quantized));
  }
  setSh(index, sh1, sh2, sh3) {
    const shVecs = SH_DEGREE_TO_VECS[this.shDegree] || 0;
    const base1 = 16 + this.numSplats * 20 + index * shVecs * 3;
    for (let j = 0; j < 9; ++j) {
      this.view.setUint8(base1 + j, SpzWriter.quantizeSh(sh1[j], 5));
    }
    if (sh2) {
      const base2 = base1 + 9;
      for (let j = 0; j < 15; ++j) {
        this.view.setUint8(base2 + j, SpzWriter.quantizeSh(sh2[j], 4));
      }
      if (sh3) {
        const base3 = base2 + 15;
        for (let j = 0; j < 21; ++j) {
          this.view.setUint8(base3 + j, SpzWriter.quantizeSh(sh3[j], 4));
        }
      }
    }
  }
  async finalize() {
    const input = new Uint8Array(this.buffer);
    const stream = new ReadableStream({
      async start(controller) {
        controller.enqueue(input);
        controller.close();
      }
    });
    const compressed = stream.pipeThrough(new CompressionStream("gzip"));
    const response = new Response(compressed);
    const buffer = await response.arrayBuffer();
    console.log(
      "Compressed",
      input.length,
      "bytes to",
      buffer.byteLength,
      "bytes"
    );
    return new Uint8Array(buffer);
  }
}
async function transcodeSpz(input) {
  var _a2, _b2, _c;
  const splats = new SplatData();
  const {
    inputs,
    clipXyz,
    maxSh,
    fractionalBits = 12,
    opacityThreshold
  } = input;
  for (const input2 of inputs) {
    let transformPos2 = function(pos) {
      pos.multiplyScalar(scale);
      pos.applyQuaternion(quaternion);
      pos.add(translate);
      return pos;
    }, transformScales = function(scales) {
      scales.multiplyScalar(scale);
      return scales;
    }, transformQuaternion = function(quat) {
      quat.premultiply(quaternion);
      return quat;
    }, withinClip = function(p) {
      return !clip || clip.containsPoint(p);
    }, withinOpacity = function(opacity) {
      return opacityThreshold !== void 0 ? opacity >= opacityThreshold : true;
    };
    const scale = ((_a2 = input2.transform) == null ? void 0 : _a2.scale) ?? 1;
    const quaternion = new THREE.Quaternion().fromArray(
      ((_b2 = input2.transform) == null ? void 0 : _b2.quaternion) ?? [0, 0, 0, 1]
    );
    const translate = new THREE.Vector3().fromArray(
      ((_c = input2.transform) == null ? void 0 : _c.translate) ?? [0, 0, 0]
    );
    const clip = clipXyz ? new THREE.Box3(
      new THREE.Vector3().fromArray(clipXyz.min),
      new THREE.Vector3().fromArray(clipXyz.max)
    ) : void 0;
    let fileType = input2.fileType;
    if (!fileType) {
      fileType = getSplatFileType(input2.fileBytes);
      if (!fileType && input2.pathOrUrl) {
        fileType = getSplatFileTypeFromPath(input2.pathOrUrl);
      }
    }
    switch (fileType) {
      case SplatFileType.PLY: {
        const ply = new PlyReader({ fileBytes: input2.fileBytes });
        await ply.parseHeader();
        let lastIndex = null;
        ply.parseSplats(
          (index, x, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {
            const center = transformPos2(new THREE.Vector3(x, y, z));
            if (withinClip(center) && withinOpacity(opacity)) {
              lastIndex = splats.pushSplat();
              splats.setCenter(lastIndex, center.x, center.y, center.z);
              const scales = transformScales(
                new THREE.Vector3(scaleX, scaleY, scaleZ)
              );
              splats.setScale(lastIndex, scales.x, scales.y, scales.z);
              const quaternion2 = transformQuaternion(
                new THREE.Quaternion(quatX, quatY, quatZ, quatW)
              );
              splats.setQuaternion(
                lastIndex,
                quaternion2.x,
                quaternion2.y,
                quaternion2.z,
                quaternion2.w
              );
              splats.setOpacity(lastIndex, opacity);
              splats.setColor(lastIndex, r, g, b);
            } else {
              lastIndex = null;
            }
          },
          (index, sh1, sh2, sh3) => {
            if (sh1 && lastIndex !== null) {
              splats.setSh1(lastIndex, sh1);
            }
            if (sh2 && lastIndex !== null) {
              splats.setSh2(lastIndex, sh2);
            }
            if (sh3 && lastIndex !== null) {
              splats.setSh3(lastIndex, sh3);
            }
          }
        );
        break;
      }
      case SplatFileType.SPZ: {
        const spz2 = new SpzReader({ fileBytes: input2.fileBytes });
        await spz2.parseHeader();
        const mapping = new Int32Array(spz2.numSplats);
        mapping.fill(-1);
        const centers = new Float32Array(spz2.numSplats * 3);
        const center = new THREE.Vector3();
        spz2.parseSplats(
          (index, x, y, z) => {
            const center2 = transformPos2(new THREE.Vector3(x, y, z));
            centers[index * 3] = center2.x;
            centers[index * 3 + 1] = center2.y;
            centers[index * 3 + 2] = center2.z;
          },
          (index, alpha) => {
            center.fromArray(centers, index * 3);
            if (withinClip(center) && withinOpacity(alpha)) {
              mapping[index] = splats.pushSplat();
              splats.setCenter(mapping[index], center.x, center.y, center.z);
              splats.setOpacity(mapping[index], alpha);
            }
          },
          (index, r, g, b) => {
            if (mapping[index] >= 0) {
              splats.setColor(mapping[index], r, g, b);
            }
          },
          (index, scaleX, scaleY, scaleZ) => {
            if (mapping[index] >= 0) {
              const scales = transformScales(
                new THREE.Vector3(scaleX, scaleY, scaleZ)
              );
              splats.setScale(mapping[index], scales.x, scales.y, scales.z);
            }
          },
          (index, quatX, quatY, quatZ, quatW) => {
            if (mapping[index] >= 0) {
              const quaternion2 = transformQuaternion(
                new THREE.Quaternion(quatX, quatY, quatZ, quatW)
              );
              splats.setQuaternion(
                mapping[index],
                quaternion2.x,
                quaternion2.y,
                quaternion2.z,
                quaternion2.w
              );
            }
          },
          (index, sh1, sh2, sh3) => {
            if (mapping[index] >= 0) {
              splats.setSh1(mapping[index], sh1);
              if (sh2) {
                splats.setSh2(mapping[index], sh2);
              }
              if (sh3) {
                splats.setSh3(mapping[index], sh3);
              }
            }
          }
        );
        break;
      }
      case SplatFileType.SPLAT:
        decodeAntiSplat(
          input2.fileBytes,
          (numSplats) => {
          },
          (index, x, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {
            const center = transformPos2(new THREE.Vector3(x, y, z));
            if (withinClip(center) && withinOpacity(opacity)) {
              const index2 = splats.pushSplat();
              splats.setCenter(index2, center.x, center.y, center.z);
              const scales = transformScales(
                new THREE.Vector3(scaleX, scaleY, scaleZ)
              );
              splats.setScale(index2, scales.x, scales.y, scales.z);
              const quaternion2 = transformQuaternion(
                new THREE.Quaternion(quatX, quatY, quatZ, quatW)
              );
              splats.setQuaternion(
                index2,
                quaternion2.x,
                quaternion2.y,
                quaternion2.z,
                quaternion2.w
              );
              splats.setOpacity(index2, opacity);
              splats.setColor(index2, r, g, b);
            }
          }
        );
        break;
      case SplatFileType.KSPLAT: {
        let lastIndex = null;
        decodeKsplat(
          input2.fileBytes,
          (numSplats) => {
          },
          (index, x, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {
            const center = transformPos2(new THREE.Vector3(x, y, z));
            if (withinClip(center) && withinOpacity(opacity)) {
              lastIndex = splats.pushSplat();
              splats.setCenter(lastIndex, center.x, center.y, center.z);
              const scales = transformScales(
                new THREE.Vector3(scaleX, scaleY, scaleZ)
              );
              splats.setScale(lastIndex, scales.x, scales.y, scales.z);
              const quaternion2 = transformQuaternion(
                new THREE.Quaternion(quatX, quatY, quatZ, quatW)
              );
              splats.setQuaternion(
                lastIndex,
                quaternion2.x,
                quaternion2.y,
                quaternion2.z,
                quaternion2.w
              );
              splats.setOpacity(lastIndex, opacity);
              splats.setColor(lastIndex, r, g, b);
            } else {
              lastIndex = null;
            }
          },
          (index, sh1, sh2, sh3) => {
            if (lastIndex !== null) {
              splats.setSh1(lastIndex, sh1);
              if (sh2) {
                splats.setSh2(lastIndex, sh2);
              }
              if (sh3) {
                splats.setSh3(lastIndex, sh3);
              }
            }
          }
        );
        break;
      }
      default:
        throw new Error(`transcodeSpz not implemented for ${fileType}`);
    }
  }
  const shDegree = Math.min(
    maxSh ?? 3,
    splats.sh3 ? 3 : splats.sh2 ? 2 : splats.sh1 ? 1 : 0
  );
  const spz = new SpzWriter({
    numSplats: splats.numSplats,
    shDegree,
    fractionalBits,
    flagAntiAlias: true
  });
  for (let i = 0; i < splats.numSplats; ++i) {
    const i3 = i * 3;
    const i4 = i * 4;
    spz.setCenter(
      i,
      splats.centers[i3],
      splats.centers[i3 + 1],
      splats.centers[i3 + 2]
    );
    spz.setScale(
      i,
      splats.scales[i3],
      splats.scales[i3 + 1],
      splats.scales[i3 + 2]
    );
    spz.setQuat(
      i,
      splats.quaternions[i4],
      splats.quaternions[i4 + 1],
      splats.quaternions[i4 + 2],
      splats.quaternions[i4 + 3]
    );
    spz.setAlpha(i, splats.opacities[i]);
    spz.setRgb(
      i,
      splats.colors[i3],
      splats.colors[i3 + 1],
      splats.colors[i3 + 2]
    );
    if (splats.sh1 && shDegree >= 1) {
      spz.setSh(
        i,
        splats.sh1.slice(i * 9, (i + 1) * 9),
        shDegree >= 2 && splats.sh2 ? splats.sh2.slice(i * 15, (i + 1) * 15) : void 0,
        shDegree >= 3 && splats.sh3 ? splats.sh3.slice(i * 21, (i + 1) * 21) : void 0
      );
    }
  }
  const spzBytes = await spz.finalize();
  return { fileBytes: spzBytes, clippedCount: spz.clippedCount };
}
class SplatSkinning {
  constructor(options) {
    this.mesh = options.mesh;
    this.numSplats = options.numSplats ?? this.mesh.numSplats;
    const { width, height, depth, maxSplats } = getTextureSize(this.numSplats);
    this.skinData = new Uint16Array(maxSplats * 4);
    this.skinTexture = new THREE.DataArrayTexture(
      this.skinData,
      width,
      height,
      depth
    );
    this.skinTexture.format = THREE.RGBAIntegerFormat;
    this.skinTexture.type = THREE.UnsignedShortType;
    this.skinTexture.internalFormat = "RGBA16UI";
    this.skinTexture.needsUpdate = true;
    this.numBones = options.numBones ?? 256;
    this.boneData = new Float32Array(this.numBones * 16);
    this.boneTexture = new THREE.DataTexture(
      this.boneData,
      4,
      this.numBones,
      THREE.RGBAFormat,
      THREE.FloatType
    );
    this.boneTexture.internalFormat = "RGBA32F";
    this.boneTexture.needsUpdate = true;
    this.uniform = new DynoUniform({
      key: "skinning",
      type: GsplatSkinning,
      globals: () => [defineGsplatSkinning],
      value: {
        numSplats: this.numSplats,
        numBones: this.numBones,
        skinTexture: this.skinTexture,
        boneTexture: this.boneTexture
      }
    });
  }
  // Apply the skeletal animation to a Gsplat in a dyno program.
  modify(gsplat) {
    return applyGsplatSkinning(gsplat, this.uniform);
  }
  // Set the "rest" pose for a bone with position and quaternion orientation.
  setRestQuatPos(boneIndex, quat, pos) {
    const i16 = boneIndex * 16;
    this.boneData[i16 + 0] = quat.x;
    this.boneData[i16 + 1] = quat.y;
    this.boneData[i16 + 2] = quat.z;
    this.boneData[i16 + 3] = quat.w;
    this.boneData[i16 + 4] = pos.x;
    this.boneData[i16 + 5] = pos.y;
    this.boneData[i16 + 6] = pos.z;
    this.boneData[i16 + 7] = 0;
    this.boneData[i16 + 8] = 0;
    this.boneData[i16 + 9] = 0;
    this.boneData[i16 + 10] = 0;
    this.boneData[i16 + 11] = 1;
    this.boneData[i16 + 12] = 0;
    this.boneData[i16 + 13] = 0;
    this.boneData[i16 + 14] = 0;
    this.boneData[i16 + 15] = 0;
  }
  // Set the "current" position and orientation of a bone.
  setBoneQuatPos(boneIndex, quat, pos) {
    const i16 = boneIndex * 16;
    const origQuat = new THREE.Quaternion(
      this.boneData[i16 + 0],
      this.boneData[i16 + 1],
      this.boneData[i16 + 2],
      this.boneData[i16 + 3]
    );
    const origPos = new THREE.Vector3(
      this.boneData[i16 + 4],
      this.boneData[i16 + 5],
      this.boneData[i16 + 6]
    );
    const relQuat = origQuat.clone().invert();
    const relPos = pos.clone().sub(origPos);
    relPos.applyQuaternion(relQuat);
    relQuat.multiply(quat);
    const dual = new THREE.Quaternion(
      relPos.x,
      relPos.y,
      relPos.z,
      0
    ).multiply(origQuat);
    this.boneData[i16 + 8] = relQuat.x;
    this.boneData[i16 + 9] = relQuat.y;
    this.boneData[i16 + 10] = relQuat.z;
    this.boneData[i16 + 11] = relQuat.w;
    this.boneData[i16 + 12] = 0.5 * dual.x;
    this.boneData[i16 + 13] = 0.5 * dual.y;
    this.boneData[i16 + 14] = 0.5 * dual.z;
    this.boneData[i16 + 15] = 0.5 * dual.w;
  }
  // Set up to 4 bone indices and weights for a Gsplat. For fewer than 4 bones,
  // you can set the remaining weights to 0 (and index=0).
  setSplatBones(splatIndex, boneIndices, weights) {
    const i4 = splatIndex * 4;
    this.skinData[i4 + 0] = Math.min(255, Math.max(0, Math.round(weights.x * 255))) + (boneIndices.x << 8);
    this.skinData[i4 + 1] = Math.min(255, Math.max(0, Math.round(weights.y * 255))) + (boneIndices.y << 8);
    this.skinData[i4 + 2] = Math.min(255, Math.max(0, Math.round(weights.z * 255))) + (boneIndices.z << 8);
    this.skinData[i4 + 3] = Math.min(255, Math.max(0, Math.round(weights.w * 255))) + (boneIndices.w << 8);
  }
  // Call this to indicate that the bones have changed and the Gsplats need to be
  // re-generated with updated skinning.
  updateBones() {
    this.boneTexture.needsUpdate = true;
    this.mesh.needsUpdate = true;
  }
}
const GsplatSkinning = { type: "GsplatSkinning" };
const defineGsplatSkinning = unindent(`
  struct GsplatSkinning {
    int numSplats;
    int numBones;
    usampler2DArray skinTexture;
    sampler2D boneTexture;
  };
`);
const defineApplyGsplatSkinning = unindent(`
  void applyGsplatSkinning(
    int numSplats, int numBones,
    usampler2DArray skinTexture, sampler2D boneTexture,
    int splatIndex, inout vec3 center, inout vec4 quaternion
  ) {
    if ((splatIndex < 0) || (splatIndex >= numSplats)) {
      return;
    }

    uvec4 skinData = texelFetch(skinTexture, splatTexCoord(splatIndex), 0);

    float weights[4];
    weights[0] = float(skinData.x & 0xffu) / 255.0;
    weights[1] = float(skinData.y & 0xffu) / 255.0;
    weights[2] = float(skinData.z & 0xffu) / 255.0;
    weights[3] = float(skinData.w & 0xffu) / 255.0;

    uint boneIndices[4];
    boneIndices[0] = (skinData.x >> 8u) & 0xffu;
    boneIndices[1] = (skinData.y >> 8u) & 0xffu;
    boneIndices[2] = (skinData.z >> 8u) & 0xffu;
    boneIndices[3] = (skinData.w >> 8u) & 0xffu;

    vec4 quat = vec4(0.0);
    vec4 dual = vec4(0.0);
    for (int i = 0; i < 4; i++) {
      if (weights[i] > 0.0) {
        int boneIndex = int(boneIndices[i]);
        vec4 boneQuat = vec4(0.0, 0.0, 0.0, 1.0);
        vec4 boneDual = vec4(0.0);
        if (boneIndex < numBones) {
          boneQuat = texelFetch(boneTexture, ivec2(2, boneIndex), 0);
          boneDual = texelFetch(boneTexture, ivec2(3, boneIndex), 0);
        }

        if ((i > 0) && (dot(quat, boneQuat) < 0.0)) {
          // Flip sign if next blend is pointing in the opposite direction
          boneQuat = -boneQuat;
          boneDual = -boneDual;
        }
        quat += weights[i] * boneQuat;
        dual += weights[i] * boneDual;
      }
    }

    // Normalize dual quaternion
    float norm = length(quat);
    quat /= norm;
    dual /= norm;
    vec3 translate = vec3(
      2.0 * (-dual.w * quat.x + dual.x * quat.w - dual.y * quat.z + dual.z * quat.y),
      2.0 * (-dual.w * quat.y + dual.x * quat.z + dual.y * quat.w - dual.z * quat.x),
      2.0 * (-dual.w * quat.z - dual.x * quat.y + dual.y * quat.x + dual.z * quat.w)
    );

    center = quatVec(quat, center) + translate;
    quaternion = quatQuat(quat, quaternion);
  }
`);
function applyGsplatSkinning(gsplat, skinning) {
  const dyno2 = new Dyno({
    inTypes: { gsplat: Gsplat, skinning: GsplatSkinning },
    outTypes: { gsplat: Gsplat },
    globals: () => [defineGsplatSkinning, defineApplyGsplatSkinning],
    inputs: { gsplat, skinning },
    statements: ({ inputs, outputs }) => {
      const { skinning: skinning2 } = inputs;
      const { gsplat: gsplat2 } = outputs;
      return unindentLines(`
        ${gsplat2} = ${inputs.gsplat};
        if (isGsplatActive(${gsplat2}.flags)) {
          applyGsplatSkinning(
            ${skinning2}.numSplats, ${skinning2}.numBones,
            ${skinning2}.skinTexture, ${skinning2}.boneTexture,
            ${gsplat2}.index, ${gsplat2}.center, ${gsplat2}.quaternion
          );
        }
      `);
    }
  });
  return dyno2.outputs.gsplat;
}
function constructGrid({
  // PackedSplats object to add splats to
  splats,
  // min and max box extents of the grid
  extents,
  // step size along each grid axis
  stepSize = 1,
  // spherical radius of each Gsplat
  pointRadius = 0.01,
  // relative size of the "shadow copy" of each Gsplat placed behind it
  pointShadowScale = 2,
  // Gsplat opacity
  opacity = 1,
  // Gsplat color (THREE.Color) or function to set color for position:
  // ((THREE.Color, THREE.Vector3) => void) (default: RGB-modulated grid)
  color
}) {
  const EPSILON = 1e-6;
  const center = new THREE.Vector3();
  const scales = new THREE.Vector3();
  const quaternion = new THREE.Quaternion(0, 0, 0, 1);
  if (color == null) {
    color = (color2, point) => color2.set(
      0.55 + 0.45 * Math.cos(point.x * 1),
      0.55 + 0.45 * Math.cos(point.y * 1),
      0.55 + 0.45 * Math.cos(point.z * 1)
    );
  }
  const pointColor = new THREE.Color();
  for (let z = extents.min.z; z < extents.max.z + EPSILON; z += stepSize) {
    for (let y = extents.min.y; y < extents.max.y + EPSILON; y += stepSize) {
      for (let x = extents.min.x; x < extents.max.x + EPSILON; x += stepSize) {
        center.set(x, y, z);
        for (let layer = 0; layer < 2; ++layer) {
          scales.setScalar(pointRadius * (layer ? 1 : pointShadowScale));
          if (!layer) {
            pointColor.setScalar(0);
          } else if (typeof color === "function") {
            color(pointColor, center);
          } else {
            pointColor.copy(color);
          }
          splats.pushSplat(center, scales, quaternion, opacity, pointColor);
        }
      }
    }
  }
}
function constructAxes({
  // PackedSplats object to add splats to
  splats,
  // scale (Gsplat scale along axis)
  scale = 0.25,
  // radius of the axes (Gsplat scale orthogonal to axis)
  axisRadius = 75e-4,
  // relative size of the "shadow copy" of each Gsplat placed behind it
  axisShadowScale = 2,
  // origins of the axes (default single axis at origin)
  origins = [new THREE.Vector3()]
}) {
  const center = new THREE.Vector3();
  const scales = new THREE.Vector3();
  const quaternion = new THREE.Quaternion(0, 0, 0, 1);
  const color = new THREE.Color();
  const opacity = 1;
  for (const origin of origins) {
    for (let axis = 0; axis < 3; ++axis) {
      center.set(
        origin.x + (axis === 0 ? scale : 0),
        origin.y + (axis === 1 ? scale : 0),
        origin.z + (axis === 2 ? scale : 0)
      );
      for (let layer = 0; layer < 2; ++layer) {
        scales.set(
          (axis === 0 ? scale : axisRadius) * (layer ? 1 : axisShadowScale),
          (axis === 1 ? scale : axisRadius) * (layer ? 1 : axisShadowScale),
          (axis === 2 ? scale : axisRadius) * (layer ? 1 : axisShadowScale)
        );
        color.setRGB(
          layer === 0 ? 0 : axis === 0 ? 1 : 0,
          layer === 0 ? 0 : axis === 1 ? 1 : 0,
          layer === 0 ? 0 : axis === 2 ? 1 : 0
        );
        splats.pushSplat(center, scales, quaternion, opacity, color);
      }
    }
  }
}
function constructSpherePoints({
  // PackedSplats object to add splats to
  splats,
  // center of the sphere (default: origin)
  origin = new THREE.Vector3(),
  // radius of the sphere
  radius = 1,
  // maximum depth of recursion for subdividing the sphere
  // Warning: Gsplat count grows exponentially with depth
  maxDepth = 3,
  // filter function to apply to each point, for example to select
  // points in a certain direction or other function ((THREE.Vector3) => boolean)
  // (default: null)
  filter = null,
  // radius of each oriented Gsplat
  pointRadius = 0.02,
  // flatness of each oriented Gsplat
  pointThickness = 1e-3,
  // color of each Gsplat (THREE.Color) or function to set color for point:
  // ((THREE.Color, THREE.Vector3) => void) (default: white)
  color = new THREE.Color(1, 1, 1)
}) {
  const pointsHash = {};
  function addPoint(p) {
    if (filter && !filter(p)) {
      return;
    }
    const key = `${p.x},${p.y},${p.z}`;
    if (!pointsHash[key]) {
      pointsHash[key] = p;
    }
  }
  function recurse(depth, p0, p1, p2) {
    addPoint(p0);
    addPoint(p1);
    addPoint(p2);
    if (depth >= maxDepth) {
      return;
    }
    const p01 = new THREE.Vector3().addVectors(p0, p1).normalize();
    const p12 = new THREE.Vector3().addVectors(p1, p2).normalize();
    const p20 = new THREE.Vector3().addVectors(p2, p0).normalize();
    recurse(depth + 1, p0, p01, p20);
    recurse(depth + 1, p01, p1, p12);
    recurse(depth + 1, p20, p12, p2);
    recurse(depth + 1, p01, p12, p20);
  }
  for (const x of [-1, 1]) {
    for (const y of [-1, 1]) {
      for (const z of [-1, 1]) {
        const p0 = new THREE.Vector3(x, 0, 0);
        const p1 = new THREE.Vector3(0, y, 0);
        const p2 = new THREE.Vector3(0, 0, z);
        recurse(0, p0, p1, p2);
      }
    }
  }
  const points = Object.values(pointsHash);
  const scales = new THREE.Vector3(pointRadius, pointRadius, pointThickness);
  const quaternion = new THREE.Quaternion();
  const pointColor = typeof color === "function" ? new THREE.Color() : color;
  for (const point of points) {
    quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, -1), point);
    if (typeof color === "function") {
      color(pointColor, point);
    }
    point.multiplyScalar(radius);
    point.add(origin);
    splats.pushSplat(point, scales, quaternion, 1, pointColor);
  }
}
function textSplats({
  // text string to display
  text,
  // browser font to render text with (default: "Arial")
  font,
  // font size in pixels/Gsplats (default: 32)
  fontSize,
  // SplatMesh.recolor tint assuming white Gsplats (default: white)
  color,
  // Individual Gsplat color (default: white)
  rgb,
  // Gsplat radius (default: 0.8 covers 1-unit spacing well)
  dotRadius,
  // text alignment: "left", "center", "right", "start", "end" (default: "start")
  textAlign,
  // line spacing multiplier, lines delimited by "\n" (default: 1.0)
  lineHeight,
  // Coordinate scale in object-space (default: 1.0)
  objectScale
}) {
  font = font ?? "Arial";
  fontSize = fontSize ?? 32;
  color = color ?? new THREE.Color(1, 1, 1);
  dotRadius = dotRadius ?? 0.8;
  textAlign = textAlign ?? "start";
  lineHeight = lineHeight ?? 1;
  objectScale = objectScale ?? 1;
  const lines = text.split("\n");
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    throw new Error("Failed to create canvas context");
  }
  ctx.font = `${fontSize}px ${font}`;
  ctx.textAlign = textAlign;
  const metrics = ctx.measureText("");
  const fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;
  let minLeft = Number.POSITIVE_INFINITY;
  let maxRight = Number.NEGATIVE_INFINITY;
  let minTop = Number.POSITIVE_INFINITY;
  let maxBottom = Number.NEGATIVE_INFINITY;
  for (let line = 0; line < lines.length; ++line) {
    const metrics2 = ctx.measureText(lines[line]);
    const y = fontHeight * lineHeight * line;
    minLeft = Math.min(minLeft, -metrics2.actualBoundingBoxLeft);
    maxRight = Math.max(maxRight, metrics2.actualBoundingBoxRight);
    minTop = Math.min(minTop, y - metrics2.actualBoundingBoxAscent);
    maxBottom = Math.max(maxBottom, y + metrics2.actualBoundingBoxDescent);
  }
  const originLeft = Math.floor(minLeft);
  const originTop = Math.floor(minTop);
  const width = Math.ceil(maxRight) - originLeft;
  const height = Math.ceil(maxBottom) - originTop;
  canvas.width = width;
  canvas.height = height;
  ctx.font = `${fontSize}px ${font}`;
  ctx.textAlign = textAlign;
  ctx.textBaseline = "alphabetic";
  ctx.fillStyle = "#FFFFFF";
  for (let i = 0; i < lines.length; ++i) {
    const y = fontHeight * lineHeight * i - originTop;
    ctx.fillText(lines[i], -originLeft, y);
  }
  const imageData = ctx.getImageData(0, 0, width, height);
  const rgba = new Uint8Array(imageData.data.buffer);
  const splats = new PackedSplats();
  const center = new THREE.Vector3();
  const scales = new THREE.Vector3().setScalar(dotRadius * objectScale);
  const quaternion = new THREE.Quaternion(0, 0, 0, 1);
  rgb = rgb ?? new THREE.Color(1, 1, 1);
  let offset = 0;
  for (let y = 0; y < height; ++y) {
    for (let x = 0; x < width; ++x) {
      const a = rgba[offset + 3];
      if (a > 0) {
        const opacity = a / 255;
        center.set(x - 0.5 * (width - 1), 0.5 * (height - 1) - y, 0);
        center.multiplyScalar(objectScale);
        splats.pushSplat(center, scales, quaternion, opacity, rgb);
      }
      offset += 4;
    }
  }
  const mesh = new SplatMesh({ packedSplats: splats });
  mesh.recolor = color;
  return mesh;
}
function imageSplats({
  // URL of the image to convert to splats (example: `url: "./image.png"`)
  url,
  // Radius of each Gsplat, default covers 1-unit spacing well (default: 0.8)
  dotRadius,
  // Subsampling factor for the image. Higher values reduce resolution,
  // for example 2 will halve the width and height by averaging (default: 1)
  subXY,
  // Optional callback function to modify each Gsplat before it's added.
  // Return null to skip adding the Gsplat, or a number to set the opacity
  // and add the Gsplat with parameter values in the objects center, rgba etc. were
  // passed into the forEachSplat callback. Ending the callback in `return opacity;`
  // will retain the original opacity.
  // ((width: number, height: number, index: number, center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion, opacity: number, color: THREE.Color) => number | null)
  forEachSplat
}) {
  dotRadius = dotRadius ?? 0.8;
  subXY = Math.max(1, Math.floor(subXY ?? 1));
  return new SplatMesh({
    constructSplats: async (splats) => {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onerror = reject;
        img.onload = () => {
          const { width, height } = img;
          const canvas = document.createElement("canvas");
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext("2d");
          if (!ctx) {
            reject(new Error("Failed to create canvas context"));
            return;
          }
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = "high";
          const destWidth = Math.round(width / subXY);
          const destHeight = Math.round(height / subXY);
          ctx.drawImage(img, 0, 0, destWidth, destHeight);
          try {
            const imageData = ctx.getImageData(0, 0, destWidth, destHeight);
            const rgba = new Uint8Array(imageData.data.buffer);
            const center = new THREE.Vector3();
            const scales = new THREE.Vector3().setScalar(dotRadius);
            const quaternion = new THREE.Quaternion(0, 0, 0, 1);
            const rgb = new THREE.Color();
            let index = 0;
            for (let y = 0; y < destHeight; ++y) {
              for (let x = 0; x < destWidth; ++x) {
                const offset = index * 4;
                const a = rgba[offset + 3];
                if (a > 0) {
                  let opacity = a / 255;
                  rgb.set(
                    rgba[offset + 0] / 255,
                    rgba[offset + 1] / 255,
                    rgba[offset + 2] / 255
                  );
                  center.set(
                    x - 0.5 * (destWidth - 1),
                    0.5 * (destHeight - 1) - y,
                    0
                  );
                  scales.setScalar(dotRadius);
                  quaternion.set(0, 0, 0, 1);
                  let push = true;
                  if (forEachSplat) {
                    const maybeOpacity = forEachSplat(
                      destWidth,
                      destHeight,
                      index,
                      center,
                      scales,
                      quaternion,
                      opacity,
                      rgb
                    );
                    opacity = maybeOpacity ?? opacity;
                    push = maybeOpacity !== null;
                  }
                  if (push) {
                    splats.pushSplat(center, scales, quaternion, opacity, rgb);
                  }
                }
                index += 1;
              }
            }
            resolve();
          } catch (error) {
            reject(error);
          }
        };
        img.src = url;
      });
    }
  });
}
function staticBox({
  box,
  cells,
  dotScale,
  color,
  opacity
}) {
  cells.x = Math.max(1, Math.round(cells.x));
  cells.y = Math.max(1, Math.round(cells.y));
  cells.z = Math.max(1, Math.round(cells.z));
  opacity = opacity ?? 1;
  const numSplats = cells.x * cells.y * cells.z;
  const dynoX = dynoConst("int", cells.x);
  const dynoY = dynoConst("int", cells.y);
  dynoConst("int", cells.z);
  const dynoTime = dynoFloat(0);
  const generator = new SplatGenerator({
    numSplats,
    generator: dynoBlock(
      { index: "int" },
      { gsplat: Gsplat },
      ({ index }) => {
        if (!index) {
          throw new Error("index is undefined");
        }
        const cellX = imod(index, dynoX);
        const index2 = div(index, dynoX);
        const cellY = imod(index2, dynoY);
        const cellZ = div(index2, dynoY);
        const cell = combine({
          vectorType: "ivec3",
          x: cellX,
          y: cellY,
          z: cellZ
        });
        const intTime = floatBitsToInt(dynoTime);
        const inputs = combine({ vectorType: "ivec2", x: index, y: intTime });
        const random = hashVec3(inputs);
        const min2 = dynoConst("vec3", box.min);
        const max2 = dynoConst("vec3", box.max);
        const size = sub(max2, min2);
        const coord = div(add(vec3(cell), random), dynoConst("vec3", cells));
        let r;
        let g;
        let b;
        if (color) {
          r = dynoConst("float", color.r);
          g = dynoConst("float", color.g);
          b = dynoConst("float", color.b);
        } else {
          ({ r, g, b } = split(coord).outputs);
        }
        const rgba = combine({
          vectorType: "vec4",
          r,
          g,
          b,
          a: dynoConst("float", opacity)
        });
        const center = add(min2, mul(size, coord));
        const scales = vec3(dynoConst("float", dotScale));
        const quaternion = dynoConst("vec4", new THREE.Quaternion(0, 0, 0, 1));
        let gsplat = combineGsplat({
          flags: dynoLiteral("uint", "GSPLAT_FLAG_ACTIVE"),
          index,
          center,
          scales,
          quaternion,
          rgba
        });
        gsplat = transformer.applyGsplat(gsplat);
        return { gsplat };
      },
      {
        globals: () => [defineGsplat]
      }
    ),
    update: ({ time }) => {
      dynoTime.value = time;
      transformer.update(generator);
      generator.updateVersion();
    }
  });
  const transformer = new SplatTransformer();
  return generator;
}
const DEFAULT_SNOW = {
  box: new THREE.Box3(
    new THREE.Vector3(-1, -1, -1),
    new THREE.Vector3(1, 1, 1)
  ),
  density: 100,
  fallDirection: new THREE.Vector3(-1, -3, 1).normalize(),
  fallVelocity: 0.02,
  wanderScale: 0.04,
  wanderVariance: 2,
  color1: new THREE.Color(1, 1, 1),
  color2: new THREE.Color(0.5, 0.5, 1),
  minScale: 1e-3,
  maxScale: 5e-3,
  anisoScale: new THREE.Vector3(1, 1, 1)
};
const DEFAULT_RAIN = {
  box: new THREE.Box3(
    new THREE.Vector3(-2, -1, -2),
    new THREE.Vector3(2, 5, 2)
  ),
  density: 10,
  fallDirection: new THREE.Vector3(0, -1, 0),
  fallVelocity: 2,
  wanderScale: 0.1,
  wanderVariance: 1,
  color1: new THREE.Color(1, 1, 1),
  color2: new THREE.Color(0.25, 0.25, 0.5),
  minScale: 5e-3,
  maxScale: 0.01,
  anisoScale: new THREE.Vector3(0.1, 1, 0.1)
};
function snowBox({
  // min and max box extents of the snowBox
  box,
  // minimum y-coordinate to clamp particle position, which can be used to
  // fake hitting a ground plane and lingering there for a bit
  minY,
  // number of Gsplats to generate (default: calculated from box and density)
  numSplats,
  // density of Gsplats per unit volume (default: 100)
  density,
  // The xyz anisotropic scale of the Gsplat, which can be used for example
  // to elongate rain particles (default: (1, 1, 1))
  anisoScale,
  // Minimum Gsplat particle scale (default: 0.001)
  minScale,
  // Maximum Gsplat particle scale (default: 0.005)
  maxScale,
  // The average direction of fall (default: (0, -1, 0))
  fallDirection,
  // The average speed of the fall (multiplied with fallDirection) (default: 0.02)
  fallVelocity,
  // The world scale of wandering overlay motion (default: 0.01)
  wanderScale,
  // Controls how uniformly the particles wander in sync, more variance mean
  // more randomness in the motion (default: 2)
  wanderVariance,
  // Color 1 of the two colors interpolated between (default: (1, 1, 1))
  color1,
  // Color 2 of the two colors interpolated between (default: (0.5, 0.5, 1))
  color2,
  // The base opacity of the Gsplats (default: 1)
  opacity,
  // Optional callback function to call each frame.
  onFrame
}) {
  box = box ?? new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1));
  const volume = (box.max.x - box.min.x) * (box.max.y - box.min.y) * (box.max.z - box.min.z);
  density = density ?? 100;
  numSplats = numSplats ?? Math.max(1, Math.min(1e6, Math.round(volume * density)));
  const dynoMinScale = dynoFloat(minScale ?? 1e-3);
  const dynoMaxScale = dynoFloat(maxScale ?? 5e-3);
  const dynoAnisoScale = dynoVec3(
    ((anisoScale == null ? void 0 : anisoScale.clone()) ?? new THREE.Vector3(1, 1, 1)).normalize()
  );
  const dynoFallDirection = dynoVec3(
    (fallDirection ?? new THREE.Vector3(0, -1, 0)).normalize()
  );
  const dynoFallVelocity = dynoFloat(fallVelocity ?? 0.02);
  const dynoWanderScale = dynoFloat(wanderScale ?? 0.01);
  const dynoWanderVariance = dynoFloat(wanderVariance ?? 2);
  const dynoColor1 = dynoVec3(color1 ?? new THREE.Color(1, 1, 1));
  const dynoColor2 = dynoVec3(color2 ?? new THREE.Color(0.5, 0.5, 1));
  const dynoOpacity = dynoFloat(opacity ?? 1);
  const dynoTime = dynoFloat(0);
  const globalOffset = dynoVec3(new THREE.Vector3(0, 0, 0));
  const dynoMin = dynoVec3(box.min);
  const dynoMax = dynoVec3(box.max);
  const dynoMinY = dynoFloat(minY ?? Number.NEGATIVE_INFINITY);
  const minMax = sub(dynoMax, dynoMin);
  const snow = new SplatGenerator({
    numSplats,
    generator: dynoBlock(
      { index: "int" },
      { gsplat: Gsplat },
      ({ index }) => {
        if (!index) {
          throw new Error("index not defined");
        }
        const random = hashVec4(index);
        const randomW = split(random).outputs.w;
        let position = vec3(random);
        let size = fract(mul(randomW, dynoConst("float", 100)));
        size = sin(mul(dynoLiteral("float", "PI"), size));
        size = add(dynoMinScale, mul(size, sub(dynoMaxScale, dynoMinScale)));
        const scales = mul(size, dynoAnisoScale);
        const intensity = fract(mul(randomW, dynoConst("float", 10)));
        const hue = fract(randomW);
        const color = mix(dynoColor1, dynoColor2, hue);
        const rgb = mul(color, intensity);
        const random2 = hashVec4(
          combine({
            vectorType: "ivec2",
            x: index,
            y: dynoConst("int", 6837)
          })
        );
        let perturb = vec3(random2);
        let timeOffset = mul(split(random2).outputs.w, dynoWanderVariance);
        timeOffset = add(dynoTime, timeOffset);
        position = add(position, globalOffset);
        const modulo = mod(
          position,
          dynoConst("vec3", new THREE.Vector3(1, 1, 1))
        );
        position = add(dynoMin, mul(minMax, modulo));
        const quaternion = dynoConst("vec4", new THREE.Quaternion(0, 0, 0, 1));
        perturb = sin(add(vec3(timeOffset), perturb));
        perturb = mul(perturb, dynoWanderScale);
        let center = add(position, perturb);
        let centerY = split(center).outputs.y;
        centerY = max(dynoMinY, centerY);
        center = combine({ vector: center, y: centerY });
        let gsplat = combineGsplat({
          flags: dynoLiteral("uint", "GSPLAT_FLAG_ACTIVE"),
          index,
          center,
          scales,
          quaternion,
          rgb,
          opacity: dynoOpacity
        });
        gsplat = transformer.applyGsplat(gsplat);
        return { gsplat };
      },
      {
        globals: () => [defineGsplat]
      }
    ),
    update: ({ object, time, deltaTime }) => {
      dynoTime.value = time;
      transformer.update(snow);
      const fallDelta = dynoFallDirection.value.clone().multiplyScalar(dynoFallVelocity.value * deltaTime);
      globalOffset.value.add(fallDelta);
      object.visible = dynoOpacity.value > 0;
      onFrame == null ? void 0 : onFrame({ object, time, deltaTime });
      snow.updateVersion();
    }
  });
  const transformer = new SplatTransformer();
  return {
    snow,
    min: dynoMin,
    max: dynoMax,
    minY: dynoMinY,
    color1: dynoColor1,
    color2: dynoColor2,
    opacity: dynoOpacity,
    fallVelocity: dynoFallVelocity,
    wanderVariance: dynoWanderVariance,
    wanderScale: dynoWanderScale,
    fallDirection: dynoFallDirection,
    minScale: dynoMinScale,
    maxScale: dynoMaxScale,
    anisoScale: dynoAnisoScale
  };
}
const generators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DEFAULT_RAIN,
  DEFAULT_SNOW,
  snowBox,
  staticBox
}, Symbol.toStringTag, { value: "Module" }));
function makeNormalColorModifier(splatToView) {
  return dynoBlock({ gsplat: Gsplat }, { gsplat: Gsplat }, ({ gsplat }) => {
    if (!gsplat) {
      throw new Error("No gsplat input");
    }
    let normal = gsplatNormal(gsplat);
    const viewGsplat = splatToView.applyGsplat(gsplat);
    const viewCenter = splitGsplat(viewGsplat).outputs.center;
    const viewNormal = gsplatNormal(viewGsplat);
    const splatDot = dot(viewCenter, viewNormal);
    const sameDir = greaterThanEqual(splatDot, dynoConst("float", 0));
    normal = select(sameDir, neg(normal), normal);
    const rgb = add(
      mul(normal, dynoConst("float", 0.5)),
      dynoConst("float", 0.5)
    );
    gsplat = combineGsplat({ gsplat, rgb });
    return { gsplat };
  });
}
function setWorldNormalColor(splats) {
  splats.enableWorldToView = true;
  splats.worldModifier = makeNormalColorModifier(splats.context.worldToView);
  splats.updateGenerator();
}
function makeDepthColorModifier(splatToView, minDepth, maxDepth, reverse) {
  return dynoBlock({ gsplat: Gsplat }, { gsplat: Gsplat }, ({ gsplat }) => {
    if (!gsplat) {
      throw new Error("No gsplat input");
    }
    let { center } = splitGsplat(gsplat).outputs;
    center = splatToView.apply(center);
    const { z } = split(center).outputs;
    let depth = normalizedDepth(neg(z), minDepth, maxDepth);
    depth = select(reverse, sub(dynoConst("float", 1), depth), depth);
    gsplat = combineGsplat({ gsplat, r: depth, g: depth, b: depth });
    return { gsplat };
  });
}
function setDepthColor(splats, minDepth, maxDepth, reverse) {
  splats.enableWorldToView = true;
  const dynoMinDepth = dynoConst("float", minDepth);
  const dynoMaxDepth = dynoConst("float", maxDepth);
  const dynoReverse = dynoConst("bool", reverse ?? false);
  splats.worldModifier = makeDepthColorModifier(
    splats.context.worldToView,
    dynoMinDepth,
    dynoMaxDepth,
    dynoReverse
  );
  splats.updateGenerator();
  return {
    minDepth: dynoMinDepth,
    maxDepth: dynoMaxDepth,
    reverse: dynoReverse
  };
}
const modifiers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  makeDepthColorModifier,
  makeNormalColorModifier,
  setDepthColor,
  setWorldNormalColor
}, Symbol.toStringTag, { value: "Module" }));
const _VRButton = class _VRButton {
  static createButton(renderer, sessionInit = {}) {
    const navigatorXr = navigator.xr;
    if (!navigatorXr) {
      return null;
    }
    const xr = navigatorXr;
    const button = document.createElement("button");
    renderer.xr.enabled = true;
    renderer.xr.setReferenceSpaceType("local");
    function showEnterVR() {
      let currentSession = null;
      async function onSessionStarted(session) {
        console.log("onSessionStarted");
        session.addEventListener("end", onSessionEnded);
        await renderer.xr.setSession(session);
        button.textContent = "EXIT VR";
        currentSession = session;
      }
      function onSessionEnded() {
        console.log("onSessionEnded");
        currentSession == null ? void 0 : currentSession.removeEventListener("end", onSessionEnded);
        button.textContent = "ENTER VR";
        currentSession = null;
      }
      button.style.display = "";
      button.style.cursor = "pointer";
      button.style.left = "calc(50% - 100px)";
      button.style.width = "200px";
      button.style.height = "100px";
      button.textContent = "ENTER VR";
      const sessionOptions = {
        ...sessionInit,
        optionalFeatures: [
          // "local-floor",
          // "bounded-floor",
          // "layers",
          ...sessionInit.optionalFeatures || []
        ]
      };
      button.onmouseenter = () => {
        button.style.opacity = "1.0";
      };
      button.onmouseleave = () => {
        button.style.opacity = "0.5";
      };
      button.onclick = () => {
        if (currentSession === null) {
          console.log("requesting session");
          xr.requestSession("immersive-vr", sessionOptions).then(
            onSessionStarted
          );
        } else {
          console.log("ending session");
          currentSession.end();
        }
      };
    }
    function disableButton() {
      button.style.display = "none";
      button.style.cursor = "auto";
      button.style.left = "calc(50% - 75px)";
      button.style.width = "150px";
      button.onmouseenter = null;
      button.onmouseleave = null;
      button.onclick = null;
    }
    function showWebXRNotFound() {
      disableButton();
      button.textContent = "VR NOT SUPPORTED";
    }
    function showVRNotAllowed(exception) {
      disableButton();
      console.warn(
        "Exception when trying to call xr.isSessionSupported",
        exception
      );
      button.textContent = "VR NOT ALLOWED";
    }
    function stylizeElement(element) {
      element.style.position = "absolute";
      element.style.bottom = "20px";
      element.style.padding = "12px 6px";
      element.style.border = "1px solid #fff";
      element.style.borderRadius = "4px";
      element.style.background = "rgba(0,0,0,0.1)";
      element.style.color = "#fff";
      element.style.font = "normal 13px sans-serif";
      element.style.textAlign = "center";
      element.style.opacity = "0.5";
      element.style.outline = "none";
      element.style.zIndex = "999";
    }
    button.id = "VRButton";
    button.style.display = "none";
    stylizeElement(button);
    xr.isSessionSupported("immersive-vr").then((supported) => {
      supported ? showEnterVR() : showWebXRNotFound();
      if (supported && _VRButton.xrSessionIsGranted) {
        button.click();
      }
    }).catch(showVRNotAllowed);
    return button;
  }
  static registerSessionGrantedListener() {
    const navigatorXr = navigator.xr;
    if (!navigatorXr) {
      return null;
    }
    const xr = navigatorXr;
    if (/WebXRViewer\//i.test(navigator.userAgent)) return;
    xr.addEventListener("sessiongranted", () => {
      _VRButton.xrSessionIsGranted = true;
    });
  }
};
_VRButton.xrSessionIsGranted = false;
let VRButton = _VRButton;
VRButton.registerSessionGrantedListener();
const DEFAULT_MOVE_INERTIA$1 = 0.5;
const DEFAULT_ROTATE_INERTIA$1 = 0.5;
const TOUCH_BIAS = 0;
var JointEnum = /* @__PURE__ */ ((JointEnum2) => {
  JointEnum2["w"] = "wrist";
  JointEnum2["t0"] = "thumb-metacarpal";
  JointEnum2["t1"] = "thumb-phalanx-proximal";
  JointEnum2["t2"] = "thumb-phalanx-distal";
  JointEnum2["t3"] = "thumb-tip";
  JointEnum2["i0"] = "index-finger-metacarpal";
  JointEnum2["i1"] = "index-finger-phalanx-proximal";
  JointEnum2["i2"] = "index-finger-phalanx-intermediate";
  JointEnum2["i3"] = "index-finger-phalanx-distal";
  JointEnum2["i4"] = "index-finger-tip";
  JointEnum2["m0"] = "middle-finger-metacarpal";
  JointEnum2["m1"] = "middle-finger-phalanx-proximal";
  JointEnum2["m2"] = "middle-finger-phalanx-intermediate";
  JointEnum2["m3"] = "middle-finger-phalanx-distal";
  JointEnum2["m4"] = "middle-finger-tip";
  JointEnum2["r0"] = "ring-finger-metacarpal";
  JointEnum2["r1"] = "ring-finger-phalanx-proximal";
  JointEnum2["r2"] = "ring-finger-phalanx-intermediate";
  JointEnum2["r3"] = "ring-finger-phalanx-distal";
  JointEnum2["r4"] = "ring-finger-tip";
  JointEnum2["p0"] = "pinky-finger-metacarpal";
  JointEnum2["p1"] = "pinky-finger-phalanx-proximal";
  JointEnum2["p2"] = "pinky-finger-phalanx-intermediate";
  JointEnum2["p3"] = "pinky-finger-phalanx-distal";
  JointEnum2["p4"] = "pinky-finger-tip";
  return JointEnum2;
})(JointEnum || {});
const JOINT_IDS = Object.keys(JointEnum);
const NUM_JOINTS = JOINT_IDS.length;
const JOINT_INDEX = {
  w: 0,
  t0: 1,
  t1: 2,
  t2: 3,
  t3: 4,
  i0: 5,
  i1: 6,
  i2: 7,
  i3: 8,
  i4: 9,
  m0: 10,
  m1: 11,
  m2: 12,
  m3: 13,
  m4: 14,
  r0: 15,
  r1: 16,
  r2: 17,
  r3: 18,
  r4: 19,
  p0: 20,
  p1: 21,
  p2: 22,
  p3: 23,
  p4: 24
};
const JOINT_RADIUS = {
  w: 0.02,
  t0: 0.02,
  t1: 0.014,
  t2: 0.0115,
  t3: 85e-4,
  i0: 0.022,
  i1: 0.012,
  i2: 85e-4,
  i3: 75e-4,
  i4: 65e-4,
  m0: 0.021,
  m1: 0.012,
  m2: 8e-3,
  m3: 75e-4,
  m4: 65e-4,
  r0: 0.019,
  r1: 0.011,
  r2: 75e-4,
  r3: 7e-3,
  r4: 6e-3,
  p0: 0.012,
  p1: 0.01,
  p2: 7e-3,
  p3: 65e-4,
  p4: 55e-4
};
const JOINT_SEGMENTS = [
  ["w", "t0", "t1", "t2", "t3"],
  ["w", "i0", "i1", "i2", "i3", "i4"],
  ["w", "m0", "m1", "m2", "m3", "m4"],
  ["w", "r0", "r1", "r2", "r3", "r4"],
  ["w", "p0", "p1", "p2", "p3", "p4"]
];
const JOINT_SEGMENT_STEPS = [
  [8, 10, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6]
];
const JOINT_TIPS = ["t3", "i4", "m4", "r4", "p4"];
const FINGER_TIPS = ["i4", "m4", "r4", "p4"];
var Hand = /* @__PURE__ */ ((Hand2) => {
  Hand2["left"] = "left";
  Hand2["right"] = "right";
  return Hand2;
})(Hand || {});
const HANDS = Object.keys(Hand);
class XrHands {
  constructor() {
    this.hands = {};
    this.last = {};
    this.values = {};
    this.tests = {};
    this.lastTests = {};
    this.updated = false;
  }
  update({ xr, xrFrame }) {
    const xrSession = xr.getSession();
    if (!xrSession) {
      return;
    }
    const referenceSpace = xr.getReferenceSpace();
    if (!referenceSpace) {
      return;
    }
    if (!xrFrame.getJointPose) {
      return;
    }
    this.last = this.hands;
    this.lastTests = this.tests;
    this.hands = {};
    this.values = {};
    this.tests = {};
    for (const inputSource of xrSession.inputSources) {
      if (!inputSource.hand) {
        continue;
      }
      const hand = inputSource.handedness;
      this.hands[hand] = {};
      for (const jointId of JOINT_IDS) {
        const jointSpace = inputSource.hand.get(JointEnum[jointId]);
        if (jointSpace) {
          const jointPose = xrFrame.getJointPose(jointSpace, referenceSpace);
          if (jointPose) {
            const { position, orientation } = jointPose.transform;
            this.hands[hand][jointId] = {
              position: new Vector3(position.x, position.y, position.z),
              quaternion: new Quaternion(
                orientation.x,
                orientation.y,
                orientation.z,
                orientation.w
              ),
              radius: jointPose.radius || 1e-3
            };
          }
        }
      }
    }
    for (const hand of HANDS) {
      for (const { key, value } of [
        { key: `${hand}AllTips`, value: this.allTipsTouching(hand) },
        {
          key: `${hand}IndexThumb`,
          value: this.touching(hand, "i4", hand, "t3")
        },
        {
          key: `${hand}MiddleThumb`,
          value: this.touching(hand, "m4", hand, "t3")
        },
        {
          key: `${hand}RingThumb`,
          value: this.touching(hand, "r4", hand, "t3")
        },
        {
          key: `${hand}PinkyThumb`,
          value: this.touching(hand, "p4", hand, "t3")
        },
        { key: `${hand}TriTips`, value: this.triTipsTouching(hand) }
      ]) {
        this.values[key] = value;
        this.tests[key] = value === 1 ? true : value === 0 ? false : this.lastTests[key] ?? false;
      }
    }
  }
  makeGhostMesh() {
    const center = new Vector3();
    const scales = new Vector3(0.01, 0.01, 0.01);
    const quaternion = new Quaternion(0, 0, 0, 1);
    const color = new Color(1, 1, 1);
    const CYCLE = Math.PI * 3;
    new Color(1, 1, 1);
    let opacity = 1;
    const mesh = new SplatMesh({
      onFrame: () => {
        let splatIndex = 0;
        for (const handedness of HANDS) {
          const xrHand = this.hands[handedness];
          for (const [index, segment] of JOINT_SEGMENTS.entries()) {
            for (let i = 1; i < segment.length; ++i) {
              const segmentSplats = JOINT_SEGMENT_STEPS[index][i - 1] * 2;
              const lastSegment = i + 1 === segment.length;
              const jointA = xrHand == null ? void 0 : xrHand[segment[i - 1]];
              const jointB = xrHand == null ? void 0 : xrHand[segment[i]];
              for (let j = 0; j < segmentSplats; ++j) {
                const t = (j + 0.5) / segmentSplats;
                opacity = 0;
                if (jointA && jointB) {
                  center.copy(jointA.position).lerp(jointB.position, t);
                  quaternion.copy(jointA.quaternion).slerp(jointB.quaternion, t);
                  const radiusA = JOINT_RADIUS[segment[i - 1]];
                  const radiusB = JOINT_RADIUS[segment[i]];
                  let radius = (1 - t) * radiusA + t * radiusB;
                  if (lastSegment && t > 0.8) {
                    radius *= Math.sqrt(1 - ((t - 0.8) / 0.2) ** 2);
                  }
                  scales.set(0.65 * radius, 0.5 * radius, 3e-3);
                  color.set(
                    0.55 + 0.45 * Math.sin(center.x * CYCLE),
                    0.55 + 0.45 * Math.sin(center.y * CYCLE),
                    0.55 + 0.45 * Math.sin(center.z * CYCLE)
                  );
                  if (handedness === "right") {
                    color.set(1 - color.r, 1 - color.g, 1 - color.b);
                  }
                  opacity = 0.75;
                }
                mesh.packedSplats.setSplat(
                  splatIndex,
                  center,
                  scales,
                  quaternion,
                  opacity,
                  color
                );
                splatIndex += 1;
              }
            }
          }
        }
        mesh.packedSplats.numSplats = splatIndex;
        mesh.packedSplats.needsUpdate = true;
        mesh.numSplats = splatIndex;
        mesh.updateVersion();
      }
    });
    return mesh;
  }
  distance(handA, jointA, handB, jointB, last = false) {
    const hA = last ? this.last[handA] : this.hands[handA];
    const hB = last ? this.last[handB] : this.hands[handB];
    const jA = hA == null ? void 0 : hA[jointA];
    const jB = hB == null ? void 0 : hB[jointB];
    if (!jA || !jB) {
      return Number.POSITIVE_INFINITY;
    }
    return jA.position.distanceTo(jB.position);
  }
  separation(handA, jointA, handB, jointB, last = false) {
    const d = this.distance(handA, jointA, handB, jointB, last);
    if (d === Number.POSITIVE_INFINITY) {
      return Number.POSITIVE_INFINITY;
    }
    return d - JOINT_RADIUS[jointA] - JOINT_RADIUS[jointB];
  }
  touching(handA, jointA, handB, jointB, last = false) {
    const d = this.separation(handA, jointA, handB, jointB, last);
    if (d === Number.POSITIVE_INFINITY) {
      return Number.POSITIVE_INFINITY;
    }
    return 1 - Math.max(0, Math.min(1, d / 0.01 - TOUCH_BIAS));
  }
  allTipsTouching(hand, last = false) {
    return Math.min(
      this.touching(hand, "t3", hand, "i4", last),
      this.touching(hand, "i4", hand, "m4", last),
      this.touching(hand, "m4", hand, "r4", last),
      this.touching(hand, "r4", hand, "p4", last)
      // this.touching(hand, "p4", hand, "t3", last),
    );
  }
  triTipsTouching(hand, last = false) {
    return Math.min(
      this.touching(hand, "t3", hand, "i4", last),
      this.touching(hand, "i4", hand, "m4", last),
      this.touching(hand, "m4", hand, "t3", last)
    );
  }
}
class HandMovement {
  constructor({
    xrHands,
    control,
    moveInertia,
    rotateInertia
  }) {
    this.lastGrip = {};
    this.lastPivot = new Vector3();
    this.rotateVelocity = 0;
    this.velocity = new Vector3();
    this.xrHands = xrHands;
    this.control = control;
    this.moveInertia = moveInertia ?? DEFAULT_MOVE_INERTIA$1;
    this.rotateInertia = rotateInertia ?? DEFAULT_ROTATE_INERTIA$1;
  }
  update(deltaTime) {
    var _a2, _b2, _c, _d, _e;
    const grip = {};
    for (const handedness of HANDS) {
      const hand = this.xrHands.hands[handedness];
      if (hand && this.xrHands.tests[`${handedness}MiddleThumb`]) {
        grip[handedness] = new Vector3().add(((_a2 = hand.t3) == null ? void 0 : _a2.position) ?? new Vector3()).add(((_b2 = hand.i4) == null ? void 0 : _b2.position) ?? new Vector3()).add(((_c = hand.m4) == null ? void 0 : _c.position) ?? new Vector3()).add(((_d = hand.r4) == null ? void 0 : _d.position) ?? new Vector3()).add(((_e = hand.p4) == null ? void 0 : _e.position) ?? new Vector3()).multiplyScalar(1 / 5);
      }
    }
    if (grip.left && grip.right && this.lastGrip.left && this.lastGrip.right) {
      const mid = grip.left.clone().add(grip.right).multiplyScalar(0.5);
      const lastMid = this.lastGrip.left.clone().add(this.lastGrip.right).multiplyScalar(0.5);
      this.lastPivot = mid;
      const delta = mid.clone().applyMatrix4(this.control.matrix);
      delta.sub(lastMid.clone().applyMatrix4(this.control.matrix));
      delta.multiplyScalar(1 / deltaTime);
      this.velocity.lerp(delta, 1 - Math.exp(-20 * deltaTime));
      const angle = Math.atan2(grip.left.z - mid.z, grip.left.x - mid.x);
      const lastAngle = Math.atan2(
        this.lastGrip.left.z - lastMid.z,
        this.lastGrip.left.x - lastMid.x
      );
      let closestAngle = angle - lastAngle;
      if (closestAngle > Math.PI) {
        closestAngle -= Math.PI * 2;
      } else if (closestAngle < -Math.PI) {
        closestAngle += Math.PI * 2;
      }
      const rotateVelocity = closestAngle / deltaTime;
      const blend = Math.exp(-20 * deltaTime);
      this.rotateVelocity = this.rotateVelocity * blend + rotateVelocity * (1 - blend);
    } else {
      this.rotateVelocity *= Math.exp(-deltaTime / this.rotateInertia);
      if (grip.left && this.lastGrip.left) {
        const delta = grip.left.clone().applyMatrix4(this.control.matrix);
        delta.sub(this.lastGrip.left.clone().applyMatrix4(this.control.matrix));
        delta.multiplyScalar(1 / deltaTime);
        this.velocity.lerp(delta, 1 - Math.exp(-20 * deltaTime));
      } else if (grip.right && this.lastGrip.right) {
        const delta = grip.right.clone().applyMatrix4(this.control.matrix);
        delta.sub(
          this.lastGrip.right.clone().applyMatrix4(this.control.matrix)
        );
        delta.multiplyScalar(1 / deltaTime);
        this.velocity.lerp(delta, 1 - Math.exp(-20 * deltaTime));
      } else {
        this.velocity.multiplyScalar(Math.exp(-deltaTime / this.moveInertia));
      }
    }
    const negPivot = this.lastPivot.clone().negate();
    const rotate = new Matrix4().makeTranslation(negPivot).premultiply(new Matrix4().makeRotationY(this.rotateVelocity * deltaTime)).premultiply(new Matrix4().makeTranslation(this.lastPivot));
    this.control.matrix.multiply(rotate);
    this.control.matrix.decompose(
      this.control.position,
      this.control.quaternion,
      this.control.scale
    );
    this.control.updateMatrixWorld(true);
    this.control.position.sub(this.velocity.clone().multiplyScalar(deltaTime));
    this.lastGrip = grip;
  }
}
const DEFAULT_MOVEMENT_SPEED = 1;
const DEFAULT_ROLL_SPEED = 2;
const DEFAULT_ROTATE_SPEED = 2e-3;
const DEFAULT_SLIDE_SPEED = 6e-3;
const DEFAULT_SCROLL_SPEED = 15e-4;
const DEFAULT_ROTATE_INERTIA = 0.15;
const DEFAULT_MOVE_INERTIA = 0.15;
const DEFAULT_STICK_THRESHOLD = 0.1;
const DEFAULT_FPS_ROTATE_SPEED = 2;
const DEFAULT_POINTER_ROLL_SCALE = 1;
const DUAL_PRESS_MS = 200;
const DOUBLE_PRESS_LIMIT_MS = 400;
const DOUBLE_PRESS_DISTANCE = 50;
const WASD_KEYCODE_MOVE = {
  KeyW: new THREE.Vector3(0, 0, -1),
  KeyS: new THREE.Vector3(0, 0, 1),
  KeyA: new THREE.Vector3(-1, 0, 0),
  KeyD: new THREE.Vector3(1, 0, 0),
  KeyR: new THREE.Vector3(0, 1, 0),
  KeyF: new THREE.Vector3(0, -1, 0)
};
const ARROW_KEYCODE_MOVE = {
  ArrowUp: new THREE.Vector3(0, 0, -1),
  ArrowDown: new THREE.Vector3(0, 0, 1),
  ArrowLeft: new THREE.Vector3(-1, 0, 0),
  ArrowRight: new THREE.Vector3(1, 0, 0),
  PageUp: new THREE.Vector3(0, 1, 0),
  PageDown: new THREE.Vector3(0, -1, 0)
};
const QE_KEYCODE_ROTATE = {
  KeyQ: new THREE.Vector3(0, 0, 1),
  KeyE: new THREE.Vector3(0, 0, -1)
};
const ARROW_KEYCODE_ROTATE = {
  Home: new THREE.Vector3(0, -1, 0),
  End: new THREE.Vector3(0, 1, 0),
  Insert: new THREE.Vector3(-1, 0, 0),
  Delete: new THREE.Vector3(1, 0, 0)
};
class SparkControls {
  constructor({ canvas }) {
    this.lastTime = 0;
    this.fpsMovement = new FpsMovement({});
    this.pointerControls = new PointerControls({ canvas });
  }
  update(control) {
    const time = performance.now();
    const deltaTime = (time - (this.lastTime || time)) / 1e3;
    this.lastTime = time;
    this.fpsMovement.update(deltaTime, control);
    this.pointerControls.update(deltaTime, control);
  }
}
class FpsMovement {
  constructor({
    moveSpeed,
    rollSpeed,
    stickThreshold,
    rotateSpeed,
    keycodeMoveMapping,
    keycodeRotateMapping,
    gamepadMapping,
    capsMultiplier,
    shiftMultiplier,
    ctrlMultiplier,
    xr
  } = {}) {
    this.enable = true;
    this.moveSpeed = moveSpeed ?? DEFAULT_MOVEMENT_SPEED;
    this.rollSpeed = rollSpeed ?? DEFAULT_ROLL_SPEED;
    this.stickThreshold = stickThreshold ?? DEFAULT_STICK_THRESHOLD;
    this.rotateSpeed = rotateSpeed ?? DEFAULT_FPS_ROTATE_SPEED;
    this.keycodeMoveMapping = keycodeMoveMapping ?? {
      ...WASD_KEYCODE_MOVE,
      ...ARROW_KEYCODE_MOVE
    };
    this.keycodeRotateMapping = keycodeRotateMapping ?? {
      ...QE_KEYCODE_ROTATE,
      ...ARROW_KEYCODE_ROTATE
    };
    this.gamepadMapping = gamepadMapping ?? {
      4: "rollLeft",
      5: "rollRight",
      6: "ctrl",
      7: "shift"
    };
    this.capsMultiplier = capsMultiplier ?? 10;
    this.shiftMultiplier = shiftMultiplier ?? 5;
    this.ctrlMultiplier = ctrlMultiplier ?? 1 / 5;
    this.xr = xr;
    this.keydown = {};
    this.keycode = {};
    document.addEventListener("keydown", (event) => {
      this.keydown[event.key] = true;
      this.keycode[event.code] = true;
    });
    document.addEventListener("keyup", (event) => {
      this.keydown[event.key] = false;
      this.keycode[event.code] = false;
    });
    window.addEventListener("blur", () => {
      this.keydown = {};
      this.keycode = {};
    });
  }
  // Call this method in your render loop with `control` set to the object to control
  // (`THREE.Camera` or a `THREE.Object3D` that contains it), with `deltaTime`
  // in seconds since the last update.
  update(deltaTime, control) {
    var _a2, _b2;
    if (!this.enable) {
      return;
    }
    const sticks = [new THREE.Vector2(), new THREE.Vector2()];
    const gamepad = navigator.getGamepads()[0];
    if (gamepad) {
      sticks[0].set(gamepad.axes[0], gamepad.axes[1]);
      sticks[1].set(gamepad.axes[2], gamepad.axes[3]);
    }
    const gamepadButtons = (gamepad == null ? void 0 : gamepad.buttons.map((button) => button.pressed)) || [];
    const xrSources = Array.from(((_b2 = (_a2 = this.xr) == null ? void 0 : _a2.getSession()) == null ? void 0 : _b2.inputSources) ?? []);
    for (const source of xrSources) {
      const gamepad2 = source.gamepad;
      if (gamepad2) {
        switch (source.handedness) {
          case "none": {
            sticks[0].x += gamepad2.axes[0];
            sticks[0].y += gamepad2.axes[1];
            sticks[1].x += gamepad2.axes[2];
            sticks[1].y += gamepad2.axes[3];
            break;
          }
          case "left": {
            sticks[0].x += gamepad2.axes[2];
            sticks[0].y += gamepad2.axes[3];
            break;
          }
          case "right": {
            sticks[1].x += gamepad2.axes[2];
            sticks[1].y += gamepad2.axes[3];
            break;
          }
        }
      }
    }
    for (const stick of sticks) {
      stick.x = Math.abs(stick.x) >= this.stickThreshold ? stick.x : 0;
      stick.y = Math.abs(stick.y) >= this.stickThreshold ? stick.y : 0;
    }
    const rotate = new THREE.Vector3(
      sticks[1].x,
      sticks[1].y,
      0
    ).multiplyScalar(this.rotateSpeed);
    for (const [keycode, rot] of Object.entries(this.keycodeRotateMapping)) {
      if (this.keycode[keycode]) {
        rotate.add(rot);
      }
    }
    for (const button in this.gamepadMapping) {
      if (gamepadButtons[Number.parseInt(button)]) {
        switch (this.gamepadMapping[button]) {
          case "rollLeft":
            rotate.z += 1;
            break;
          case "rollRight":
            rotate.z -= 1;
            break;
        }
      }
    }
    rotate.multiply(
      new THREE.Vector3(this.rotateSpeed, this.rotateSpeed, this.rollSpeed)
    );
    if (rotate.manhattanLength() > 0) {
      rotate.multiplyScalar(deltaTime);
      const eulers = new THREE.Euler().setFromQuaternion(
        control.quaternion,
        "YXZ"
      );
      eulers.y -= rotate.x;
      eulers.x = Math.max(
        -Math.PI / 2,
        Math.min(Math.PI / 2, eulers.x - rotate.y)
      );
      eulers.z = Math.max(-Math.PI, Math.min(Math.PI, eulers.z + rotate.z));
      control.quaternion.setFromEuler(eulers);
    }
    const moveVector = new THREE.Vector3(sticks[0].x, 0, sticks[0].y);
    for (const [keycode, move] of Object.entries(this.keycodeMoveMapping)) {
      if (this.keycode[keycode]) {
        moveVector.add(move);
      }
    }
    let speedMultiplier = 1;
    if (this.keydown.CapsLock) {
      speedMultiplier *= this.capsMultiplier;
    }
    if (this.keycode.ShiftLeft || this.keycode.ShiftRight) {
      speedMultiplier *= this.shiftMultiplier;
    }
    if (this.keycode.ControlLeft || this.keycode.ControlRight) {
      speedMultiplier *= this.ctrlMultiplier;
    }
    for (const button in this.gamepadMapping) {
      if (gamepadButtons[Number.parseInt(button)]) {
        switch (this.gamepadMapping[button]) {
          case "shift":
            speedMultiplier *= this.shiftMultiplier;
            break;
          case "ctrl":
            speedMultiplier *= this.ctrlMultiplier;
            break;
        }
      }
    }
    moveVector.applyQuaternion(control.quaternion);
    control.position.add(
      moveVector.multiplyScalar(this.moveSpeed * speedMultiplier * deltaTime)
    );
  }
}
class PointerControls {
  constructor({
    // The HTML canvas element to attach pointer events to
    canvas,
    // Speed of rotation (default DEFAULT_ROTATE_SPEED)
    rotateSpeed,
    // Speed of sliding when dragging with right/middle mouse button or two fingers
    // (default DEFAULT_SLIDE_SPEED)
    slideSpeed,
    // Speed of movement when using mouse scroll wheel (default DEFAULT_SCROLL_SPEED)
    scrollSpeed,
    // Swap the direction of rotation and sliding (default: false)
    swapRotateSlide,
    // Reverse the direction of rotation (default: false)
    reverseRotate,
    // Reverse the direction of sliding (default: false)
    reverseSlide,
    // Reverse the direction of swipe gestures (default: false)
    reverseSwipe,
    // Reverse the direction of scroll wheel movement (default: false)
    reverseScroll,
    // Inertia factor for movement (default: DEFAULT_MOVE_INERTIA)
    moveInertia,
    // Inertia factor for rotation (default: DEFAULT_ROTATE_INERTIA)
    rotateInertia,
    // Pointer rolling scale factor (default: DEFAULT_POINTER_ROLL_SCALE)
    pointerRollScale,
    // Callback for double press events (default: () => {})
    doublePress
  }) {
    this.enable = true;
    this.canvas = canvas;
    this.rotateSpeed = rotateSpeed ?? DEFAULT_ROTATE_SPEED;
    this.slideSpeed = slideSpeed ?? DEFAULT_SLIDE_SPEED;
    this.scrollSpeed = scrollSpeed ?? DEFAULT_SCROLL_SPEED;
    this.swapRotateSlide = swapRotateSlide ?? false;
    this.reverseRotate = reverseRotate ?? false;
    this.reverseSlide = reverseSlide ?? false;
    this.reverseSwipe = reverseSwipe ?? false;
    this.reverseScroll = reverseScroll ?? false;
    this.moveInertia = moveInertia ?? DEFAULT_MOVE_INERTIA;
    this.rotateInertia = rotateInertia ?? DEFAULT_ROTATE_INERTIA;
    this.pointerRollScale = pointerRollScale ?? DEFAULT_POINTER_ROLL_SCALE;
    this.doublePress = doublePress ?? (() => {
    });
    this.doublePressLimitMs = DOUBLE_PRESS_LIMIT_MS;
    this.doublePressDistance = DOUBLE_PRESS_DISTANCE;
    this.lastUp = null;
    this.rotating = null;
    this.sliding = null;
    this.dualPress = false;
    this.scroll = new THREE.Vector3();
    this.rotateVelocity = new THREE.Vector3();
    this.moveVelocity = new THREE.Vector3();
    canvas.addEventListener("pointerdown", (event) => {
      const position = this.getPointerPosition(event);
      const initial = position.clone();
      const last = position.clone();
      const isRotate = !this.swapRotateSlide && !this.rotating && (event.pointerType !== "mouse" || event.button === 0) || this.swapRotateSlide && this.sliding && !this.rotating && (event.pointerType !== "mouse" || event.button === 1);
      const { pointerId, timeStamp } = event;
      if (isRotate) {
        this.rotating = { initial, last, position, pointerId, timeStamp };
        canvas.setPointerCapture(event.pointerId);
        this.dualPress = false;
      } else if (!this.sliding) {
        const button = event.pointerType === "mouse" ? event.button : void 0;
        this.sliding = {
          initial,
          last,
          position,
          pointerId,
          button,
          timeStamp
        };
        canvas.setPointerCapture(event.pointerId);
        this.dualPress = this.rotating != null && timeStamp - this.rotating.timeStamp < DUAL_PRESS_MS;
      }
    });
    const pointerUp = (event) => {
      var _a2, _b2;
      if (((_a2 = this.rotating) == null ? void 0 : _a2.pointerId) === event.pointerId) {
        this.rotating = null;
        canvas.releasePointerCapture(event.pointerId);
        if (this.dualPress && this.sliding) {
          canvas.releasePointerCapture(this.sliding.pointerId);
          this.sliding = null;
        }
      } else if (((_b2 = this.sliding) == null ? void 0 : _b2.pointerId) === event.pointerId) {
        this.sliding = null;
        canvas.releasePointerCapture(event.pointerId);
        if (this.dualPress && this.rotating) {
          canvas.releasePointerCapture(this.rotating.pointerId);
          this.rotating = null;
        }
      }
      const position = this.getPointerPosition(event);
      const lastUp = this.lastUp;
      this.lastUp = { position, time: event.timeStamp };
      if (lastUp) {
        const distance2 = lastUp.position.distanceTo(position);
        if (distance2 < this.doublePressDistance) {
          const intervalMs = event.timeStamp - lastUp.time;
          if (intervalMs < this.doublePressLimitMs) {
            this.lastUp = null;
            this.doublePress({ position, intervalMs });
          }
        }
      }
    };
    document.addEventListener("pointerup", pointerUp);
    document.addEventListener("pointercancel", pointerUp);
    document.addEventListener("pointermove", (event) => {
      var _a2, _b2;
      if (((_a2 = this.rotating) == null ? void 0 : _a2.pointerId) === event.pointerId) {
        this.rotating.position = this.getPointerPosition(event);
      } else if (((_b2 = this.sliding) == null ? void 0 : _b2.pointerId) === event.pointerId) {
        this.sliding.position = this.getPointerPosition(event);
      }
    });
    canvas.addEventListener("contextmenu", (event) => {
      event.preventDefault();
    });
    canvas.addEventListener("wheel", (event) => {
      this.scroll.add(
        new THREE.Vector3(event.deltaX, event.deltaY, event.deltaZ)
      );
      event.preventDefault();
    });
  }
  getPointerPosition(event) {
    const rect = this.canvas.getBoundingClientRect();
    return new THREE.Vector2(
      event.clientX - rect.left,
      event.clientY - rect.top
    );
  }
  update(deltaTime, control) {
    if (!this.enable) {
      return;
    }
    if (this.dualPress && this.rotating && this.sliding) {
      const motion = [
        this.rotating.position.clone().sub(this.rotating.last),
        this.sliding.position.clone().sub(this.sliding.last)
      ];
      const coincidence = motion[0].dot(motion[1]);
      if (coincidence >= 0.2) {
        const totalMotion = motion[0].clone().add(motion[1]);
        const slide = new THREE.Vector3(totalMotion.x, -totalMotion.y, 0);
        slide.multiplyScalar(this.slideSpeed * (this.reverseSwipe ? 1 : -1));
        slide.applyQuaternion(control.quaternion);
        control.position.add(slide);
        this.moveVelocity = slide.clone().multiplyScalar(1 / deltaTime);
      } else if (coincidence <= -0.2) {
        const deltaDir = this.sliding.last.clone().sub(this.rotating.last);
        const deltaDist = deltaDir.length();
        deltaDir.multiplyScalar(1 / deltaDist).normalize();
        const orthoDir = new THREE.Vector2(-deltaDir.y, deltaDir.x);
        const motionDir = [motion[0].dot(deltaDir), motion[1].dot(deltaDir)];
        const motionOrtho = [motion[0].dot(orthoDir), motion[1].dot(orthoDir)];
        const midpoint = this.rotating.last.clone().add(this.sliding.last).multiplyScalar(0.5);
        let midpointDir = new THREE.Vector3();
        if (control instanceof THREE.Camera) {
          const ndcMidpoint = new THREE.Vector2(
            midpoint.x / this.canvas.clientWidth * 2 - 1,
            -(midpoint.y / this.canvas.clientHeight) * 2 + 1
          );
          const raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(ndcMidpoint, control);
          midpointDir = raycaster.ray.direction;
        }
        const pinchOut = motionDir[1] - motionDir[0];
        const slide = midpointDir.multiplyScalar(pinchOut * this.slideSpeed);
        control.position.add(slide);
        this.moveVelocity = slide.clone().multiplyScalar(1 / deltaTime);
        const angles = [
          Math.atan(motionOrtho[0] / (-0.5 * deltaDist)),
          Math.atan(motionOrtho[1] / (0.5 * deltaDist))
        ];
        const rotate = 0.5 * (angles[0] + angles[1]) * this.pointerRollScale;
        const eulers = new THREE.Euler().setFromQuaternion(
          control.quaternion,
          "YXZ"
        );
        eulers.z = Math.max(
          -Math.PI,
          Math.min(Math.PI, eulers.z + 0.5 * rotate)
        );
        control.quaternion.setFromEuler(eulers);
      }
      this.rotating.last.copy(this.rotating.position);
      this.sliding.last.copy(this.sliding.position);
    } else {
      const rotate = new THREE.Vector3();
      if (this.rotating && !this.dualPress) {
        const delta = this.rotating.position.clone().sub(this.rotating.last);
        this.rotating.last.copy(this.rotating.position);
        rotate.set(delta.x, delta.y, 0);
        rotate.multiplyScalar(this.rotateSpeed * (this.reverseRotate ? -1 : 1));
        this.rotateVelocity = rotate.clone().multiplyScalar(1 / deltaTime);
      } else {
        this.rotateVelocity.multiplyScalar(
          Math.exp(-deltaTime / this.rotateInertia)
        );
        rotate.addScaledVector(this.rotateVelocity, deltaTime);
      }
      const eulers = new THREE.Euler().setFromQuaternion(
        control.quaternion,
        "YXZ"
      );
      eulers.y -= rotate.x;
      eulers.x = Math.max(
        -Math.PI / 2,
        Math.min(Math.PI / 2, eulers.x - rotate.y)
      );
      eulers.z *= Math.exp(-0 * deltaTime);
      control.quaternion.setFromEuler(eulers);
      if (this.sliding && !this.dualPress) {
        const delta = this.sliding.position.clone().sub(this.sliding.last);
        this.sliding.last.copy(this.sliding.position);
        const slide = this.sliding.button !== 2 ? new THREE.Vector3(delta.x, 0, delta.y) : new THREE.Vector3(delta.x, -delta.y, 0);
        slide.multiplyScalar(this.slideSpeed * (this.reverseSlide ? -1 : 1));
        slide.applyQuaternion(control.quaternion);
        control.position.add(slide);
        this.moveVelocity = slide.clone().multiplyScalar(1 / deltaTime);
      } else {
        this.moveVelocity.multiplyScalar(
          Math.exp(-deltaTime / this.moveInertia)
        );
        control.position.addScaledVector(this.moveVelocity, deltaTime);
      }
    }
    const scroll = this.scroll.multiplyScalar(this.scrollSpeed);
    scroll.set(scroll.x, scroll.z, scroll.y);
    if (this.reverseScroll) {
      scroll.multiplyScalar(-1);
    }
    scroll.applyQuaternion(control.quaternion);
    control.position.add(scroll);
    this.scroll.set(0, 0, 0);
  }
}
export {
  FINGER_TIPS,
  FpsMovement,
  HANDS,
  Hand,
  HandMovement,
  JOINT_IDS,
  JOINT_INDEX,
  JOINT_RADIUS,
  JOINT_SEGMENTS,
  JOINT_SEGMENT_STEPS,
  JOINT_TIPS,
  JointEnum,
  LN_SCALE_MAX,
  LN_SCALE_MIN,
  NUM_JOINTS,
  NewSparkRenderer,
  NewSplatAccumulator,
  PackedSplats,
  PlyReader,
  PointerControls,
  Readback,
  RgbaArray,
  Sint8ToFloat,
  SparkControls,
  SparkRenderer,
  SparkViewpoint,
  SplatAccumulator,
  SplatEdit,
  SplatEditRgbaBlendMode,
  SplatEditSdf,
  SplatEditSdfType,
  SplatEdits,
  SplatFileType,
  SplatGenerator,
  SplatLoader,
  SplatMesh,
  SplatModifier,
  SplatSkinning,
  SplatTransformer,
  SpzReader,
  SpzWriter,
  Uint8ToFloat,
  VRButton,
  XrHands,
  constructAxes,
  constructGrid,
  constructSpherePoints,
  defines,
  dyno,
  flipPixels,
  floatToSint8,
  floatToUint8,
  fromHalf,
  generators,
  getSplatFileType,
  imageSplats,
  isAndroid,
  isMobile,
  isOculus,
  isPcSogs,
  modifiers,
  pixelsToPngUrl,
  setPackedSplat,
  textSplats,
  toHalf,
  transcodeSpz,
  unpackSplat,
  unpackSplats,
  utils
};
//# sourceMappingURL=spark.module.js.map
